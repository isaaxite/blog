# 前言
正则表达式不常用，常用的也是比较简单的，比如全局替换。另外就是在表单验证的时候会用到。偶尔还会还匹配url的时候用到。今天突然想到一个需求，非要跟自己过不去，正则匹配字符串多个目标字符的最后一个。比如说下面这个url：
```javascript
let url = "https://github.com/issaxite/issaxite.github.io/issues/new";
```
怎么匹配最后一个“/”之后的所有字符呢？

# 字符切割
首先是根据`/`全局分隔字符串，然后获取最后一个数组元素就好。
```javascript
let pattern = /\//g;
let strs = url.split(pattern);
console.log(strs, strs[strs.length - 1]);
```
![image](https://user-images.githubusercontent.com/25907273/35163101-9271ad28-fd80-11e7-9cb0-4316d5da7817.png)



# 直接正则匹配最后一个
关键是`$`匹配结尾和一个非`/`字符集，因为我们要匹配的是最后一个`/`，所以之后就在没有`/`。
```javascript
let pattern = /\/[^/]*$/;
let strs = url.split(pattern);
console.log(strs[0]);
```
![image](https://user-images.githubusercontent.com/25907273/35163020-44e19122-fd80-11e7-8fa7-06a5763d614e.png)

# 扩展
- 加入目标字符不是字符而是一个字符串又该怎么改？
以全局匹配的方式为例子：
加入目标字串是：`/i`
```javascript
let pattern = /(?:\/i)/g;
let strs = url.split(pattern);
console.log(strs, strs[strs.length - 1]);
```
![image](https://user-images.githubusercontent.com/25907273/35163612-4d0242fa-fd82-11e7-9ffc-b09904d270de.png)
See, 搞定了吧！
关键道具就是`(?:xxx)`，以下是它的作用
>匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。

- 假如不是匹配最后一个，是倒数第n个呢？
这里假设匹配倒数第二个。
用全局匹配分割字串的方法就不用多说。那么第二种，直接匹配要怎么做呢？
```javascript
let pattern = /\/[^\/]*(?=(?:\/[^\/]*){1}$)/;
let strs = url.match(pattern);
console.log(strs)
```
![image](https://user-images.githubusercontent.com/25907273/35164982-87701674-fd87-11e7-8dbc-d86422c0eaa0.png)

来分析一下这个正则表达式

- `[^\/]`是一个不包函数/的字符集；
-  `\/[^\/]*` 这个意思是：`/` + 0~n个`[^\/]`字符，比如`/xxxxx`， 但是不会匹配`/xxx/xxx`
- x(?=y)
对比以上的正则表达式，发现这个正则表达式多个一个`x(?=y)`的规则！

规则描述如下
>匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。
例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。

- (?:\/[^\/]*){1}$
看见`(?:\/[^\/]*)`我们就知道，`\/[^\/]*`是作为一个整体进行匹配， `\/[^\/]*`是意思就不多说，再看`{1}`，此规则限制匹配`\/[^\/]*`的字串只能出现一次，最后是`$`，即是匹配结尾。

综合以上，我们就可以知道`/\/[^\/]*(?=(?:\/[^\/]*){1}$)/`的意思是：
匹配`/\/[^\/]*`，并且他后面只能有一个`/\/[^\/]*`且是字符串的结尾。

# 封装
```javascript
function findFromLast(str, flag, num) {
  num = typeof num == "undefined" ? 0 : num;
  var pattern = new RegExp(
    flag + "[^"+flag+"]*(?=("+flag+"[^"+flag+"]*){" + num + "}$)", "g");
  var target = str.match(pattern);
  return target ? target[0] : target; 
}
```

