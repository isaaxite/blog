oauth2实践

auth2中的角色

![](asset/2022-10-07-03-23-41.png)

# 管理OAuth客户端注册

oauth服务器需要为每个客户端分配唯一的客户端标识！

## 由谁来生成客户端 ID？ 

在常规 的 OAuth系统中，客户端 ID（client_id）和密钥（client_secret）由 *授权服务器* 颁发给客户端

通过客户端 ID查找信息，客户端 ID是从请求 

## 对客户端授权 

OAuth协议要求授权服务器提供两个端点：

- 授权端点，运行在前端信道上；
- 令牌端点，运行 在后端信道上

### 授权端点

授权服务器提供了一个授权端点，供客户端请求访问令牌和刷新令牌。客户端直接向该端点 发出请求，携带一组表单格式的参数，授权服务器解析并处理这些参数。然后授权服务器返回一 个代表令牌的 JSON对象

### 令牌端点

令牌端点不面向用户

客户端得到授权码，它可以将其发送给授权服务器的令牌端点，换取 OAuth访问令牌， 再进行解析和存储

![](asset/2022-10-07-12-10-49.png)


OAuth流程中的很多部分都使用标准的 HTTP请求和响应格式来相互通信。由于这些请求通 常都发生在资源拥有者和用户代理的可见范围之外，因此它们统称为后端信道通信

![](asset/2022-10-07-12-05-02.png)

### 重定向到授权端点 

授权端点是一个前端信道端点，客户端会 将用户浏览器重定向至该端点，以发出授权请求。

资源拥有者从客户端重定向到授权端点，它会带上客户端id。授权端点根客户端 ID查找客户端的详细信息：

1. 需要检查客户端是否存在；
2. 需要渲染出一个页面来（/authorize），让用户交互并进行授权

### 资源拥有者对客户端授权

1. 在授权页面交互，发请求（/approve）给授权点，生成授权码。
2. 生成授权码，将授权码存储。以便后续客户端用授权码换令牌

通过浏览器传过来的唯一信息就是 client_id，由于该信息是用浏览器通过前端信道传输的， 因此被视为公开信息。如此一来，任何人都可以冒充该客户端，但是我们还是可以借助一些信息 来判断请求的合法性，其中重要的就是检查传入的 redirect_uri 是否与客户端注册信息中 的一致

### 授权点需要保存客户端注册信息

1. client_id
2. redirect_uri，可以是array
3. client_secret

## 令牌颁发
1. 对客户端进行身份认证
2. 处理授权许可请求

客户端带过来的授权码其实没有很大用处。至少在书中它没和令牌有直接的关系！

授权码是作为一个一次性凭证，请求的时候就必须消耗，二次请求就会失效！

授权码的作用：保持一次性！

![](asset/2022-10-07-08-14-35.png)


### 对客户端进行身份认证

客户端会带来 client_id 和 client_secret，用client_id去查client_id对应的的客户端已经注册的信息！比对 client_secret 是否正确有效！

### 处理授权许可请求

根据 grant_type 参数，选择令牌颁发方式！

OAuth 2.0完全没有规定访问令牌的内容应该是什么样的，它有一个很好的理由：支持多 样化的选择，每种选择都有各自的权衡，并适应于不同的场景。



看下面代码，我思考后发现：access_token，它颗粒度是去到单个用户，而不是单个client的维度！

![](asset/2022-10-07-11-32-59.png)

客户端获取权限之后，用access_token访问受保护资源时，使用access_token去数据库查找详细信息，得到scope！


# 授权许可类型

1. **隐式许可类型**，直接从授权端点返回令牌，没有令牌端点；
2. **客户端凭据许可类型**，没有明确的资源拥有。只使用后端信道。
3. **资源拥有者凭据许可类型**，资源拥有者通过客户端使用账号密码换令牌
4. **断言许可类型**,

## 隐式许可类型

```js
} else if (query.response_type == 'token') { 
```

完全运行在浏览器中的 JavaScript应用就属于这种情况。在这种情况下，通过浏览器向客户端传递仅用于换 取令牌的授权码就没有任何实际意义了，因为这个额外的保密层没有起到任何作.

这种许可流程只使用授权端点而不使 用令牌端点

隐式许可流程不可用于获取刷新令牌。因为浏览器内的应用具有短暂运行的特点，只会在被加载到浏览器的期间保持会话，所以刷新令牌在这里的作用非常有限。

response_type 参数的值为 token，而不是 code。这样会通知授权服务器直接生成令牌，而 不是生成一个用于换取令牌的授权码。 


## 客户端凭据许可类型

```js
} else if (req.body.grant_type == 'client_credentials') { 
```

比如后端系统之间需要直接通信
只使用后端信道，客户端代表自己（它自己就是资源拥有 者）从令牌端点获取令牌。 

客户端向授权服务器的令牌端点发出令牌请求，这与授权码流程是一样的，只不过这一次使 用 client_credentials 作为 grant_type 参数的值，而且没有授权码或者其他用于换取令牌 的临时凭据。相反，客户端直接向授权服务器进行身份认证，而授权服务器给客户端颁发访问令牌

![](asset/2022-10-07-14-51-53.png)

在客户端凭据许可流程中不会颁发刷新令牌，因为我们认为客户端能够随时获取新令牌，无 须单独的资源拥有者参与，因此在这种情况下没有必要使用刷新令牌。 

客户端凭据许可类型没有任何直接的用户交互!它确实是为可信的后端系统直接 访问服务而准备的。

![](asset/2022-10-07-14-34-57.png)


## 资源拥有者凭据许可类型 

![](asset/2022-10-07-16-00-30.png)

用户名和密码，那么客户端可以向用户索取用户 的凭据，然后用这个凭据换取令牌。支持客户端这样做的是资源拥有者凭据许可类型，也叫作密码流程。


这种许可类型的工作方式很简单。客户端收集用户的用户名和密码（使用什么样的交互接口 由客户端决定），然后将它们发送至授权服务器。 

授权服务器从收到的请求中取出用户名和密码，并与本地存储的用户信息对比。如果匹配， 则授权服务器向客户端颁发令牌。 

```js
grant_type == 'password'
```

完成所有的检查之后，就可以生成并返回令牌了。请注意，还可以生成刷新令牌（我们的练 习中这样做了）。为客户端提供刷新令牌之后，它就不需要再保存用户的密码了

![](asset/2022-10-08-05-42-33.png)

# 客户端部署的应用类型

1. Web应用；
2. 浏览器应用；
3. 原生应用；

## Web应用

Web应用运行在远程服务器上，需要通过Web浏览器访问。应用的配置和运行时状态由 Web 服务器维护，通常使用会话 cookie 与浏览器保持 连接。

Web 应用很容易有效地使用授权码、客 户端凭据或者断言许可流程。由于浏览器一般不会将请求 URI 中的片段部分发送给服务器，大 多数情况下隐式许可流程不适用于Web 应用。 

## 浏览器应用

浏览器应用完全运行在浏览器内，一般使用 JavaScript。虽然应用的代码确实需要由Web 服 务器提供，但代码本身并不在服务器上运行，Web 服务器也不会维护应用的任何运行时状态。应 用的所有执行动作都发生在最终用户计算机的浏览器内。 

因 为浏览器应用受限于同源策略以及其他安全限制条件，这些限制是为了防止跨站攻击。因此，最 适合这类应用的是隐式许可流程，该许可流程就是针对这种应用场景而做的优化。 

## 原生应用

原生应用是直接在最终用户的设备（计算机或者移动设备）上运行的应用。应用软件通常是在外部经过编译或者打包之后再安装到设备上的。 


# 附录

## 参考

- [oauth2 nodejs实战](http://laibh.top/2020-07-17-oauth2%20nodejs%E5%AE%9E%E6%88%98.html)
- [使用 Nodejs 搭建一个 OAuth2.0 服务](https://www.jianshu.com/p/7febbe553c83)
- [rfc6749](http://www.rfcreader.com/#rfc6749)