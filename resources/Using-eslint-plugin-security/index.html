<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png"><link rel="mask-icon" href="/blog/images/logo.svg" color="#222"><meta name="google-site-verification" content="D3uaiX9T8gcr1zBjqu9y67t-0DhGNCa7yyjpQ27T_Co"><meta name="msvalidate.01" content="AFD16F68B2DF363759600CB5E8825AEC"><link rel="stylesheet" href="/blog/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"isaaxite.github.io","root":"/blog/","images":"/blog/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script><meta name="description" content="前言近来，主要的研究课题是 JavaScript 代码的静态分析。在研究期间用到 Eslint 对此做实践，了解到它的一个插件，eslint-plugin-security。如其名，它的作用是安全相关方面的代码扫描。在看了它的配置规则后，觉得甚是有趣，不少规则都涉及到常见的前端安全的问题。故有了想法，为什么不以它为引子，来个管中窥豹。"><meta property="og:type" content="article"><meta property="og:title" content="从 eslint-plugin-security 看前端安全"><meta property="og:url" content="https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/index.html"><meta property="og:site_name" content="Isaac Kam&#39;s Blog"><meta property="og:description" content="前言近来，主要的研究课题是 JavaScript 代码的静态分析。在研究期间用到 Eslint 对此做实践，了解到它的一个插件，eslint-plugin-security。如其名，它的作用是安全相关方面的代码扫描。在看了它的配置规则后，觉得甚是有趣，不少规则都涉及到常见的前端安全的问题。故有了想法，为什么不以它为引子，来个管中窥豹。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-09-02T09:35:02.000Z"><meta property="article:modified_time" content="2025-03-07T23:26:45.928Z"><meta property="article:author" content="Isaac Kam"><meta property="article:tag" content="eslint-plugin-security"><meta property="article:tag" content="实践"><meta property="article:tag" content="trojan source attacks"><meta property="article:tag" content="安全漏洞"><meta property="article:tag" content="命令注入攻击"><meta property="article:tag" content="XSS"><meta property="article:tag" content="DoS"><meta property="article:tag" content="CSRF"><meta property="article:tag" content="路径遍历"><meta property="article:tag" content="ReDoS"><meta property="article:tag" content="allow 攻击"><meta property="article:tag" content="对象注入漏洞"><meta property="article:tag" content="计时攻击"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/","path":"resources/Using-eslint-plugin-security/","title":"从 eslint-plugin-security 看前端安全"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>从 eslint-plugin-security 看前端安全 | Isaac Kam's Blog</title><noscript><link rel="stylesheet" href="/blog/css/noscript.css"></noscript><link rel="alternate" href="/blog/atom.xml" title="Isaac Kam's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/blog/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Isaac Kam's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">I am a slow walker, but I never walk backwards.</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/blog/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-rss"><a href="/blog/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#eslint-plugin-security"><span class="nav-text">eslint-plugin-security</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-text">安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-text">配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-bidi-characters"><span class="nav-text">detect-bidi-characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-buffer-noassert"><span class="nav-text">detect-buffer-noassert</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-child-process"><span class="nav-text">detect-child-process</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-disable-mustache-escape"><span class="nav-text">detect-disable-mustache-escape</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-eval-with-expression"><span class="nav-text">detect-eval-with-expression</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-new-buffer"><span class="nav-text">detect-new-buffer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-no-csrf-before-method-override"><span class="nav-text">detect-no-csrf-before-method-override</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-non-literal-fs-filename"><span class="nav-text">detect-non-literal-fs-filename</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-non-literal-regexp"><span class="nav-text">detect-non-literal-regexp</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-non-literal-require"><span class="nav-text">detect-non-literal-require</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-object-injection"><span class="nav-text">detect-object-injection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-possible-timing-attacks"><span class="nav-text">detect-possible-timing-attacks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-pseudoRandomBytes"><span class="nav-text">detect-pseudoRandomBytes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detect-unsafe-regex"><span class="nav-text">detect-unsafe-regex</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E8%A7%84%E5%88%99"><span class="nav-text">完整规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Isaac Kam" src="/blog/images/avatar.jpg"><p class="site-author-name" itemprop="name">Isaac Kam</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/"><span class="site-state-item-count">92</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/isaaxite" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;isaaxite" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="isaacgun:isaacgun@outlook.com" title="E-Mail → isaacgun:isaacgun@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog/images/avatar.jpg"><meta itemprop="name" content="Isaac Kam"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Isaac Kam's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="从 eslint-plugin-security 看前端安全 | Isaac Kam's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">从 eslint-plugin-security 看前端安全</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-09-02 17:35:02" itemprop="dateCreated datePublished" datetime="2023-09-02T17:35:02+08:00">2023-09-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-03-08 07:26:45" itemprop="dateModified" datetime="2025-03-08T07:26:45+08:00">2025-03-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">静态代码分析</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">前端安全</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来，主要的研究课题是 JavaScript 代码的静态分析。在研究期间用到 Eslint 对此做实践，了解到它的一个插件，<code>eslint-plugin-security</code>。如其名，它的作用是安全相关方面的代码扫描。在看了它的配置规则后，觉得甚是有趣，不少规则都涉及到常见的前端安全的问题。故有了想法，为什么不以它为引子，来个管中窥豹。</p><span id="more"></span><p>背景：</p><ul><li><p>系统：WSL2 - Debian 12；</p></li><li><p>仓库：<a target="_blank" rel="noopener" href="https://github.com/isaaxite/practices/tree/main/packages/eslint-security">isaaxite&#x2F;practices - eslint-security</a>；</p></li><li><p>包管理器：pnpm；</p></li><li><p>已安装的包：</p><ul><li>eslint <code>8.48.0</code></li><li>eslint-config-airbnb-base <code>15.0.0</code></li><li>eslint-plugin-import <code>2.28.1</code></li></ul></li></ul><h1 id="eslint-plugin-security"><a href="#eslint-plugin-security" class="headerlink" title="eslint-plugin-security"></a>eslint-plugin-security</h1><p><code>eslint-plugin-security</code> 是一个 ESLint 插件，用于检测 JavaScript 代码中的常见安全问题。</p><p>这里给出它的一个简要概述:</p><ul><li><p><strong>名称</strong>：eslint-plugin-security</p></li><li><p><strong>作用</strong>：通过 ESLint 规则检查 JavaScript 代码中的安全隐患</p></li><li><p><strong>检测项</strong>：</p><ul><li><p>XSS（跨站脚本）；</p></li><li><p>SQL 注入；</p></li><li><p>缓冲区溢出；</p></li><li><p>XXE；</p></li><li><p>敏感数据泄漏；</p></li><li><p>引用不安全模块；</p></li><li><p>文件操作权限；</p></li><li><p>随机数生成；</p></li><li><p>CRLF注入；</p></li><li><p>点击劫持；</p></li><li><p>暴露详细错误信息。</p></li></ul></li><li><p><strong>使用步骤</strong>：</p><ol><li><p>安装插件；</p></li><li><p>在 Eslint 配置文件中配置 <code>plugins</code> 和 <code>rules</code>；</p></li><li><p>运行ESLint扫描代码。</p></li></ol></li><li><p><strong>规则可配置</strong>：</p><p>可以针对不同的检测项单独开启或者关闭相关规则。</p></li><li><p><strong>输出结果</strong>：</p><p>标注出代码中的潜在安全问题位置和类型。</p></li><li><p><strong>目的</strong>：</p><p>在开发阶段早期发现安全隐患，帮助编写更安全的代码。</p></li></ul><table><thead><tr><th align="left">Order</th><th align="left">Name</th><th align="left">Description</th><th align="left">Rules</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-bidi-characters.md">detect-bidi-characters</a></td><td align="left">检测双向字符攻击,可能注入代码</td><td align="left"><code>security/detect-bidi-characters</code></td></tr><tr><td align="left">2</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-buffer-noassert.md">detect-buffer-noassert</a></td><td align="left">检测Buffer使用noAssert可能导致溢出</td><td align="left"><code>security/detect-buffer-noassert</code></td></tr><tr><td align="left">3</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-child-process.md">detect-child-process</a></td><td align="left">检测child_process调用是否安全</td><td align="left"><code>security/detect-child-process</code></td></tr><tr><td align="left">4</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-disable-mustache-escape.md">detect-disable-mustache-escape</a></td><td align="left">检测模板引擎是否关闭转义功能</td><td align="left"><code>security/detect-disable-mustache-escape</code></td></tr><tr><td align="left">5</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-eval-with-expression.md">detect-eval-with-expression</a></td><td align="left">检测eval是否使用可控参数</td><td align="left"><code>security/detect-eval-with-expression</code></td></tr><tr><td align="left">6</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-new-buffer.md">detect-new-buffer</a></td><td align="left">检测Buffer构造是否使用可控参数</td><td align="left"><code>security/detect-new-buffer</code></td></tr><tr><td align="left">7</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-no-csrf-before-method-override.md">detect-no-csrf-before-method-override</a></td><td align="left">检测CSRF顺序设置是否正确</td><td align="left"><code>security/detect-no-csrf-before-method-override</code></td></tr><tr><td align="left">8</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-fs-filename.md">detect-non-literal-fs-filename</a></td><td align="left">检测文件操作是否使用可控文件名</td><td align="left"><code>security/detect-non-literal-fs-filename</code></td></tr><tr><td align="left">9</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-regexp.md">detect-non-literal-regexp</a></td><td align="left">检测正则是否使用可控参数可能导致DOS</td><td align="left"><code>security/detect-non-literal-regexp</code></td></tr><tr><td align="left">10</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-require.md">detect-non-literal-require</a></td><td align="left">检测require是否使用可控参数</td><td align="left"><code>security/detect-non-literal-require</code></td></tr><tr><td align="left">11</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-object-injection.md">detect-object-injection</a></td><td align="left">检测对象属性注入</td><td align="left"><code>security/detect-object-injection</code></td></tr><tr><td align="left">12</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-possible-timing-attacks.md">detect-possible-timing-attacks</a></td><td align="left">检测时间攻击</td><td align="left"><code>security/detect-possible-timing-attacks</code></td></tr><tr><td align="left">13</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-pseudoRandomBytes.md">detect-pseudoRandomBytes</a></td><td align="left">检测随机数是否真随机</td><td align="left"><code>security/detect-pseudoRandomBytes</code></td></tr><tr><td align="left">14</td><td align="left"><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-unsafe-regex.md">detect-unsafe-regex</a></td><td align="left">检测正则表达式安全问题</td><td align="left"><code>security/detect-unsafe-regex</code></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eslint-plugin-security 1.7.1</span></span><br><span class="line"></span><br><span class="line">pnpm add eslint-plugin-security --save-dev</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在安装 <code>eslint-plugin-security</code> 后，<code>eslint-plugin-security</code> 已经内置上面表格中的所有规则，并且设置告警等级为 <code>warn</code>。因此无需手动配置规则，除非需要修改告警等级。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">+   <span class="string">&#x27;plugin:security/recommended&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">overrides</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">files</span>: [</span><br><span class="line">        <span class="string">&#x27;.eslintrc.&#123;js,cjs&#125;&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="detect-bidi-characters"><a href="#detect-bidi-characters" class="headerlink" title="detect-bidi-characters"></a>detect-bidi-characters</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-bidi-characters&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>检测利用 unicode bidi（”bidirectional”的缩写，是指双向书写或双向格式的意思） 攻击注入恶意代码的 <a target="_blank" rel="noopener" href="https://trojansource.codes/">trojan source attacks</a> 案例。</p><details open><summary><strong>什么是 <code>trojan source attacks</code> ？</strong></summary><blockquote><br><p>trojan source attacks 是一种利用双向书写系统中的特殊字符实现隐藏代码注入的攻击方式。</p><p>具体来说:</p><ul><li><p>双向书写系统指阿拉伯数字和希伯来字母可以从右到左或者从左到右流畅书写的语言。</p></li><li><p>这些语言中的部分字符既可以作为一般字符显示,也可以用于控制书写方向。</p></li><li><p>攻击者会利用这些特殊字符在源代码中隐藏恶意代码段。</p></li><li><p>正常阅读源代码时无法发现隐藏段,但在特定环境中执行时被触发执行。</p></li><li><p>比如利用Unicode字符格式控制(LRE/RLE)在源码中间插入JavaScript代码。</p></li><li><p>当页面使用这种双向书写格式解析源码时,控制字符会触发隐藏代码执行。</p></li></ul><p>此类攻击很难通过简单查看源代码发现,通常需要专门的检测工具分析可能存在的隐藏代码段。</p><br></blockquote></details><br><p>这里给一个利用双向书写格式控制字符隐藏注入代码的 JavaScript 示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向书写格式左到右控制码插入隐藏代码</span></span><br><span class="line">\u202a</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;被注入的代码!&#x27;</span>);</span><br><span class="line">\u202c </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当使用支持双向书写的浏览器&#x2F;环境解析此源码时,会出现如下效果：</p><ol><li><p>首先正常显示”正常源码…”日志；</p></li><li><p>然后遇到 <code>\u202a</code> 控制码,切换解释方向从右到左；</p></li><li><p>这会导致 <code>alert(&#39;被注入的代码!&#39;);</code> 这段码变成隐藏状态,在源码中不可见；</p></li><li><p>再遇到 <code>\u202c</code> 控制码后切换回正常左到右方向；</p></li><li><p>最后再正常显示尾部”正常源码…”日志。</p></li></ol><p>而普通浏览器直接查看源码只会看到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>中间隐藏的 <code>alert</code> 调用无法见到，从而实现了代码注入的攻击目的。</p><details open><summary><strong><code>\u202a</code> 和 <code>\u202c</code> 这两个控制码的作用是什么 ？</strong></summary><blockquote><br><p><code>\u202a</code> 和 <code>\u202c</code> 是 <code>Unicode</code> 的双向格式控制字符。</p><p>它们的作用是控制文本书写的方向：</p><ul><li><p><code>\u202a</code> 是 <code>Unicode</code> 左到右标记(LRE)。它可以切换当前文本流的书写方向为从右到左；</p></li><li><p><code>\u202c</code> 是 <code>Unicode</code> 弹性冲突终止(PDF)。它可以把当前文本流的书写方向切换回正常的左到右。</p></li></ul><p>这两个控制字符常被用在支持双向书写的语言环境中，以控制阿拉伯数字和希伯来字母等文本的流向。</p><p>在 trojan source attacks 中，攻击者会利用它们来隐藏代码注入：</p><ul><li><p>使用 <code>\u202a</code> 指令切换流向右到左；</p></li><li><p>在这段流中插入要隐藏的代码，因为流向右到左，代码就会处于隐藏状态；</p></li><li><p>再使用 <code>\u202c</code> 指令切换流向回正常左到右。</p></li></ul><p>这样一来，正常查看源代码就看不见被隐藏的代码段了。但在支持双向的运行环境中，隐藏代码依然会被执行。</p><p>所以说,<code>\u202a</code> 和 <code>\u202c</code> 具有控制文本显示方向的关键作用，能很好地实现源代码层面的&quot;隐写术&quot;攻击手法。</p><br></blockquote></details><br><p>除了上面 2 个 Unicode 的双向格式控制字符外，还有其他的。以下是相关 Unicode 双向格式字符的表格及描述：</p><table><thead><tr><th>序号</th><th align="left">缩写</th><th align="left">Unicode字符</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td>1</td><td align="left">LRE</td><td align="left">U+202A</td><td align="left">左到右嵌入</td><td align="left">将以下文本处理为从左到右</td></tr><tr><td>2</td><td align="left">RLE</td><td align="left">U+202B</td><td align="left">右到左嵌入</td><td align="left">将以下文本处理为从右到左</td></tr><tr><td>3</td><td align="left">LRO</td><td align="left">U+202D</td><td align="left">左到右重写</td><td align="left">强制将以下文本作为从左到右处理</td></tr><tr><td>4</td><td align="left">RLO</td><td align="left">U+202E</td><td align="left">右到左重写</td><td align="left">强制将以下文本作为从右到左处理</td></tr><tr><td>5</td><td align="left">LRI</td><td align="left">U+2066</td><td align="left">左到右隔离</td><td align="left">将以下文本作为从左到右处理,不影响相邻文本</td></tr><tr><td>6</td><td align="left">RLI</td><td align="left">U+2067</td><td align="left">右到左隔离</td><td align="left">将以下文本作为从右到左处理,不影响相邻文本</td></tr><tr><td>7</td><td align="left">FSI</td><td align="left">U+2068</td><td align="left">首个强隔离</td><td align="left">根据接下来的字符强制处理以下文本的方向</td></tr><tr><td>8</td><td align="left">PDF</td><td align="left">U+202C</td><td align="left">弹出方向格式</td><td align="left">终止最近的 LRE、RLE、LRO 或 RLO</td></tr><tr><td>9</td><td align="left">PDI</td><td align="left">U+2069</td><td align="left">弹出方向隔离</td><td align="left">终止最近的 LRI 或 RLI</td></tr></tbody></table><p>trojan source attacks 属于源代码层面的攻击，需要攻击者能获取和修改受保护源代码，一般来说这需要内部人员参与恶意行为才行。</p><p>更具体地说:</p><ul><li><p>如果源代码完全开源，任何人都可以下载和修改，那么外部人也可能进行这种攻击；</p></li><li><p>但如果源代码受到良好控制和管理，只有内部开发和维护人员可以访问和提交代码，那么进行 trojan 源代码改动的就很可能是内部人员之一；</p></li><li><p>除非通过其他漏洞获得源代码写入权限，否则外部人很难直接进行源代码层面改动；</p></li><li><p>所以大多数情况下，这种攻击更可能源自内部人员的恶意行为，如内鬼、骇客入侵内部系统等。</p></li></ul><p>所以总之，trojan source attacks 强调源代码方面的改动，这更需要内部人员的参与进行，而不太可能是外部直接攻击。这也是它与其他类型攻击的一个区别。</p><h1 id="detect-buffer-noassert"><a href="#detect-buffer-noassert" class="headerlink" title="detect-buffer-noassert"></a>detect-buffer-noassert</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-buffer-noassert&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用于检测代码中没有做边界检查直接调用 buffer 的情况，这可能会导致缓冲区溢出漏洞。<code>noAssert</code> 标志禁用了边界检查，所以使用这个标志调用 buffer 是危险的做法。</p><p>主要的检测逻辑是：</p><ol><li><p>检测对 <code>buffer()</code> 的调用；</p></li><li><p>检查调用是否设置了 <code>noAssert</code> 标志；</p></li><li><p>如果同时满足以上两点，则报告警告</p></li></ol><p>这可以帮助开发者发现危险的 buffer 调用，进行修改以避免引入安全漏洞。总体来说,这个规则通过静态分析提高了代码安全性,防止缓冲区溢出等问题的产生。</p><p>下面是一个使用 <code>noAssert</code> 标志调用 <code>buffer()</code> 的错误示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">buf.<span class="title function_">write</span>(<span class="string">&#x27;some data&#x27;</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="string">&#x27;ascii&#x27;</span>, noAssert);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line">buf.<span class="title function_">write</span>(<span class="string">&#x27;some data&#x27;</span>, <span class="number">0</span>, buf.<span class="property">length</span>, <span class="string">&#x27;ascii&#x27;</span>); </span><br></pre></td></tr></table></figure><p>在这个例子中，<code>write()</code> 方法可能会向 buf 缓冲区写入超过其长度的数据，因为传入的长度参数为 120，大于 buf 的长度 100。而且使用了 <code>noAssert</code> 标志来禁用长度检查。</p><p>这就可能导致缓冲区溢出，造成内存污染、崩溃或安全漏洞。</p><p><code>security/detect-buffer-noassert</code> 规则会捕获像这样危险的 <code>noAssert</code> 调用，从而帮助发现并修复类似的问题。</p><h1 id="detect-child-process"><a href="#detect-child-process" class="headerlink" title="detect-child-process"></a>detect-child-process</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-child-process&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这条规则用来检测代码中是否存在潜在的子进程命令注入漏洞。</p><p>子进程模块 <code>child_process</code> 可以用来生成子进程，如果拼接用户输入到子进程命令中，可能会导致 <em>命令注入攻击</em>。</p><p>例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userInput = process.<span class="property">argv</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br></pre></td></tr></table></figure><p>如果用户输入包含特殊字符，可能会造成命令注入。</p><p>detect-child-process 规则会检查代码中是否：</p><ol><li><p>使用了 child_process 模块；</p></li><li><p>构造子进程命令时，拼接了用户可控变量。</p></li></ol><p>如果同时满足上述条件，则会报告高优先级警告,提示这里存在潜在的命令注入风险。</p><p><strong>如果实在需要拼接用户的输入，可以参考以下常见的安全措施：</strong></p><ol><li><p>使用白名单过滤用户输入，只允许安全的字符，过滤掉特殊字符；</p></li><li><p>对用户输入进行转义，防止特殊字符被解析为命令语法；</p></li><li><p>使用参数数组传入用户输入，而不是直接拼接字符串；</p></li><li><p>设置子进程的用户权限，限制它可以执行的命令；</p></li><li><p>使用沙箱机制限制子进程访问系统资源；</p></li><li><p>不直接使用用户输入，而是根据白名单映射为内部命令；</p></li><li><p>监控子进程的执行情况，设置超时时间，防止阻塞；</p></li><li><p>如果可能，避免直接使用用户输入，使用预定义的命令集合；</p></li><li><p>其他输入验证和输出编码等手段。</p></li></ol><p>在确认已经确认采取防范措施，可以使用内联的规则忽略方式去掉警告，如下：</p><ol><li><p>单行注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line security/detect-child-process</span></span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br></pre></td></tr></table></figure></li><li><p>范围注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safeExec</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* eslint-disable security/detect-child-process */</span></span><br><span class="line"></span><br><span class="line">  cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* eslint-enable security/detect-child-process */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><details open><summary><strong>命令注入攻击是什么？</strong></summary><blockquote><br><p>命令注入攻击（Command Injection）是一种常见的代码注入攻击，其方法是将操作系统命令通过利用程序漏洞注入到执行环境中。</p><p>攻击场景通常是：</p><ul><li><p>应用程序将用户输入当作命令参数执行；</p></li><li><p>但没有对用户输入进行足够验证和过滤；</p></li><li><p>攻击者通过特殊字符注入额外的命令。</p></li></ul><p>例如在未过滤用户输入的情况下执行：</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-title">runProgram</span><span class="hljs-params">(‘ls ‘ + userInput)</span></span>
    </code></pre><p>攻击者可以通过 <code>userInput</code> 注入额外命令：</p><pre><code class="lang-js"><span class="hljs-attribute">userInput</span> = ‘-la<span class="hljs-comment">; rm *’</span>
    </code></pre><p>从而读取目录内容并删除文件。</p><p>防范命令注入需要：</p><ul><li><p>对用户所有输入进行校验过滤，移除特殊字符；</p></li><li><p>使用参数化接口避免直接拼接命令字符串；</p></li><li><p>为子进程设置最少特权原则；</p></li><li><p>采用沙箱机制限制子进程权限。</p></li></ul><p>命令注入是常见且危险的攻击方式，开发人员必须警惕。</p><p>更多信息可参考：<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Command_Injection">OWASP - Command Injection</a></p><br></blockquote></details><br><h1 id="detect-disable-mustache-escape"><a href="#detect-disable-mustache-escape" class="headerlink" title="detect-disable-mustache-escape"></a>detect-disable-mustache-escape</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-disable-mustache-escape&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>它用于检测是否在使用 <a target="_blank" rel="noopener" href="http://mustache.github.io/">Mustache 模板引擎</a> 时关闭了 HTML 转义，这可能会导致 <em>XSS 漏洞</em>。</p><p>这个规则的主要逻辑是：</p><ol><li><p>检查代码中是否使用了 <a target="_blank" rel="noopener" href="http://mustache.github.io/">Mustache 模板引擎</a>；</p></li><li><p>检查 <code>Mustache</code> 的调用是否通过 <code>disableEscape</code> 选项关闭了 HTML 转义；</p></li><li><p>如果同时满足上述两个条件，则会报告警告；</p></li></ol><p>示例危险代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Mustache</span> = <span class="built_in">require</span>(<span class="string">&#x27;mustache&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">text</span>: <span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用转义,导致 XSS 漏洞</span></span><br><span class="line"><span class="title class_">Mustache</span>.<span class="title function_">render</span>(<span class="string">&#x27;&lt;p&gt;&#123;&#123;&#123;text&#125;&#125;&#125;&lt;/p&gt;&#x27;</span>, data); </span><br></pre></td></tr></table></figure><p>关闭转义后，用户输入的数据就可能包含恶意代码而没有被过滤。</p><p>这个规则可以帮助开发者识别 Mustache 模板中关闭转义的危险用法，修正为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Mustache</span>.<span class="title function_">render</span>(<span class="string">&#x27;&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt;&#x27;</span>, data);</span><br></pre></td></tr></table></figure><details open><summary><strong>XSS 是什么？</strong></summary><blockquote><br><p>XSS（Cross-Site Scripting，跨站脚本）攻击是一种代码注入攻击，它允许攻击者将恶意脚本注入到易受攻击的 Web 应用程序中。</p><p>简单来说，XSS 攻击的过程是：</p><ol><li><p>攻击者构造出特殊的恶意代码（通常是 JavaScript）。</p></li><li><p>恶意代码被提交到易受攻击的网站，并保存在服务器端（比如用户提交表单，注入恶意 JavaScript 代码）。</p></li><li><p>网站将未过滤的恶意代码发送给其他用户（比如在结果页面直接输出用户输入的内容）。</p></li><li><p>其他用户的浏览器执行了这段恶意 JavaScript 代码，导致账号被盗用、页面被篡改等后果。</p></li></ol><p>XSS 因此可以让攻击者得到目标用户的敏感信息，篡改页面内容，以受害者的身份执行操作等。</p><p>防范 XSS 需要对用户输入进行校验和输出编码，避免直接暴露给浏览器，即输入验证和输出编码。现在也有许多静态扫描工具可以检测 XSS 漏洞。</p><p>关于更多 XSS 的内容可参考：<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/xss/">Cross Site Scripting (XSS)</a></p><br></blockquote></details><br><details open><summary><strong>Mustache 模板引擎是什么？</strong></summary><blockquote><br><p>Mustache 是一种流行的 JavaScript 模板引擎，它可以用来根据视图模板和数据渲染 HTML。</p><p>Mustache 的一些关键特点包括：</p><ul><li><p>语法简单，双大括号表示变量插入点。如：<code>Hello &#123;&#123;name&#125;&#125;</code>；</p></li><li><p>不需要预编译，在客户端实时渲染模板；</p></li><li><p>支持主流前端框架，可以配合 React、Vue 等使用；</p></li><li><p>默认进行 HTML 转义，防止 XSS 攻击；</p></li><li><p>支持自定义语法扩展；</p></li><li><p>无依赖，体积小。</p></li></ul><p>Mustache 的用法示例:</p><pre>
<code class="lang-js"><span class="hljs-comment">// 定义模板 </span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">template</span> = <span class="hljs-string">"Hello &#123;&#123;name&#125;&#125;"</span>; 
<span class="hljs-comment">// 渲染函数</span>
<span class="hljs-keyword">const</span> render = Mustache.render(<span class="hljs-keyword">template</span>, &#123;name: <span class="hljs-string">"Jack"</span>&#125;);
<span class="hljs-comment">// 得到渲染结果</span>
render; <span class="hljs-comment">// "Hello Jack"</span>
</code></pre><p>必须注意的是，在使用 Mustache 时不要关闭 HTML 转义选项，否则可能会导致XSS漏洞。建议配合 ESLint 的 <code>detect-disable-mustache-escape</code> 规则进行静态检查。</p><p>总体上，Mustache是一个轻量简单的模板引擎，可以快速实现数据渲染，但需要注意安全性。</p><p>保持默认的转义打开，然后再根据需要通过白名单等手段过滤用户输入数据，从而避免 XSS 漏洞。</p><br></blockquote></details><br><p>目前常见的前端框架大多<strong>基于或可以集成</strong> Mustache 模板引擎，比如：</p><ul><li><p>React - 可以通过 react-mustache 这个库集成 Mustache；</p></li><li><p>Vue - 可以通过 vue-mustache 这个库集成 Mustache；</p></li><li><p>Angular - 可以通过 ngx-mustache 库集成；</p></li><li><p>Ember - Ember 内置对 Mustache 的支持；</p></li><li><p>Backbone - Backbone 推荐的模板引擎就是 Mustache；</p></li><li><p>Meteor - Meteor 提供了空间风格(Spacebars)模板，语法与 Mustache 类似；</p></li><li><p>Node.js - 可以通过 mustache 模块在后端使用；</p></li><li><p>Vanilla JS - 直接通过嵌入式 JS 或从 CDN 引入 Mustache。</p></li></ul><p>支持多种语言，其中 JavaScript 由 <a target="_blank" rel="noopener" href="https://github.com/janl/mustache.js">mustache.js</a> 支持。</p><h1 id="detect-eval-with-expression"><a href="#detect-eval-with-expression" class="headerlink" title="detect-eval-with-expression"></a>detect-eval-with-expression</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-eval-with-expression&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>检测代码中调用 <code>eval()</code> 时是否传入了表达式，这可能会导致代码注入漏洞。</p><p>这个规则的主要逻辑是：</p><ol><li><p>检查代码中是否调用了 <code>eval()</code> 函数；</p></li><li><p>检查 <code>eval()</code> 调用时的参数是否是一个表达式，而不是 <code>String</code> 类型的代码文本；</p></li><li><p>如果同时满足上述两个条件，则会报告高级别的警告。</p></li></ol><p>因为直接传入表达式给 <code>eval</code> 可能会执行用户可控制的代码。示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;&#123;&quot;foo&quot;: 1&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">eval</span>(userInput); </span><br></pre></td></tr></table></figure><p>这里用户可以输入任意 JavaScript 表达式。</p><p>建议的更安全写法是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;&#123;&quot;foo&quot;: 1&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span> + userInput + <span class="string">&#x27;)&#x27;</span>); </span><br></pre></td></tr></table></figure><p>把输入包装为字符串，限制为表达式形式。</p><p>这个规则通过静态分析帮助发现可能的 <code>eval</code> 注入漏洞，提高代码的安全性。但如果输入来源可信，或者有其他安全保障措施，也可以通过配置忽略该规则。</p><p>更多关于 <code>eval</code> 可能引起的问题可参考：<a target="_blank" rel="noopener" href="http://security.stackexchange.com/questions/94017/what-are-the-security-issues-with-eval-in-javascript">What are the security issues with eval in JavaScript?</a></p><h1 id="detect-new-buffer"><a href="#detect-new-buffer" class="headerlink" title="detect-new-buffer"></a>detect-new-buffer</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-new-buffer&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>用于检测代码直接通过 <code>new Buffer()</code> 创建 Buffer 的情况,推荐使用 <code>Buffer.from()</code> 来替代。</p><p>主要原因是:</p><ol><li><p><code>new Buffer()</code> 已被 Node.js 废弃（v6.0.0开始，v15.0.0完全废弃），可能会导致应用出现警告；</p></li><li><p><code>new Buffer()</code> 在处理参数时有一定风险；比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">Buffer</span>(userInput);</span><br></pre></td></tr></table></figure><p>如果 <code>userInput</code> 是数字，可能会分配非常大的内存空间， 造成 <em>DoS 攻击</em>。</p></li><li><p><code>Buffer.from()</code> 在处理参数时更安全可靠。</p></li></ol><p>所以该规则会对 <code>new Buffer()</code> 的使用报出警告，推荐更安全的 <code>Buffer.from()</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果业务需要兼容旧版本 Node.js，可以通过注释或配置的方式忽略此规则，但需要注意风险。</p><p>总之该规则推荐使用新的 Buffer API 来避免潜在问题，提升代码质量和安全性。</p><details open><summary><strong>DoS 攻击是什么 ？</strong></summary><blockquote><br><p>DoS（Denial of Service，拒绝服务）攻击是一种使目标失去提供正常服务能力的攻击。常见的 DoS 攻击有：</p><ol><li><p>带宽攻击：通过大量流量淹没目标，消耗网络带宽。比如 UDP flood，ICMP flood 等；</p></li><li><p>资源攻击：消耗关键系统资源如 CPU、内存等。比如 fork bomb；</p></li><li><p>协议攻击：利用网络协议漏洞进行攻击。比如 SYN flood 利用 TCP 三次握手漏洞；</p></li><li><p>应用层攻击：针对应用程序漏洞进行攻击。比如 HTTP flood；</p></li><li><p>分布式 DoS：使用多台攻击源同时进行攻击。</p></li></ol><p>DoS 攻击的目的是使服务暂时不可用。与 DoS 类似但有差别的是 DDoS 攻击，它利用了大量的分布式节点参与攻击，造成更大的威胁。</p><p>预防 DoS 攻击需要从网络架构、系统资源、应用程序等不同层面进行保护，比如使用过滤、限速、负载均衡、堆栈随机化等技术。</p><br></blockquote></details><br><h1 id="detect-no-csrf-before-method-override"><a href="#detect-no-csrf-before-method-override" class="headerlink" title="detect-no-csrf-before-method-override"></a>detect-no-csrf-before-method-override</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-no-csrf-before-method-override&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>用于检测 Node.js <strong>Express</strong> 应用中是否在 <a target="_blank" rel="noopener" href="https://github.com/expressjs/method-override">method-override</a> 中间件之前使用了 csrf 中间件。</p><p>在 Express 应用中，<a target="_blank" rel="noopener" href="https://github.com/expressjs/method-override">method-override</a> 中间件允许通过查询参数或者请求体改变 HTTP 请求方法。</p><p><strong>如果在 method override 之前没有 csrf 保护，那么攻击者可以通过构造查询参数轻易地绕过 csrf 防护，以 POST 的权限调用敏感的 GET 操作。</strong></p><p>例如，正常的 csrf 校验路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">csrf</span>()) <span class="comment">// csrf中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">methodOverride</span>()) <span class="comment">// 方法重写中间件</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/transfer&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 转账逻辑</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>攻击者可以直接构造查询参数执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/transfer?_method=<span class="variable constant_">POST</span></span><br></pre></td></tr></table></figure><p>绕过 csrf 防护，以 POST 权限调用转账接口。</p><p>所以该规则会检测 <a target="_blank" rel="noopener" href="https://github.com/expressjs/method-override">method-override</a> 是否在 csrf 之前，以发现这个潜在的问题。解决方式是确保 csrf 中间件在 <a target="_blank" rel="noopener" href="https://github.com/expressjs/method-override">method-override</a> 之前。</p><p>detect-no-csrf-before-method-override 规则不仅可以检测 Express 的中间件使用顺序，也可以检测其他框架中的类似用法。</p><p>该规则的基本检测逻辑是：</p><ol><li><p>检测是否使用了方法覆盖（method override）功能；</p></li><li><p>检测方法覆盖是否在 CSRF 防护之前。</p></li></ol><p>只要代码中具有这种“方法覆盖先于 CSRF 防护”的结构，该规则都能检测出来。</p><p>除了 Express 路由之外，它也能够检测：</p><ul><li><a target="_blank" rel="noopener" href="https://fastify.dev/">Fastify ↗</a> 中类似的中间件使用顺序；</li><li><a target="_blank" rel="noopener" href="https://koajs.com/">Koa ↗</a> 中间件注册顺序；</li><li><a target="_blank" rel="noopener" href="https://nestjs.com/">NestJS ↗</a> 中间件顺序；</li><li>其他类框架的中间件&#x2F;拦截器顺序。</li></ul><p>只要框架提供了方法覆盖和 CSRF 防护机制，并可能存在方法覆盖先于 CSRF 校验的情况，该规则就可以起到检测作用。</p><p>所以更准确地说，这条规则是框架无关的，只要保证方法覆盖不会绕过 CSRF 即可。</p><details open><summary><strong>CSRF 是什么 ？</strong></summary><blockquote><br><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络攻击，它冒充受信任用户的身份，在目标网站上执行未授权的命令。</p><p>CSRF攻击的过程通常如下：</p><ol><li><p>用户登录受信任网站 A，并在本地生成了 cookie；</p></li><li><p>用户打开另一个网站 B，网站 B 包含了点击链接、提交表单等向网站 A 发起请求的操作；</p></li><li><p>用户被诱导在网站 B 上触发了操作，同时利用用户本地的 cookie，在网站A中完成了未授权的动作。</p></li></ol><p>例如：</p><p>网站 B 包含了向网站 A 转账的表单，利用用户本地 cookie 可以完成转账动作。</p><p>常见的CSRF防御手段有：</p><ul><li><p>检查 HTTP Referer，拒绝外域请求；</p></li><li><p>在请求中设置 token，并验证 token 是否合法；</p></li><li><p>在提交敏感请求时重新验证用户身份；</p></li><li><p>GET 请求不对数据进行修改；</p></li><li><p>关键操作使用 POST 请求，并进行 token 验证。</p></li></ul><p>CSRF 攻击依赖于用户认证状态，可以进行敏感操作篡改或数据窃取。正确的防范手段可以有效防止 CSRF 攻击。</p><br></blockquote></details><br><h1 id="detect-non-literal-fs-filename"><a href="#detect-non-literal-fs-filename" class="headerlink" title="detect-non-literal-fs-filename"></a>detect-non-literal-fs-filename</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-fs-filename&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用于检测代码中是否向 fs 模块的文件操作方法传入了非字面量的文件名参数。</p><p>例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename = <span class="title function_">getFilenameFromUser</span>(); </span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(filename, ...);</span><br></pre></td></tr></table></figure><p>传入可以由用户控制的 filename 变量是危险的，可能会导致 <em>路径遍历（<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a>） 攻击</em> 。</p><p>攻击者可以通过 <code>../</code> 构造文件名，访问任意文件。</p><p>所以该规则会检测以下情况：</p><ol><li><p>调用了 fs 模块的文件操作函数（readFile 等）；</p></li><li><p>文件名参数不是字符串字面量，可能是变量或表达式计算；</p></li></ol><p>一旦满足上述条件，就会报出警告。</p><p>建议的更安全写法是使用字面量文件名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./somefile.txt&#x27;</span>, ...); </span><br></pre></td></tr></table></figure><p>或者进行文件名校验：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">validateFilename</span>(filename);</span><br><span class="line">fs.<span class="title function_">readFile</span>(filename, ...);</span><br></pre></td></tr></table></figure><p>该规则通过静态分析帮助发现路径遍历问题，提升了代码安全性。</p><details open><summary><strong>路径遍历（Path Traversal）攻击是什么 ？</strong></summary><blockquote><br><p>路径遍历（Path Traversal）漏洞允许攻击者通过操纵目标文件的路径字符串访问超出预定范围的文件系统区域。</p><p>常见的攻击手法包括：</p><ul><li><p>使用 <code>../</code> 绕过文件系统限制，访问任意文件；</p></li><li><p>利用可替换组件如用户名访问其他文件名；</p></li><li><p>乱码等绕过过滤。</p></li></ul><p>该漏洞常见于将用户输入直接用于文件读取的函数，例如 <code>fs.readFile()</code>。</p><p>影响范围从信息泄露到远程代码执行不等。</p><p>防范措施：</p><ul><li><p>对用户输入进行校验，过滤特殊字符；</p></li><li><p>使用白名单验证文件名；</p></li><li><p>Restrict file system access；</p></li><li><p>使用不包含用户输入的随机文件名；</p></li><li><p>对路径组件进行标准化处理；</p></li><li><p>CDN 或存储服务器的访问控制；</p></li><li><p>其他输入验证方式。</p></li></ul><p>开发人员应该意识到这样的风险，在代码中采取防范措施，避免导致路径遍历漏洞。</p><br></blockquote></details><br><h1 id="detect-non-literal-regexp"><a href="#detect-non-literal-regexp" class="headerlink" title="detect-non-literal-regexp"></a>detect-non-literal-regexp</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-regexp&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用于检测代码中是否构造正则表达式时使用了非字面量的参数。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(userInput);</span><br></pre></td></tr></table></figure><p>如果用户输入是正则特殊字符，可能会导致 <em>ReDoS（正则拒绝服务）</em> 攻击。</p><p>攻击者可以构造谐音回退、组合重复等看似合法的正则，但处理非常缓慢。这可能占用大量 CPU 资源，成为 DoS 攻击。</p><p>所以该规则会检测以下情况：</p><ol><li>构造了正则表达式；</li><li>参数不是字符串字面量。</li></ol><p>建议的更安全写法是使用字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure><p>如果必须使用变量，也需要先对其进行过滤，移除危险的正则特殊字符。</p><p>该规则通过静态分析帮助发现潜在的 ReDoS 问题，提升了代码安全性。但如果有其他防范手段，也可以通过配置忽略该规则。</p><details open><summary><strong>ReDoS（正则拒绝服务）攻击是什么 ？</strong></summary><blockquote><br><p>ReDoS（Regular expression Denial of Service）即正则拒绝服务攻击，是一种对目标应用程序正则表达式引擎进行的拒绝服务攻击。</p><p>攻击方式是构造非常复杂的正则表达式，这些正则语法上合法，但是处理会非常缓慢。这样就可以让目标服务器 cpu 耗尽，无法响应正常请求。</p><p>例如：</p><ul><li><p>重复高次方数：<code>/(a+)+/</code>；</p></li><li><p>谐音回退：<code>/([a-z]+)*/</code>；</p></li></ul><p>防范 ReDoS 攻击的方法：</p><ul><li><p>使用简单正则，避免递归、重复、回溯等高危结构；</p></li><li><p>对用户输入正则进行过滤和限制；</p></li><li><p>设置正则处理超时；</p></li><li><p>使用安全的正则引擎，如 Rust 的 Regex；</p></li><li><p>限制正则复杂度，如匹配长度、分支数等</p></li><li><p>提高应用异步容错能力，避免全局阻塞。</p></li></ul><p>开发者需要谨慎处理用户提供的正则表达式，识别 ReDoS 攻击模式，采取防御措施。</p><p>更多关于 ReDoS 的信息可参考：<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">Regular expression Denial of Service - ReDoS</a></p><br></blockquote></details><br><h1 id="detect-non-literal-require"><a href="#detect-non-literal-require" class="headerlink" title="detect-non-literal-require"></a>detect-non-literal-require</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-require&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用于检测代码中是否使用非字面量的参数调用了 <code>require()</code> 函数。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleName = <span class="title function_">getModuleName</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(moduleName); </span><br></pre></td></tr></table></figure><p>allow 攻击者通过 <code>moduleName</code> 变量控制引入的模块。</p><p>攻击者可能利用这个漏洞执行任意代码。</p><p>所以该规则会检测以下情况：</p><ol><li><p>调用了 <code>require()</code> 函数；</p></li><li><p>参数不是字符串字面量。</p></li></ol><p>一旦同时满足上述条件，就会报出警告。</p><p>建议的更安全写法是使用字面量模块路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或者事先校验模块名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">validateModuleName</span>(moduleName); </span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(moduleName);</span><br></pre></td></tr></table></figure><p>该规则通过静态分析帮助发现非字面量 <code>require</code> 的风险，提升了代码安全性。</p><details open><summary><strong>allow 攻击是什么 ？</strong></summary><blockquote><br><p>allow 攻击（Arbitrary Code Execution）是一种通过植入恶意代码并执行来进行的攻击方式。</p><p>常见的 allow 攻击形式包括：</p><ul><li><p>代码/命令注入（Code/Command Injection）：通过注入漏洞向应用传入恶意代码并执行；</p></li><li><p>目录遍历/文件包含（Path Traversal/File Include）：访问恶意文件并作为代码运行；</p></li><li><p>不安全的反序列化（Unsafe Deserialization）：通过反序列化运行恶意构造的对象；</p></li><li><p>权限提升（Privilege Escalation）：利用漏洞提权，执行未授权的代码；</p></li><li><p>库/依赖注入（Dependency Injection）：通过依赖关系执行恶意代码；</p></li><li><p>服务器端请求伪造（SSRF）：利用内网请求漏洞执行任意代码；</p></li><li><p>诱导用户运行附件/程序（User Execution）：诱使用户自行运行恶意程序。</p></li></ul><p>防范allow攻击的方法包括：</p><ul><li><p>输入验证和输出编码；</p></li><li><p>最少特权原则；</p></li><li><p>安全的反序列化和依赖管理；</p></li><li><p>配额限制和沙箱隔离；</p></li><li><p>强化认证和授权模型。</p></li></ul><p>开发人员必须谨防用户非法输入，避免代码执行漏洞。</p><br></blockquote></details><br><h1 id="detect-object-injection"><a href="#detect-object-injection" class="headerlink" title="detect-object-injection"></a>detect-object-injection</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-object-injection&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用于检测代码中可能存在的对象注入漏洞。</p><p>对象注入漏洞形成的原因是将用户输入直接用于对象构造，用户可以修改对象原型行为。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;constructor&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [userInput]: <span class="string">&#x27;test&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>用户可以通过输入 <code>constructor</code> 来改写原型，进而可能执行任意代码。</p><p>所以该规则检测以下情况：</p><ol><li><p>从外部输入构造了对象字面量；</p></li><li><p>字面量中可能包含危险属性名，如 <code>constructor</code>、<code>prototype</code>、<code>proto</code> 等。</p></li></ol><p>一旦同时满足上述条件，就会报出警告。</p><p>建议的安全写法是先校验用户输入，过滤危险属性名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">filterInput</span>(userInput);</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [userInput]: <span class="string">&#x27;test&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>也可以通过 <code>Proto.freeze()</code> 冻结原型防止扩展。</p><p>该规则通过静态分析帮助发现对象注入问题，提升了代码安全性。但有时候可能会产生误报，需要结合业务逻辑处理。</p><p>更多关于对象注入漏洞的信息可参考：<a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/the-dangers-of-square-bracket-notation.md">The Dangers of Square Bracket Notation</a></p><h1 id="detect-possible-timing-attacks"><a href="#detect-possible-timing-attacks" class="headerlink" title="detect-possible-timing-attacks"></a>detect-possible-timing-attacks</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-possible-timing-attacks&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则是用来检测代码中可能存在的 <em>计时攻击</em> 风险的。</p><p>计时攻击是一种侧信道攻击，通过比较操作时间差异来猜测敏感信息。</p><p>例如下面的登录验证逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">login</span>(<span class="params">user, password</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (password === secretPassword) &#123; </span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 登录失败  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击者可以通过测量验证时间的不同来猜测密码。</p><p>因此，该规则会检测</p><ol><li><p>代码中是否存在涉及秘密的基于时序的比较；</p></li><li><p>这个时序是否可以被外部观测到。</p></li></ol><p>如果检测到这样的模式，则会报出警告。</p><p>修复方式是避免基于时序的密码学比较，改用定时算法等加密方法。</p><p>该规则可以帮助开发者提前发现这类风险，防止将来被计时攻击利用。</p><details open><summary><strong>计时攻击是什么 ？</strong></summary><blockquote><br><p>计时攻击（Timing Attack）是一种侧信道攻击，它通过分析代码执行时间的不同来获取敏感信息。</p><p>计时攻击的基本原理是：</p><ul><li><p>程序中的加密验证等算法，时序会随着输入的不同而有细微变化；</p></li><li><p>通过观测大量运行时间，可以统计出时间与输入值的关联性；</p></li><li><p>最终可以推导出敏感信息，如密码、密钥等。</p></li></ul><p>例如在登录验证过程中，验证时间随密码的不同而变化，这可以被利用来破解密码。</p><p>常见的计时攻击场景还包括：</p><ul><li><p>比较密码哈希时的时间差异；</p></li><li><p>加解密运算时间微差；</p></li><li><p>TCP 序列号预测等。</p></li></ul><p>防范计时攻击的方法：</p><ul><li><p>使用定时算法，避免时序依据；</p></li><li><p>在非密文区添加随机等待；</p></li><li><p>防止外部精确计时；</p></li><li><p>整体设计上避免秘密相关的时序依据。</p></li></ul><p>计时攻击有时效性较差，但成功可能导致严重后果。识别时序依据并采取防范措施非常重要。</p><br></blockquote></details><br><h1 id="detect-pseudoRandomBytes"><a href="#detect-pseudoRandomBytes" class="headerlink" title="detect-pseudoRandomBytes"></a>detect-pseudoRandomBytes</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-pseudoRandomBytes&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用来检测代码中是否使用了伪随机数生成函数 <code>Math.random()</code>。</p><p><code>Math.random()</code> 这个函数生成的随机数质量较差，存在确定性，不适用于要求高强度随机数的场景，比如生成密码或密钥。</p><p>该规则会检测调用了 <code>Math.random()</code> 的情况，并给出警告。</p><p>需要随机数的更好选择是使用 Node.js 中的 <code>crypto</code> 模块，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bytes = crypto.<span class="title function_">randomBytes</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure><p><code>crypto.randomBytes</code> 使用更强的随机数生成器，可以应对密码学和安全场景。</p><p>该规则提醒开发者不要使用 <code>Math.random()</code>，而是考虑使用 <code>crypto.randomBytes()</code> 来获取更强质量的随机数。</p><p>当然，如果不是用于安全相关的随机数，用 <code>Math.random()</code> 也可以接受。可以通过注释或配置的方式绕过该规则。</p><p>在 Web 场景中，也存在一些需要高质量随机数的 case，比如：</p><ul><li><p>生成用户登录、注册等的验证码；</p></li><li><p>生成安全令牌和会话 ID；</p></li><li><p>加密通信中的初始化向量；</p></li><li><p>在浏览器中生成密码或密钥。</p></li></ul><p>这时使用 <code>Math.random()</code> 都是不合适的。更好的处理方式是：</p><ul><li><p>使用浏览器提供的加密安全随机数生成器：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues">crypto.getRandomValues()</a>，它利用系统熵源。</p></li><li><p>将随机数生成服务端化，由后端生成并提供给前端。</p></li><li><p>使用第三方的加密库，如 <a target="_blank" rel="noopener" href="https://github.com/bitwiseshiftleft/sjcl">Stanford Javascript Crypto Library</a>。</p></li><li><p>对 <code>Math.random()</code> 进行种子混淆、hash 运算等提升随机性。</p></li><li><p>根据业务场景允许弱随机性，但注明其限制。</p></li></ul><p>Web 前端中如果需要高安全性的随机数，要注意不要直接使用 <code>Math.random()</code>，而要考虑浏览器&#x2F;服务端的加密安全替代方案。</p><p>同时，也要明确什么场景可以接受弱随机，什么场景要强随机，针对性应用正确的随机数源。</p><details open><summary><strong>为什么说 <code>Math.random()</code> 这个函数生成的随机数质量较差，存在确定性？</strong></summary><blockquote><br><p><code>Math.random()</code> 生成的随机数质量较差，主要有以下原因：</p><ol><li><p>确定性：<code>Math.random()</code> 的种子通常是基于时间戳的，在同一毫秒内会生成同样的序列，有确定性。</p></li><li><p>复现性：种子是可预测的，给定种子可以复现整个随机数序列。</p></li><li><p>周期性：序列会重复循环使用，较短的周期。</p></li><li><p>随机性缺陷：统计测试结果不达标，比如游程测试。</p></li><li><p>算法缺陷：线性同余或类似的伪随机算法。</p></li><li><p>语言运行时缺陷：部分语言运行时 <code>Math.random()</code> 实现存在缺陷。</p></li><li><p>环境固有缺陷：比如虚拟机可预测的熵源。</p></li></ol><p>相比之下，像 Node.js 的 <code>crypto.randomBytes()</code> 使用杂凑和系统熵源，可以生成不可预测的加密安全随机数，适用于对安全和随机性要求非常高的场景。</p><p>所以 <code>Math.random()</code> 不应被滥用于密码学和安全相关场景中。</p><br><p>关于更多不应使用<code>Math.random()</code>的信息可参考：<a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/181580/why-is-math-random-not-designed-to-be-cryptographically-secure">Why is Math.random() not designed to be cryptographically secure?</a></p><br></blockquote></details><br><h1 id="detect-unsafe-regex"><a href="#detect-unsafe-regex" class="headerlink" title="detect-unsafe-regex"></a>detect-unsafe-regex</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-unsafe-regex&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure><p>这个规则用来检测代码中是否存在潜在的不安全正则表达式。</p><p>不安全正则表达式的典型问题有：</p><ul><li><p>具有指数级别复杂度的正则，可能成为 ReDoS 攻击的受害者；</p></li><li><p>容易回溯的正则，如递归正则，也可能导致复杂度爆炸；</p></li><li><p>利用特殊字符做键控注入的正则。</p></li></ul><p>该规则通过匹配一些模式,来检测像 <code>(a+)+</code> 这样复杂度高的正则，以及像 <code>/[Designer match Sajon]/</code> 这样可能存在注入风险的正则。一旦匹配到则会给出警告。</p><p>更安全的做法是：</p><ul><li><p>尽量使用简单的正则;</p></li><li><p>对用户输入的正则进行过滤和转义;</p></li><li><p>设置正则处理的超时和长度限制;</p></li><li><p>使用正则引擎的安全匹配模式。</p></li></ul><p>这个规则可以帮助开发者提前发现不安全的正则表达式，防止被利用为 DoS 攻击的向量。但有时也会误报，需要结合业务场景处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面通过安装 <code>eslint-plugin-security</code>，实践了它所支持的 14 个规则。对每个规则都站来了较为详尽的描述，了解规则的配置方式、起到的作用，涉及到的安全问题。并以此简述了规则所预防的网络攻击。</p><p>通过本次实践，了解以下网络攻击：</p><ul><li><p>trojan source attacks：利用双向书写系统中的特殊字符实现隐藏代码注入的攻击方式；</p></li><li><p>以 <code>noAsset</code> 标志使用 <code>Buffer</code> 引发的缓冲区溢出，造成内存污染、崩溃或安全漏洞；</p></li><li><p>命令注入攻击（Command Injection）：将操作系统命令通过利用程序漏洞注入到执行环境中的代码注入攻击；</p></li><li><p>XSS（Cross-Site Scripting，跨站脚本）攻击；</p></li><li><p>DoS（Denial of Service，拒绝服务）攻击；</p></li><li><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）；</p></li><li><p>路径遍历（Path Traversal）漏洞；</p></li><li><p>ReDoS（Regular expression Denial of Service）即正则拒绝服务攻击；</p></li><li><p>allow 攻击（Arbitrary Code Execution）；</p></li><li><p>对象注入漏洞；</p></li><li><p>计时攻击（Timing Attack）：是一种侧信道攻击，它通过分析代码执行时间的不同来获取敏感信息；</p></li><li><p>伪随机数生成函数引发的密码类安全问题；</p></li><li><p>不安全正则表达式引发的 ReDoS 攻击 或 DoS 攻击；</p></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="完整规则"><a href="#完整规则" class="headerlink" title="完整规则"></a>完整规则</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;security/detect-buffer-noassert&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-child-process&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-disable-mustache-escape&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-eval-with-expression&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-new-buffer&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-no-csrf-before-method-override&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-fs-filename&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-regexp&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-require&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-object-injection&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-possible-timing-attacks&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-pseudoRandomBytes&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-unsafe-regex&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-bidi-characters&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh-hans/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF">双向文稿</a></li><li><a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a></li><li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Denial-of-service_attack">Denial-of-service attack</a></li><li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Timing_attack">Wikiwand - Timing attack</a></li><li><a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/xss/">Cross Site Scripting (XSS)</a></li><li><a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Command_Injection">OWASP - Command Injection</a></li><li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Denial-of-service_attack">Wikiwand - Denial-of-service attack</a></li><li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Arbitrary_code_execution">Wikiwand - Arbitrary code execution</a></li><li><a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/csrf">Cross Site Request Forgery (CSRF)</a></li><li><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/regular-expression-dos-and-node.md">Regular Expression DoS and Node.js</a></li><li><a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/the-dangers-of-square-bracket-notation.md">The Dangers of Square Bracket Notation</a></li><li><a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">Regular expression Denial of Service - ReDoS</a></li><li><a target="_blank" rel="noopener" href="http://security.stackexchange.com/questions/94017/what-are-the-security-issues-with-eval-in-javascript">What are the security issues with eval in JavaScript?</a></li><li><a target="_blank" rel="noopener" href="https://www.bennadel.com/blog/2169-where-does-node-js-and-require-look-for-modules.htm">Where Does Node.js And Require() Look For Modules?</a></li><li><a target="_blank" rel="noopener" href="https://pvs-studio.com/en/blog/posts/cpp/0933/">Trojan Source attack for introducing invisible vulnerabilities</a></li><li><a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/181580/why-is-math-random-not-designed-to-be-cryptographically-secure">Why is Math.random() not designed to be cryptographically secure?</a></li></ul></div><footer class="post-footer"><div class="reward-container"><div>Buy me a coffee</div><button>赞赏</button><div class="post-reward"><div><img src="/blog/images/wechatpay.jpg" alt="Isaac Kam 微信"> <span>微信</span></div><div><img src="/blog/images/alipay.jpg" alt="Isaac Kam 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Isaac Kam</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/" title="从 eslint-plugin-security 看前端安全">https://isaaxite.github.io/blog/resources/Using-eslint-plugin-security/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://www.zhihu.com/people/issac-79"><span class="icon"><i class="fab | fa-zhihu"></i> </span><span class="label">Zhihu</span></a></div><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span> </span><img class="social-item-img" src="/blog/images/wechat_qrcode.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/blog/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://github.com/isaaxite"><span class="icon"><i class="fab fa-github"></i> </span><span class="label">GitHub</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="isaacgun:isaacgun@outlook.com"><span class="icon"><i class="fa fa-envelope"></i> </span><span class="label">E-Mail</span></a></div></div></div><div class="post-tags"><a href="/blog/tags/eslint-plugin-security/" rel="tag"><i class="fa fa-tag"></i> eslint-plugin-security</a> <a href="/blog/tags/%E5%AE%9E%E8%B7%B5/" rel="tag"><i class="fa fa-tag"></i> 实践</a> <a href="/blog/tags/trojan-source-attacks/" rel="tag"><i class="fa fa-tag"></i> trojan source attacks</a> <a href="/blog/tags/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/" rel="tag"><i class="fa fa-tag"></i> 安全漏洞</a> <a href="/blog/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/" rel="tag"><i class="fa fa-tag"></i> 命令注入攻击</a> <a href="/blog/tags/XSS/" rel="tag"><i class="fa fa-tag"></i> XSS</a> <a href="/blog/tags/DoS/" rel="tag"><i class="fa fa-tag"></i> DoS</a> <a href="/blog/tags/CSRF/" rel="tag"><i class="fa fa-tag"></i> CSRF</a> <a href="/blog/tags/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" rel="tag"><i class="fa fa-tag"></i> 路径遍历</a> <a href="/blog/tags/ReDoS/" rel="tag"><i class="fa fa-tag"></i> ReDoS</a> <a href="/blog/tags/allow-%E6%94%BB%E5%87%BB/" rel="tag"><i class="fa fa-tag"></i> allow 攻击</a> <a href="/blog/tags/%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" rel="tag"><i class="fa fa-tag"></i> 对象注入漏洞</a> <a href="/blog/tags/%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB/" rel="tag"><i class="fa fa-tag"></i> 计时攻击</a></div><div class="post-nav"><div class="post-nav-item"><a href="/blog/resources/Linux-Package-Manager-Apt/" rel="prev" title="Linux 包管理器 - APT"><i class="fa fa-chevron-left"></i> Linux 包管理器 - APT</a></div><div class="post-nav-item"><a href="/blog/resources/Get-Start-Of-VScode-Ext-Dev/" rel="next" title="Get-Start-Of-VScode-Ext-Dev">Get-Start-Of-VScode-Ext-Dev <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Isaac Kam</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/blog/js/third-party/search/local-search.js"></script><script src="/blog/js/third-party/fancybox.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"isaaxite/blog","issue_term":"title","theme":"github-light"}</script><script src="/blog/js/third-party/comments/utterances.js"></script></body></html>