<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue中的diff算法实现</title>
    <url>/blog/2019/12/26/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#diff%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">diff算法是什么</a><ul>
<li><a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a></li>
<li><a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a></li>
<li><a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a></li>
<li><a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a></li>
<li><a href="#5%E5%BD%93%E5%89%8D%E6%96%B0vnode%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%B0%BE%E4%B9%8B%E9%97%B4%E7%9A%84vnode%E5%AF%B9%E6%AF%94">5.当前新vnode与旧头尾之间的vnode对比</a></li>
<li><a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a></li>
<li><a href="#0%E8%B7%B3%E8%BF%87%E5%8F%B3%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">0.跳过右边已经复用的vnode</a></li>
<li><a href="#while%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E9%A1%BA%E5%BA%8F">while中的控制流顺序</a></li>
</ul>
</li>
<li><a href="#while%E4%B9%8B%E5%A4%96">while之外</a></li>
<li><a href="#%E6%96%B0%E6%97%A7vnode%E4%B8%8E%E7%9C%9F%E5%AE%9E%E5%85%83%E7%B4%A0elm%E7%9A%84%E5%85%B3%E7%B3%BB">新旧vnode与真实元素elm的关系</a></li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a><ul>
<li><a href="#sameVnode%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">sameVnode的功能与实现逻辑</a></li>
<li><a href="#patchVnode%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0">patchVnode函数的关键实现</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>vue版本：2.6.10</strong></p>
<p>每次更新视图前都会根据视图模板生成vnode（虚拟的节点树），vnode类似dom树，但更简陋，每个vnode都与页面的上的元素html元素一一对应！为了更好的性能，因此要复用元素。那么就要知道怎么复用！就要对比newVnode（当前生成的vnode）和oldVnode（上次生成的vnode），对比完之后才知道那些是要删除，那些是需要重新创建，那些需要移动、移动到哪里！？<br>而diff算法则是对比的一种比较好的方式，更好的更快地对比，谁被谁复用！</p>
<p>newVnode和oldVnode的比对仅限于同层级之间对比，兄弟之间相互比较，如下图。不会出现跨层级的对比。</p>
<img src="diff-vnode.png" width="100%" alt="vue中的diff算法实现"/>


<h1 id="diff算法是什么"><a href="#diff算法是什么" class="headerlink" title="diff算法是什么"></a>diff算法是什么</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>diff算法不是一种对比的方法，而是一种寻找与当前节点匹配可复用节点的方法；寻找oldVnode.children中那个成员与newVnode.children中那个成员相同。</p>
<p>这种寻找的方法如图可见一斑，主要的方法有5种，辅助的有2种（未画在图上），一共7种。每种寻找方式相互独立！通过循环遍历children，逐一判断，直到循环结束。下面结合代码分别说明其中寻找方式。</p>
<p><strong>ps：无需过于在意图中所表达的逻辑，图只是用于辅助说明下面的源码</strong></p>
<img src="diff-vnode-children.png" width="100%" alt="vue中的diff算法实现"/>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (</span><br><span class="line">  parentElm,  <span class="comment">// &#123;Element&#125;，父节点的真实html元素</span></span><br><span class="line">  oldCh,  <span class="comment">// &#123;Vnode[]&#125;，oldVnode.children</span></span><br><span class="line">  newCh,  <span class="comment">// &#123;Vnode[]&#125;，newVnode.children</span></span><br><span class="line">  insertedVnodeQueue,   <span class="comment">// &#123;Vnode[]&#125;，插入的节点队列（此时可忽略）</span></span><br><span class="line">  removeOnly  <span class="comment">// &#123;Boolean&#125;，是否只可以删除</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立四个指针<code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code>，由<code>updateChildren</code>中的定义可以知道：开始时，他们分别指向<code>oldVnode.children</code>的头部、<code>oldVnode.children</code>的尾部、<code>newVnode.children</code>的头部、<code>newVnode.children</code>的尾部。然后，这四个指针的指向也不是固定的，在循环遍历的过程中，他们的指向也会变动，他们指向会因为以下索引的变动而变动，<code>oldStartIdx</code>、<code>oldEndIdx</code>、<code>newStartIdx</code>、<code>newEndIdx</code>。</p>
<h2 id="1-新头与旧头垂直对比"><a href="#1-新头与旧头垂直对比" class="headerlink" title="1.新头与旧头垂直对比"></a>1.新头与旧头垂直对比</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<img src="diff-vnode-children-01.png" width="100%" alt="vue中的diff算法实现"/>

<p>新旧头部vnode进行对比，判断是否匹配，以复用。sameVnode的功能与实现逻辑参考<a href="#sameVnode%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">附录：sameVnode的功能与实现逻辑</a>，值得一提的是：a.是input元素，更新前后type不一致；b.变动的是key属性；c.元素更新前后将所有属性删除，或从无到有；只要不是以上三种情况之一，不论怎么增删、修改元素上的属性，都不会影响是否匹配的结果！</p>
<p>1.判断新旧头部是匹配的，那么就调用<code>patchVnode</code>，给<code>newStartVnode</code>打补丁！</p>
<p><code>patchVnode</code>函数的主要功能：</p>
<p>a. 复用elm，将oldVnode.elm赋值到newVnode.elm；<br>b. 更新elm上的属性变动；<br>c. 更新newVnode.children，增删或复用，这里的复用就是通过调用<code>updateChildren</code>来实现，没错递归了！</p>
<p>patchVnode函数的主要功能参考：<a href="#patchVnode%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0">附录：patchVnode函数的关键实现</a></p>
<p>2.分别右移<code>oldStartVnode</code>和<code>newStartVnode</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-新尾与旧尾垂直对比"><a href="#2-新尾与旧尾垂直对比" class="headerlink" title="2.新尾与旧尾垂直对比"></a>2.新尾与旧尾垂直对比</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<img src="diff-vnode-children-02.png" width="100%" alt="vue中的diff算法实现"/>

<p>新旧尾部的对比情况和[1新头与旧头垂直对比]类似，再次再累累述，以下实现的逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-新尾与旧头交叉对比"><a href="#3-新尾与旧头交叉对比" class="headerlink" title="3.新尾与旧头交叉对比"></a>3.新尾与旧头交叉对比</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<img src="diff-vnode-children-03.png" width="100%" alt="vue中的diff算法实现"/>

<p>当前情况与[1新头与旧头垂直对比]略有不同！看源码中，多出了下面这句：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br></pre></td></tr></table></figure>

<p>这句代码实现就是图片中移动elm的功能！为什么要移动elm？因为newEndVnode复用了oldStartVnode.elm，复用这一步已经由<code>patchVnode</code>函数实现，然后还需要让elm列的顺序与newVnode的顺序保持一致，所以需要将<code>oldStartVnode.elm</code>移动到正确的位置！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。</span></span><br><span class="line"><span class="comment">       * 如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// canMove &amp;&amp; 在parentElm的nodeOps.nextSibling(oldEndVnode.elm)前面插入oldStartVnode.elm</span></span><br><span class="line">      <span class="comment">// 换言之，在 oldEndVnode.elm 前面插入 oldStartVnode.elm</span></span><br><span class="line">      <span class="comment">// 旧children的 头部真实元素 移动到 尾部真实元素的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-新头与旧尾交叉对比"><a href="#4-新头与旧尾交叉对比" class="headerlink" title="4.新头与旧尾交叉对比"></a>4.新头与旧尾交叉对比</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<img src="diff-vnode-children-04.png" width="100%" alt="vue中的diff算法实现"/>

<p>当前情况与[新尾与旧头交叉对比]类似，不做赘述！配合图片和源码食用口味更佳~</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      <span class="comment">// 将旧children的尾部真实元素移动到头部真实元素的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-当前新vnode与旧头尾之间的vnode对比"><a href="#5-当前新vnode与旧头尾之间的vnode对比" class="headerlink" title="5.当前新vnode与旧头尾之间的vnode对比"></a>5.当前新vnode与旧头尾之间的vnode对比</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>在本次循环中，前4种控制流都没有进入，就说明一头一尾、两次交叉对比都没有找到可复用的节点！但这并非代表旧children中无可复用，因为头与尾之间的元素还没有比对过，第5种方式即是如此！这第5种方式在有定义<code>key</code>(<code>v-for</code>指令中的<code>key</code>)或没有的情况下又是不同的表现！</p>
<p><strong>注意：在此情况下，是用新头去旧children的头尾之间寻找可复用元素</strong></p>
<h3 id="5-1-构建oldCildren映射表-key-x3D-gt-idx"><a href="#5-1-构建oldCildren映射表-key-x3D-gt-idx" class="headerlink" title="5-1.构建oldCildren映射表(key &#x3D;&gt; idx)"></a>5-1.构建oldCildren映射表(key &#x3D;&gt; idx)</h3><p>从oldChildren构建一个映射表(key &#x3D;&gt; idx)，这样就可以通过key，结合这个映射表快速找到匹配的可复用的元素。时间复杂度就是<code>O(1)</code>！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 5-1 */</span></span><br><span class="line">      <span class="comment">// 只会执行一次，第一次定义映射表</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) &#123;</span><br><span class="line">        <span class="comment">// 创建对象映射表，children.key =&gt; children.i, i ∈ [oldStartIdx, oldEndIdx]</span></span><br><span class="line">        oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createKeyToOldIdx的实现：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createKeyToOldIdx</span> (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="keyword">let</span> i, key</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].<span class="property">key</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-根据5-1的映射表找到可复用vnode的索引"><a href="#5-2-根据5-1的映射表找到可复用vnode的索引" class="headerlink" title="5-2.根据5-1的映射表找到可复用vnode的索引"></a>5-2.根据5-1的映射表找到可复用vnode的索引</h3><p>列表渲染中不一定会定义<code>key</code>，如果没有定义那么<code>5-1</code>的映射表就没有用了。那么就需要遍历旧children节点寻找与新头匹配的元素（详见下面代码的<code>findIdxInOld</code>方法）！那么时间复杂度就上来了，不再是使用映射表时的<code>O(1)</code>，而是<code>O(n)</code>。由此也可以知道使用<code>key</code>的性能优化优越之所在！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5.2 */</span></span><br><span class="line">      <span class="comment">// 定义key，直接在名射表找，时间复杂度: O(1)</span></span><br><span class="line">      <span class="comment">// 没有定义key，用新vnode与旧vnode数组比对，时间复杂度：O(n)</span></span><br><span class="line">      <span class="comment">// const isDef = (v) =&gt; v !== undefined &amp;&amp; v !== null</span></span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        <span class="comment">// 返回oldCh中与newStartVnode相同（ sameVnode(newStartVnode, oldCh[itIdx]) ）节点(即isDef(oldCh[itIdx].key) 同样是false)的index</span></span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findIdxInOld：时间复杂度<code>O(n)</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findIdxInOld</span> (node, oldCh, start, end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = oldCh[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(c) &amp;&amp; <span class="title function_">sameVnode</span>(node, c)) <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-无可复用旧元素"><a href="#5-3-无可复用旧元素" class="headerlink" title="5-3.无可复用旧元素"></a>5-3.无可复用旧元素</h3><p>在旧children可能会找到也可能找不到可复用的元素，没有找到是什么情况？如图：</p>
<img src="diff-vnode-children-05.png" width="100%" alt="vue中的diff算法实现：在头尾见找可复用元素"/>

<p>假如现在<code>newStartVnode</code>指向的是<code>key = 1.5</code>的vnode，那么很明显旧children中就没有可以复用的vnode，那么需要做的就是：a.创建一个与<code>newStartVnode</code>对应的newElm(新的真实html元素)；b.然后将newElm插入到旧children中<code>key=02</code>的vnode对应的真实元素的前面！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5.3 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中不存在新节点，无法复用旧元素</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]</span></span><br><span class="line"><span class="comment">       * [ 1 ] [ 2 ] [2.5] [ 3 ] [ 4 ] [ 5 ]</span></span><br><span class="line"><span class="comment">       * [2.5]就是插入的，且就children中没有与之“相同”的vnode</span></span><br><span class="line"><span class="comment">       * 目前 newStartIdx = oldStartIdx = 2</span></span><br><span class="line"><span class="comment">       * 那么现在需要做的是：a.创建一个与[2.5]对应的真实元素；b.将元素插入到 [ 2 ] 后面 [ 3 ]前面</span></span><br><span class="line"><span class="comment">       * nodeOps.insertBefore(parentElm, newElm, oldStartVnode.elm)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建 newStartVnode 对应的elm，将elm插入到parentElm的子元素oldStartVnode.elm的前面（如果oldStartVnode.elm不存在即插入到parentElm的最后）</span></span><br><span class="line">        <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-复用旧元素"><a href="#5-4-复用旧元素" class="headerlink" title="5-4.复用旧元素"></a>5-4.复用旧元素</h3><p>5-3和5-4是互斥的，进入5-4控制流就表示5-2中返回的<code>idxInOld</code>不为空，旧children中存在这匹配的vnode。虽然存在可用的vnode，但如果<code>key</code>并不可信呢？比如<code>v-for=&quot;(item, index) in items&quot;</code>中的索引被用作<code>key</code>！！！因此有了下面的5-4-1和5-4-2。</p>
<h4 id="5-4-1-确实可复用"><a href="#5-4-1-确实可复用" class="headerlink" title="5-4-1.确实可复用"></a>5-4-1.确实可复用</h4><p>使用sameVnode方法二次确认vnodeToMove（在旧children中找到的vnode）时可用的！接下就是类似的操作。但比较明显的不同是：其他都是递增或递减新旧索引，但在5-4-1中则是递增newStartIdx，然后旧vnode置为null(<code>oldCh[idxInOld] = undefined</code>)，这是设计的巧妙之处，当前还没有感受到，再看下<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a>和<a href="#0%E8%B7%B3%E8%BF%87%E5%8F%B3%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">0.跳过右边已经复用的vnode</a>中的内容就会豁然开朗！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5-4 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中存在新节点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 5-4-1 */</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">// 保证节点的key和虚拟节点都相同（ oldKeyToIdx[newStartVnode.key] 获取的idxInOld，指向</span></span><br><span class="line">        <span class="comment">// 的虚拟节点可能与newStartVnode节点不一样(!sameVnode) ）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-虚假的可复用"><a href="#5-4-2-虚假的可复用" class="headerlink" title="5-4-2.虚假的可复用"></a>5-4-2.虚假的可复用</h4><p>5-4-1与5-4-2是互斥的，既然没有元素可以复用到<code>newStartVnode</code>中，那么只能像5-3中那样创建与<code>newStartVnode</code>对应的html元素！！！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5-4 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中存在新节点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 5-4-2 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// key相同但虚拟节点不同，newStartVnode当做新元素创建</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-跳过左边已经复用的vnode"><a href="#1-跳过左边已经复用的vnode" class="headerlink" title="-1.跳过左边已经复用的vnode"></a>-1.跳过左边已经复用的vnode</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>我们知道<code>oldStartVnode</code>这个指针是不断地右移，从下面的代码中的<code>isUndef(oldStartVnode)</code>知道，一旦碰到未定的vnode就会右移一个单位，继续循环比对后面的vnode。为什么会有未定义的vnode？正常来说应该存在，因为vnode都是与页面上的html元素一一对应的！在<a href="#5-4-1%E7%A1%AE%E5%AE%9E%E5%8F%AF%E5%A4%8D%E7%94%A8">5-4-1.确实可复用</a>中，vue确实地将旧children中存在可复用elm的vnode手动置为了undefined：<code>oldCh[idxInOld] = undefined</code>！为什么置空不直接用<code>delete</code>操作符删除？！删了就换了idx顺序！！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">/* -1 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-跳过右边已经复用的vnode"><a href="#0-跳过右边已经复用的vnode" class="headerlink" title="0.跳过右边已经复用的vnode"></a>0.跳过右边已经复用的vnode</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>参考<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while中的控制流顺序"><a href="#while中的控制流顺序" class="headerlink" title="while中的控制流顺序"></a>while中的控制流顺序</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>上面为了突出重点去讲，没有按while中控制流的顺序书写，以下是while块总各控制流的顺序：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="comment">/* -1：跳过左边已经复用的vnode */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 0：跳过右边已经复用的vnode */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 1：新头与旧头垂直对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 2：新尾与旧尾垂直对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 3：新尾与旧头交叉对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 4：新头与旧尾交叉对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="while之外"><a href="#while之外" class="headerlink" title="while之外"></a>while之外</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>留意while的循环条件：<code>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx</code>，只要<code>oldStartIdx</code>大于<code>oldEndIdx</code>或<code>newStartIdx</code>大于<code>newEndIdx</code>就会结束循环！换言之，只要遍历完新旧children任意一个就会结束循环！</p>
<p>a. 先遍历完旧children就说明<strong>新children新增了vnode</strong>，那么就要创建与这些vnodes对应的elm；<br>b. 先遍历完新children就说明<strong>新children删除了一些vnode</strong>，那么就要删除多出的vnodes。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  <span class="comment">// 会用调用node.insertBefore插入新元素，现在就是找引用元素，在refElm前面插入新元素</span></span><br><span class="line">  refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>])</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的children没有新增元素（newStartIdx &gt; newEndIdx） </span></span><br><span class="line"><span class="comment">     * 或 后面新增了vnode（newStartIdx &lt;= newEndIdx）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    ? <span class="literal">null</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * newStartIdx &lt;= newEndIdx</span></span><br><span class="line"><span class="comment">     * 新的children新增了元素，但不是在后面！</span></span><br><span class="line"><span class="comment">     * 可能是中间！</span></span><br><span class="line"><span class="comment">     * 也可能是在前面</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环调用 createElm</span></span><br><span class="line">  <span class="title function_">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  <span class="title function_">removeVnodes</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在循环遍历children的时候，startIdx（newStartIdx或oldStartIdx）和endIdx分别会向左和右移动。下面是四个索引移动的情况：</p>
<ul>
<li><p>newStartIdx右移：<a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>、<a href="#5%E5%BD%93%E5%89%8D%E6%96%B0vnode%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%B0%BE%E4%B9%8B%E9%97%B4%E7%9A%84vnode%E5%AF%B9%E6%AF%94">5.当前新vnode与旧头尾之间的vnode对比</a>；</p>
</li>
<li><p>newEndIdx左移：<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>；</p>
</li>
<li><p>oldStartIdx右移：<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a>、<a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>；</p>
</li>
<li><p>ildEndIdx左移：<a href="#0%E8%B7%B3%E8%BF%87%E5%8F%B3%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">0.跳过右边已经复用的vnode</a>、<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>；</p>
</li>
</ul>
<h2 id="新children新增了vnode"><a href="#新children新增了vnode" class="headerlink" title="新children新增了vnode"></a>新children新增了vnode</h2><p>根据newStartIdx和newEndIdx的移动情况</p>
<p>1.newStartIdx一直右移，由于新增的vnode都在后面，可以复用的vnode都在前面了，newEndIdx会保持不变，直到遍历完旧children：<br><img src="add-in-after.png" width="100%" alt="vue中的diff算法实现"/><br>&amp;nbsp;</p>
<p>2.newStartIdx右移，newEndIdx左移，直到遍历完旧children：</p>
<img src="add-in-middle.png" width="100%" alt="vue中的diff算法实现"/>

<p>3.新增的vnode都在前面了，由于是新的节点所以存在“newStartIdx右移”的情况，newStartIdx就保持不变了，而可复用的vnode在右边，随着一次次循环，newEndIdx则会左移：</p>
<img src="add-in-before.png" width="100%" alt="vue中的diff算法实现"/>

<p>新children删除了vnode的情况就不赘述，情况可以从上面的解析类推！</p>
<h1 id="新旧vnode与真实元素elm的关系"><a href="#新旧vnode与真实元素elm的关系" class="headerlink" title="新旧vnode与真实元素elm的关系"></a>新旧vnode与真实元素elm的关系</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>vnode是和elm一一对应的，vnode的顺序和elm保持这一致，vnode上的属性也是与对应的elm的属性对应。所以，在patch（给oldVnode打补丁）前，可以认为oldVnode树与页面上elm树是对应的！</p>
<p>1.oldVnode.children中vnode的顺序和oldVnode.elm.children(oldVnode对应的elm的子元素列表)的顺序是保持一致的、elm上的属性也是保持一致；</p>
<p>2.diff算法通过对比oldVnode.children与newVnode.children的vnode，找到可以复用的elm，并改变elm的位置，使之与newVnode.children的顺序保持一致！</p>
<h1 id="diff的特点"><a href="#diff的特点" class="headerlink" title="diff的特点"></a>diff的特点</h1><ul>
<li><strong>先垂直，再交叉，最后中间找</strong>，diff在旧vnode.children找可复用vnode，所用比对方式的优先级！</li>
</ul>
<p>&amp;nbsp;</p>
<ul>
<li><strong>只与同级vnode中寻找复用的elm</strong>，由上面的分析可以知道，只会在同级的children中寻找可以复用的vnode。但现实是可以复用的元素可以存在于dom树任意的地方，明显这样是可能回错过实际存在的复用元素，而重新创建元素！这里就是vue或diff的权衡的地方，是不计代价全局去找最优解，还是如当前这般在同级节点中寻找！？</li>
</ul>
<p>&amp;nbsp;</p>
<ul>
<li><strong>定义key属性可以大幅度减少操作数</strong>，在<a href="#5%E5%BD%93%E5%89%8D%E6%96%B0vnode%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%B0%BE%E4%B9%8B%E9%97%B4%E7%9A%84vnode%E5%AF%B9%E6%AF%94">5.当前新vnode与旧头尾之间的vnode对比</a>中，在定义了key的情况下，会创建一个映射表<code>oldKeyToIdx</code>，通过映射表可以快速找到可复用vnode，而没有定义的话，就需要遍历oldVnode.children，逐一使用<code>sameVnode</code>比对！</li>
</ul>
<h1 id="实用主义"><a href="#实用主义" class="headerlink" title="实用主义"></a>实用主义</h1><p><a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>，以上四种不论是否定义元素属性key</p>
<ol>
<li>定义了，可以快速判断出不相同（但不完全可靠）</li>
</ol>
<p>使用遍历索引作为key，</p>
<blockquote>
<p>它也可以用于强制替换元素&#x2F;组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<p>完整地触发组件的生命周期钩子<br>触发过渡</p>
</blockquote>
<blockquote>
<p>diff算法默认使用“就地复用”的策略，是一个首尾交叉对比的过程。<br>用index作为key和不加key是一样的，都采用“就地复用”的策略<br>“就地复用”的策略，只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>将与元素唯一对应的值作为key，可以最大化利用dom节点，提升性能</p>
</blockquote>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h2 id="sameVnode的功能与实现逻辑"><a href="#sameVnode的功能与实现逻辑" class="headerlink" title="sameVnode的功能与实现逻辑"></a>sameVnode的功能与实现逻辑</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        <span class="comment">// 标签相同</span></span><br><span class="line">        a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都是注释元素, 或都不是</span></span><br><span class="line">        a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// idDef = (v) =&gt; v !== undefined &amp;&amp; v !== null</span></span><br><span class="line">        <span class="comment">// 都定义了，或都没有定义</span></span><br><span class="line">        <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a = &#123; data: &#123; atttrs: &#123; type: &#x27;xxx&#x27; &#125; &#125; &#125;</span></span><br><span class="line">        <span class="comment">// 1. 两节点的type相同，</span></span><br><span class="line">        <span class="comment">//   i. type存在, 且相同；</span></span><br><span class="line">        <span class="comment">//   ii. 两个type都没有定义，都是undefined；a、b都算是通过</span></span><br><span class="line">        <span class="comment">// 2. a、b节点type都是&#x27;text,number,password,search,email,tel,url&#x27;中之一</span></span><br><span class="line">        <span class="comment">// 换言之 a.type = text, b.type = password，也可以说两个input节点相同</span></span><br><span class="line">        <span class="comment">// 3. a不是input标签</span></span><br><span class="line">        <span class="title function_">sameInputType</span>(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        <span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp;</span><br><span class="line">        a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * makeMap是个工厂函数，生成 isTextInputType = (key) =&gt; &#123;</span></span><br><span class="line"><span class="comment"> *   const map = &#123; text: true, ..., url: true &#125;;</span></span><br><span class="line"><span class="comment"> *   return map[key];</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 类似于 (val) =&gt; [text,number,password,search,email,tel,url].include(val);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">const</span> isTextInputType = <span class="title function_">makeMap</span>(<span class="string">&#x27;text,number,password,search,email,tel,url&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sameInputType</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">tag</span> !== <span class="string">&#x27;input&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> typeA = <span class="title function_">isDef</span>(i = a.<span class="property">data</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">attrs</span>) &amp;&amp; i.<span class="property">type</span></span><br><span class="line">  <span class="keyword">const</span> typeB = <span class="title function_">isDef</span>(i = b.<span class="property">data</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">attrs</span>) &amp;&amp; i.<span class="property">type</span></span><br><span class="line">  <span class="keyword">return</span> typeA === typeB || <span class="title function_">isTextInputType</span>(typeA) &amp;&amp; <span class="title function_">isTextInputType</span>(typeB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patchVnode函数的关键实现"><a href="#patchVnode函数的关键实现" class="headerlink" title="patchVnode函数的关键实现"></a>patchVnode函数的关键实现</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (<span class="comment">/* */</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a. 复用elm，将oldVnode.elm赋值到newVnode.elm；</span></span><br><span class="line">  <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// b. 更新elm上的属性变动；</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      cbs.<span class="property">update</span>[i](oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有文本，即是还有子节点等情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// 新旧vnode都有children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// c. 更新newVnode.children，增删或复用，这里的复用就是通过调用`updateChildren`来实现，没错递归了！</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他的更新children的操作：增、删等</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nodeOps-insertBefore实现"><a href="#nodeOps-insertBefore实现" class="headerlink" title="nodeOps.insertBefore实现"></a>nodeOps.insertBefore实现</h2><p>path: src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;node-ops.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">insertBefore</span> (<span class="attr">parentNode</span>: <span class="title class_">Node</span>, <span class="attr">newNode</span>: <span class="title class_">Node</span>, <span class="attr">referenceNode</span>: <span class="title class_">Node</span>) &#123;</span><br><span class="line">  parentNode.<span class="title function_">insertBefore</span>(newNode, referenceNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置（在将节点附加到其他节点之前，不需要从其父节点删除该节点）。</p>
</blockquote>
<h2 id="vnode（虚拟节点）的成员属性"><a href="#vnode（虚拟节点）的成员属性" class="headerlink" title="vnode（虚拟节点）的成员属性"></a>vnode（虚拟节点）的成员属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="comment">// 标签</span></span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// elm（Element）的属性</span></span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 子虚拟节点</span></span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 真实dom元素</span></span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 元素命名空间</span></span><br><span class="line">  <span class="attr">ns</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?<span class="built_in">string</span>; <span class="comment">// functional scope id support</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL的hosts文件被重置</title>
    <url>/blog/2023/03/08/WSL%E7%9A%84hosts%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用WSL安装软件时，需要从 <code>raw.githubusercontent.com</code> 拉取数据，抛异常 403。经查阅是DNS污染导致，推荐的解决方案是修改hosts文件，添加域名与ip的映射。</p>
<p>然而，再第二天打开电脑再次登入wsl发现，继续403异常！查看hosts文件：内容被重置！</p>
<span id="more"></span>


<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><img src="/blog/2023/03/08/WSL%E7%9A%84hosts%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E7%BD%AE/Snipaste_2023-03-08_16-08-58.png"></p>
<p>注释已经解释，host文件会被WSL自动生成，导致对hosts的历史修改被覆盖！</p>
<p>想要关闭自动生成功能，则需要在 <code>/etc/wsl.conf</code> 中设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">generateHosts = false</span><br></pre></td></tr></table></figure>

<p>抱着以防万一的心态，查阅 <code>wsl.conf</code> 详情：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#network-settings">https://learn.microsoft.com/en-us/windows/wsl/wsl-config#network-settings</a></p>
<p><img src="/blog/2023/03/08/WSL%E7%9A%84hosts%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E7%BD%AE/Snipaste_2023-03-08_16-15-42.png"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>关闭 generateHosts；</li>
<li>在win系统下的hosts做修改；</li>
</ul>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器（Debian）内终端的中文展示与输入问题</title>
    <url>/blog/2023/02/28/Docker%E5%AE%B9%E5%99%A8%EF%BC%88Debian%EF%BC%89%E5%86%85%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%AD%E6%96%87%E5%B1%95%E7%A4%BA%E4%B8%8E%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用docker容器作为开发环境。以Debian11镜像启动容器，出现两个问题：</p>
<ol>
<li>无法展示中文，ls输出的都是八进制编码的字符串；</li>
<li>终端无法输入中文，粘贴可以但同学展示为八进制字符串；</li>
</ol>
<p><img src="/blog/2023/02/28/Docker%E5%AE%B9%E5%99%A8%EF%BC%88Debian%EF%BC%89%E5%86%85%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%AD%E6%96%87%E5%B1%95%E7%A4%BA%E4%B8%8E%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/Snipaste_2023-02-27_20-24-42.png"></p>
<span id="more"></span>

<h1 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h1><p>经查阅，确定问题是系统语言环境导致，默认使用的语言环境不支持中文编码！</p>
<p>使用 <code>locale</code> 查看当前使用的字符集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:~/workspace# locale</span><br><span class="line"></span><br><span class="line">LANG=</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=&quot;POSIX&quot;</span><br><span class="line">LC_NUMERIC=&quot;POSIX&quot;</span><br><span class="line">LC_TIME=&quot;POSIX&quot;</span><br><span class="line">LC_COLLATE=&quot;POSIX&quot;</span><br><span class="line">LC_MONETARY=&quot;POSIX&quot;</span><br><span class="line">LC_MESSAGES=&quot;POSIX&quot;</span><br><span class="line">LC_PAPER=&quot;POSIX&quot;</span><br><span class="line">LC_NAME=&quot;POSIX&quot;</span><br><span class="line">LC_ADDRESS=&quot;POSIX&quot;</span><br><span class="line">LC_TELEPHONE=&quot;POSIX&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;POSIX&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;POSIX&quot;</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>显然，当前我使用的Debian11镜像默认使用的是<code>POSIX</code>字符集！</p>
<p>可以使用 <code>locale -a</code> 查看当前系统支持的字符集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:~/workspace# locale -a</span><br><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">POSIX</span><br></pre></td></tr></table></figure>

<p>在 Debian 使用指南中关于 <code>locale</code> 中看到：</p>
<blockquote>
<p>You can set <code>LANG</code> or <code>LC_ALL</code> to your preferred locale.</p>
</blockquote>
<p>然后，将 <code>LANG</code> 环境变量设置成 <code>C.UTF-8</code>，这个系统支持的中文字符集！</p>
<p>设置方式有多种，在<code>~/.bashrc</code>文件、进入容器通过<code>env</code>变量设置或者通过<code>dockerfile</code>，详细不展开！</p>
<p>设置成功后可以通过 <code>locale</code> 命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:/# locale</span><br><span class="line">LANG=C.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_NUMERIC=&quot;C.UTF-8&quot;</span><br><span class="line">LC_TIME=&quot;C.UTF-8&quot;</span><br><span class="line">LC_COLLATE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MONETARY=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MESSAGES=&quot;C.UTF-8&quot;</span><br><span class="line">LC_PAPER=&quot;C.UTF-8&quot;</span><br><span class="line">LC_NAME=&quot;C.UTF-8&quot;</span><br><span class="line">LC_ADDRESS=&quot;C.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;C.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;C.UTF-8&quot;</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>Debian容器终端无法展示和输入中文，这个问题的原因之一是：系统默认使用不支持中文编码的字符集；</p>
</li>
<li><p>可以使用 <code>locale</code>查看当前系统使用的字符集，使用<code>locale -a</code>列出当前系统支持的字符集；</p>
</li>
<li><p>通过设置<code>LANG</code> 环境变量可以修改系统使用的字符集；</p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a href="https://wiki.debian.org/Locale">Debian使用指南locale篇章</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>debian</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装与基本使用</title>
    <url>/blog/2023/02/27/nvm%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="nvm-与-n-的区别"><a href="#nvm-与-n-的区别" class="headerlink" title="nvm 与 n 的区别"></a>nvm 与 n 的区别</h1><p>node 版本管理工具还有一个是 TJ大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node&#x2F;npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。</p>
<span id="more"></span>

<p>由于 npm 安装的模块路径均为 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node&#x2F;npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。</p>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure>

<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>在 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> 文件末尾添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>

<p> 保存！</p>
<p>重新加载配置：<code>source ~/.bashrc</code> 或 <code>source ~/.zshrc</code> </p>
<p>查看 nvm 版本，借此检查安装情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm -v</span></span><br><span class="line">0.39.1</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>安装node版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install &lt;node version&gt;</span><br></pre></td></tr></table></figure>

<p>查看版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure>
<p> <br>切换node版本（要先安装再切换）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm use &lt;node version&gt;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>github：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT添加文章置顶feat</title>
    <url>/blog/2023/02/25/NexT%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6feat/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hexo以及NexT主题默认没有置顶功能！本文旨在通过现有方案，花费最小力气补充此缺失的功能！</p>
<span id="more"></span>

<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>使用现有解决方案：<a href="https://github.com/netcan/hexo-generator-index-pin-top">https://github.com/netcan/hexo-generator-index-pin-top</a></p>
<blockquote>
<p>Feautres </p>
<p>This version supports pin-top feature, you can add the top: True field to post’s front-matter to pin it.</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>修改主题文件，添加“置顶”标志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">themes/next/layout/_partials/post/post-meta.njk</span></span><br><span class="line"></span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;font color=&quot;#1fa67a&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-thumb-tack&quot; style=&quot;position: relative;top: 1px;&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;span&gt; 置顶&lt;/span&gt;</span><br><span class="line">  &lt;/font&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h2><p>修改需要置顶的文章，Front-matter 添加 <code>top: true</code>，见下栗子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">vue中的diff算法实现</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-26 08:41:47</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">vue</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">vue源码分析</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">源码分析</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">vue</span>]</span><br><span class="line"><span class="string">+</span> <span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><blockquote>
<p><img src="/blog/2023/02/25/NexT%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6feat/Snipaste_2023-02-25_21-11-27.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust学习</title>
    <url>/blog/2023/02/15/Rust%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。</p>
<span id="more"></span>

<p>Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。</p>
<p>Rust 通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。</p>
<p>Rust是内存安全、没有GC(垃圾回收)的高效语言。</p>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b workspace]# curl --proto &#x27;=https&#x27; --tlsv1.3 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<p>安装成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info: default toolchain set to &#x27;stable-x86_64-unknown-linux-gnu&#x27;                 </span><br><span class="line">                                                                                 </span><br><span class="line">  stable-x86_64-unknown-linux-gnu installed - rustc 1.65.0 (897e37553 2022-11-02)</span><br><span class="line">                                                                                 </span><br><span class="line">                                                                                 </span><br><span class="line">Rust is installed now. Great!                                                    </span><br><span class="line">                                                                                 </span><br><span class="line">To get started you may need to restart your current shell.                       </span><br><span class="line">This would reload your PATH environment variable to include                      </span><br><span class="line">Cargo&#x27;s bin directory ($HOME/.cargo/bin).                                        </span><br><span class="line">                                                                                 </span><br><span class="line">To configure your current shell, run:                                            </span><br><span class="line">source &quot;$HOME/.cargo/env&quot;                                                        </span><br></pre></td></tr></table></figure>

<p>刷新当前shell配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b workspace]# source ~/.bashrc</span><br><span class="line"></span><br><span class="line">[root@f8ac270c7b6b workspace]# rustc --version</span><br><span class="line">rustc 1.65.0 (897e37553 2022-11-02)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><ul>
<li>Code</li>
<li>编译</li>
<li>执行</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>文件名：hello_world.rs</p>
<p>使用的是 <code>.rs</code> 后缀！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  println!(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装 vs code的 rust 扩展！</p>
<p>Extension ID：dustypomerleau.rust-syntax<br><img src="https://user-images.githubusercontent.com/25907273/204077420-7c3a88eb-57d2-4393-ae55-5ad625521997.png" alt="image"></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>rustc xxx.rs</code> 编译rust程序！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# rustc hello_world.rs</span><br><span class="line">[root@f8ac270c7b6b rust-learn]# ls</span><br><span class="line">hello_world  hello_world.rs</span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>直接执行编译后的文件！不需要启动程序！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# ./hello_world</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构建系统和包管理器，Cargo"><a href="#构建系统和包管理器，Cargo" class="headerlink" title="构建系统和包管理器，Cargo"></a>构建系统和包管理器，Cargo</h1><p>Cargo 是 Rust 的构建系统和包管理器。它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库</p>
<p>使用官方方式安装，会自带 Cargo！</p>
<p>Cargo的详细命令可以使用 <code>--help</code>，也可查看 <a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1327996209">附录</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# cargo --version</span><br><span class="line">cargo 1.65.0 (4bc8f24d3 2022-10-20)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建项目</li>
<li>编译项目<ul>
<li>开发时编译</li>
<li>生产时编译</li>
</ul>
</li>
<li>执行项目</li>
<li>快速检测</li>
<li>小结</li>
<li>参考</li>
</ul>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用 <code>cargo new &lt;new dir name&gt;</code></p>
<p>产物结构</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089591-b2abeda6-5cdc-4bda-8498-3a06cf746f4a.png" alt="image"></p>
<p>生成一个配置文件，是toml文件。</p>
<p>这个文件使用 <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) 格式，这是 Cargo 配置文件的格式。</p>
<p>还生成一个src以及src下的z&#x3D;主文件main。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089548-adadc8f1-ff1a-48e5-826b-68257e30cb6f.png" alt="image"></p>
<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><ul>
<li>开发时编译</li>
<li>生产时编译</li>
</ul>
<h3 id="开发时编译"><a href="#开发时编译" class="headerlink" title="开发时编译"></a>开发时编译</h3><p>切换到 项目目录下（此处是 hello_cargo），执行build命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>build 结果如下：</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089646-b505984f-8cf6-4fae-b221-cbb47c59dcbb.png" alt="image"></p>
<p>增加了 <code>Cargo.lock</code> 和 <code>target/</code> 目录！</p>
<h3 id="生产时编译"><a href="#生产时编译" class="headerlink" title="生产时编译"></a>生产时编译</h3><p>在开发时编译的基础上增加 <code>--release</code>。</p>
<p>编译的产物会放在 <code>target/release</code> 中！详细参考 <a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1327996209">附录</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204099490-4309d4b8-7122-44d0-a7e7-2668d1940238.png" alt="image"></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>使用 <code>run</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204089972-fb695c14-1456-4863-8c09-fb8e5184a9bd.png" alt="image"></p>
<h2 id="快速检查"><a href="#快速检查" class="headerlink" title="快速检查"></a>快速检查</h2><p>在项目根目录下执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204100025-89f68fa1-26a0-4303-a32f-3a240ae04503.png" alt="image"></p>
<p>该命令快速检查代码确保其可以编译，但并不产生可执行文件！</p>
<p>通常 cargo check 要比 cargo build 快得多，因为它省略了生成可执行文件的步骤。如果你在编写代码时持续的进行检查，cargo check 可以让你快速了解现在的代码能不能正常通过编译！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>cargo new</code>，创建项目。</li>
<li><code>cargo build</code>，构建项目。</li>
<li><code>cargo run</code>，一步构建并运行项目。</li>
<li><code>cargo check</code>，在不生成二进制文件的情况下构建项目来检查错误。</li>
<li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target目录，默认在 <code>target/debug</code>，生产时在 <code>target/release</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html#hello-cargo">Rust 程序设计语言 简体中文版 —— Hello, Cargo!</a></li>
</ul>
<hr>
<h1 id="语法概念"><a href="#语法概念" class="headerlink" title="语法概念"></a>语法概念</h1><ul>
<li>结束符号</li>
<li>注释</li>
<li>变量&#x2F;常量</li>
<li>数据类型</li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328515749">函数定义</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1330017240">控制流</a></li>
</ul>
<h2 id="结束符号"><a href="#结束符号" class="headerlink" title="结束符号"></a>结束符号</h2><p>使用分号（<code>;</code>）作为结束符号</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一段注释</span></span><br></pre></td></tr></table></figure>

<h2 id="变量-x2F-常量"><a href="#变量-x2F-常量" class="headerlink" title="变量&#x2F;常量"></a>变量&#x2F;常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量默认是不可重复赋值！<br>如果要重复赋值可以使用<code>mut</code>配合声明。<br>变量是可以重复声明的！</p>
<p>使用 <code>let</code> 声明标量！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>需要重复赋值时声明</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以重复声明变量</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在此之前foo=1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">foo</span>: <span class="type">u8</span> = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 解析来foo = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用 <code>const</code>声明，与变量不同，它声明之后总是不可重复声明与赋值！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FOO = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型的分类</li>
</ul>
<h3 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h3><p>数据类型的分为<em>标量（scalar）</em>和<em>复合（compound）</em>，以及其他</p>
<p><strong>标量（scalar）</strong> 类型代表一个单独的值。Rust 有四种基本的标量类型：</p>
<ul>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328102385">整型</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328105183">浮点型</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328105689">布尔类型</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328111816">字符类型</a></li>
</ul>
<p><strong>复合类型（Compound types）</strong> 可以将多个值组合成一个类型。Rust 有两个原生的复合类型：</p>
<ul>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328122358">元组（tuple）</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328195135">数组（array）</a></li>
</ul>
<p>其他类型包含：</p>
<ul>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328463936">引用类型</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328510984">Slice类型</a></li>
</ul>
<hr>
<h1 id="所有权（ownership）"><a href="#所有权（ownership）" class="headerlink" title="所有权（ownership）"></a>所有权（ownership）</h1><ul>
<li>前言</li>
<li>所有权的规则</li>
<li>变量作用域</li>
<li>变量与数据交互的方式</li>
<li>引用与借用</li>
</ul>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>[栈（Stack）与堆（Heap）内存。</p>
<p>栈以放入值的顺序存储值。</p>
<p>堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。</p>
<p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<h2 id="所有权的规则"><a href="#所有权的规则" class="headerlink" title="所有权的规则"></a>所有权的规则</h2><ol>
<li>Rust 中的每一个值都有一个 所有者（owner）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><code>&#123;&#125;</code>，每个花括号包含的代码块都是一个作用域！</p>
<p>注意，这不包含 struct 的花括号！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">var_scope_main</span>() &#123;</span><br><span class="line">  &#123;                     <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">  &#125;                     <span class="comment">// Rust 在结尾的 &#125; 处自动调用 drop, 释放内存</span></span><br><span class="line">                        <span class="comment">// 此作用域已结束，s 不再有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>Rust 有第二个字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String。</p>
<p>String类型有别于字面量字符串，它是可修改的！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>

<p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器（memory allocator）请求内存。</li>
<li>需要一个当我们处理完 String 时将内存返回给分配器的方法。</li>
</ul>
<h3 id="变量与数据交互的方式"><a href="#变量与数据交互的方式" class="headerlink" title="变量与数据交互的方式"></a>变量与数据交互的方式</h3><p>使用堆内存的变量，他们之间的数据交互方式！</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204480696-4188bc14-809f-49dd-be12-3ef7868d3b0e.png" alt="图片"></p>
<ul>
<li>转移</li>
<li>拷贝</li>
</ul>
<h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>为了确保内存安全，在 let s2 &#x3D; s1 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。</p>
<p>相当于 s1 赋值给 s2，就将数据转移到s2。不是浅拷贝（将引用复制给s2），也不是深拷贝！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">heap_var_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;s1 is &#123;&#125;&quot;</span>, s1);</span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204481489-09ebb4e5-5fb3-413c-83a6-36a528ed980a.png" alt="图片"></p>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>使用一个叫做 <a href="https://doc.rust-lang.org/std/clone/index.html">clone</a> 的通用函数。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">clone_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;\ns1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204489601-c2e6f02b-4aa7-46bc-97d5-e707e7643458.png" alt="图片"></p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><p>引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。</p>
<p><code>&amp;</code> 符号就是 引用，它们允许你使用值但不获取其所有权。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204947997-bd4878ea-b295-47fd-bd0d-895d2f703fc1.png" alt="图片"></p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ref_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  &#125;<span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;\ns1 len = &#123;&#125;&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值。</p>
<p>我们将创建一个引用的行为称为 借用（borrowing）。</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mut_ref_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;\ns = &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。</strong></p>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。</p>
<hr>
<h1 id="包、crate和模块"><a href="#包、crate和模块" class="headerlink" title="包、crate和模块"></a>包、crate和模块</h1><p>use 关键字: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用crate::garden::vegetables::Asparagus的作用域, 你可以通过 use crate::garden::vegetables::Asparagus;创建一个快捷方式，然后你就可以在作用域中只写Asparagus来使用该类型。</p>
<p>外部模块的寻址过程 </p>
<ol>
<li>内联；</li>
<li>在文件 <code>src/&lt;mod&gt;.rs</code>；</li>
<li>在文件 <code>src/&lt;mod&gt;/mod.rs</code>。</li>
</ol>
<p>内联模块：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>参考</li>
<li>cargo –help</li>
<li>cargo编译后的产物</li>
<li>Rust内存布局</li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://doc.rust-lang.org/book/#the-rust-programming-language">The Rust Programming Language</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html">Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://rust-book.junmajinlong.com/">Rust入门秘籍</a></li>
<li><a href="https://www.rustwiki.org.cn/docs/">Rust 中文教程等相关资源列表</a></li>
</ul>
<h2 id="cargo-–help"><a href="#cargo-–help" class="headerlink" title="cargo –help"></a>cargo –help</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# cargo --help                                                    </span><br><span class="line">Rust&#x27;s package manager                                                                          </span><br><span class="line">                                                                                                </span><br><span class="line">USAGE:                                                                                          </span><br><span class="line">    cargo [+toolchain] [OPTIONS] [SUBCOMMAND]                                                   </span><br><span class="line">                                                                                                </span><br><span class="line">OPTIONS:                                                                                        </span><br><span class="line">    -V, --version               Print version info and exit                                     </span><br><span class="line">        --list                  List installed commands                                         </span><br><span class="line">        --explain &lt;CODE&gt;        Run `rustc --explain CODE`                                      </span><br><span class="line">    -v, --verbose               Use verbose output (-vv very verbose/build.rs output)           </span><br><span class="line">    -q, --quiet                 Do not print cargo log messages                                 </span><br><span class="line">        --color &lt;WHEN&gt;          Coloring: auto, always, never                                   </span><br><span class="line">        --frozen                Require Cargo.lock and cache are up to date                     </span><br><span class="line">        --locked                Require Cargo.lock is up to date                                </span><br><span class="line">        --offline               Run without accessing the network                               </span><br><span class="line">        --config &lt;KEY=VALUE&gt;    Override a configuration value                                  </span><br><span class="line">    -Z &lt;FLAG&gt;                   Unstable (nightly-only) flags to Cargo, see &#x27;cargo -Z help&#x27; for </span><br><span class="line">                                details                                                         </span><br><span class="line">    -h, --help                  Print help information                                          </span><br><span class="line">                                                                                                </span><br><span class="line">Some common cargo commands are (see all commands with --list):                                  </span><br><span class="line">    build, b    Compile the current package                                                     </span><br><span class="line">    check, c    Analyze the current package and report errors, but don&#x27;t build object files     </span><br><span class="line">    clean       Remove the target directory                                                     </span><br><span class="line">    doc, d      Build this package&#x27;s and its dependencies&#x27; documentation                        </span><br><span class="line">    new         Create a new cargo package                                                      </span><br><span class="line">    init        Create a new cargo package in an existing directory                             </span><br><span class="line">    add         Add dependencies to a manifest file                                             </span><br><span class="line">    run, r      Run a binary or example of the local package                                    </span><br><span class="line">    test, t     Run the tests                                                                   </span><br><span class="line">    bench       Run the benchmarks                                                              </span><br><span class="line">    update      Update dependencies listed in Cargo.lock                                        </span><br><span class="line">    search      Search registry for crates                                                      </span><br><span class="line">    publish     Package and upload this package to the registry                                 </span><br><span class="line">    install     Install a Rust binary. Default location is $HOME/.cargo/bin                     </span><br><span class="line">    uninstall   Uninstall a Rust binary                                                         </span><br><span class="line">                                                                                                </span><br><span class="line">See &#x27;cargo help &lt;command&gt;&#x27; for more information on a specific command.                          </span><br><span class="line">                                                                                                </span><br></pre></td></tr></table></figure>

<h2 id="cargo编译后的产物"><a href="#cargo编译后的产物" class="headerlink" title="cargo编译后的产物"></a>cargo编译后的产物</h2><ul>
<li>开发时产物</li>
<li>生产时产物</li>
</ul>
<h3 id="开发时产物"><a href="#开发时产物" class="headerlink" title="开发时产物"></a>开发时产物</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b hello_cargo]# tree                      </span><br><span class="line">.                                                          </span><br><span class="line">|-- Cargo.lock                                             </span><br><span class="line">|-- Cargo.toml                                             </span><br><span class="line">|-- src                                                    </span><br><span class="line">|   `-- main.rs                                            </span><br><span class="line">`-- target                                                 </span><br><span class="line">    |-- CACHEDIR.TAG                                       </span><br><span class="line">    `-- debug                                              </span><br><span class="line">        |-- build                                          </span><br><span class="line">        |-- deps                                           </span><br><span class="line">        |   |-- hello_cargo-84cd33c7f338469a               </span><br><span class="line">        |   `-- hello_cargo-84cd33c7f338469a.d             </span><br><span class="line">        |-- examples                                       </span><br><span class="line">        |-- hello_cargo                                    </span><br><span class="line">        |-- hello_cargo.d                                  </span><br><span class="line">        `-- incremental                                    </span><br><span class="line">            `-- hello_cargo-aokenuaryvra                   </span><br><span class="line">                |-- s-gfry8e3ogd-1vtypym-2e5m3t5mj48xn     </span><br><span class="line">                |   |-- 1b24fot1ksjfohwq.o                 </span><br><span class="line">                |   |-- 2pcmwubz98u8588d.o                 </span><br><span class="line">                |   |-- 2skhc1xjwld6hx4y.o                 </span><br><span class="line">                |   |-- 387f08navk0xr9hq.o                 </span><br><span class="line">                |   |-- 41zl1lnzyfy87gmq.o                 </span><br><span class="line">                |   |-- 4gfj2nd48vmsnha0.o                 </span><br><span class="line">                |   |-- dep-graph.bin                      </span><br><span class="line">                |   |-- query-cache.bin                    </span><br><span class="line">                |   `-- work-products.bin                  </span><br><span class="line">                `-- s-gfry8e3ogd-1vtypym.lock              </span><br><span class="line">                                                           </span><br><span class="line">9 directories, 18 files                                    </span><br></pre></td></tr></table></figure>

<h3 id="生产时产物"><a href="#生产时产物" class="headerlink" title="生产时产物"></a>生产时产物</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b target]# tree                   </span><br><span class="line">.                                                  </span><br><span class="line">|-- CACHEDIR.TAG                                   </span><br><span class="line">|-- debug                                          </span><br><span class="line">|   |-- build                                      </span><br><span class="line">|   |-- deps                                       </span><br><span class="line">|   |   |-- hello_cargo-84cd33c7f338469a           </span><br><span class="line">|   |   `-- hello_cargo-84cd33c7f338469a.d         </span><br><span class="line">|   |-- examples                                   </span><br><span class="line">|   |-- hello_cargo                                </span><br><span class="line">|   |-- hello_cargo.d                              </span><br><span class="line">|   `-- incremental                                </span><br><span class="line">|       `-- hello_cargo-aokenuaryvra               </span><br><span class="line">|           |-- s-gfryfk4nh1-10dc9z2-2e5m3t5mj48xn </span><br><span class="line">|           |   |-- 1b24fot1ksjfohwq.o             </span><br><span class="line">|           |   |-- 2pcmwubz98u8588d.o             </span><br><span class="line">|           |   |-- 2skhc1xjwld6hx4y.o             </span><br><span class="line">|           |   |-- 387f08navk0xr9hq.o             </span><br><span class="line">|           |   |-- 41zl1lnzyfy87gmq.o             </span><br><span class="line">|           |   |-- 4gfj2nd48vmsnha0.o             </span><br><span class="line">|           |   |-- dep-graph.bin                  </span><br><span class="line">|           |   |-- query-cache.bin                </span><br><span class="line">|           |   `-- work-products.bin              </span><br><span class="line">|           `-- s-gfryfk4nh1-10dc9z2.lock          </span><br><span class="line">`-- release                                        </span><br><span class="line">    |-- build                                      </span><br><span class="line">    |-- deps                                       </span><br><span class="line">    |   |-- hello_cargo-42d24d7ef33ef483           </span><br><span class="line">    |   `-- hello_cargo-42d24d7ef33ef483.d         </span><br><span class="line">    |-- examples                                   </span><br><span class="line">    |-- hello_cargo                                </span><br><span class="line">    |-- hello_cargo.d                              </span><br><span class="line">    `-- incremental                                </span><br><span class="line">                                                   </span><br><span class="line">12 directories, 19 files</span><br></pre></td></tr></table></figure>

<h2 id="Rust-内存布局"><a href="#Rust-内存布局" class="headerlink" title="Rust 内存布局"></a>Rust 内存布局</h2><img width="100%" src="https://user-images.githubusercontent.com/25907273/204198140-44b47b88-e8ed-43b0-a554-181ebdd3ef0c.png" />

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2日志优化</title>
    <url>/blog/2022/11/01/PM2%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="默认pm2日志存在的问题"><a href="#默认pm2日志存在的问题" class="headerlink" title="默认pm2日志存在的问题"></a>默认pm2日志存在的问题</h1><ol>
<li>缺少日志时间戳；</li>
<li>缺少日志分片；</li>
<li>没有日志rotate 功能，定期清除防止磁盘爆满</li>
</ol>
<span id="more"></span>


<h2 id="PM2自带的日志"><a href="#PM2自带的日志" class="headerlink" title="PM2自带的日志"></a>PM2自带的日志</h2><p><a href="https://pm2.keymetrics.io/docs/usage/log-management/">https://pm2.keymetrics.io/docs/usage/log-management/</a></p>
<h2 id="PM2的日志扩展插件"><a href="#PM2的日志扩展插件" class="headerlink" title="PM2的日志扩展插件"></a>PM2的日志扩展插件</h2><p><a href="https://github.com/keymetrics/pm2-logrotate">pm2-logrotate</a></p>
<h1 id="默认情况下，处理日志临近饱满磁盘的办法"><a href="#默认情况下，处理日志临近饱满磁盘的办法" class="headerlink" title="默认情况下，处理日志临近饱满磁盘的办法"></a>默认情况下，处理日志临近饱满磁盘的办法</h1><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>1 查看日志文件位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 show &lt;app name&gt;</span><br></pre></td></tr></table></figure>

<p>2 删除日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure>

<p>3 重启应用</p>
<p>重启应用会自动再生成日志文件！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 relaod &lt;app name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="pm2清洗日志命令"><a href="#pm2清洗日志命令" class="headerlink" title="pm2清洗日志命令"></a>pm2清洗日志命令</h2><p>这将清空当前pm2应用程序日志! </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 flush</span><br><span class="line"></span><br><span class="line">pm2 flush &lt;api&gt; # Clear the logs for the app with name/id matching &lt;api&gt;</span><br></pre></td></tr></table></figure>


<h1 id="pm2-logrotate基本使用"><a href="#pm2-logrotate基本使用" class="headerlink" title="pm2-logrotate基本使用"></a>pm2-logrotate基本使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 install pm2-logrotate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output</span></span><br><span class="line"></span><br><span class="line">[PM2][Module] Installing NPM pm2-logrotate module</span><br><span class="line">[PM2][Module] Calling [NPM] to install pm2-logrotate ...</span><br><span class="line">+ pm2-logrotate@2.7.0</span><br><span class="line">added 213 packages from 236 contributors and audited 214 packages in 9.267s</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/25907273/199225377-6850e2b9-ffe8-4952-973c-571f591c711e.png" alt="image"></p>
<h2 id="查看rotate配置"><a href="#查看rotate配置" class="headerlink" title="查看rotate配置"></a>查看rotate配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 conf</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line"></span><br><span class="line">Module: pm2-logrotate</span><br><span class="line">$ pm2 set pm2-logrotate:max_size 10M</span><br><span class="line">$ pm2 set pm2-logrotate:retain 30</span><br><span class="line">$ pm2 set pm2-logrotate:compress false</span><br><span class="line">$ pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss</span><br><span class="line">$ pm2 set pm2-logrotate:workerInterval 30</span><br><span class="line">$ pm2 set pm2-logrotate:rotateInterval 0 0 * * *</span><br><span class="line">$ pm2 set pm2-logrotate:rotateModule true</span><br><span class="line">Module: module-db-v2</span><br><span class="line">$ pm2 set module-db-v2:pm2-logrotate [object Object]</span><br></pre></td></tr></table></figure>

<h2 id="查看日志分片"><a href="#查看日志分片" class="headerlink" title="查看日志分片"></a>查看日志分片</h2><p><img src="https://user-images.githubusercontent.com/25907273/199226021-2a431cae-143f-4350-baa9-65f0ea038ae4.png" alt="image"></p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 set pm2-logrotate:&lt;conf key&gt; &lt;conf val&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>PM2</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>编写油猴脚本扩展github评论编辑器，增加全屏模式</title>
    <url>/blog/2022/10/31/%E7%BC%96%E5%86%99%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E6%89%A9%E5%B1%95github%E8%AF%84%E8%AE%BA%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>安装 <a href="https://www.tampermonkey.net/index.php?version=4.18.0&ext=dhdg&show=dhdg#">tampermonkey</a></p>
<h1 id="注释说明"><a href="#注释说明" class="headerlink" title="注释说明"></a>注释说明</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Comment Zoomer</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      1.0.0</span></span><br><span class="line"><span class="comment">// @description  Add zoom button in github comment to provide full screen mode, allowing you to write comments more elegantly</span></span><br><span class="line"><span class="comment">// @author       IsaacKam</span></span><br><span class="line"><span class="comment">// @match        https://github.com/*</span></span><br><span class="line"><span class="comment">// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @license MIT</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">油猴脚本的名字</td>
</tr>
<tr>
<td align="left">namespace</td>
<td align="left">命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td>
</tr>
<tr>
<td align="left">version</td>
<td align="left">脚本版本，油猴脚本的更新会读取这个版本号</td>
</tr>
<tr>
<td align="left">description</td>
<td align="left">描述，用来告诉用户这个脚本是干什么用的</td>
</tr>
<tr>
<td align="left">author</td>
<td align="left">作者名字</td>
</tr>
<tr>
<td align="left">match</td>
<td align="left">只有匹配的网址才会执行对应的脚本，例如*、http:&#x2F;&#x2F;*、<a href="http://www.baidu.com/*%E7%AD%89%EF%BC%8C%E5%8F%82%E8%A7%81%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E6%96%87%E6%A1%A3">http://www.baidu.com/*等，参见谷歌开发者文档</a></td>
</tr>
<tr>
<td align="left">grant</td>
<td align="left">指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为none的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td>
</tr>
<tr>
<td align="left">require</td>
<td align="left">如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td>
</tr>
<tr>
<td align="left">connect</td>
<td align="left">当用户使用GM_xmlhttpRequest请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及*通配符</td>
</tr>
<tr>
<td align="left">updateURL</td>
<td align="left">脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td>
</tr>
<tr>
<td align="left">license</td>
<td align="left">声明开源协议，<em>在发布是必须的</em></td>
</tr>
</tbody></table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><code>@match</code>，<em>是必要的参数，用来匹配当前脚本要在那个页面生效！</em></li>
</ul>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>最简单的方式是编写完后，将代码复制到 tampermonkey 上。然后刷新脚本应用到的页面！</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><ol>
<li>进入 <a href="https://greasyfork.org/en">greasyfork</a>！</li>
<li>选择发布脚本；</li>
</ol>
<table>
<thead>
<tr>
<th><img width="383" alt="image" style="border: 1px solid black;" src="https://user-images.githubusercontent.com/25907273/198898570-20993ce2-6890-4583-9583-018500c99b1e.png"></th>
</tr>
</thead>
</table>
<ol start="3">
<li>输入代码，以及说明，即可发布！</li>
</ol>
<h1 id="栗子🌰"><a href="#栗子🌰" class="headerlink" title="栗子🌰"></a>栗子🌰</h1><p>欢迎 <a href="https://greasyfork.org/en/scripts/453950-comment-zoomer">使用</a> 和 <a href="https://github.com/isaaxite/comment_zoomer">star</a>!</p>
<table>
<thead>
<tr>
<th><img src="https://user-images.githubusercontent.com/25907273/198898702-ac29ff5d-7cbf-4086-a8d5-6ea28db837f4.png" alt="image"></th>
</tr>
</thead>
</table>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000021654926">油猴脚本编写教程</a></li>
<li><a href="https://www.tampermonkey.net/documentation.php">This section describes how the Tampermonkey API can be used and what is different to Geasemonkey</a></li>
<li><a href="https://www.tampermonkey.net/index.php?version=4.18.0&ext=dhdg&show=dhdg#">tampermonkey</a></li>
</ul>
]]></content>
      <categories>
        <category>油猴脚本</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>tampermonkey</tag>
        <tag>油猴脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>oauth2实践</title>
    <url>/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-03-23-41.png"></p>
<span id="more"></span>

<h1 id="管理OAuth客户端注册"><a href="#管理OAuth客户端注册" class="headerlink" title="管理OAuth客户端注册"></a>管理OAuth客户端注册</h1><p>oauth服务器需要为每个客户端分配唯一的客户端标识！</p>
<h2 id="由谁来生成客户端-ID？"><a href="#由谁来生成客户端-ID？" class="headerlink" title="由谁来生成客户端 ID？"></a>由谁来生成客户端 ID？</h2><p>在常规 的 OAuth系统中，客户端 ID（client_id）和密钥（client_secret）由 <em>授权服务器</em> 颁发给客户端</p>
<p>通过客户端 ID查找信息，客户端 ID是从请求 </p>
<h2 id="对客户端授权"><a href="#对客户端授权" class="headerlink" title="对客户端授权"></a>对客户端授权</h2><p>OAuth协议要求授权服务器提供两个端点：</p>
<ul>
<li>授权端点，运行在前端信道上；</li>
<li>令牌端点，运行 在后端信道上</li>
</ul>
<h3 id="授权端点"><a href="#授权端点" class="headerlink" title="授权端点"></a>授权端点</h3><p>授权服务器提供了一个授权端点，供客户端请求访问令牌和刷新令牌。客户端直接向该端点 发出请求，携带一组表单格式的参数，授权服务器解析并处理这些参数。然后授权服务器返回一 个代表令牌的 JSON对象</p>
<h3 id="令牌端点"><a href="#令牌端点" class="headerlink" title="令牌端点"></a>令牌端点</h3><p>令牌端点不面向用户</p>
<p>客户端得到授权码，它可以将其发送给授权服务器的令牌端点，换取 OAuth访问令牌， 再进行解析和存储</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-12-10-49.png"></p>
<p>OAuth流程中的很多部分都使用标准的 HTTP请求和响应格式来相互通信。由于这些请求通 常都发生在资源拥有者和用户代理的可见范围之外，因此它们统称为后端信道通信</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-12-05-02.png"></p>
<h3 id="重定向到授权端点"><a href="#重定向到授权端点" class="headerlink" title="重定向到授权端点"></a>重定向到授权端点</h3><p>授权端点是一个前端信道端点，客户端会 将用户浏览器重定向至该端点，以发出授权请求。</p>
<p>资源拥有者从客户端重定向到授权端点，它会带上客户端id。授权端点根客户端 ID查找客户端的详细信息：</p>
<ol>
<li>需要检查客户端是否存在；</li>
<li>需要渲染出一个页面来（&#x2F;authorize），让用户交互并进行授权</li>
</ol>
<h3 id="资源拥有者对客户端授权"><a href="#资源拥有者对客户端授权" class="headerlink" title="资源拥有者对客户端授权"></a>资源拥有者对客户端授权</h3><ol>
<li>在授权页面交互，发请求（&#x2F;approve）给授权点，生成授权码。</li>
<li>生成授权码，将授权码存储。以便后续客户端用授权码换令牌</li>
</ol>
<p>通过浏览器传过来的唯一信息就是 client_id，由于该信息是用浏览器通过前端信道传输的， 因此被视为公开信息。如此一来，任何人都可以冒充该客户端，但是我们还是可以借助一些信息 来判断请求的合法性，其中重要的就是检查传入的 redirect_uri 是否与客户端注册信息中 的一致</p>
<h3 id="授权点需要保存客户端注册信息"><a href="#授权点需要保存客户端注册信息" class="headerlink" title="授权点需要保存客户端注册信息"></a>授权点需要保存客户端注册信息</h3><ol>
<li>client_id</li>
<li>redirect_uri，可以是array</li>
<li>client_secret</li>
</ol>
<h2 id="令牌颁发"><a href="#令牌颁发" class="headerlink" title="令牌颁发"></a>令牌颁发</h2><ol>
<li>对客户端进行身份认证</li>
<li>处理授权许可请求</li>
</ol>
<p>客户端带过来的授权码其实没有很大用处。至少在书中它没和令牌有直接的关系！</p>
<p>授权码是作为一个一次性凭证，请求的时候就必须消耗，二次请求就会失效！</p>
<p>授权码的作用：保持一次性！</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-08-14-35.png"></p>
<h3 id="对客户端进行身份认证"><a href="#对客户端进行身份认证" class="headerlink" title="对客户端进行身份认证"></a>对客户端进行身份认证</h3><p>客户端会带来 client_id 和 client_secret，用client_id去查client_id对应的的客户端已经注册的信息！比对 client_secret 是否正确有效！</p>
<h3 id="处理授权许可请求"><a href="#处理授权许可请求" class="headerlink" title="处理授权许可请求"></a>处理授权许可请求</h3><p>根据 grant_type 参数，选择令牌颁发方式！</p>
<p>OAuth 2.0完全没有规定访问令牌的内容应该是什么样的，它有一个很好的理由：支持多 样化的选择，每种选择都有各自的权衡，并适应于不同的场景。</p>
<p>看下面代码，我思考后发现：access_token，它颗粒度是去到单个用户，而不是单个client的维度！</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-11-32-59.png"></p>
<p>客户端获取权限之后，用access_token访问受保护资源时，使用access_token去数据库查找详细信息，得到scope！</p>
<h1 id="授权许可类型"><a href="#授权许可类型" class="headerlink" title="授权许可类型"></a>授权许可类型</h1><p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-24-00-46-21.png"></p>
<ol>
<li><strong>隐式许可类型</strong>，直接从授权端点返回令牌，没有令牌端点；</li>
<li><strong>客户端凭据许可类型</strong>，没有明确的资源拥有者。只使用后端信道。</li>
<li><strong>资源拥有者凭据许可类型</strong>，资源拥有者通过客户端使用账号密码换令牌</li>
<li><strong>断言许可类型</strong>,</li>
</ol>
<p>隐式许可类型 的起点入口： </p>
<p>授权点接口（<code>/authorize</code>）的url search参数</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">response_type</td>
<td align="left">emAuthRespType</td>
<td align="left">响应类型</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">scope</td>
<td align="left">string</td>
<td align="left">需要申请的权限域</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">client_id</td>
<td align="left">string</td>
<td align="left">客户端的唯一标识</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">redirect_uri</td>
<td align="left">string</td>
<td align="left">客户端地址，需要授权完成后跳转的地址</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">string</td>
<td align="left">csrf-token</td>
<td align="left">optional</td>
</tr>
</tbody></table>
<p>回包结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式许可类型</span></span><br><span class="line">?access_token=987tghjkiu6trfghjuytrghj&amp;token_type=<span class="title class_">Bearer</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emAuthRespType &#123;</span><br><span class="line">  <span class="attr">CODE</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">TOKEN</span>: <span class="string">&#x27;token&#x27;</span>  <span class="comment">// 隐式许可类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端凭据许可类型 与 资源拥有者凭据许可类型 的起点接口</p>
<p><code>/token</code>，该接口是上面用code换access_token</p>
<table>
<thead>
<tr>
<th align="left">body参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">grant_type</td>
<td align="left">emGrantType</td>
<td align="left">获取token的方式</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">scope</td>
<td align="left">string</td>
<td align="left">csrf-token</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">username</td>
<td align="left">string</td>
<td align="left">账户，资源拥有者凭据许可类型使用，账户是受保护资源的账户</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">string</td>
<td align="left">密码，资源拥有者凭据许可类型使用，账户是受保护资源的账户</td>
<td align="left">optional</td>
</tr>
</tbody></table>
<p>注意</p>
<ul>
<li>账号和密码是由用户交互输出的，交互的页面由客户端提供！</li>
</ul>
<table>
<thead>
<tr>
<th align="left">header参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Authorization</td>
<td align="left">‘Basic <clent_id>+<clent_secret>‘</td>
<td align="left"><em>客户端凭证许可类型</em>和*资源拥有者凭据许可类型 *的使用，传递账号密码</td>
<td align="left">optional</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emGrantType &#123;</span><br><span class="line">  <span class="attr">AUTHORIZATION_CODE</span>: <span class="string">&#x27;authorization_code&#x27;</span>,</span><br><span class="line">  <span class="attr">CLIENT_CREDENTIALS</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">  <span class="attr">PASSWORD</span>: <span class="string">&#x27;password&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回报接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>: <span class="string">&quot;987tghjkiu6trfghjuytrghj&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;foo bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="隐式许可类型"><a href="#隐式许可类型" class="headerlink" title="隐式许可类型"></a>隐式许可类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.<span class="property">response_type</span> == <span class="string">&#x27;token&#x27;</span>) &#123; </span><br></pre></td></tr></table></figure>

<p>完全运行在浏览器中的 JavaScript应用就属于这种情况。在这种情况下，通过浏览器向客户端传递仅用于换 取令牌的授权码就没有任何实际意义了，因为这个额外的保密层没有起到任何作.</p>
<p>这种许可流程只使用授权端点而不使 用令牌端点</p>
<p>隐式许可流程不可用于获取刷新令牌。因为浏览器内的应用具有短暂运行的特点，只会在被加载到浏览器的期间保持会话，所以刷新令牌在这里的作用非常有限。</p>
<p>response_type 参数的值为 token，而不是 code。这样会通知授权服务器直接生成令牌，而 不是生成一个用于换取令牌的授权码。 </p>
<h2 id="客户端凭据许可类型"><a href="#客户端凭据许可类型" class="headerlink" title="客户端凭据许可类型"></a>客户端凭据许可类型</h2><p>与前面不同，使用另外一个接口（<code>/token</code>）</p>
<p><code>/token</code>，该接口是上面用code换access_token</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">grant_type</td>
<td align="left">emGrantType</td>
<td align="left">获取token的方式</td>
<td align="left">required</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emGrantType &#123;</span><br><span class="line">  <span class="attr">AUTHORIZATION_CODE</span>: <span class="string">&#x27;authorization_code&#x27;</span>,</span><br><span class="line">  <span class="attr">CLIENT_CREDENTIALS</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">body</span>.<span class="property">grant_type</span> == emGrantType.<span class="property">CLIENT_CREDENTIALS</span>) &#123; </span><br></pre></td></tr></table></figure>

<p>比如后端系统之间需要直接通信<br>只使用后端信道，客户端代表自己（它自己就是资源拥有 者）从令牌端点获取令牌。 </p>
<p>客户端向授权服务器的令牌端点发出令牌请求，这与授权码流程是一样的，只不过这一次使 用 client_credentials 作为 grant_type 参数的值，而且没有授权码或者其他用于换取令牌 的临时凭据。相反，客户端直接向授权服务器进行身份认证，而授权服务器给客户端颁发访问令牌</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-14-51-53.png"></p>
<p>在客户端凭据许可流程中不会颁发刷新令牌，因为我们认为客户端能够随时获取新令牌，无 须单独的资源拥有者参与，因此在这种情况下没有必要使用刷新令牌。 </p>
<p>客户端凭据许可类型没有任何直接的用户交互!它确实是为可信的后端系统直接 访问服务而准备的。</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-14-34-57.png"></p>
<h2 id="资源拥有者凭据许可类型"><a href="#资源拥有者凭据许可类型" class="headerlink" title="资源拥有者凭据许可类型"></a>资源拥有者凭据许可类型</h2><p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-07-16-00-30.png"></p>
<p>用户名和密码，那么客户端可以向用户索取用户 的凭据，然后用这个凭据换取令牌。支持客户端这样做的是资源拥有者凭据许可类型，也叫作密码流程。</p>
<p>这种许可类型的工作方式很简单。客户端收集用户的用户名和密码（使用什么样的交互接口 由客户端决定），然后将它们发送至授权服务器。 </p>
<p>授权服务器从收到的请求中取出用户名和密码，并与本地存储的用户信息对比。如果匹配， 则授权服务器向客户端颁发令牌。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grant_type == <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<p>完成所有的检查之后，就可以生成并返回令牌了。请注意，还可以生成刷新令牌（我们的练 习中这样做了）。为客户端提供刷新令牌之后，它就不需要再保存用户的密码了</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-08-05-42-33.png"></p>
<h1 id="客户端部署的应用类型"><a href="#客户端部署的应用类型" class="headerlink" title="客户端部署的应用类型"></a>客户端部署的应用类型</h1><ol>
<li>Web应用；</li>
<li>浏览器应用；</li>
<li>原生应用；</li>
</ol>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><p>Web应用运行在远程服务器上，需要通过Web浏览器访问。应用的配置和运行时状态由 Web 服务器维护，通常使用会话 cookie 与浏览器保持 连接。</p>
<p>Web 应用很容易有效地使用授权码、客 户端凭据或者断言许可流程。由于浏览器一般不会将请求 URI 中的片段部分发送给服务器，大 多数情况下隐式许可流程不适用于Web 应用。 </p>
<h2 id="浏览器应用"><a href="#浏览器应用" class="headerlink" title="浏览器应用"></a>浏览器应用</h2><p>浏览器应用完全运行在浏览器内，一般使用 JavaScript。虽然应用的代码确实需要由Web 服 务器提供，但代码本身并不在服务器上运行，Web 服务器也不会维护应用的任何运行时状态。应 用的所有执行动作都发生在最终用户计算机的浏览器内。 </p>
<p>因 为浏览器应用受限于同源策略以及其他安全限制条件，这些限制是为了防止跨站攻击。因此，最 适合这类应用的是隐式许可流程，该许可流程就是针对这种应用场景而做的优化。 </p>
<h2 id="原生应用"><a href="#原生应用" class="headerlink" title="原生应用"></a>原生应用</h2><p>原生应用是直接在最终用户的设备（计算机或者移动设备）上运行的应用。应用软件通常是在外部经过编译或者打包之后再安装到设备上的。</p>
<h1 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h1><p>客户端密钥属 于配置期间秘密，因为它代表客户端自身，是配置在客户端软件内部的。访问令牌、刷新令牌和 授权码都属于运行时秘密，因为它们都是在客户端软件被部署之后由客户端存储的。</p>
<p>运行时秘密仍然需要安全存储并保护，但是它们被设计得容易撤销或更改。相反，配置期间秘密一般不会经 常改变。 </p>
<p>不要求所有客户端都拥有客户端密钥，而是将客户 端分为两种类型：公开客户端和保密客户端，划分依据是能否持有配置期间秘密</p>
<p>Web 应用是最常见的保密客户端类 型，它是运行在 Web 服务器上的单个实例，单个 OAuth客户端可以对应多个资源拥有者</p>
<h1 id="OAuth令牌"><a href="#OAuth令牌" class="headerlink" title="OAuth令牌"></a>OAuth令牌</h1><p><strong>授权服务器生成令牌之后，会将令牌值存储在磁盘上的共享数据库中。当受保护资源从客户 端收到令牌之后，它会在同一个数据库中查找令牌值，以确定令牌有效</strong></p>
<p><em>授权服务器</em> 和 <em>受保护资源</em> 间共享数据库。存在两者不共享的场景！</p>
<p>在授权服务器和受保护资源间共享数据库并不总是实际可行，特别是在一个授权服务器需要 保护下游的多个资源服务器的情况下。该如何解决这个问题呢？本章将讨论另外两种常见的方 案：结构化令牌和令牌内省</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-08-13-31-55.png"></p>
<h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>JWT的核心是将一个 JSON对象封 装为一种用于网络传输的格式</p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9. </p>
</blockquote>
<p>句点符号将字符串分割成了两部分</p>
<p>以句点符号将令牌字符串分解，让我们可以对令牌的 不同部分分别进行处理</p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0</p>
<p>. </p>
<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</p>
<p>.</p>
</blockquote>
<p>对第一部分解码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>, </span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这是 JWT的头部，它是一个 JSON对象，用于描述与令牌剩余部分有关的信息。其中的 typ 头告诉处理程序令牌的第二部分（载荷）是何种类型。</p>
<p>第二部分是令牌的载荷，它的序列化方式与 JWT头部相同：对 JSON对象进行 Base64URL 编码。由于它是 JWT，因此其载荷可以是任意的 JSON对象</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-08-14-54-58.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = &#123; <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>, <span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;none&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> payload = &#123;</span><br><span class="line">  <span class="attr">iss</span>: <span class="string">&#x27;http://localhost:9001/&#x27;</span>,   </span><br><span class="line">  <span class="attr">sub</span>: code.<span class="property">user</span> ? code.<span class="property">user</span>.<span class="property">sub</span> : <span class="literal">undefined</span>,   </span><br><span class="line">  <span class="attr">aud</span>: <span class="string">&#x27;http://localhost:9002/&#x27;</span>,   </span><br><span class="line">  <span class="attr">iat</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>),   </span><br><span class="line">  <span class="attr">exp</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) + (<span class="number">5</span> * <span class="number">60</span>),   </span><br><span class="line">  <span class="attr">jti</span>: randomstring.<span class="title function_">generate</span>(<span class="number">8</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> access_token = base64url.<span class="title function_">encode</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(header))</span><br><span class="line">  + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">  + base64url.<span class="title function_">encode</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload))</span><br><span class="line">  + <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="令牌的加密保护：JOSE"><a href="#令牌的加密保护：JOSE" class="headerlink" title="令牌的加密保护：JOSE"></a>令牌的加密保护：JOSE</h2><p>JSON对象的签名和加密标准（JOSE①）。这套规范以 JSON为基础数据模型，提供了 签名（JSON Web签名，或称 JWS）、加密（JSON Web加密，或称 JWE）以及密钥存储格式（JSON Web 密钥，或称 JWK）的标准</p>
<h3 id="使用HS256的对称签名"><a href="#使用HS256的对称签名" class="headerlink" title="使用HS256的对称签名"></a>使用HS256的对称签名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = &#123; <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>, <span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;HS256&#x27;</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> access_token = jose.<span class="property">jws</span>.<span class="property">JWS</span>.<span class="title function_">sign</span>(</span><br><span class="line">  header.<span class="property">alg</span>,   </span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(header),   </span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload),   </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Buffer</span>(sharedTokenSecret).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// access_token</span></span><br><span class="line"><span class="comment">// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEv   </span></span><br><span class="line"><span class="comment">// Iiwic3ViIjoiOVhFMy1KSTM0LTAwMTMyQSIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMi8   </span></span><br><span class="line"><span class="comment">// iLCJpYXQiOjE0NjcyNTEwNzMsImV4cCI6MTQ2NzI1MTM3MywianRpIjoiaEZLUUpSNmUifQ.Wq  </span></span><br><span class="line"><span class="comment">// RsY03pYwuJTx-9pDQXftkcj7YbRn95o-16NHrVugg</span></span><br></pre></td></tr></table></figure>

<h3 id="使用RS256的非对称签名"><a href="#使用RS256的非对称签名" class="headerlink" title="使用RS256的非对称签名"></a>使用RS256的非对称签名</h3><p>使用共享密钥时，创建签名和验证签名的系统使用的是同一个密钥。这实际上意味着授权服务器和资源服务器都能够生成令牌，因为它们都拥有创建令牌所需的密钥。</p>
<p>使用公钥 加密的话，授权服务器拥有公钥和私钥，可用于生成令牌，而受保护资源则只能访问授权服务器 的公钥，用于验证令牌。与使用共享密钥不同的是，受保护资源虽然能够很容易地验证令牌，但它无法自己生成有效的令牌。、</p>
<p><em>使用非对称加密签名的目的就为了将创建令牌的权限收归到授权服务器。受保护资源服务器只能使用公钥进行验证而不能创建令牌！</em></p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-09-06-17-02.png"></p>
<h1 id="内省协议"><a href="#内省协议" class="headerlink" title="内省协议"></a>内省协议</h1><p>OAuth令牌内省协议定义了一种机制，让受保护资源能够主动向授权服务器查询令牌状态。<br>该协议是对 OAuth 的一个简单增强。授权服务器向客户端颁发令牌，客户端向受保护资源 出示令牌，受保护资源则向授权服务器查询令牌状</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-09-07-08-23.png"></p>
<p>内省请求</p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-09-07-15-45.png"></p>
<p>内省请求的响应是一个 JSON 对象，用于描述令牌信息。它的内容与 JWT 的载荷相似，任 何有效的 JWT声明都可以包含在响应中。 </p>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-09-07-16-11.png"></p>
<p>内省协议规范还在 JWT的基础上增加了几个声明定义，其中重要的是 active 声明。此 声明告诉受保护资源当前令牌在授权服务器上是否有效，且是唯一必须返回的声明。</p>
<h2 id="构建内省端点"><a href="#构建内省端点" class="headerlink" title="构建内省端点"></a>构建内省端点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> protectedResources = [&#123;</span><br><span class="line">  <span class="string">&quot;resource_id&quot;</span>: <span class="string">&quot;protected-resource-1&quot;</span>,        </span><br><span class="line">  <span class="string">&quot;resource_secret&quot;</span>: <span class="string">&quot;protected-resource-secret-1&quot;</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getProtectedResource = <span class="keyword">function</span>(<span class="params">resourceId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> __.<span class="title function_">find</span>(protectedResources, <span class="keyword">function</span>(<span class="params">protectedResource</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>   protectedResource.<span class="property">resource_id</span> == resourceId;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/introspect&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> auth = req.<span class="property">headers</span>[<span class="string">&#x27;authorization&#x27;</span>]; </span><br><span class="line">  <span class="keyword">var</span> resourceCredentials = <span class="title function_">decodeClientCredentials</span>(auth); </span><br><span class="line">  <span class="keyword">var</span> resourceId = resourceCredentials.<span class="property">id</span>; </span><br><span class="line">  <span class="keyword">var</span> resourceSecret = resourceCredentials.<span class="property">secret</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resource = <span class="title function_">getProtectedResource</span>(resourceId);</span><br><span class="line">  <span class="keyword">if</span> (!resource) &#123;   </span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">end</span>();   </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resource.<span class="property">resource_secret</span> != resourceSecret) &#123;   </span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">end</span>();   </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> inToken = req.<span class="property">body</span>.<span class="property">token</span>; </span><br><span class="line">  </span><br><span class="line">  nosql.<span class="title function_">one</span>(<span class="keyword">function</span>(<span class="params">token</span>) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (token.<span class="property">access_token</span> == inToken) &#123;        </span><br><span class="line">      <span class="keyword">return</span> token;   </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err, token</span>) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (token) &#123; </span><br><span class="line">      <span class="keyword">var</span> introspectionResponse = &#123;              </span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,              </span><br><span class="line">        <span class="attr">iss</span>: <span class="string">&#x27;http://localhost:9001/&#x27;</span>,              </span><br><span class="line">        <span class="attr">aud</span>: <span class="string">&#x27;http://localhost:9002/&#x27;</span>,              </span><br><span class="line">        <span class="attr">sub</span>: token.<span class="property">user</span> ? token.<span class="property">user</span>.<span class="property">sub</span> : <span class="literal">undefined</span>,              </span><br><span class="line">        <span class="attr">username</span>: token.<span class="property">user</span> ? token.<span class="property">user</span>.<span class="property">preferred_username</span> : <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">scope</span>: token.<span class="property">scope</span> ? token.<span class="property">scope</span>.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) : <span class="literal">undefined</span>,              </span><br><span class="line">        <span class="attr">client_id</span>: token.<span class="property">client_id</span>       </span><br><span class="line">      &#125;; </span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(introspectionResponse);       </span><br><span class="line">      <span class="keyword">return</span>;   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;       </span><br><span class="line">      <span class="keyword">var</span> introspectionResponse = &#123;              </span><br><span class="line">        <span class="attr">active</span>: <span class="literal">false</span>       </span><br><span class="line">      &#125;;       </span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(introspectionResponse);       </span><br><span class="line">      <span class="keyword">return</span>;   </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="发起令牌内省请求"><a href="#发起令牌内省请求" class="headerlink" title="发起令牌内省请求"></a>发起令牌内省请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> protectedResource = &#123;   </span><br><span class="line">  <span class="string">&quot;resource_id&quot;</span>: <span class="string">&quot;protected-resource-1&quot;</span>,   </span><br><span class="line">  <span class="string">&quot;resource_secret&quot;</span>: <span class="string">&quot;protected-resource-secret-1&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> form_data = qs.<span class="title function_">stringify</span>(&#123;   </span><br><span class="line">  <span class="attr">token</span>: inToken</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> headers = &#123;   </span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,   </span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Basic &#x27;</span> + <span class="title function_">encodeClientCredentials</span>(</span><br><span class="line">    protectedResource.<span class="property">resource_id</span>, protectedResource.<span class="property">resource_secret</span>)</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> tokRes = <span class="keyword">await</span> <span class="title function_">request</span>(<span class="string">&#x27;POST&#x27;</span>, authServer.<span class="property">introspectionEndpoint</span>, &#123;   </span><br><span class="line">  <span class="attr">body</span>: form_data,   </span><br><span class="line">  <span class="attr">headers</span>: headers </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tokRes.<span class="property">statusCode</span> &gt;= <span class="number">200</span> &amp;&amp; tokRes.<span class="property">statusCode</span> &lt; <span class="number">300</span>) &#123;   </span><br><span class="line">  <span class="keyword">var</span> body = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(tokRes.<span class="title function_">getBody</span>()); </span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got introspection response&#x27;</span>, body);   </span><br><span class="line">  <span class="keyword">var</span> active = body.<span class="property">active</span>;   </span><br><span class="line">  <span class="keyword">if</span> (active) &#123;        </span><br><span class="line">    req.<span class="property">access_token</span> = body;   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>呈现了两种用于授权服务器和受保护资源之间传递信息的方法：结构化令牌（具体来说 就是 JWT）和令牌内省。看起来这两种方法需要二选一，但实际上，将它们结合起来使用也可 以得到很好的效果</p>
<h1 id="动态客户端注册"><a href="#动态客户端注册" class="headerlink" title="动态客户端注册"></a>动态客户端注册</h1><p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-09-12-16-09.png"></p>
<p>OAuth 动态客户端注册协议②提供了一种方法，让客户端可以自行加入授权服务器，并注册 自己的各类相关信息。</p>
<h1 id="生成授权码"><a href="#生成授权码" class="headerlink" title="生成授权码"></a>生成授权码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomString = <span class="built_in">require</span>(<span class="string">&#x27;random-string&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="title function_">randomString</span>();</span><br><span class="line"></span><br><span class="line">mysql.<span class="title function_">insert</span>(&#123;</span><br><span class="line">  <span class="attr">table</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">field</span>: &#123; code &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">KEYUTIL</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;jsrsasign&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rsaKeypair = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">generateKeypair</span>(<span class="string">&quot;RSA&quot;</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE</span> = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getPEM</span>(rsaKeypair.<span class="property">prvKeyObj</span>, <span class="string">&quot;PKCS8PRV&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC</span> = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getPEM</span>(rsaKeypair.<span class="property">pubKeyObj</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/blog/2022/10/18/oauth2%E5%AE%9E%E8%B7%B5/2022-10-24-03-52-06.png"><br>参考：<a href="http://kjur.github.io/jsrsasign/api/symbols/KEYUTIL.html">http://kjur.github.io/jsrsasign/api/symbols/KEYUTIL.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://laibh.top/2020-07-17-oauth2%20nodejs%E5%AE%9E%E6%88%98.html">oauth2 nodejs实战</a></li>
<li><a href="https://www.jianshu.com/p/7febbe553c83">使用 Nodejs 搭建一个 OAuth2.0 服务</a></li>
<li><a href="http://www.rfcreader.com/#rfc6749">rfc6749</a></li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title>【win】安装ADB</title>
    <url>/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://developer.android.com/studio/releases/platform-tools">下载adb for windows</a></p>
<p><img src="/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/58064e0ddf514a219e22db69e7dbb67c.webp"></p>
<span id="more"></span>

<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p><img src="/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/02512be76de14b79948bb73c4bd20785.webp"></p>
<p>在platform-tools目录下运行命令行工具（power shell或者cmd）</p>
<p><img src="/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/363090a2e94b46f69101c41d06237dd8.webp"></p>
<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>我的电脑 &gt; 高级系统设置 &gt; 环境变量 &gt; 编辑 Path 环境变量</p>
<p>增加 platform-tools目录 路径</p>
<p><img src="/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/2c4dd95b1ff24d0bbc38641b8399802e.webp"></p>
<p>结果</p>
<p><img src="/blog/2022/06/17/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/00feed73893f4d84a8e2958e07d91771.webp"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.xda-developers.com/install-adb-windows-macos-linux/#adbsetupwindows">https://www.xda-developers.com/install-adb-windows-macos-linux/#adbsetupwindows</a></li>
</ul>
]]></content>
      <categories>
        <category>开发调试</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>adb</tag>
        <tag>安卓调试</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：从0开始与踩坑实录</title>
    <url>/blog/2021/03/16/hexo%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%B8%8E%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<h1 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h1><h2 id="curl下载github-zip链接"><a href="#curl下载github-zip链接" class="headerlink" title="curl下载github zip链接"></a>curl下载github zip链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -LJO https://github.com/theme-next/theme-next-fancybox3 </span><br></pre></td></tr></table></figure>

<h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip theme-next-fancybox3-master.zip</span><br></pre></td></tr></table></figure>

<h1 id="page布局有什么用？"><a href="#page布局有什么用？" class="headerlink" title="page布局有什么用？"></a>page布局有什么用？</h1><p>官文档说的布局概念</p>
<blockquote>
<p><img src="/blog/2021/03/16/hexo%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%B8%8E%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/Snipaste_2023-02-14_21-58-08.png"></p>
</blockquote>
<p><strong>布局概念含糊不清！</strong></p>
<h1 id="为什么主页将所有文章以详情的形式全列出来了？"><a href="#为什么主页将所有文章以详情的形式全列出来了？" class="headerlink" title="为什么主页将所有文章以详情的形式全列出来了？"></a>为什么主页将所有文章以详情的形式全列出来了？</h1><p>文章没有添加 <code>description</code> 属性。形如</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo：从0开始与踩坑实录</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-16 14:46:49</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">记录入坑hexo的过程中遇到的问题与最终解决</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>只有添加 <code>description</code>并且字段值不为空（可以使用空格占位），才会以概览模式在主页列出所有文章！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://ryderchan.github.io/2017/01/26/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7-%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E5%9B%BE%E7%89%87/">hexo小技巧-首页显示文章摘要及图片</a></li>
</ul>
<h1 id="文章中的图片的保存位置以及使用方式"><a href="#文章中的图片的保存位置以及使用方式" class="headerlink" title="文章中的图片的保存位置以及使用方式"></a>文章中的图片的保存位置以及使用方式</h1><h2 id="post-asset-folder"><a href="#post-asset-folder" class="headerlink" title="post_asset_folder"></a>post_asset_folder</h2><p>开启 <code>post_asset_folder</code>，将生成文章同名目录。可以使用路径访问此目录下的资源！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Markdown语法"><a href="#使用Markdown语法" class="headerlink" title="使用Markdown语法"></a>使用Markdown语法</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： image.jpg 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; </code>。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>hexo博客中如何插入图片: <a href="https://cloud.tencent.com/developer/article/1736563">https://cloud.tencent.com/developer/article/1736563</a></li>
<li>资源文件夹: <a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></li>
</ul>
<h1 id="Next如何添加分类页与标签页？"><a href="#Next如何添加分类页与标签页？" class="headerlink" title="Next如何添加分类页与标签页？"></a>Next如何添加分类页与标签页？</h1><h2 id="将Next配置文件中的Menu开启"><a href="#将Next配置文件中的Menu开启" class="headerlink" title="将Next配置文件中的Menu开启"></a>将Next配置文件中的Menu开启</h2><p>路径：themes&#x2F;next&#x2F;_config.yml</p>
<p>将配置开启后，就可以在页面上看到 分类页 和 标签页 的入口。但是仅仅只有入口没有内容！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h2 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h2><p>添加分类页面。执行下面命令将会生成 source&#x2F;categories&#x2F;index.md</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>categories&#x2F;index.md 的内容如下，还需做些必要修改：添加 <code>type: &quot;categories&quot;</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-02-14 16:56:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>标签页的添加与以上大部分相似！需要注意的是：</p>
<ul>
<li>标签页创建：<code>hexo new page tags</code>；</li>
<li>标签页属性修改：<code>type: &quot;tags&quot;</code></li>
</ul>
<h2 id="使用分类"><a href="#使用分类" class="headerlink" title="使用分类"></a>使用分类</h2><p>在 <code>source/_posts/</code> 目录的文章中的yml配置，添加 <code>categories</code> 属性。如下面例子。</p>
<p>文章添加标签后，再编译就会生成对应的标签文件！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">面试题62.</span> <span class="string">圆圈中最后剩下的数字</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-04-17 02:13:49</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">算法题</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">LCOF</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译后继承生成分类、标签目录，见下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">categories</span><br><span class="line">├── hexo</span><br><span class="line">|  └── index.html</span><br><span class="line">├── index.html</span><br><span class="line">└── 算法题</span><br><span class="line">   └── index.html</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="预览图片"><a href="#预览图片" class="headerlink" title="预览图片"></a>预览图片</h1><h2 id="打开-fancybox-开关"><a href="#打开-fancybox-开关" class="headerlink" title="打开 fancybox 开关"></a>打开 fancybox 开关</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NexT _config.yml</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="方式1：CDN"><a href="#方式1：CDN" class="headerlink" title="方式1：CDN"></a>方式1：CDN</h3><p>打开 NexT 配置文件FancyBox资源配置的注释即可！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NexT _config.yml</span></span><br><span class="line"><span class="comment"># FancyBox</span></span><br><span class="line"><span class="comment"># jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js</span></span><br><span class="line"><span class="comment"># fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line"><span class="comment"># fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br></pre></td></tr></table></figure>


<h3 id="方式2：下载-fancybox-插件资源"><a href="#方式2：下载-fancybox-插件资源" class="headerlink" title="方式2：下载 fancybox 插件资源"></a>方式2：下载 fancybox 插件资源</h3><p>将 fancybox 包下载到 cd next&#x2F;source&#x2F;lib，并将资源解压（假如需要）后命名为 fancybox 即可！</p>
<p>fancybox包：<a href="https://github.com/theme-next/theme-next-fancybox3">https://github.com/theme-next/theme-next-fancybox3</a></p>
<h1 id="评论插件-gittalk"><a href="#评论插件-gittalk" class="headerlink" title="评论插件(gittalk)"></a>评论插件(gittalk)</h1><p>仓库：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a></p>
<p>NexT已经内置，只需要修改NexT配置文件！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span>  <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span>  <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span>  <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span>  <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span>  <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">false</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<p>上面配置 client_id 和 client_secret 需要在github注册 OAuth App: </p>
<p><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<p><img src="/blog/2021/03/16/hexo%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%B8%8E%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/Snipaste_2023-02-16_13-28-44.png"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Application</span> <span class="string">name：</span> <span class="comment"># 应用名称，随意填写即可</span></span><br><span class="line"><span class="string">Homepage</span> <span class="string">URL：</span> <span class="comment"># 你的网站地址，如https://yourname.github.io</span></span><br><span class="line"><span class="string">Application</span> <span class="string">description</span> <span class="comment"># 描述，随意填写即可</span></span><br><span class="line"><span class="string">Authorization</span> <span class="string">callback</span> <span class="string">URL：#</span> <span class="string">你的网站地址，如https://yourname.github.io</span></span><br></pre></td></tr></table></figure>

<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://chenfeng2000.github.io/2020/01/30/NexT-7-7-0%E4%BB%A5%E5%90%8E%E7%89%88%E6%9C%AC-gitalk%E9%85%8D%E7%BD%AE/">hexo博客 NexT 7.7.0以后版本 gitalk配置</a></li>
<li><a href="https://blog.mmzi.online/2021/07/10/Hexo-%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0Valine%E5%92%8CGitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">Hexo 博客增加Valine&#x2F;Gitalk评论插件</a></li>
<li><a href="https://github.com/gitalk/gitalk">github:gitalk&#x2F;gitalk</a></li>
</ul>
<h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://theme-next.js.org/">NexT官方文档</a></li>
<li><a href="https://www.jianshu.com/p/5a1e6d8c83af">初步了解Hexo站点的布局</a></li>
<li><a href="https://ben286.github.io/2018/08/21/%E5%85%B6%E4%BB%96/hexo%E5%B8%83%E5%B1%80%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/">hexo布局架构及功能分析</a></li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Hook实现轻量级自动化部署</title>
    <url>/blog/2020/05/07/Git-Hook%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在整理项目，发现以前的一个项目中，发现使用git hook和pm2实现了一个简单的自动化部署，也没有写什么记录，故复记录之。</p>
<span id="more"></span>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://user-images.githubusercontent.com/25907273/81206194-59d7c700-8ffe-11ea-82b1-d8672393d6c7.png" alt="image"></p>
<h2 id="原理与流程"><a href="#原理与流程" class="headerlink" title="原理与流程"></a>原理与流程</h2><ol>
<li>git用户执行git push操作；</li>
<li>远程仓库发现有用户执行了push操作，就会执行一个脚本post-update（钩子）；</li>
<li>在post-update脚本中，将git仓库的代码拷贝到web站点目录下。</li>
</ol>
<h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>Git 钩子(hooks)是在 Git 仓库中特定事件(certain points)触发后被调用的脚本。通过钩子可以自定义 Git 内部的相关（如 git push）行为，在开发周期中的关键点触发自定义的行为。Git 含有两种类型的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<p>每个使用git进行版本版本管理的项目都存在hooks，这些hooks存在于项目目录下的<code>.git/hooks/</code>：</p>
<p><img src="https://user-images.githubusercontent.com/25907273/81207013-7fb19b80-8fff-11ea-9846-7565991e923a.png" alt="image"></p>
<p>以上这些就是git hook脚本。简单地说，hook是一种特殊的脚本（代码），仅在满足特定条件时执行。git hooks分别有对应各种操作的hook。每个hook都对应在不同的情况下触发，比如接下来要用到的post-update脚本，则是在检测到push的操作时触发。</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><ol>
<li>在服务端创建一个裸仓库；</li>
<li>编辑裸仓库中的post-update hook脚本；</li>
<li>本地仓库添加远程裸仓库作为remote。</li>
</ol>
<h3 id="1-在服务端创建一个裸仓库"><a href="#1-在服务端创建一个裸仓库" class="headerlink" title="1. 在服务端创建一个裸仓库"></a>1. 在服务端创建一个裸仓库</h3><p>什么是裸仓库？</p>
<p>裸仓库与 git init 初使化的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的.git文件夹，整个裸仓库中只有git索引（index），不包含工作目录。裸仓库只保存了一些配置信息等，肉眼找不到上传的代码。简单说就是一个简单版的git仓库，不能使用常见的git命令，比如<code>git status</code>等等。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/81208387-8b05c680-9001-11ea-8cad-8fbcdf45bcff.png" alt="image"></p>
<p>创建裸仓库很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bare.git名字可以任意</span></span><br><span class="line">git init --bare bare.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">mkdir bare.git</span><br><span class="line">cd bare.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<p>为什么要创建裸仓库？</p>
<p>裸仓库存在于服务端，是我们要提交代码的目标。我们在本地仓库push代码，就是要push到这个裸仓库。当我们push到这个裸仓库时，就会触发裸仓库响应的git hook——post-update。</p>
<h3 id="2-编辑裸仓库中的post-update-hook脚本"><a href="#2-编辑裸仓库中的post-update-hook脚本" class="headerlink" title="2. 编辑裸仓库中的post-update hook脚本"></a>2. 编辑裸仓库中的post-update hook脚本</h3><p>在脚本中，你可以写Bash、Python、JavaScript等代码，Git通过Shebang来选择执行代码的解释器。如果要写Bash，Shebang可以是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>使用Windows的读者请注意，如果脚本文件含有BOM（字节序标识符），可能会导致一些问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去掉sample后缀才会触发</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> post-update.sample post-update</span></span><br></pre></td></tr></table></figure>

<p>下面是一个比较简单的hook脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bare-repos是实际要部署代码的目录，这个目录是需要现在服务端创建的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然也可以当前脚本中自动化创建</span></span><br><span class="line">DIR_ONE=/Users/baohua/workspace/bare-repos/</span><br><span class="line">cd $DIR_ONE</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git remote add origin /Users/baohua/workspace/bare.git</span><br><span class="line">git clean -df</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">npm run deploy</span><br></pre></td></tr></table></figure>
<p><strong>注意： 一定要unset GIT_DIR清除变量， 不然会引起remote: fatal: Not a git repository: ‘.’错误。</strong></p>
<p>上面脚本做的事情很简单：</p>
<ol>
<li>切换到部署目录；</li>
<li>初始化git，在部署目录中添加裸仓库作为remote；</li>
<li>拉取裸仓库中的代码；</li>
<li>执行打包脚本。</li>
</ol>
<p>接着还需要给 post-update 添加执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +x将所有用户的执行权限添加到现有权限</span></span><br><span class="line">chmod +x post-update</span><br></pre></td></tr></table></figure>

<h3 id="3-本地仓库添加远程裸仓库作为remote"><a href="#3-本地仓库添加远程裸仓库作为remote" class="headerlink" title="3. 本地仓库添加远程裸仓库作为remote"></a>3. 本地仓库添加远程裸仓库作为remote</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 如果测试，并且裸仓库建在本地</span><br><span class="line">git remote add deploy /Users/baohua/workspace/bare.git</span><br><span class="line"></span><br><span class="line">// 默认ssh端口号为22时</span><br><span class="line">git remote add deploy user@serverIp:/Users/baohua/workspace/bare.git</span><br><span class="line"></span><br><span class="line">// ssh端口号为不22时</span><br><span class="line">git  remote  add  deploy  ssh://user@serverIp:port/Users/baohua/workspace/bare.git</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>利用每次push到目标仓库都会触发对应git hook的机制，在git hook中进行需要部署的代码从目标仓库中克隆到实际的代码部署目录；</li>
<li>实现流程分为三步：<ol>
<li>在服务端创建一个裸仓库；</li>
<li>编辑裸仓库中的post-update hook脚本；</li>
<li>本地仓库添加远程裸仓库作为remote。</li>
</ol>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Customizing Git - Git Hooks</a></li>
<li><a href="https://juejin.im/post/5ce607946fb9a07ef5620e5b">前端自动化工作流中的hooks</a></li>
<li><a href="https://www.jianshu.com/p/c1478bfcb372">利用Git Hooks自动部署</a></li>
<li><a href="https://aotu.io/notes/2017/04/10/githooks/index.html">用 Git 钩子进行简单自动部署</a></li>
<li><a href="https://blog.csdn.net/u010837612/article/details/70825225?utm_source=itdadao&utm_medium=referral">git hook实现代码自动部署</a></li>
<li><a href="https://www.cnblogs.com/wowchky/p/9177036.html">使用 Git Hook 实现网站的自动部署</a></li>
<li><a href="https://segmentfault.com/q/1010000004683286">git init 和 git init –bare 的区别？</a></li>
<li><a href="https://segmentfault.com/a/1190000016513388">使用git hook 实现nodejs项目自动部署</a></li>
<li><a href="https://www.jianshu.com/p/ef373ea5c61b">不会写shell的程序员照样是好前端——用Node.JS实现git hooks</a></li>
<li><a href="https://ubuntuqa.com/article/2264.html">“chmod + x”和“chmod 755”有什么区别？</a></li>
</ul>
]]></content>
      <categories>
        <category>部署发布</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>部署发布</tag>
        <tag>git hook</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Generator</title>
    <url>/blog/2020/04/25/%E6%B5%85%E6%9E%90Generator/</url>
    <content><![CDATA[<p>Generator 函数就是遍历器生成函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>foo()</code>会生成迭代器对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>



<p>第一次执行<code>generator.next()</code>，指针指向的是<code>yield 1;</code>的执行结果。</p>
<p><strong>而<code>console.log(1)</code>则是会被放在<code>next</code>中执行，这是猜想！</strong></p>
<p>迭代器对象的原理可以参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>在调用<code>next</code>方法时会返回一个对象，但是在generator内部，<code>yield</code>表达式是不会有返回值（或者说是返回<code>undefind</code>）。</p>
<p>但是想起在koa的时候，下面的方法又是可以有返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/detail&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  * <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">headers</span>[setting.<span class="property">bizHeader</span>];</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">const</span> out = <span class="keyword">yield</span> model.<span class="property">Business</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">      <span class="attr">raw</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">attributes</span>: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>, <span class="string">&#x27;avatar&#x27;</span>],</span><br><span class="line">      <span class="attr">where</span>: &#123; <span class="attr">bizId</span>: id &amp; <span class="number">65535</span>, <span class="title class_">CompanyId</span>: id &gt;&gt; <span class="number">16</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out 会储存一个Business的对象</span></span><br></pre></td></tr></table></figure>

<p><strong><code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</strong></p>
<p>比如上面的handler generator函数，只要如是操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="title function_">handler</span>();</span><br><span class="line"><span class="comment">// 计算 const out = yield model.Business.findOne(&#123; /* ... */ &#125;)</span></span><br><span class="line"><span class="keyword">const</span> res = generator.<span class="title function_">next</span>();		<span class="comment">// &#123; value: /* Business对象 */, done: false &#125;</span></span><br><span class="line"><span class="comment">// res.value就会赋值给out</span></span><br><span class="line">generator.<span class="title function_">next</span>(res.<span class="property">value</span>);</span><br><span class="line"><span class="comment">// 最终就return out</span></span><br></pre></td></tr></table></figure>



<p>从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数</p>
<h2 id="generator的throw方法"><a href="#generator的throw方法" class="headerlink" title="generator的throw方法"></a>generator的throw方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="keyword">yield</span> <span class="string">&#x27;isaac&#x27;</span>; </span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`inner error:`</span>, e.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> 	<span class="keyword">const</span> generator = <span class="title function_">foo</span>();</span><br><span class="line">  <span class="comment">// 必须先启动，调用throw方法才有效</span></span><br><span class="line">  generator.<span class="title function_">next</span>();</span><br><span class="line">  generator.<span class="keyword">throw</span>(<span class="string">&#x27;i am a error&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;outer error:&#x27;</span>, e.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// inner error: i am a error</span></span><br></pre></td></tr></table></figure>

<p>正如上面例子，使用<code>generator.throw</code>方法抛出的错误会被<code>generator</code>函数内部的<code>try...catch</code>捕获到，当然如果<code>generator</code>函数内部没有使用<code>try...catch</code>则会冒泡想外层抛出。</p>
<h2 id="yield-的本质"><a href="#yield-的本质" class="headerlink" title="yield*的本质"></a>yield*的本质</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历迭代器的同时再生成迭代器</p>
<p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实</p>
<h2 id="generator对异步任务的封装"><a href="#generator对异步任务的封装" class="headerlink" title="generator对异步任务的封装"></a>generator对异步任务的封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">bio</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> result = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器实现路由的自动挂载</title>
    <url>/blog/2020/04/23/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="装饰器实现路由的自动挂载"><a href="#装饰器实现路由的自动挂载" class="headerlink" title="装饰器实现路由的自动挂载"></a>装饰器实现路由的自动挂载</h1><ul>
<li>类装饰器工作记录contriller路径；</li>
<li>方法装饰器记录方法路径；</li>
<li>参数装饰器记录参数类型；</li>
<li>组合路由</li>
</ul>
<span id="more"></span>

<h1 id="类装饰器工作记录controller路径"><a href="#类装饰器工作记录controller路径" class="headerlink" title="类装饰器工作记录controller路径"></a>类装饰器工作记录controller路径</h1><p>controller装饰器的实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Control</span> = (<span class="params">prefix: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_CONTROLLER_METADATA</span>, prefix, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现一个装饰个装饰器工厂函数，传入要保存的controller路径，工厂函数内部返回一个闭包函数（即是装饰器），在类装饰器函数中会传入一下参数，第一个是当前类构造函数的引用。然后使用reflect-metadata这个库的defineMetadata方法保存controller路径。这个方法一共需要传入三个参数：分别是metadata的key，第二个是要保存的数据，第三个也是一个键值，在这里使用构造函数的引用作为键值，这里的存储路径是：“构造函数”下保存以“metadate key”作为键值的数据“controller路径”。</p>
<p>在取出时只需要使用方法<code>getMetadata(&lt;metadata key&gt;, &lt;ref&gt;)</code>按defineMetadata方法的顺序传参即可在任何地方取出刚刚保存的数据。</p>
<h1 id="方法装饰器记录方法路径"><a href="#方法装饰器记录方法路径" class="headerlink" title="方法装饰器记录方法路径"></a>方法装饰器记录方法路径</h1><p>方法装饰器根据http的动词方法进行封装。</p>
<p>跟controller装饰器实现类型，同样封装一样的装饰工厂来保存路径。与controller装饰器的实现不同的是，还需要额外保存另外两个数据：1.http动词；2.保存方法名。需要http方法动词是因为挂载路由时需要制定不同的http方法；保存方法名，则是为了在后续可以访问到与路径对应的方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createHttpMethodDecorator</span> = (<span class="params">methodtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">path: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlers = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, target) || [];</span><br><span class="line">      handlers.<span class="title function_">push</span>(propertyKey);</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, handlers, target);</span><br><span class="line">      <span class="comment">// 设置方法</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_METHOD_METADATA</span>, methodtype, target, propertyKey);</span><br><span class="line">      <span class="comment">// 设置路由</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_URL_METADATA</span>, path, target, propertyKey);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Get</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">GET</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Post</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">POST</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Put</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">PUT</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Delete</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">DELETE</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Patch</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">PATCH</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">All</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">ALL</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Options</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">OPTIONS</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Head</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">HEAD</span>);</span><br></pre></td></tr></table></figure>

<p>注意：方法装饰器传入的第一个参数和类装饰器不同，类装饰器传入的是构造函数的引用，而方法装饰器传入的构造函数原型对象的引用（Ctor.prototype）。</p>
<h1 id="参数装饰器记录参数类型"><a href="#参数装饰器记录参数类型" class="headerlink" title="参数装饰器记录参数类型"></a>参数装饰器记录参数类型</h1><p>参数装饰器的封装比以上两种会稍微复杂一点，主要需要保存的数据有：</p>
<ol>
<li>参数装饰的类型：包含Query对应get方法请求参数，Body对应post等方法参数，Param对应路径上的参数；</li>
<li>参数的索引：参数在方法参数列表上的索引；</li>
<li>参数名：参数的名字（字符串）。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">assignMetadata</span> = (<span class="params">args, paramtype, index, data, ...pipes: PipeTransform[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;...args,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;paramtype&#125;</span>:<span class="subst">$&#123;index&#125;</span>`</span>]: &#123;</span><br><span class="line">      paramtype,</span><br><span class="line">      <span class="attr">paramIndex</span>: index,</span><br><span class="line">      <span class="attr">propName</span>: data,</span><br><span class="line">      pipes,</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouteParamDecorator</span> = (<span class="params">paramtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">data?: <span class="built_in">any</span>, ...pipes: PipeTransform[]</span>) =&gt;</span> <span class="function">(<span class="params">target, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_ARGS_METADATA</span>, target, key) || &#123;&#125;;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(</span><br><span class="line">      <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">      <span class="title function_">assignMetadata</span>(args, paramtype, index, data, ...pipes),</span><br><span class="line">      target,</span><br><span class="line">      key,</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Request</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">REQUEST</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Response</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">RESPONSE</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UploadFileStream</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">FILE_STREAM</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Headers</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">HEADERS</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Query</span> = (<span class="params">property?: <span class="built_in">string</span>, ...pipes: PipeTransform[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">QUERY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Body</span> = (<span class="params">property?: <span class="built_in">string</span>, ...pipes: PipeTransform[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">BODY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Param</span> = (<span class="params">property?: <span class="built_in">string</span>, ...pipes: PipeTransform[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">PARAM</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="组合路由"><a href="#组合路由" class="headerlink" title="组合路由"></a>组合路由</h1><p>首先需要动态引入Controller，因为装饰器保存的数据都是保存在键名是构造函数引用下或构造函数原型对象引用下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="built_in">require</span>(file).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> prototype = controller.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>取出Controller装饰器保存的路径：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制器前缀 类装饰器，传入的是构造函数</span></span><br><span class="line"><span class="keyword">const</span> ctrlPrefix = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_CONTROLLER_METADATA</span>, constructor) || <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>取出存储的方法名：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 方法、属性装饰器，传入原型</span></span><br><span class="line"><span class="keyword">const</span> methodNames = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, prototype) || [];</span><br></pre></td></tr></table></figure>

<p>取出该方法下的数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">methodNames.<span class="title function_">forEach</span>(<span class="function">(<span class="params">methodName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// http方法：get 、post、put等</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">httpMethod</span>: <span class="built_in">string</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_METHOD_METADATA</span>, prototype, methodName);</span><br><span class="line">  <span class="comment">// 方法装饰器声明的路由</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">urlPath</span>: <span class="built_in">string</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_URL_METADATA</span>, prototype, methodName) || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// 是否上传文件</span></span><br><span class="line">  <span class="keyword">const</span> uploadFile = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">UPLOAD_FILE_METADATA</span>, prototype, methodName) || <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// handler的参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">handlerArgs</span>: <span class="title class_">RouteParamMetadataInterface</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">    prototype,</span><br><span class="line">    methodName,</span><br><span class="line">  ) || &#123;&#125;;</span><br><span class="line">  <span class="comment">// handlerArgs的参数类型</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">handlerArgsTypes</span>: <span class="built_in">any</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="title class_">ReflectDefaultMetadata</span>.<span class="property">DESGIN_PARAMTYPES</span>,</span><br><span class="line">    prototype,</span><br><span class="line">    methodName,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(handlerArgs)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;paramIndex&#125; = handlerArgs[key];</span><br><span class="line">    <span class="comment">// 相应位置的参数类型。类型声明</span></span><br><span class="line">    handlerArgs[key].<span class="property">type</span> = handlerArgsTypes[paramIndex];</span><br><span class="line">  &#125;</span><br><span class="line">  handlers.<span class="title function_">push</span>(&#123;</span><br><span class="line">    urlPath,</span><br><span class="line">    httpMethod,</span><br><span class="line">    methodName,</span><br><span class="line">    handlerArgs,</span><br><span class="line">    uploadFile,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从上面我们就拿到了：</p>
<ul>
<li>Controller装饰器保存的路径；<code>ctrlPrefix</code></li>
<li>方法装饰器保存的路径：<code>urlPath</code>；</li>
<li>方法装饰器的类型：<code>httpMethod</code>、</li>
</ul>
<p>有以上数据就可以进行路由的挂载：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// url = [ctrlPrefix, urlPath].join(&#x27;/&#x27;);</span></span><br><span class="line">app.<span class="property">router</span>[httpMethod](url, ...middleware, <span class="keyword">async</span> (<span class="attr">ctx</span>: <span class="title class_">Context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">controller</span>(ctx);</span><br><span class="line">  <span class="keyword">if</span> (uploadFile) &#123;</span><br><span class="line">    ctx.<span class="property">request</span>.<span class="property">file</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getUploadFile</span>(ctx, uploadFile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">params</span>: <span class="built_in">any</span>[] = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getRouteParams</span>(ctx, handlerArgs);</span><br><span class="line">  <span class="comment">// instance[methodName]使用methodName保存的方法名调用与路由对应的方法</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> instance[methodName](...params);</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">body</span> === <span class="literal">undefined</span> &amp;&amp; result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>使用类装饰器和方法装饰器工厂函数保存路由的路径；</li>
<li>方法装饰器除了保存路径外，还需要保存以下数据：<ol>
<li>方法装饰器根据http方法进行封装，所以还需要保存不同方法的类型；</li>
<li>方法的名字，用于后续挂载路由时，调用与路由对应的方法</li>
</ol>
</li>
<li>使用<code>reflect-metadata</code>将路径保存在构造函数或构造函数原型对象的引用下，根据metadataKey来区分不同的数据；</li>
<li>在挂载路由时只需要引入对应的Controller就可取出所存储的数据，拼接处完成的路由路径，并实例化Controller并调用对应的方法。</li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器实现参数的校验</title>
    <url>/blog/2020/04/23/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>需要用到的工具：</p>
<ul>
<li>参数装饰器：记录参数的索引，方法名；</li>
<li>tslib_1.__metadata：这是ts的内置方法用于保存方法的参数类型、方法类型以及方法返回数据的类型；</li>
<li>reflect-metadata：保存参数的数据；</li>
<li>class-validator：对类成员进行校验；</li>
<li>class-transformer：使用class-transformer的plainToClass方法将对象转化成指定类的实例。</li>
</ul>
<span id="more"></span>

<h1 id="参数装饰器保存相关元数据"><a href="#参数装饰器保存相关元数据" class="headerlink" title="参数装饰器保存相关元数据"></a>参数装饰器保存相关元数据</h1><p>参数装饰器返回返回三个参数：1.构造函数的原型对象；2.参数所属方法名；3.参数的索引。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.target: 构造函数的原型对象；</span></span><br><span class="line"><span class="comment">// 2.key: 参数所属方法名；</span></span><br><span class="line"><span class="comment">// 3.index: 参数的索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouteParamDecorator</span> = (<span class="params">paramtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">data?: <span class="built_in">any</span>, ...pipes: PipeTransform[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_ARGS_METADATA</span>, target, key) || &#123;&#125;;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(</span><br><span class="line">        <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">        <span class="title function_">assignMetadata</span>(args, paramtype, index, data, ...pipes),</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Query</span> = (<span class="params">property?: <span class="built_in">string</span>, ...pipes: PipeTransform[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">QUERY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="保存参数类型元数据"><a href="#保存参数类型元数据" class="headerlink" title="保存参数类型元数据"></a>保存参数类型元数据</h1><p>在<a href="https://github.com/isaaxite/blog/issues/279#issuecomment-617980384">参数装饰器保存相关元数据</a>分别保存了三个数据，但是为什么呢？自然是用于取出保存的某数据，而这个某数据就是参数定义的类型，比如现在有一个类<code>Foo</code>，并定义了一个<code>setInfo</code>成员方法，这个方法的参数定义了一个类型<code>NameInfo</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameInfo</span> &#123;</span><br><span class="line">  <span class="attr">ch</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">en</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeInfo</span> &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">born</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">NameInfo</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">AgeInfo</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Control</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="title class_">NameInfo</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="title class_">AgeInfo</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Put</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">  <span class="title function_">setInfo</span>(</span><br><span class="line">    <span class="meta">@Query</span>() <span class="attr">_name</span>: <span class="title class_">NameInfo</span>,</span><br><span class="line">    <span class="meta">@Query</span>() <span class="attr">_age</span>: <span class="title class_">AgeInfo</span>,</span><br><span class="line">  ): <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = _name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = _age;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>, <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setInfo</code>编译后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tslib_1.<span class="title function_">__decorate</span>([</span><br><span class="line">    index_1.<span class="title class_">Put</span>(<span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">    tslib_1.<span class="title function_">__param</span>(<span class="number">0</span>, param_dec_1.<span class="title class_">Query</span>()),</span><br><span class="line">    tslib_1.<span class="title function_">__param</span>(<span class="number">1</span>, param_dec_1.<span class="title class_">Query</span>()),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:type&quot;</span>, <span class="title class_">Function</span>),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:paramtypes&quot;</span>, [<span class="title class_">NameInfo</span>, <span class="title class_">AgeInfo</span>]),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:returntype&quot;</span>, <span class="title class_">PersonInfo</span>)</span><br><span class="line">], <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;setInfo&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>在定义的参数装饰器外，还另外多定义了三个<code>tslib_1.__metadata</code>装饰器。这个三个<code>tslib_1.__metadata</code>的定义分别是：</p>
<ul>
<li><p><code>tslib_1.__metadata(&quot;design:type&quot;, Function)</code>：存储成员方法的方法类型；</p>
</li>
<li><p><code>tslib_1.__metadata(&quot;design:paramtypes&quot;, [NameInfo, AgeInfo])</code>：方法的参数类型；</p>
</li>
<li><p><code>tslib_1.__metadata(&quot;design:returntype&quot;, PersonInfo)</code>：方法返回的类型。</p>
</li>
</ul>
<p>而这个<code>tslib_1.__metadata</code>方法相当于调用reflect-metadata库的<code>Reflect.defineMetadata</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, C.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>关于<code>tslib_1.__metadata</code>的具体实现可以参考附录中的<a href="https://github.com/isaaxite/blog/issues/279#issuecomment-617981211">tslib_1.__metadata</a>。</p>
<p>由上可知，在执行参数装饰器时，将方法的参数类型作为一个数组保存到构造函数的原型对象-&gt;参数所属方法名-&gt;metadataKey之中。</p>
<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><p>根据构造函数原型对象引用、参数所属方法名、metadata key即刚刚的<code>design:paramtypes</code>就可以拿到刚刚存储的参数类型数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">handlerArgsTypes</span>: <span class="built_in">any</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">  <span class="title class_">ReflectDefaultMetadata</span>.<span class="property">DESGIN_PARAMTYPES</span>,</span><br><span class="line">  prototype,</span><br><span class="line">  methodName,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [NameInfo, AgeInfo]</span></span><br></pre></td></tr></table></figure>

<p>然后在根据存储的参数索引即可拿到参数对应的类型。</p>
<p>有了类型信息，再加上请求是传过来的对象，就可以使用class-transformer的<code>plainToClass</code>方法将请求的参数转化成参数类型的实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">clsObj = <span class="title function_">plainToClass</span>(<span class="keyword">type</span>, param)</span><br></pre></td></tr></table></figure>

<p>有了实例，就可以使用<code>class-validator</code>的<code>validate</code>方法对请求参数进行校验。<code>class-validator</code>这个库提供了许多装饰器可以对类实例的成员进行校验，比如<code>@isInt</code>可以校验可以校验整型数据，<code>@isString</code>可以校验字符类型的数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IsInt</span>, <span class="title class_">IsString</span>, validate&#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeInfo</span> &#123;</span><br><span class="line">  <span class="meta">@IsInt</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;$property必须是整型&#x27;</span> &#125;)</span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  <span class="attr">born</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errors = <span class="keyword">await</span> <span class="title function_">validate</span>(clsObj);</span><br></pre></td></tr></table></figure>


<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="tslib-1-metadata"><a href="#tslib-1-metadata" class="headerlink" title="tslib_1.__metadata"></a>tslib_1.__metadata</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tslib_1.__metadata(&quot;design:paramtypes&quot;, [NameInfo, AgeInfo])</span></span><br><span class="line">__metadata = <span class="keyword">function</span> (<span class="params">metadataKey, metadataValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&quot;object&quot;</span></span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Reflect</span>.<span class="property">metadata</span> === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.metadata的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">metadata</span>(<span class="params">metadataKey, metadataValue</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params">target, propertyKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">IsObject</span>(target))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">IsUndefined</span>(propertyKey) &amp;&amp; !<span class="title class_">IsPropertyKey</span>(propertyKey))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    <span class="title class_">OrdinaryDefineOwnMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> decorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.defineMetadata的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineMetadata</span>(<span class="params">metadataKey, metadataValue, target, propertyKey</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">IsObject</span>(target))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">IsUndefined</span>(propertyKey))</span><br><span class="line">    propertyKey = <span class="title class_">ToPropertyKey</span>(propertyKey);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">OrdinaryDefineOwnMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="decorate"><a href="#decorate" class="headerlink" title="__decorate"></a>__decorate</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__decorate = <span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="variable language_">arguments</span>.<span class="property">length</span>, </span><br><span class="line">      r = c &lt; <span class="number">3</span> </span><br><span class="line">        ? target </span><br><span class="line">        : desc === <span class="literal">null</span> </span><br><span class="line">          ? desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key)</span><br><span class="line">          : desc,</span><br><span class="line">      d;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&quot;object&quot;</span> </span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Reflect</span>.<span class="property">decorate</span> === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    r = <span class="title class_">Reflect</span>.<span class="title function_">decorate</span>(decorators, target, key, desc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d = decorators[i]) &#123;</span><br><span class="line">        r = (</span><br><span class="line">          c &lt; <span class="number">3</span></span><br><span class="line">            ? <span class="title function_">d</span>(r)</span><br><span class="line">            : c &gt; <span class="number">3</span> </span><br><span class="line">              ? <span class="title function_">d</span>(target, key, r) </span><br><span class="line">              : <span class="title function_">d</span>(target, key)</span><br><span class="line">        ) || r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, r), r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>ElementUI源码分析-Scrolllbar组件</title>
    <url>/blog/2020/04/20/ElementUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Scrolllbar%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>scrollbar组件可以通过设置native属性，是否使用自定义的scrollbar视图，默认为<code>undefined</code>即使用自定义的，下面也是主要分析自定义scrollbar的构成。</p>
<span id="more"></span>

<p>scrollbar视图的html代码由来年两层元素构成：</p>
<ol>
<li>第一层：<code>el-scrollbar</code>，样式设为<code>overflow: hidden</code>主要用于隐藏原生scrollbar；</li>
<li>第二层：<code>el-scrollbar__wrap</code>，用于存放内容的真实视图。<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nodes = ([</span><br><span class="line">  wrap,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  	<span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveX</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeWidth</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span>,</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">vertical</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveY</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeHeight</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="scrollbar的主要逻辑"><a href="#scrollbar的主要逻辑" class="headerlink" title="scrollbar的主要逻辑"></a>scrollbar的主要逻辑</h3><p><img src="/blog/2020/04/20/ElementUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Scrolllbar%E7%BB%84%E4%BB%B6/image-20200420222553641.png"></p>
<h3 id="1-计算浏览器scrollbar默认宽度"><a href="#1-计算浏览器scrollbar默认宽度" class="headerlink" title="1,计算浏览器scrollbar默认宽度"></a>1,计算浏览器scrollbar默认宽度</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 通过离线创建一个容器，计算浏览器默认的scrollbar宽度</span><br><span class="line"><span class="comment">// 计算这个默认宽度是为了当出现默认scrollbar的时候隐藏掉</span></span><br><span class="line"><span class="keyword">let</span> gutter = <span class="title function_">scrollbarWidth</span>();</span><br></pre></td></tr></table></figure>

<p>计算方式是离线创建一个容器，并使之产生scrollbar，根据产生scrollbar前后容器的宽度计算宽度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scrollBarWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$isServer</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 使用缓存</span></span><br><span class="line">  <span class="keyword">if</span> (scrollBarWidth !== <span class="literal">undefined</span>) <span class="keyword">return</span> scrollBarWidth;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 外层</span></span><br><span class="line">  <span class="keyword">const</span> outer = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  outer.<span class="property">className</span> = <span class="string">&#x27;el-scrollbar__wrap&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;-9999px&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(outer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录产生scrollbar前的视图宽度</span></span><br><span class="line">  <span class="keyword">const</span> widthNoScroll = outer.<span class="property">offsetWidth</span>;</span><br><span class="line">  <span class="comment">// 强制显示scrollbar</span></span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;scroll&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inner = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  inner.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  outer.<span class="title function_">appendChild</span>(inner);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录产生scrollbar后的视图宽度</span></span><br><span class="line">  <span class="keyword">const</span> widthWithScroll = inner.<span class="property">offsetWidth</span>;</span><br><span class="line">  outer.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(outer);</span><br><span class="line">  scrollBarWidth = widthNoScroll - widthWithScroll;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scrollBarWidth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-撑大el-scrollbar-wrap容器隐藏原生scrollbar"><a href="#2-撑大el-scrollbar-wrap容器隐藏原生scrollbar" class="headerlink" title="2.撑大el-scrollbar__wrap容器隐藏原生scrollbar"></a>2.撑大<code>el-scrollbar__wrap</code>容器隐藏原生scrollbar</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (gutter) &#123;</span><br><span class="line">  <span class="keyword">const</span> gutterWith = <span class="string">`-<span class="subst">$&#123;gutter&#125;</span>px`</span>;</span><br><span class="line">  <span class="keyword">const</span> gutterStyle = <span class="string">`margin-bottom: <span class="subst">$&#123;gutterWith&#125;</span>; margin-right: <span class="subst">$&#123;gutterWith&#125;</span>;`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">wrapStyle</span>)) &#123;</span><br><span class="line">    style = <span class="title function_">toObject</span>(<span class="variable language_">this</span>.<span class="property">wrapStyle</span>);</span><br><span class="line">    style.<span class="property">marginRight</span> = style.<span class="property">marginBottom</span> = gutterWith;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">wrapStyle</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    style += gutterStyle;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    style = gutterStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-添加自定义滑块模拟原生scrollbar"><a href="#3-添加自定义滑块模拟原生scrollbar" class="headerlink" title="3.添加自定义滑块模拟原生scrollbar"></a>3.添加自定义滑块模拟原生scrollbar</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nodes = ([</span><br><span class="line">  wrap,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveX</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeWidth</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span>,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">vertical</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveY</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeHeight</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="4-注册scrollbar事件"><a href="#4-注册scrollbar事件" class="headerlink" title="4.注册scrollbar事件"></a>4.注册scrollbar事件</h3><p>主要用于更新自定义bar的偏移位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrap = <span class="variable language_">this</span>.<span class="property">wrap</span>;</span><br><span class="line">  <span class="comment">// 纵向偏移比例 = 内容纵向偏移量 / 视图高度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">moveY</span> = ((wrap.<span class="property">scrollTop</span> * <span class="number">100</span>) / wrap.<span class="property">clientHeight</span>);</span><br><span class="line">  <span class="comment">// 横向偏移比例 = 内容横向偏移量 / 视图宽度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">moveX</span> = ((wrap.<span class="property">scrollLeft</span> * <span class="number">100</span>) / wrap.<span class="property">clientWidth</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-注册resize事件以及初始化滑块宽度"><a href="#5-注册resize事件以及初始化滑块宽度" class="headerlink" title="5.注册resize事件以及初始化滑块宽度"></a>5.注册resize事件以及初始化滑块宽度</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> heightPercentage, widthPercentage;</span><br><span class="line">    <span class="keyword">const</span> wrap = <span class="variable language_">this</span>.<span class="property">wrap</span>;</span><br><span class="line">    <span class="keyword">if</span> (!wrap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纵轴滑块的高度 = 元素高度 / 元素内容视图高度</span></span><br><span class="line">    heightPercentage = (wrap.<span class="property">clientHeight</span> * <span class="number">100</span> / wrap.<span class="property">scrollHeight</span>);</span><br><span class="line">    <span class="comment">// 纵轴滑块的高度 = 元素宽度 / 元素内容视图宽度</span></span><br><span class="line">    widthPercentage = (wrap.<span class="property">clientWidth</span> * <span class="number">100</span> / wrap.<span class="property">scrollWidth</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sizeHeight</span> = (heightPercentage &lt; <span class="number">100</span>) ? (heightPercentage + <span class="string">&#x27;%&#x27;</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sizeWidth</span> = (widthPercentage &lt; <span class="number">100</span>) ? (widthPercentage + <span class="string">&#x27;%&#x27;</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">native</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 初始化scrollbar的宽度</span></span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="variable language_">this</span>.<span class="property">update</span>);</span><br><span class="line">  <span class="comment">// 注册resize事件，用于之后更新scrollbar的宽度</span></span><br><span class="line">  !<span class="variable language_">this</span>.<span class="property">noresize</span> &amp;&amp; <span class="title function_">addResizeListener</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">resize</span>, <span class="variable language_">this</span>.<span class="property">update</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h2 id="bar组件"><a href="#bar组件" class="headerlink" title="bar组件"></a>bar组件</h2><p>bar组件是对原生滑块的模拟，滑块由滑块容器以及滑块本身组成！</p>
<p>bar组件负责的主要功能是：计算滑块的偏移距离与滑块容器高度的比例，以次比例计算Scrill-view的偏移值。</p>
<p>实现的交互功能分别有两个：</p>
<ol>
<li>点击滑块容器，移动scroll-view内容，通过给滑块容器绑定<code>mousedown</code>事件触发；</li>
<li>拖动滑块使移动scroll-view内容，通过绑定三个事件实现：<code>mousedown</code>、<code>mousemove``mouseup</code>。</li>
</ol>
<p>注意：</p>
<ol>
<li>bar组建的滑块自身的偏移不是由bar组建自身直接改变，而是根据根据传入的两个props属性绑定到滑块的style上实现的；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">	<span class="attr">vertical</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">	<span class="attr">size</span>: <span class="title class_">String</span>,	<span class="comment">// 滑块的长度</span></span><br><span class="line">	<span class="attr">move</span>: <span class="title class_">Number</span>	<span class="comment">// 话快的偏移值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>滑块的偏移有css3的<code>tansfrom: translate()</code>实现<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderThumbStyle</span>(<span class="params">&#123; move, size, bar &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> translate = <span class="string">`translate<span class="subst">$&#123;bar.axis&#125;</span>(<span class="subst">$&#123; move &#125;</span>%)`</span>;</span><br><span class="line"></span><br><span class="line">  style[bar.<span class="property">size</span>] = size;</span><br><span class="line">  style.<span class="property">transform</span> = translate;</span><br><span class="line">  style.<span class="property">msTransform</span> = translate;</span><br><span class="line">  style.<span class="property">webkitTransform</span> = translate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">&#123;</span> [&#x27;<span class="attr">el-scrollbar__bar</span>&#x27;, &#x27;<span class="attr">is-</span>&#x27; + <span class="attr">bar.key</span>] &#125;</span></span><br><span class="line"><span class="tag">     <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickTrackHandler</span> &#125; &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">       <span class="attr">ref</span>=<span class="string">&quot;thumb&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">&quot;el-scrollbar__thumb&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickThumbHandler</span> &#125;</span></span><br><span class="line"><span class="tag">       <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">renderThumbStyle</span>(&#123; <span class="attr">size</span>, <span class="attr">move</span>, <span class="attr">bar</span> &#125;) &#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由滑块容器<code>el-scrollbar__bar</code>和滑块<code>el-scrollbar__thumb</code>组成。</p>
<h3 id="点击容器移动滑块"><a href="#点击容器移动滑块" class="headerlink" title="点击容器移动滑块"></a>点击容器移动滑块</h3><p>容器元素监听<code>onMousedown</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击滑块容器，移动父元素的内容移动`$parent.wrap`的scrollTop/scrollLeft</span></span><br><span class="line"><span class="title function_">clickTrackHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.target.getBoundingClientRect()：获取元素大小与位置信息，返回一个DOMRect对象</span></span><br><span class="line">  <span class="comment">// x: 390 // 左边距离视窗左边距离</span></span><br><span class="line">  <span class="comment">// y: 91  // 上边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// width: 240 // 元素宽度</span></span><br><span class="line">  <span class="comment">// height: 26 // 元素高度</span></span><br><span class="line">  <span class="comment">// top: 91  // 上边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// right: 630 // 右边距离视窗左边距离</span></span><br><span class="line">  <span class="comment">// bottom: 117  // 低边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// left: 390  // 左边距离视窗左边距离</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以纵向滚轴为例子</span></span><br><span class="line">  <span class="comment">// offset：计算点击位置在元素矩形内纵向的偏移数值</span></span><br><span class="line">  <span class="keyword">const</span> offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(e.<span class="property">target</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]);   <span class="comment">// e[this.bar.client]点击的横纵/坐标值</span></span><br><span class="line">  <span class="comment">// thumbHalf：滑块高度的一半</span></span><br><span class="line">  <span class="keyword">const</span> thumbHalf = (<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> thumbPositionPercentage = ((offset - thumbHalf) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this.wrap: this.$parent.wrap</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拖动滑块移动父容器内容"><a href="#拖动滑块移动父容器内容" class="headerlink" title="拖动滑块移动父容器内容"></a>拖动滑块移动父容器内容</h3><p>涉及到三个事件的监听：</p>
<ol>
<li><code>onMousedown</code>事件：负责触发事件；</li>
<li><code>mousemove</code>事件：负责计算滑块移动距离与容器高度的比例，以此更新父容器的scrollTop</li>
<li><code>mouseup</code>事件：负责移除<code>mousemove</code>事件的监听和整个功能结束的收尾。</li>
</ol>
<h4 id="点击触发，动态绑定mousemove和mouseup事件"><a href="#点击触发，动态绑定mousemove和mouseup事件" class="headerlink" title="点击触发，动态绑定mousemove和mouseup事件"></a>点击触发，动态绑定mousemove和mouseup事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clickThumbHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.ctrlKey </span></span><br><span class="line">  <span class="comment">// 鼠标事件ctrlKey是只读属性，可返回一个布尔值，当ctrl键被按下，返回true，否则返回false</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// e.button:</span></span><br><span class="line">  <span class="comment">// 0：主按键被按下，通常指鼠标左键 or the un-initialized state</span></span><br><span class="line">  <span class="comment">// 1：辅助按键被按下，通常指鼠标滚轮 or the middle button (if present)</span></span><br><span class="line">  <span class="comment">// 2：次按键被按下，通常指鼠标右键</span></span><br><span class="line">  <span class="comment">// 3：第四个按钮被按下，通常指浏览器后退按钮</span></span><br><span class="line">  <span class="comment">// 4：第五个按钮被按下，通常指浏览器的前进按钮</span></span><br><span class="line">  <span class="comment">// prevent click event of right button</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">ctrlKey</span> || e.<span class="property">button</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">startDrag</span>(e);</span><br><span class="line">  <span class="comment">// 点击位置距离滑块下边的距离</span></span><br><span class="line">  <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = (e.<span class="property">currentTarget</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - (</span><br><span class="line">    <span class="comment">// 1.点击位置的纵坐标：e[this.bar.client]</span></span><br><span class="line">    <span class="comment">// 2.滑块元素上边的纵坐标：e.currentTarget.getBoundingClientRect()[this.bar.direction])</span></span><br><span class="line">    <span class="comment">// 点击位置到滑块上边的高度 = 1 - 2</span></span><br><span class="line">    e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>] - e.<span class="property">currentTarget</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>])</span><br><span class="line">                        );</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">startDrag</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// addEventListener监听mousemove事件</span></span><br><span class="line">  <span class="comment">// addEventListener监听mouseup事件</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">  <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="动态计算父容器内容的偏移"><a href="#动态计算父容器内容的偏移" class="headerlink" title="动态计算父容器内容的偏移"></a>动态计算父容器内容的偏移</h4><p>此时鼠标右键已经被按下且未放开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动鼠标，同步移动父元素容器的内容</span></span><br><span class="line"><span class="title function_">mouseMoveDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cursorDown</span> === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> prevPage = <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevPage) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// offset：点击位置到滑块容器顶部的距离</span></span><br><span class="line">  <span class="keyword">const</span> offset = ((</span><br><span class="line">    <span class="comment">// 1.滑块容器上边距离视窗上边距离：this.$el.getBoundingClientRect()[this.bar.direction]</span></span><br><span class="line">    <span class="comment">// 2.当前点击的纵轴坐标</span></span><br><span class="line">    <span class="comment">// 点击位置距离容器上边的长度 = 1 - 2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]</span><br><span class="line">  ) * -<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 点击位置距离滑块上边的距离</span></span><br><span class="line">  <span class="keyword">const</span> thumbClickPosition = (</span><br><span class="line">    <span class="comment">// 1.this.$refs.thumb[this.bar.offset]：滑块高度</span></span><br><span class="line">    <span class="comment">// 2.prevPage：点击位置距离下边的距离</span></span><br><span class="line">    <span class="comment">// 点击位置距离滑块上边的距离 = 1 - 2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - prevPage</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 计算“滑块上边到容器上边距离”占容器高度的百分比</span></span><br><span class="line">  <span class="keyword">const</span> thumbPositionPercentage = ((</span><br><span class="line">    <span class="comment">// 计算滑块上边到容器上边的距离</span></span><br><span class="line">    offset - thumbClickPosition</span><br><span class="line">  ) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;计算滑块上边到容器上边的距离&#x27;</span>: offset - thumbClickPosition,</span><br><span class="line">  <span class="string">&#x27;容器的高度&#x27;</span>: <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过thumbPositionPercentage计算夫容器移动的距离</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="结束滑块移动"><a href="#结束滑块移动" class="headerlink" title="结束滑块移动"></a>结束滑块移动</h4><p>鼠标右键放开，结束事件重置基本变量，解绑mousemove事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mouseUpDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件生命周期结束解绑mouseup事件"><a href="#组件生命周期结束解绑mouseup事件" class="headerlink" title="组件生命周期结束解绑mouseup事件"></a>组件生命周期结束解绑mouseup事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="bar源码注释"><a href="#bar源码注释" class="headerlink" title="bar源码注释"></a>bar源码注释</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; on, off &#125; <span class="keyword">from</span> <span class="string">&#x27;zhuiyi-ui/src/utils/dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderThumbStyle, <span class="variable constant_">BAR_MAP</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="comment">// 滑块的长度</span></span><br><span class="line">    <span class="attr">size</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="comment">// 滑块的偏移量</span></span><br><span class="line">    <span class="attr">move</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">BAR_MAP</span>[<span class="variable language_">this</span>.<span class="property">vertical</span> ? <span class="string">&#x27;vertical&#x27;</span> : <span class="string">&#x27;horizontal&#x27;</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">wrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">wrap</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size, move, bar &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">class</span>=<span class="string">&#123;</span> [&#x27;<span class="attr">el-scrollbar__bar</span>&#x27;, &#x27;<span class="attr">is-</span>&#x27; + <span class="attr">bar.key</span>] &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickTrackHandler</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&quot;thumb&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">class</span>=<span class="string">&quot;el-scrollbar__thumb&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickThumbHandler</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">renderThumbStyle</span>(&#123; <span class="attr">size</span>, <span class="attr">move</span>, <span class="attr">bar</span> &#125;) &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">clickThumbHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// e.ctrlKey </span></span><br><span class="line">      <span class="comment">// 鼠标事件ctrlKey是只读属性，可返回一个布尔值，当ctrl键被按下，返回true，否则返回false</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="comment">// e.button:</span></span><br><span class="line">      <span class="comment">// 0：主按键被按下，通常指鼠标左键 or the un-initialized state</span></span><br><span class="line">      <span class="comment">// 1：辅助按键被按下，通常指鼠标滚轮 or the middle button (if present)</span></span><br><span class="line">      <span class="comment">// 2：次按键被按下，通常指鼠标右键</span></span><br><span class="line">      <span class="comment">// 3：第四个按钮被按下，通常指浏览器后退按钮</span></span><br><span class="line">      <span class="comment">// 4：第五个按钮被按下，通常指浏览器的前进按钮</span></span><br><span class="line">      <span class="comment">// prevent click event of right button</span></span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">ctrlKey</span> || e.<span class="property">button</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">startDrag</span>(e);</span><br><span class="line">      <span class="comment">// 点击位置距离滑块下边的距离</span></span><br><span class="line">      <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = (e.<span class="property">currentTarget</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - (</span><br><span class="line">        <span class="comment">// 1.点击位置的纵坐标：e[this.bar.client]</span></span><br><span class="line">        <span class="comment">// 2.滑块元素上边的纵坐标：e.currentTarget.getBoundingClientRect()[this.bar.direction])</span></span><br><span class="line">        <span class="comment">// 点击位置到滑块上边的高度 = 1 - 2</span></span><br><span class="line">        e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>] - e.<span class="property">currentTarget</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>])</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击滑块容器，移动父元素容器的内容（scrollTop/scrollLeft）</span></span><br><span class="line">    <span class="title function_">clickTrackHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// e.target.getBoundingClientRect()：获取元素大小与位置信息，返回一个DOMRect对象</span></span><br><span class="line">      <span class="comment">// x: 390 // 左边距离视窗左边距离</span></span><br><span class="line">      <span class="comment">// y: 91  // 上边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// width: 240 // 元素宽度</span></span><br><span class="line">      <span class="comment">// height: 26 // 元素高度</span></span><br><span class="line">      <span class="comment">// top: 91  // 上边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// right: 630 // 右边距离视窗左边距离</span></span><br><span class="line">      <span class="comment">// bottom: 117  // 低边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// left: 390  // 左边距离视窗左边距离</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以纵向滚轴为例子</span></span><br><span class="line">      <span class="comment">// offset：计算点击位置在元素矩形内纵向的偏移数值</span></span><br><span class="line">      <span class="keyword">const</span> offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(e.<span class="property">target</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]);   <span class="comment">// e[this.bar.client]点击的横纵/坐标值</span></span><br><span class="line">      <span class="comment">// thumbHalf：滑块高度的一半</span></span><br><span class="line">      <span class="keyword">const</span> thumbHalf = (<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> thumbPositionPercentage = ((offset - thumbHalf) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">startDrag</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// addEventListener监听mousemove事件</span></span><br><span class="line">      <span class="comment">// addEventListener监听mouseup事件dsfsdf sdfsdfsdfsdfsdfdsfds</span></span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动鼠标，同步移动父元素容器的内容</span></span><br><span class="line">    <span class="title function_">mouseMoveDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cursorDown</span> === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> prevPage = <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prevPage) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// offset：点击位置到滑块容器顶部的距离</span></span><br><span class="line">      <span class="keyword">const</span> offset = ((</span><br><span class="line">        <span class="comment">// 1.滑块容器上边距离视窗上边距离：this.$el.getBoundingClientRect()[this.bar.direction]</span></span><br><span class="line">        <span class="comment">// 2.当前点击的纵轴坐标</span></span><br><span class="line">        <span class="comment">// 点击位置距离容器上边的长度 = 1 - 2</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]</span><br><span class="line">      ) * -<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 点击位置距离滑块上边的距离</span></span><br><span class="line">      <span class="keyword">const</span> thumbClickPosition = (</span><br><span class="line">        <span class="comment">// 1.this.$refs.thumb[this.bar.offset]：滑块高度</span></span><br><span class="line">        <span class="comment">// 2.prevPage：点击位置距离下边的距离</span></span><br><span class="line">        <span class="comment">// 点击位置距离滑块上边的距离 = 1 - 2</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - prevPage</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 计算“滑块上边到容器上边距离”占容器高度的百分比</span></span><br><span class="line">      <span class="keyword">const</span> thumbPositionPercentage = (</span><br><span class="line">        (</span><br><span class="line">          <span class="comment">// 计算滑块上边到容器上边的距离</span></span><br><span class="line">          offset - thumbClickPosition</span><br><span class="line">        ) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">      );</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;计算滑块上边到容器上边的距离&#x27;</span>: offset - thumbClickPosition,</span><br><span class="line">        <span class="string">&#x27;容器的高度&#x27;</span>: <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过thumbPositionPercentage计算夫容器移动的距离</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mouseUpDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Element-UI</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题61. 扑克牌中的顺子</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9861.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [1,2,3,4,5]<br>输出: True
 </p>
<p>示例 2:</p>
<p>输入: [0,0,1,2,5]<br>输出: True
 </p>
<p>限制：</p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p>
<h2 id="1-找最大最小值"><a href="#1-找最大最小值" class="headerlink" title="1.找最大最小值"></a>1.找最大最小值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.连续序列的特点：max - min + 1 = 序列长度，由于0可以变化，所以max - min + 1 &lt;- 序列长度</span></span><br><span class="line"><span class="comment"> * 2.如果存在重复，则不是顺子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isStraight = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">14</span></span><br><span class="line">  <span class="keyword">let</span> max = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> repeated = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums[i]) <span class="keyword">continue</span>; </span><br><span class="line">    min = <span class="title class_">Math</span>.<span class="title function_">min</span>(min, nums[i]);</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (!repeated.<span class="title function_">includes</span>(nums[i])) &#123;</span><br><span class="line">      repeated.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max - min + <span class="number">1</span> &gt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>46. 全排列</title>
    <url>/blog/2020/04/17/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: [1,2,3]<br>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></p>
<h2 id="1-深度优先（比较隐含的回溯）"><a href="#1-深度优先（比较隐含的回溯）" class="headerlink" title="1.深度优先（比较隐含的回溯）"></a>1.深度优先（比较隐含的回溯）</h2><p>由于传入下一层调用栈的参数都是新值，不会影响当前栈所以不用显式地回溯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(nums, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">nums, visited</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      visited.<span class="title function_">push</span>(nums[<span class="number">0</span>]);</span><br><span class="line">      res.<span class="title function_">push</span>(visited);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>([...nums.<span class="title function_">slice</span>(<span class="number">0</span>, i), ...nums.<span class="title function_">slice</span>(i + <span class="number">1</span>)], [nums[i], ...visited]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-显式的回溯"><a href="#2-显式的回溯" class="headerlink" title="2.显式的回溯"></a>2.显式的回溯</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(nums, [], &#123;&#125;, res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">nums, path, visited, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(path.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">        <span class="title function_">dfs</span>(nums, path, visited, res);</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">        path.<span class="title function_">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题47. 礼物的最大价值</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9847.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 </p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt; grid.length &lt;= 200</span><br><span class="line">0 &lt; grid[0].length &lt;= 200</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<h2 id="1-深度优先遍历（超时）"><a href="#1-深度优先遍历（超时）" class="headerlink" title="1.深度优先遍历（超时）"></a>1.深度优先遍历（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxValue1 = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> n = grid[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j, count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; m || j &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    count += grid[i][j];</span><br><span class="line">    <span class="keyword">if</span> (i === m &amp;&amp; j === n) &#123;</span><br><span class="line">      res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, count);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// to right</span></span><br><span class="line">    <span class="title function_">dfs</span>(grid, i, j + <span class="number">1</span>, count);</span><br><span class="line">    <span class="comment">// to bottom</span></span><br><span class="line">    <span class="title function_">dfs</span>(grid, i + <span class="number">1</span>, j, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i][j]：到达(i,j)位置的最大价值</span></span><br><span class="line"><span class="comment"> * 最优子结构：</span></span><br><span class="line"><span class="comment"> * 1.从上方移动一步到达，dp[i][j-1] + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 2.从左边移动一步到达，dp[i-1][j] + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]) + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 边界：dp[0][0] = grid[0][0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxValue2 = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> n = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>();</span><br><span class="line">  dp = dp.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub1 = i &lt; <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">const</span> sub2 = j &lt; <span class="number">1</span> ? <span class="number">0</span> :dp[i][j-<span class="number">1</span>];</span><br><span class="line">      dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(sub1, sub2) + grid[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题19. 正则表达式匹配</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9819-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:</p>
<p>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。<br>示例 4:</p>
<p>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:</p>
<p>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p>
<h2 id="1-暴力递归进行穷举"><a href="#1-暴力递归进行穷举" class="headerlink" title="1.暴力递归进行穷举"></a>1.暴力递归进行穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isMatchIt</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> s === <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> subMatch = s &amp;&amp; [s[<span class="number">0</span>], <span class="string">&#x27;.&#x27;</span>].<span class="title function_">includes</span>(p[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// *是需要和前面一个字符结合使用，即至少p的长度是2</span></span><br><span class="line">  <span class="keyword">if</span> (p.<span class="property">length</span> &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 匹配0次: isMatch(s, p.slice(2))，可以忽略s[0] !== p[0]，既然匹配0次，即可以跳过“p[0]*”的匹配</span></span><br><span class="line">    <span class="comment">// 2. 匹配多次，匹配多次的前提是[p[0], &#x27;.&#x27;].includes(s[0])</span></span><br><span class="line">    <span class="comment">// 2.1 通过后移s，而不动p，然后下一个s可以持续匹配&quot;p[0]*&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isMatch</span>(s, p.<span class="title function_">slice</span>(<span class="number">2</span>)) || subMatch &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subMatch &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p.<span class="title function_">slice</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-备忘录优化暴力法"><a href="#2-备忘录优化暴力法" class="headerlink" title="2.备忘录优化暴力法"></a>2.备忘录优化暴力法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isMatchByMemo</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sLen = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> pLen = p.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> meno = &#123;&#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dp</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">    <span class="comment">// [i, sLen)</span></span><br><span class="line">    <span class="comment">// [j, pLen)</span></span><br><span class="line">    <span class="keyword">const</span> key = [i, j].<span class="title function_">join</span>();</span><br><span class="line">    <span class="keyword">const</span> sRestLen = sLen - i;</span><br><span class="line">    <span class="keyword">const</span> pRestLen = pLen - j;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> meno[key] !== <span class="string">&#x27;undefined&#x27;</span>) <span class="keyword">return</span> meno[key];</span><br><span class="line">    <span class="keyword">if</span> (pRestLen &lt; <span class="number">1</span>) <span class="keyword">return</span> sRestLen &lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> isMatch = sRestLen &gt; <span class="number">0</span> &amp;&amp; (s[i] === p[j] || p[j] === <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pRestLen &gt; <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// j: p[j], j + 1: *</span></span><br><span class="line">      isMatch = <span class="title function_">dp</span>(i, j + <span class="number">2</span>) || isMatch &amp;&amp; <span class="title function_">dp</span>(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isMatch = isMatch &amp;&amp; <span class="title function_">dp</span>(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    meno[key] = isMatch;</span><br><span class="line">    <span class="keyword">return</span> isMatch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dp</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题29. 顺时针打印矩阵</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; matrix.length &lt;&#x3D; 100<br>0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100<br>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
<h2 id="1-缩小边界直到越界"><a href="#1-缩小边界直到越界" class="headerlink" title="1.缩小边界直到越界"></a>1.缩小边界直到越界</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *  [1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"> *  [5, 6, 7, 8],</span></span><br><span class="line"><span class="comment"> *  [9,10,11,12]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *  [(0,0), (0,1), (0,2), (0,3)],</span></span><br><span class="line"><span class="comment"> *  [(1,0), (1,1), (1,2), (1,3)],</span></span><br><span class="line"><span class="comment"> *  [(2,0), (2,1), (2,2), (2,3)],</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * 0.定义边界top, right, bottom, left. [top, bottom], [left, right]</span></span><br><span class="line"><span class="comment"> * 1.顺时针打印边界元素，每打印完一条边，将这条边的位置向中心步进1</span></span><br><span class="line"><span class="comment"> * 2.直到越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!matrix.<span class="property">length</span>) <span class="keyword">return</span> []; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历上边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[top][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[i][right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; --right) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历下边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; --bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历左边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[i][left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题31. 栈的压入、弹出序列</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9831-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。<br>注意：本题与主站 946 题相同：<a href="https://leetcode-cn.com/problems/validate-stack-sequences/">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
<h2 id="使用真实stack模拟"><a href="#使用真实stack模拟" class="headerlink" title="使用真实stack模拟"></a>使用真实stack模拟</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用真实stack模拟</span></span><br><span class="line"><span class="comment"> * 0.定义辅助栈stack</span></span><br><span class="line"><span class="comment"> * 1.持续按照pushed的顺序入栈stack，直到stack的栈顶元素与poped的栈底元素相同，</span></span><br><span class="line"><span class="comment"> * 2.则按照poped顺序出栈stack直到stack的栈顶元素不再与poped的栈低元素相同，然后重复1-&gt;2之道pushed的元素使用完</span></span><br><span class="line"><span class="comment"> * 3.如果poped不为空，则stack按照poped继续出栈，直到poped使用完返回true，否则返回false；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">pushed</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">popped</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = validateStackSequences2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateStackSequences1</span>(<span class="params">pushed, popped</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (pushed.<span class="property">length</span> || popped.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === popped[<span class="number">0</span>]) &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      popped.<span class="title function_">shift</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pushed.<span class="property">length</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(pushed.<span class="title function_">shift</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pushed.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== popped[<span class="number">0</span>]) &#123;</span><br><span class="line">      isValid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateStackSequences2</span>(<span class="params">pushed, popped</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;  <span class="comment">// pushed idx</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;  <span class="comment">// poped idx</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; pushed.<span class="property">length</span> || j &lt; popped.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === popped[j]) &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pushed.<span class="property">length</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(pushed[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= pushed.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== popped[j]) &#123;</span><br><span class="line">      isValid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题37. 序列化二叉树</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9837-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<span id="more"></span>

<p>示例: </p>
<p>你可以将以下二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>

<p>序列化为 “[1,2,3,null,null,4,5]”<br>注意：本题与主站 297 题相同：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p>
<h2 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h2><p>关键：</p>
<ol>
<li>将遍历的序列转化为字符串；</li>
<li>保留空子节点（可以保存为‘null’），作为标识符来反序列化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">preOrder</span>(root);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> res.<span class="title function_">push</span>(<span class="string">&#x27;null&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">join</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = data.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = arr.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="string">&#x27;null&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    node.<span class="property">left</span> = <span class="title function_">buildTree</span>(arr);</span><br><span class="line">    node.<span class="property">right</span> = <span class="title function_">buildTree</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">buildTree</span>(arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your functions will be called as such:</span></span><br><span class="line"><span class="comment"> * deserialize(serialize(root));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题38. 字符串的排列</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9838-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入：s &#x3D; “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
<h2 id="1-暴力穷举"><a href="#1-暴力穷举" class="headerlink" title="1.暴力穷举"></a>1.暴力穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(s, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">restStr, recordStr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!restStr.<span class="property">length</span> &amp;&amp; !res.<span class="title function_">includes</span>(recordStr)) res.<span class="title function_">push</span>(recordStr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; restStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> newRest = restStr.<span class="title function_">slice</span>(<span class="number">0</span>, i) + restStr.<span class="title function_">slice</span>(i + <span class="number">1</span>);</span><br><span class="line">      <span class="title function_">dfs</span>(newRest, recordStr + restStr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题39. 数组中出现次数超过一半的数字</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9839-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
 </p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p>
<p> </p>
<p>注意：本题与主站 169 题相同：<a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a></p>
<h2 id="1-Hash去重与计数"><a href="#1-Hash去重与计数" class="headerlink" title="1.Hash去重与计数"></a>1.Hash去重与计数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash去重与计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> halfLen = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[num]) &#123;</span><br><span class="line">      obj[num]++;</span><br><span class="line">      <span class="keyword">if</span> (obj[num] &gt; halfLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[num] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[num] &gt; halfLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题41. 数据流中的中位数</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9841-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<span id="more"></span>

<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p>
<p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：</p>
<p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]
 </p>
<p>限制：</p>
<p>最多会对 addNum、findMedia进行 50000 次调用。<br>注意：本题与主站 295 题相同：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p>
<h2 id="1-二分查找找插入位置"><a href="#1-二分查找找插入位置" class="headerlink" title="1.二分查找找插入位置"></a>1.二分查找找插入位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MedianFinder</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_stack</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addNum</span> = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="title function_">push</span>(num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// [left, right)</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> midIdx = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="variable language_">this</span>.<span class="property">_stack</span>[midIdx]) &#123;</span><br><span class="line">      right = midIdx;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="variable language_">this</span>.<span class="property">_stack</span>[midIdx]) &#123;</span><br><span class="line">      right = midIdx;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = midIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="title function_">splice</span>(right, <span class="number">0</span>, num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">findMedian</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &amp; <span class="number">1</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_stack</span>[(len - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> right = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">_stack</span>[right-<span class="number">1</span>] + <span class="variable language_">this</span>.<span class="property">_stack</span>[right]) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MedianFinder()</span></span><br><span class="line"><span class="comment"> * obj.addNum(num)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.findMedian()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题48. 最长不含重复字符的子字符串</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9848-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。
 </p>
<p>提示：</p>
<p>s.length &lt;&#x3D; 40000<br>注意：本题与主站 3 题相同：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1.滑动窗口"></a>1.滑动窗口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable language_">window</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = s[idx];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="title function_">includes</span>(char) &amp;&amp; idx &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span> += char;</span><br><span class="line">      idx++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, <span class="variable language_">window</span>.<span class="property">length</span>);</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= s.<span class="property">length</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="variable language_">window</span> = <span class="variable language_">window</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题49. 丑数</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9849.%20%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: n &#x3D; 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p>
<p>1 是丑数。<br>n 不超过1690。<br>注意：本题与主站 264 题相同：<a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p>
<p>通过次数7,052提交次数11,250</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * dp[i]: 第i个丑数</span></span><br><span class="line"><span class="comment"> * 最优子结构: 左前最靠近i的因子为2的丑数dp[a], 左前最靠近i的因子为3的丑数dp[b]，左前最靠近i的因子为5的丑数dp[c]</span></span><br><span class="line"><span class="comment"> * dp[i]是丑数，所以肯定是dp[c] * 2或dp[b] * 2或dp[c] * 5得到，当前是要找下一个丑数，所以肯定是取前三者最小之一</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i] = Math.min(dp[i-1] * 2, dp[i-1] * 3. dp[i-1] * 5)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ugly1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> ugly2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> ugly3 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (count &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp1 = dp[ugly1] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp2 = dp[ugly2] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp3 = dp[ugly3] * <span class="number">5</span>;</span><br><span class="line">    dp[count] = <span class="title class_">Math</span>.<span class="title function_">min</span>(tmp1, tmp2, tmp3);</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp1) ugly1++;</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp2) ugly2++;</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp3) ugly3++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题51. 数组中的逆序对</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [7,5,6,4]<br>输出: 5
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a></p>
<h2 id="1-暴力双迭代（超时）"><a href="#1-暴力双迭代（超时）" class="headerlink" title="1.暴力双迭代（超时）"></a>1.暴力双迭代（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力双迭代，时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePairs1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在使用归并排序时，拆分的过程是不会打乱数组，</span></span><br><span class="line"><span class="comment"> * 使用归并排序成左小右大的时，会先将拆分出的两个数组中小的一个进入临时数组</span></span><br><span class="line"><span class="comment"> * 在添加左数组进入临时数组时，假如在此前右数组已经添加了一部分元素进临时数组，说明这些元素是</span></span><br><span class="line"><span class="comment"> * 比当前要添加临时数组的左数组元素要小，又因为这些元素在右数组中，说明这些元素在原数组中是在当前左元素后面的，</span></span><br><span class="line"><span class="comment"> * 换言之，这些元素可以与当前左数组元素可以构成逆序对，那么会构成多少个呢？</span></span><br><span class="line"><span class="comment"> * 只需要统计一下目前右数组已经添加了多少个元素到临时数组就好！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePairs2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">numArr, left, right</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right - left === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [numArr[left]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> leftArr = <span class="title function_">mergeSort</span>(numArr, left, mid);</span><br><span class="line">    <span class="keyword">const</span> rightArr = <span class="title function_">mergeSort</span>(numArr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(leftArr, rightArr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArr, rightArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    <span class="keyword">let</span> lIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lIdx &lt; leftArr.<span class="property">length</span> &amp;&amp; rIdx &lt; rightArr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意这里要加上等号</span></span><br><span class="line">      <span class="comment">// 因为相同的值不算逆序对，没有等号时，就是将right中的元素添加到tmp中，rIdx就会步进，</span></span><br><span class="line">      <span class="comment">// 相当于相同值也算进了逆序对</span></span><br><span class="line">      <span class="keyword">if</span> (leftArr[lIdx] &lt;= rightArr[rIdx]) &#123;</span><br><span class="line">        tmp.<span class="title function_">push</span>(leftArr[lIdx]);</span><br><span class="line">        lIdx++;</span><br><span class="line">        count += rIdx</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp.<span class="title function_">push</span>(rightArr[rIdx]);</span><br><span class="line">        rIdx++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lIdx &lt; leftArr.<span class="property">length</span>) &#123;</span><br><span class="line">      tmp.<span class="title function_">push</span>(leftArr[lIdx]);</span><br><span class="line">      lIdx++;</span><br><span class="line">      count += rIdx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rIdx &lt; rightArr.<span class="property">length</span>) &#123;</span><br><span class="line">      tmp.<span class="title function_">push</span>(rightArr[rIdx]);</span><br><span class="line">      rIdx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题56 - II. 数组中数字出现的次数 II</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9856-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II/</url>
    <content><![CDATA[<p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：nums &#x3D; [3,4,3,3]<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [9,1,7,9,7,9,7]<br>输出：1
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10000<br>1 &lt;&#x3D; nums[i] &lt; 2^31</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</a></p>
<h2 id="1-Hash表去重"><a href="#1-Hash表去重" class="headerlink" title="1.Hash表去重"></a>1.Hash表去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumberHash = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> record = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!record[num]) &#123;</span><br><span class="line">      record[num] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      record[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> record) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record[key] === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算计算目标数"><a href="#2-位运算计算目标数" class="headerlink" title="2.位运算计算目标数"></a>2.位运算计算目标数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算目标数的二进制上的每一位（0/1），注意是计算出，不是过滤出的</span></span><br><span class="line"><span class="comment"> * 1.使用2的冥值去探测各个二进制位上的情况，设要找的书是tar，设nums中，二进制第i位上的值是1的数有k个，k肯定是满足：</span></span><br><span class="line"><span class="comment"> * 1.1 当tar的二进制的第i位是1,则k=3n+1, (n = 0, 1, ..., nums,length)</span></span><br><span class="line"><span class="comment"> * 1.2 当tar的二进制的第i位是0,则k=3n, (n = 0, 1, ..., nums,length)</span></span><br><span class="line"><span class="comment"> * 2.根据1.1和1.2就可以去探测tar每一位具体是0还是1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumberBit1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tar = [];</span><br><span class="line">  <span class="comment">// 题目指出：1 &lt;= nums[i] &lt; 2^31</span></span><br><span class="line">  <span class="comment">// bit是由1左移得到，所以最多可以移30位，因为第一次是移动0位，所以可以遍历31次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// bit:</span></span><br><span class="line">    <span class="comment">// i= 0: 1</span></span><br><span class="line">    <span class="comment">// i= 1: 10</span></span><br><span class="line">    <span class="comment">// i= 2: 100</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((num &amp; bit) !== <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count % 3 !== 0, 说明tar左起第i位是</span></span><br><span class="line">    tar.<span class="title function_">unshift</span>(count % <span class="number">3</span> !== <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="built_in">parseInt</span>(tar.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>), <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-完全位运算"><a href="#3-完全位运算" class="headerlink" title="3.完全位运算"></a>3.完全位运算</h2><p>与“2.位运算计算目标数”不同，不是使用记录目标书二进制情况，而是使用按位或直接计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count % <span class="number">3</span> !== <span class="number">0</span>) tar = tar | bit;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumberBit2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tar = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 题目指出：1 &lt;= nums[i] &lt; 2^31</span></span><br><span class="line">  <span class="comment">// bit是由1左移得到，所以最多可以移30位，因为第一次是移动0位，所以可以遍历31次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((num &amp; bit) !== <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |:按位或，只要同一位不为0都得1</span></span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">3</span> !== <span class="number">0</span>) tar = tar | bit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题58 - II. 左旋转字符串</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9858-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a></p>
<h2 id="1-简单切片"><a href="#1-简单切片" class="headerlink" title="1.简单切片"></a>1.简单切片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = reverseLeftWords2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseLeftWords1</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">slice</span>(n) + s.<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符拼接"><a href="#2-字符拼接" class="headerlink" title="2.字符拼接"></a>2.字符拼接</h2><p>拼接比起数组保存后拼接要快……</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseLeftWords2</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    res += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题59 - II. 队列的最大值</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9859%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<span id="more"></span>

<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000<br>1 &lt;&#x3D; value &lt;&#x3D; 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p>
<h2 id="辅助双端队列"><a href="#辅助双端队列" class="headerlink" title="辅助双端队列"></a>辅助双端队列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助双端队列</span></span><br><span class="line"><span class="comment"> * 1._data队列正常对数据进行入队出队</span></span><br><span class="line"><span class="comment"> * 2._max是一个双端队列。每次_data入队元素，_max如下操作：</span></span><br><span class="line"><span class="comment"> * 2.1 当_max空，如对元素</span></span><br><span class="line"><span class="comment"> * 2.2 当_max非空，新数据value从右侧入队，入队前需要将右侧所有比value小的从右侧出队再入队。</span></span><br><span class="line"><span class="comment"> * 为什么？为了位置一个左到右递减的数列，这样才能维持_max每次从左侧出队的都是最大元素</span></span><br><span class="line"><span class="comment"> * 3.当出队_data元素value时，若_max的队头元素与value相等，则也出队_max的队头。为什么？因为value已经出队无效了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MaxQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_max</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max_value</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push_back</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span> &amp;&amp; value &gt; <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span>-<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">push</span>(value);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop_front</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MaxQueue()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"> * obj.push_back(value)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.pop_front()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题62. 圆圈中最后剩下的数字</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9862-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: n &#x3D; 5, m &#x3D; 3<br>输出: 3<br>示例 2：</p>
<p>输入: n &#x3D; 10, m &#x3D; 17<br>输出: 2</p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 10^5<br>1 &lt;&#x3D; m &lt;&#x3D; 10^6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a></p>
<h2 id="1-暴力模拟（超时）"><a href="#1-暴力模拟（超时）" class="headerlink" title="1.暴力模拟（超时）"></a>1.暴力模拟（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastRemaining = lastRemaining2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining1</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">getIdx</span> = (<span class="params">idx</span>) =&gt; idx % n;</span><br><span class="line">  <span class="keyword">const</span> record = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!record[num]) idx++;</span><br><span class="line">    <span class="comment">// console.log(num, idx, record)</span></span><br><span class="line">    <span class="keyword">if</span> (!record[num] &amp;&amp; idx &gt; <span class="number">0</span> &amp;&amp; idx % m === <span class="number">0</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">// console.log(&#123;count, n&#125;)</span></span><br><span class="line">      record[num] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span> num;</span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="title function_">getIdx</span>(num + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-约瑟夫自杀环"><a href="#2-约瑟夫自杀环" class="headerlink" title="2.约瑟夫自杀环"></a>2.约瑟夫自杀环</h2><p><img src="/blog/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof.assets/2020-04-16_17-00.png" alt="2020-04-16_17-00"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * f(x)：最后输出的序号</span></span><br><span class="line"><span class="comment"> * f(n, m) = (f(n - 1, m) + m)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining2</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">josephus</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="title function_">josephus</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">josephus</span>(n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-迭代优化约瑟夫问题"><a href="#3-迭代优化约瑟夫问题" class="headerlink" title="3.迭代优化约瑟夫问题"></a>3.迭代优化约瑟夫问题</h2><p>避免使用递归栈空间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining3</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = (res + m) % i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
        <tag>LCOF</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题67. 把字符串转换成整数</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9867.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<span id="more"></span>

<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。
 </p>
<p>注意：本题与主站 8 题相同：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p>
<h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strToInt1 = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> matched = str.<span class="title function_">match</span>(<span class="regexp">/^\s*([-|+]?\d+).*$/</span>);</span><br><span class="line">  <span class="keyword">if</span> (!matched) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">let</span> num = +matched[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">if</span> (num &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; min) <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-线性遍历"><a href="#2-线性遍历" class="headerlink" title="2.线性遍历"></a>2.线性遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strToInt2 = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sign;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        res += str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[i] === <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        res += str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>].<span class="title function_">includes</span>(str[i])) &#123;</span><br><span class="line">        sign = str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = sign === <span class="string">&#x27;-&#x27;</span> ? -res : res;</span><br><span class="line">  <span class="keyword">if</span> (res &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">  <span class="keyword">if</span> (res &lt; min) <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题46. 把数字翻译成字符串</title>
    <url>/blog/2020/04/17/%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
<p>提示：</p>
<p>0 &lt;&#x3D; num &lt; 231</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
<h2 id="1-深度优遍历"><a href="#1-深度优遍历" class="headerlink" title="1.深度优遍历"></a>1.深度优遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum1 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">dfs</span>(num + <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">str, start</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= str.<span class="property">length</span>) <span class="keyword">return</span> ++count;</span><br><span class="line">    <span class="keyword">const</span> num1 = +(str[start]);</span><br><span class="line">    <span class="keyword">const</span> num2 = +(str[start] + str[start+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">dfs</span>(str, start + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; num2 &amp;&amp; num2 &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>(str, start + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i]：长度为i字符串的翻译方法数</span></span><br><span class="line"><span class="comment"> * 最优子结构：dp[i-1]:最后单字符翻译，dp[i-2]：最后双字符翻译</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i] = isValid(s[i-1]+s[i-2]) ? dp[i-1] + dp[i-2] : dp[i-1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum2 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">&#x27;_&#x27;</span> + num;</span><br><span class="line">  <span class="comment">// [0, pos)</span></span><br><span class="line">  <span class="keyword">let</span> dp1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = dp2;</span><br><span class="line">    <span class="keyword">const</span> num = str[i-<span class="number">2</span>] + str[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; +num &amp;&amp; +num &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      dp2 = dp2 + dp1;</span><br><span class="line">    &#125;</span><br><span class="line">    dp1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-动态规划（优化）"><a href="#3-动态规划（优化）" class="headerlink" title="3.动态规划（优化）"></a>3.动态规划（优化）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum3 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">&#x27;_&#x27;</span> + num;</span><br><span class="line">  <span class="comment">// [0, pos)</span></span><br><span class="line">  <span class="keyword">let</span> dp1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = dp2;</span><br><span class="line">    <span class="keyword">const</span> num = str[i-<span class="number">1</span>] + str[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; +num &amp;&amp; +num &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      dp2 = dp2 + dp1;</span><br><span class="line">    &#125;</span><br><span class="line">    dp1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题26. 树的子结构</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9826-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<span id="more"></span>

<p>例如:<br>给定的树 A:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   4 </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<p>输入：A &#x3D; [1,2,3], B &#x3D; [3,1]<br>输出：false<br>示例 2：</p>
<p>输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]<br>输出：true<br>限制：</p>
<p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a></p>
<h2 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题思路：</span></span><br><span class="line"><span class="comment"> * 1.先序遍历找到与B根节点匹配的A子节点或A的根节点subA，找到后暂停</span></span><br><span class="line"><span class="comment"> * 2.比较从B和subA的根节点开始比较，B是不是subA的子树</span></span><br><span class="line"><span class="comment"> * 3.如果2判断不是，则重复1、2直到遍历完A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="keyword">function</span>(<span class="params">A, B</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isSub = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">preOrder</span>(A);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">val</span> === B.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isSubOf</span>(node, B)) &#123;</span><br><span class="line">        isSub = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isSubOf</span>(<span class="params">sup, sub</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sub) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sup || sup.<span class="property">val</span> !== sub.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isSubOf</span>(sup.<span class="property">left</span>, sub.<span class="property">left</span>) &amp;&amp; <span class="title function_">isSubOf</span>(sup.<span class="property">right</span>, sub.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题30. 包含min函数的栈</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9830.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<span id="more"></span>

<p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MinStack</span> minStack = <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">minStack.<span class="title function_">push</span>(-<span class="number">2</span>);</span><br><span class="line">minStack.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">minStack.<span class="title function_">push</span>(-<span class="number">3</span>);</span><br><span class="line">minStack.<span class="title function_">min</span>();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.<span class="title function_">pop</span>();</span><br><span class="line">minStack.<span class="title function_">top</span>();   --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.<span class="title function_">min</span>();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次
 </p>
<p>注意：本题与主站 155 题相同：<a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a></p>
<h2 id="双栈实现最小栈"><a href="#双栈实现最小栈" class="headerlink" title="双栈实现最小栈"></a>双栈实现最小栈</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双栈实现最小栈</span></span><br><span class="line"><span class="comment"> * 1._data保存数据 _data: 9, 10, 7, 11, 5</span></span><br><span class="line"><span class="comment"> * 2._min保存最小值 _min: 9, 7, 5</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.每次push的时候，在push到_data同时，如果新值比_min的最小值（栈顶元素）小就入栈_min，否则不入_min</span></span><br><span class="line"><span class="comment"> * 4.在pop的时候_data出栈，如果出栈的元素和_min栈顶元素相等，那么_min也出栈，因为这个最小值已经失效</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_min</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> || x &lt;= <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_min</span>.<span class="title function_">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tail = <span class="variable language_">this</span>.<span class="property">_data</span>[<span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (tail === <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_min</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>[len - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题52. 两个链表的第一个公共节点</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9852.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src="/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9852.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/160_statement.png"></p>
<p>在节点 c1 开始相交。</p>
<span id="more"></span>

<p>示例 1：</p>
<p><img src="/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9852.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/160_example_1.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：</p>
<p><img src="/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9852.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/160_example_2.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：</p>
<p><img src="/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9852.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/160_example_3.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<h2 id="计算长短链表差值"><a href="#计算长短链表差值" class="headerlink" title="计算长短链表差值"></a>计算长短链表差值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.遍历headA, headB，分别计算长度countA, countB</span></span><br><span class="line"><span class="comment"> * 2.根据countA, countB判断长链表long和短链表short，相差长度k</span></span><br><span class="line"><span class="comment"> * 3.让long先步进k步，然后long和short一起步进，直到long.next和short.next相等就break, long或short就是公共节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (headA === headB) <span class="keyword">return</span> headA;</span><br><span class="line">  <span class="keyword">let</span> curA = headA;</span><br><span class="line">  <span class="keyword">let</span> curB = headB;</span><br><span class="line">  <span class="keyword">let</span> countA = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> countB = <span class="number">0</span>;  </span><br><span class="line">  <span class="comment">// 计算A链表和B链表的长度</span></span><br><span class="line">  <span class="keyword">while</span> (curA.<span class="property">next</span> || curB.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curA.<span class="property">next</span>) &#123;</span><br><span class="line">      countA++;</span><br><span class="line">      curA = curA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curB.<span class="property">next</span>) &#123;</span><br><span class="line">      countB++;</span><br><span class="line">      curB = curB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (curA !== curB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> long;</span><br><span class="line">  <span class="keyword">let</span> short;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">if</span> (countB &gt; countA) &#123;</span><br><span class="line">    long = headB;</span><br><span class="line">    short = headA;</span><br><span class="line">    k = countB - countA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    long = headA;</span><br><span class="line">    short = headB;</span><br><span class="line">    k = countA - countB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (long) &#123;</span><br><span class="line">    long = long.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (k) &#123;</span><br><span class="line">      k--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      short = short.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (long === short) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> long;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题53 - II. 0～n-1中缺失的数字</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9853%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 注意点：每个数字都在范围0～n-1之内，最大值不超过n，所以若给的nums是一个递增无缺少的序列，则是缺少n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nums[mid] !== mid</span><br><span class="line">      &amp;&amp; (nums[mid - <span class="number">1</span>] === mid - <span class="number">1</span> || nums[mid - <span class="number">1</span>] === <span class="literal">undefined</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === mid) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题55 - II. 平衡二叉树</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9855%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<span id="more"></span>


<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 false 。</p>
<p> </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000<br>注意：本题与主站 110 题相同：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof</a></p>
<h2 id="1-深度优先遍历（后序）"><a href="#1-深度优先遍历（后序）" class="headerlink" title="1.深度优先遍历（后序）"></a>1.深度优先遍历（后序）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先（后序递归遍历）计算左右子树的深度</span></span><br><span class="line"><span class="comment"> * 判断左右子树深度差是否超过1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced1 = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">dfs</span>(root);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> lDeep = <span class="title function_">dfs</span>(node.<span class="property">left</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> rDeep = <span class="title function_">dfs</span>(node.<span class="property">right</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(lDeep - rDeep) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      res = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(lDeep, rDeep);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isBalanced = isBalanced1;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题57 - II. 和为s的连续正数序列</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9857%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<span id="more"></span>
<p> </p>
<p>示例 1：</p>
<p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p>
<p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; target &lt;&#x3D; 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a></p>
<h2 id="使用滑动窗口（双指针变种）"><a href="#使用滑动窗口（双指针变种）" class="headerlink" title="使用滑动窗口（双指针变种）"></a>使用滑动窗口（双指针变种）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用滑动窗口（双指针变种）</span></span><br><span class="line"><span class="comment"> * idx向右移动，同时累加当前总数sum，win入栈idx，直到sum大于或等于target</span></span><br><span class="line"><span class="comment"> * 1.当sum等于target，则保存win副本，然后继续右移idx</span></span><br><span class="line"><span class="comment"> * 2.当sum大于target，则出队win头元素tmp，并sum -= tmp（相当于右移win的边界）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> win = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(target / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (idx &lt;= max) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">      sum += idx;</span><br><span class="line">      win.<span class="title function_">push</span>(idx);</span><br><span class="line">      idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">      sum -= win.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(win.<span class="title function_">slice</span>(<span class="number">0</span>));</span><br><span class="line">      sum -= win.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题58 - I. 翻转单词顺序</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9858%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 </p>
<p>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>注意：本题与主站 151 题相同：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p>
<p>注意：此题对比原题有改动</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a></p>
<h2 id="1-滑动窗口-双指针"><a href="#1-滑动窗口-双指针" class="headerlink" title="1.滑动窗口+双指针"></a>1.滑动窗口+双指针</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口+双指针</span></span><br><span class="line"><span class="comment"> * 1.使用滑动窗口取出每个单词</span></span><br><span class="line"><span class="comment"> * 2.双指针，left=0, right=len-1，同时向中间偏移同时交换元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isSpace</span> = (<span class="params">val</span>) =&gt; [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>].<span class="title function_">includes</span>(val); </span><br><span class="line">  <span class="keyword">const</span> wordArr = [];</span><br><span class="line">  <span class="comment">// [left. right)</span></span><br><span class="line">  <span class="keyword">while</span> (right &lt;= s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="title function_">isSpace</span>(s[left])</span><br><span class="line">      &amp;&amp; !<span class="title function_">isSpace</span>(s[right - <span class="number">1</span>])</span><br><span class="line">      &amp;&amp; <span class="title function_">isSpace</span>(s[right] || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      wordArr.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(left, right));</span><br><span class="line">      left = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSpace</span>(s[left])) left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  left = <span class="number">0</span>;</span><br><span class="line">  right = wordArr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = wordArr[left];</span><br><span class="line">    wordArr[left] = wordArr[right];</span><br><span class="line">    wordArr[right] = tmp;</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wordArr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题59 - I. 滑动窗口的最大值</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9859%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  滑动窗口的位置                 最大值</span><br><span class="line">---------------               -------</span><br><span class="line">[</span><br><span class="line">  1  3  -1] -3  5  3  6  7       3</span><br><span class="line">  1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line">  1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line">  1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line">  1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line">  1  3  -1  -3  5 [3  6  7       7</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a></p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = k - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (right &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// [left, right]</span></span><br><span class="line">    <span class="keyword">let</span> max = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(max);</span><br><span class="line">    left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res= [];</span><br><span class="line">  <span class="keyword">let</span> curMaxNumIdx;</span><br><span class="line">  <span class="keyword">const</span> deQueue = <span class="keyword">new</span> <span class="title class_">DeQueue</span>(nums, k);</span><br><span class="line"></span><br><span class="line">  curMaxNumIdx = deQueue.<span class="title function_">getLeftHead</span>();</span><br><span class="line">  res.<span class="title function_">push</span>(nums[curMaxNumIdx]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    deQueue.<span class="title function_">push</span>(i);</span><br><span class="line">    curMaxNumIdx = deQueue.<span class="title function_">getLeftHead</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(nums[curMaxNumIdx]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护一个队列，成员是nums中元素的idx，并且这些idx都是当前</span></span><br><span class="line"><span class="comment"> * 并且这些idx都是在滑动中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DeQueue</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_queue</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_nums</span> = nums;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_k</span> = k;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">idx</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_clean</span>(idx);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">push</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getLeftHead</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">_k</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_clean</span> = <span class="keyword">function</span>(<span class="params">idx</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queueLen = <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> leftHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> minValidIdx = idx + <span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">_k</span>;</span><br><span class="line">  <span class="comment">// 队列为空，不需要清理无用元素</span></span><br><span class="line">  <span class="keyword">if</span> (!queueLen) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ps: 每次调用_clean只会调用一次</span></span><br><span class="line">  <span class="comment">// 当前滑动窗口中index的取值范围是：[minValidIdx, idx]</span></span><br><span class="line">  <span class="comment">// 如果deQueue的中的元素已经不再取值范围内就已经无用，出队清理掉</span></span><br><span class="line">  <span class="keyword">if</span> (leftHead &lt; minValidIdx) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PS: 调用多次更新序列</span></span><br><span class="line">  <span class="comment">// 背景：nums[idx]将会进入deQueue，现在这里的逻辑是在入队新元素前的整理工作</span></span><br><span class="line">  <span class="comment">// deQueue中的元素要求是：一个由大到小的有序列</span></span><br><span class="line">  <span class="comment">// 如果队尾（队列中最小）元素指向的nums的真实值比nums[idx]还小，那就没用，要清理掉</span></span><br><span class="line">  <span class="keyword">let</span> rightHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_nums</span>[idx] &gt;= <span class="variable language_">this</span>.<span class="property">_nums</span>[rightHead]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">    rightHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题60. n个骰子的点数</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9860.%20n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<span id="more"></span>

<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: 1<br>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<br>示例 2:</p>
<p>输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 11</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof</a></p>
<h2 id="1-动态规划穷举"><a href="#1-动态规划穷举" class="headerlink" title="1.动态规划穷举"></a>1.动态规划穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态：dp[n][i]:掷出第n个骰子，总点数是i的所有次数</span></span><br><span class="line"><span class="comment"> * 最优子结构：每枚骰子6个点数，dp[n][i]的次数可以由 dp[n-1][i-1] + 1或dp[n-1][i-2] + 2或...或dp[n-1][i-6] + 6构成</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[n][i] = sum(dp[n-1][i-j]), 1 &lt;= j &lt;= 6</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = twoSumDp2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSumDp1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>();</span><br><span class="line">  dp = dp.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">7</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;=  <span class="number">6</span>; i++) &#123;</span><br><span class="line">    dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dpCount</span>(n);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> all = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt;= n * <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dp[n][i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">const</span> tmp = dp[n][i] / all;</span><br><span class="line">    res.<span class="title function_">push</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dpCount</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= i * <span class="number">6</span>; j++) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j - num &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">const</span> sub = dp[i - <span class="number">1</span>][j - num] || <span class="number">0</span>;</span><br><span class="line">          dp[i][j] += sub;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-优化动态规划"><a href="#2-优化动态规划" class="headerlink" title="2.优化动态规划"></a>2.优化动态规划</h2><p>使用一个长度是2的二维数值存储dp元素，因为计算<code>dp[i][j]</code>只是依赖<code>dp[i - 1][j - num]</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twoSumDp2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], []];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dpCount</span>(n);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> all = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt;= n * <span class="number">6</span>; i++) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(dp[<span class="number">0</span>][i] / all);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dpCount</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= i * <span class="number">6</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j - num &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          dp[<span class="number">1</span>][j] += dp[<span class="number">0</span>][j - num] || <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>] = [];</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题50. 第一个只出现一次的字符</title>
    <url>/blog/2020/04/16/%E9%9D%A2%E8%AF%95%E9%A2%9850.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<span id="more"></span>

<p>示例:</p>
<p>s &#x3D; “abaccdeff”<br>返回 “b”</p>
<p>s &#x3D; “”<br>返回 “ “
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a></p>
<h2 id="Hash表记录"><a href="#Hash表记录" class="headerlink" title="Hash表记录"></a>Hash表记录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">character</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> charMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    charMap[s[i]] = charMap[s[i]] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> charMap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charMap[key] === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript创建对象的多种模式</title>
    <url>/blog/2020/01/07/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>工厂模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> o.<span class="property">name</span> = name;</span><br><span class="line"> o.<span class="property">age</span> = age</span><br><span class="line"> o.<span class="property">job</span> = job;</span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>工作模式是通过一个函数返回一个对象，但是有个问题是：新建对象实例和普通的调用函数没有辨识度。</p>
</blockquote>
<ul>
<li>构造函数模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>和工厂模式相比，构造函数模式，没有显示地创建对象，并返回，而是直接将属性和“静态“方法赋值给this对象。使用new操作符新建实例，this对象引用的是以Person对象为模板的新对象。</li>
</ul>
</blockquote>
<ul>
<li>使用new操作符这种方式调用构造函数，实际上是经历了下面四个步骤：</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋值给新对象（因此this对象引用的是新对象，而不是原型对象）；</li>
<li>执行构造函数的代码；</li>
<li>返回这个新对象。</li>
</ol>
<blockquote>
<p><em>上面的工厂模式也是经历的这几个步骤，不过工厂模式是在构造函数中使用new操作符新建对象实例。</em></p>
</blockquote>
<p>&amp;nbsp;</p>
<blockquote>
<p>使用构造函数模式，解决了“标识函数和类型”的问题，但是如果在构造函数内部新建函数就会有个问题：<br><strong>在实例person1和person2中都sayName函数，虽然功能相同，<br>但是他们却是开辟了两个空间，新建了两个函数，因为他们各自在不同的作用域中。</strong><br>避免重复新建同样功能函数，避免冗余可以这样做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做也带来一个新的问题：<br><em><em>为了避免同功能函数的冗余，然后我们把这些”静态函数”都放在了全局作用域中，而在新对象中进行引用。但是一旦函数多起来，封装性就会失去，一堆函数在全局作用域，这样也污染全局作用域。我自己的一个折中的做法是：用“+function(){ &#x2F;*代码</em>&#x2F; }()”包裹。js提供另外一种方法：<em>原型模式</em></em>*</p>
<ul>
<li>原型模式</li>
</ul>
<blockquote>
<p>构造函数会有一个prototype属性，他存放的是一个指针，指向原型对象，实例也是有个功能相同的内部属性[[prototype]] &#x2F; __proto__(__proto__属性只在FireFox、chrome、Safari得到支持)指向原型对象，而原型对象中则有一个属性，constructor，他指向构造函数，而prototype是原型模式的核心：</p>
</blockquote>
<ul>
<li>prototype &#x2F; [[prototype]]，该属性存放的是一个指针，指向原型对象；</li>
<li>原型对象的属性：constructor，该属性存放的是一个指针，指向构造函数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;issac&#x27;</span>;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><strong>更简单的原型语法</strong></p>
<blockquote>
<p>将对象赋值给prototype属性，即使用字面量的方法简写为：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样虽然可以很好的简写，但要注意的一点是，这样做相当于重写了原型对象，constructor不再指向Person，而是指向Object构造函数。如果要使用到这个属性，就要手动将constructor指向Person</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做，也并非和默认获得的constructor属性相同，因为该属性是手动添加的，那么内部属性[[Enumerable]]是默认为true的，而默认获得的constructor的枚举是false的。可以使用defineProperty方法设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property">proptotype</span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: fase,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>只用原型模式的问题</li>
</ul>
<p><strong>原型模式最大的问题是由他的共享性引起，在属性还是基本类型的时候还没有什么问题，但如果是引用类型，问题就很明显了。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;issac&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arr</span> = [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;iron&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;man&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">arr</span>);  <span class="comment">//[&#x27;issac&#x27;, &#x27;is&#x27;, &#x27;iron&#x27;, &#x27;man&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">arr</span>);  <span class="comment">//[&#x27;issac&#x27;, &#x27;is&#x27;, &#x27;iron&#x27;, &#x27;man&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果一开始就是打算共享这个数组还好说，但是更多时候这种情况是希望每个对象实例拥有独立的数组。这也是，比较少单独使用原型模式的原因。</p>
</blockquote>
<p>&amp;nbsp;</p>
<blockquote>
<ul>
<li>小插曲：实例对象中建立和原型对象属性同名的属性，会屏蔽原型对象的属性，就算将实例对象中的同名属性赋值为null也不能取消屏蔽，但是可以使用 delete 操作符 删除实例对象中的同名属性，可以重新访问到原型对象中的同名属性。<br>&amp;nbsp;</li>
<li>hasOwnProperty可以用来判断属性是不是属于实例对象</li>
</ul>
</blockquote>
<ul>
<li>组合原型模式和构造函数模式</li>
</ul>
<blockquote>
<p>从上面的构造函数模式和原型模式，可以知道，构造函数模式，定义的属性和方法是非共享的，在新建对象实例时复制了一份属性副本(没有必要在这里定义方法，因为方法功能一样，不必给每个实例分配一个副本，这是冗余，浪费内存)，都是独立的；而用原型模式构造的属性和方法是共享的，每个属性调用的原型属性和方法都是共享的，相当于静态的属性&#x2F;方法。<br>结合这两个特点，可以以构造函数模式定义实例属性&#x2F;方法（非共享），以原型模式定义静态方法&#x2F;属性（共享）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造实例属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">not_share</span> = [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;frank&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态的共享属性/方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">share</span>: [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;person&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">p1.<span class="property">share</span>.<span class="title function_">push</span>(<span class="string">&#x27;dube&#x27;</span>);</span><br><span class="line">p1.<span class="property">not_share</span>.<span class="title function_">push</span>(<span class="string">&#x27;dube&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">not_share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">not_share</span>);</span><br></pre></td></tr></table></figure>

<img src="2838289-cbf09eba34a5fef8.png" alt="JavaScript创建对象的多种模式"/>

<ul>
<li>寄生构造函数模式</li>
</ul>
<p><strong>个人是认为这种模式适合用在原生对象上进行扩展，这样也很适合“寄生”这一词。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给Array添加一个特殊的方法，但是有不污染Array对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>);</span><br><span class="line">  values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">toPipedString</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个小插曲，也是写到这里才知道，函数可以不写形参，而直接从arguments对象（数组）中获取实参。</p>
</blockquote>
<img src="2838289-f07fc44919e0c0f6.png" alt="JavaScript创建对象的多种模式"/>


<ul>
<li>小结：主要介绍了以下五种创建对象的模式。</li>
</ul>
<ol>
<li>工厂模式;</li>
<li>构造函数模式；</li>
<li>原型模式；</li>
<li>组合原型模式和构造函数模式；</li>
<li>寄生构造函数模式；</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript函数提升和变量的声明提前</title>
    <url>/blog/2020/01/07/javascript%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>把他们两个概念放在一起说，并不是因为他们有多大关联，只是因为他们都会被“提前”。</p>
<span id="more"></span>

<h1 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h1><p>函数提升，比较好理解，基本就是js的运行规则了，记住就好。就是无论函数被定义在上下问那个位置，都会在代码执行前优先定义。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="2838289-b42e2aadee7b912f.png" alt="javascript函数提升和变量的声明提前"/>

<p>上面的例子是可以执行的，不会报错，会正常输出“issac”。虽然上面说到上下文的任何位置，但是这个任何位置是指同一个执行环境，怎么才叫同一个执行环境？比如说下面的例子就会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fnCreat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fnCreate</span>();</span><br></pre></td></tr></table></figure>

<p>为什么会报错？fn函数执行的执行环境，和fn定义的执行环境已经不同，每个函数都创建一个执行环境，自身的执行环境，外部环境对其是不可见的，全局执行环境对于任何一个函数的函数体内的代码来说都是外部执行环境。</p>
<img src="2838289-081624fdf69205c5.png" alt="javascript函数提升和变量的声明提前"/>

<p>所以上面你在全局执行环境调用，就要在全局执行环境定义。</p>
<p>PS：谈到函数定义想必会想到下面这样的方式定义函数，这样的定义函数个人觉得是很好看的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issax&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种函数的定义方式叫“函数表达式”，这样定义函数是不会被函数提升，因此上面的代码执行会抛出异常：</p>
<img src="2838289-069a3b74b6763e02.png" alt="javascript函数提升和变量的声明提前"/>

<h1 id="变量的声明提前"><a href="#变量的声明提前" class="headerlink" title="变量的声明提前"></a>变量的声明提前</h1><p>变量和函数有一点相同：他们都会被提前到当前作用域的顶部；但是变量的提前和函数的提前也是有一点不同：函数是会被提升，并且会定义，而变量的提前是不会被提前定义的，即不会当前作用域提前定义；如果你不清楚作用域的话，对于函数来说，你可以笼统地认为是函数体内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<img src="2838289-634314a72255a147.png" alt="javascript函数提升和变量的声明提前"/>

<p>如上面的例子所见，a变量没有被提前定义。<br>如果不会被提前定义，那么怎么体现变量的声明提前？<br>你知道作用域链（感兴趣可以自行Google）吗？不知道？也不要紧，写过js代码的coder，都应该会有这样的经验：函数内部可以访问到外层作用域（比如说最外层的全局作用域）定义的变量和函数，而函数内部的定义的和外层作用域同名的变量会遮盖外层的，就是说如果函数内部有和外层同名的函数会变量，内部的优先级更高，了解到这一点就算不了解作用域链也可以理解变量提升。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<img src="2838289-358c20b812529f39.png" alt="javascript函数提升和变量的声明提前"/>

<p>变量的声明提前就体现在下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);   </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<p>你认为会输出什么？会输出  <code>1</code>  <code>2</code> ？然而并不是！</p>
<img src="2838289-17c44cf694435498.png" alt="javascript函数提升和变量的声明提前"/>

<p>为什么会这样，就是因为变量的声明提前，相信到这里你已经大概知道什么是变量提前，通俗地讲：在当前作用域内，变量会提前声明，遮盖外层作用域的同名变量，因为没有解析作用域链，所以就笼统地说一下，毕竟在深入学习前就得不求甚解嘛。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析JavaScript作用域链</title>
    <url>/blog/2020/01/02/%E6%B5%85%E6%9E%90JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为可以大概了解作用域链是个什么东西，本文着重说明作用域链，尽量不引入其他的概念。</p>
<span id="more"></span>

<h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>在说作用域链前，先简单地说明变量对象，毕竟是作用域链的核心组成。每个函数内部都会定义变量，会定义函数，在全局环境下也会定义函数、变量。对应的区域都会有一个特殊对象，这个对象就会存放对应区域的变量、函数，这个特殊的对象就是变量对象。所以说全局环境有和全局环境对应的变量对象，每个函数内部也有一个与之对应的变量对象，不如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">isShow</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> gihubLink = <span class="string">&#x27;https://github.com/issaxite&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(isShow) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(githubLink);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issax&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码中,</p>
<ul>
<li>全局环境的变量对象存储的是：a, b, fn</li>
<li>fn函数的变量对象存储的是：isShow，gihubLink；<strong>你可以看见，fn函数的变量对象没有包含全局环境定义的变量和函数</strong></li>
</ul>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>为什么要说变量对象呢？因为作用域链就是由变量对象组成，作用域链是一个由变量对象组成的列表，一个有序，只能由头开始逐个往尾访问的列表（说是列表其实更应该说是链表，先不要在意这个概念）。<br>并且作用域链和变量对象有一个共同的特点：每个区域都会有一个与之对象对的。比如说上面的代码中，全局环境有一个与之对应的变量对象，也有一个和全局环境对应的作用域链；fn函数也是如此。</p>
<h2 id="那么作用域链是有哪些变量对象组成呢？"><a href="#那么作用域链是有哪些变量对象组成呢？" class="headerlink" title="那么作用域链是有哪些变量对象组成呢？"></a>那么作用域链是有哪些变量对象组成呢？</h2><p>我们先看下图：</p>
<img src="2838289-ea22086b2a47a918.png" alt="浅析JavaScript作用域链"/>

<p>由上图应该可以看出，作用域链由当前区域的变量对象作为开头，然后是逐层往外直至全局环境的变量对象组成如上图一样的列表，这就是作用域链，并且如上文所说，每个区域都有这样一个与之对应的作用域链。比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">isShow</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> gihubLink = <span class="string">&#x27;https://github.com/issaxite&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">param1, param2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> mailLink = <span class="string">&#x27;issaxite@gmail.com&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fn1函数的作用域链：</p>
<img src="2838289-b0a1699c6beb4b74.png" alt="浅析JavaScript作用域链"/>
</li>
<li><p>fn的作用域链：</p>
<img src="2838289-9fdc6ccc56ef3e26.png" alt="浅析JavaScript作用域链"/>
</li>
<li><p>全局环境的作用域链</p>
<img src="2838289-828698a0bf9bc1b4.png" alt="浅析JavaScript作用域链"/></li>
</ul>
<p>那么作用域链的作用是什么？<br>jser都应该有这样的体验，在函数内部可以访问到外部区域的变量和函数，而在外部区域访问不了函数内定义的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<img src="2838289-2a0bdcdf12428f9a.png" alt="浅析JavaScript作用域链"/>

<p>如上所示，fn函数内部可以访问到外层区域（全局环境）的变量，为什么可以，就是因为fn函数的作用域链，在变量调用的时候（在fn就是访问c变量的时候），会在当前作用域链的头部开始往尾部，依次在变量对象中查询对应的变量，找到即返回，不再继续查询，这个也是内层同名变量比外层同名变量优先级更高的原因，这个查询的过程叫做<strong>变量解析</strong>，也叫<strong>标识符解析</strong>，<code>console.log(c);</code>会抛出异常就是因为全局环境的作用域链中的变量对象没有该变量。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>正如本文开头所说，本文仅是浅析作用域链，一些相关概念都被隐掉了，比如说上文说的“区域“，应该说是作用域或执行环境，这两个概念其实说的不是很明确，比如说执行环境，在《javascript高级程序设计》的4.2中有说到，简直堪称极具迷惑性，标题更加是醉”执行环境和作用域“，然而基本没有谈到作用域。作用域在《javascript权威指南》的3.10中倒是说的挺多，还分变量作用域和函数作用域。不过啊，要是拘泥于这些细节更加难搞明白作用域链了。上文也说道作用域链更像链表，个人也是这样认为，但两书中都没有明确地说是，权威指南倒是提了一下，而且作用域链也是很符合链表的特点，如果不了解链表，但由不了解其他语言，推荐这本书<strong>《数据结构与算法JavaScript描述》</strong>，吐槽完毕，作用域链的解析当然没有那么浅显，想了解更多细节还是自己去看看书。</p>
<p>有说得不对的，欢迎指出</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>我不知道的hash表</title>
    <url>/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%AD%A3%E6%96%87">正文</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%A3%E5%88%97%E8%A1%A8">什么是散列表</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%A3%E5%88%97%E8%A1%A8">为什么需要散列表</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%95%A3%E5%88%97%E8%A1%A8">如何构建散列表</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%A2%B0%E6%92%9E">哈希冲突（碰撞）</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6">平均查找长度</a></li>
<li><a href="#%E8%BD%BD%E8%8D%B7%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90">载荷（装填）因子</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%90%8E%E5%86%99%E4%B8%A4%E5%8F%A5">最后写两句</a></li>
</ul>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>为什么要写散列表（Hash Table）？！因为忘记，就算以前在大学的时候学得多好，分数考多高。成了前端狗之后一方面是自己对自己不够严格，另一方面工作方面也是用得少这方面的知识，平时大多都是一群朋友吹牛皮的时候，亮出来吓吓人（也只能说自己记得的部分）。当夜深人静时都会想想自己吹过的牛皮~感叹这些知识自己真的忘得差不多了，三分钟热度来写个文章温故知新！</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>散列表（Hash Table），用一个映射函数将数据的特征值与数据保存表的存储位置建立联系，以便在寻找数据的时候可以快速定位，这样的表成为散列表（Hash Table），上述映射函数成为hash函数。</p>
<blockquote>
<p>根据设定的哈希函数和冲突处理方法将一组关键字映射到一个有限连续的地址集上，并以关键字映射得到的值作为关键字对应数据在表中的存储位置，这种称为哈希表。</p>
</blockquote>
<blockquote>
<p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。（摘自<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表维基百科</a>）</p>
</blockquote>
<h3 id="为什么需要散列表"><a href="#为什么需要散列表" class="headerlink" title="为什么需要散列表"></a>为什么需要散列表</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>一般来说hash表的数据会用一个一维数组存储。而在低级语言中使用数组是需要预先申请数组的长度，即是内存大小。而在实际应用中，很难确定最后应该申请多大的内存，过大浪费资源，过小则会造成内存溢出。在溢出前你就需要扩容，扩容的时候又涉及到内存拷贝的问题，因为数组是一组连续的地址集，你难保在这段地址集后面的地址没有保存另外的数据。另外，单纯用数组存储数据，存储的时候很爽，但是在寻找的时候就一身骚了~毕竟在数组一定规模的时候你遍历一次或许就要做成千上万次的对比数据，这还是单纯的一维数组而已，如果是个矩阵呢？复杂度是不是就蹭蹭往上涨！</p>
<h3 id="如何构建散列表"><a href="#如何构建散列表" class="headerlink" title="如何构建散列表"></a>如何构建散列表</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>如上文所述，哈希函数就是用来确定数据特征值与数据在哈希表存储位置的映射关系。</p>
<blockquote>
<p>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)&#x3D;f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。</p>
</blockquote>
<p>常用的几个用于构建哈希函数的方法如下：</p>
<ul>
<li>直接定址法：使用一个线性函数作为映射函数；</li>
<li>除留余数法：通过模 一个小于或等于散列表长度的值，取其余数作为散列表的存储位置；</li>
<li>数字分析法：肉眼观测，剔除显而易见的噪点；</li>
<li>平方中值法：将数据特征（一般是自然数）平方后取中间几位数，取几位取决于表的大小；</li>
<li>折叠法：将数据特征值分隔成为数相同的几部分，然后取叠加和（舍去高位）；</li>
<li>伪随机数法；</li>
</ul>
<p>以上每个方法不一一阐述，我只挑出“除留余数法”浅析。一是它常用；二是我只想说它。</p>
<p>除留余数法的数学表达式：</p>
<div style="font-weight: bold;">
    <dl style="text-align: center;">hash( key ) = key mod p ( p ≤ m )</dl>
    <dl style="text-align: right;">
        <sub>key: 数据特征值；</sub>
        <sub>m: 散列表的长度；</sub>
    </dl>
</div>



<p>下面用一例子对上述数学表达式进行实践（注意，一下例子只是对除留余数法的实践，并未完全达到理想的映射关系，仅仅是基本的关系）：</p>
<p>假设现有一组数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Issac&#x27;</span>, <span class="string">&#x27;Fanck&#x27;</span>, <span class="string">&#x27;Sonia&#x27;</span>, <span class="string">&#x27;Gary&#x27;</span>, <span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;Ryron&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>取以上人名的首字母的 <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII码</a> 作为数据的特征值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nameKeys = names.map((name) =&gt; &#123;</span><br><span class="line">	const initial = name.slice(0, 1);</span><br><span class="line">	const key = initial.charCodeAt();</span><br><span class="line">	return key;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// print: [73, 70, 83, 71, 82, 82, 69]</span><br></pre></td></tr></table></figure>

<p>然后，取 <code>p = 7</code>。<strong>对p的选择很重要，一般取素数（质数）或m，若p选择不好，容易产生冲突（哈希冲突）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> indexs = nameKeys.<span class="title function_">map</span>(<span class="function">(<span class="params">nameKey</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = nameKey % p;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print: [3, 0, 6, 1, 5, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>根据 <code>names</code> 和 <code>indexs</code> 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<p>可以得到一个基本的关系表：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">-</td>
<td align="center">Issac</td>
<td align="center">-</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Ryron</td>
<td align="center">Emma</td>
</tr>
</tbody></table>
<p>由表中的数据你可以看见3、5、6这三个位置都有一个以上的name映射到了同一个存储位置上，显然一个位置是不能存放多个数据，除非使用别的储存方式。该当如何下节分解！</p>
<h4 id="哈希冲突（碰撞）"><a href="#哈希冲突（碰撞）" class="headerlink" title="哈希冲突（碰撞）"></a>哈希冲突（碰撞）</h4><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>前一小节中出现“多个name映射到了同一个存储位置”的情况就是典型的哈希冲突。<br>出现哈希冲突，一是更换其他的哈希函数，二是对哈希函数的结果进行处理。要知道在数据足够大后无论怎么更换哈希函数都无法避免哈希冲突，只能尽量减小出现哈希冲突的几率。</p>
<p>常用方法有以下几种：</p>
<ul>
<li>开放定址法；</li>
<li>单独链表法；</li>
<li>再散列；</li>
<li>双散列；</li>
</ul>
<p>以下浅析前两种方法，原因同上。 </p>
<h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>开放定址法的数学表达式：</p>
<div style="text-align: center;font-weight: bold;">
    <dl>Hash = (hash(key) + d<sub>i</sub>) mod m, i=1,2,3...k (k <= m-1)</dl>
    <dl style="text-align: right;">
        <sub>m为散列表长，d<sub>i</sub>为增量序列（函数），i为已发生冲突的次数</sub>
    </dl>
</div>



<p>增量序列的构建方法有以下几种：</p>
<ul>
<li>线性探测：d(i) &#x3D; i;</li>
<li>平方探测：d(i) &#x3D; i^2;</li>
<li>伪随机探测；</li>
</ul>
<p>下面用“线性探测”编写例子。</p>
<p>回顾哈希函数得到的映射结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<p>取哈希表的长度<code>m = p = 7</code>。</p>
<p>映射 <code>Ryron</code> 时出现冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># i = 1, d(1) = 1，hash(key) = 5</span><br><span class="line">(5 + 1) mod 7 = 6   # 冲突</span><br><span class="line"></span><br><span class="line"># i = 2, d(2) = 2，hash(key) = 5</span><br><span class="line">(5 + 2) mod 7 = 0   # 冲突</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line"># i = 4, d(4) = 4，hash(key) = 5</span><br><span class="line">(5 + 4) mod 7 = 2   # 命中</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">Ryron</td>
<td align="center">Issac</td>
<td align="center">-</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
</tbody></table>
<p>映射 <code>Emma</code> 时继续出现冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># i = 1, d(1) = 1，hash(key) = 6</span><br><span class="line">(6 + 1) mod 7 = 0   # 冲突</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># i = 5, d(5) = 5，hash(key) = 6</span><br><span class="line">(6 + 5) mod 7 = 4   # 命中</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">Ryron</td>
<td align="center">Issac</td>
<td align="center">Emma</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
</tbody></table>
<p>到此，冲突处理完毕，散列表构建完成！我们可以试着在散列表中查找数据。</p>
<p>假设现在要查找 <code>Issac</code> 和 <code>Ryron</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Issac</span><br><span class="line"># key(&#x27;I&#x27;) = 73, Hash(key) = 3</span><br><span class="line">hashTable(3)  # output &#x27;Issac&#x27; =&gt; Hit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Ryron</span><br><span class="line"># key(&#x27;R&#x27;) = 82, Hash(key) = 5</span><br><span class="line">hashTable(3)  # output &#x27;Rick&#x27; =&gt; Miss</span><br><span class="line"></span><br><span class="line"># d(1) = 1, Hash(key) = 6</span><br><span class="line">hashTable(6)  # output &#x27;Sonia&#x27; =&gt; Miss</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># d(4) = 4, Hash(key) = 2</span><br><span class="line">hashTable(2)  # output &#x27;Ryron&#x27; =&gt; Hit</span><br></pre></td></tr></table></figure>





<h5 id="单独链表法"><a href="#单独链表法" class="headerlink" title="单独链表法"></a>单独链表法</h5><p>使用单链表作为存储数据的方式，言外之意，hash(key)得到的在哈希表的存储位置不再是数据的存储位置，而是用于存储数据所用链表的地址。</p>
<p><img src="/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/169da0ac46bad36d.png"></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">单链表</a>（LinkList）形如：</p>
<p><img src="/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/169da0ebd588f9f9.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LinkList() &#123;</span><br><span class="line">    constructor(_data, _next) &#123;</span><br><span class="line">        this.head = new Entry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert(_data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    find(_data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的每个节点形如：</p>
<p><img src="/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/169da10a5c98fb7c.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_data, _next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = _data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾哈希函数得到的映射结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">const</span> hashTable = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Issac&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Issac&#x27;</span>);    <span class="comment">// 73</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 3, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Issac&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Fanck&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Fanck&#x27;</span>);    <span class="comment">// 70</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 0, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Fanck&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Sonia&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Sonia&#x27;</span>);    <span class="comment">// 83</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 6, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Sonia&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Gary&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Gary&#x27;</span>);    <span class="comment">// 71</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 1, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Gary&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Rick&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Rick&#x27;</span>);    <span class="comment">// 82</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 5, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Rick&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Ryron&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Ryron&#x27;</span>);    <span class="comment">// 82</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 5, 冲突</span></span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Ryron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Emma&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Emma&#x27;</span>);    <span class="comment">// 69</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 6, 冲突</span></span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Emma&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/169da36dcac47d29.png"></p>
<h3 id="平均查找长度"><a href="#平均查找长度" class="headerlink" title="平均查找长度"></a>平均查找长度</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>为什么要求取“平均查找长度”？从上文中你可以发现，由于哈希冲突的出现，用数据特征并不能直接获取数据的储存位置，是需要进行一次以上的对比才能找到目标数据，也可能数据并不存在于哈希表中，即查找不成功。因此，就需要一个量度去衡量查找效率，即平均查找长度。</p>
<p>平均查找长度分为下面两类：</p>
<ul>
<li>成功的平均查找长度：</li>
</ul>
<div style="font-weight: bold;">
    <dl style="text-align: center;">ASL = (d<sub>0</sub> + d<sub>1</sub> + d<sub>2</sub> + ... + d<sub>i</sub>) / n, (i = 0, 1, 2 ... n)</dl>
    <dl style="text-align: right;">
        <sub>ASL: 平均查找长度</sub>,<sub>n: 哈希表的元素个数</sub><br>
        <sub>di: 第 i 个元素查找成功所需要的查找（比对）次数</sub>
    </dl>
</div>


<ul>
<li>不成功的平均查找长度：</li>
</ul>
<div style="font-weight: bold;">
    <dl style="text-align: center;">ASL = (d<sub>0</sub> + d<sub>1</sub> + d<sub>2</sub> + ... + d<sub>i</sub>) / n, (i = 0, 1, 2 ... l)</dl>
    <dl style="text-align: right;">
        <sub>l: 哈希表的长度</sub>,
        <sub>n: 哈希表的元素个数</sub>,
        <sub>ASL: 平均查找长度</sub><br/>
        <sub>di: 在第 i 个存储位置开始查找直到确定不存在所需要的查找（比对）次数</sub>
    </dl>
</div>

<p>下面分别计算前一小节中哈希表的成功和不成功的平均查找长度。</p>
<p><img src="/blog/2020/01/01/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/169da36dcac47d29.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 成功的平均查找长度</span><br><span class="line">Frank：1</span><br><span class="line">Gary: 1</span><br><span class="line">Issac: 1</span><br><span class="line">Rick: 1</span><br><span class="line">Ryron: 2</span><br><span class="line">Sonia: 1</span><br><span class="line">Emma: 2</span><br><span class="line"></span><br><span class="line">ASL = (1 + 1 + 1 + 1 + 2 + 1 + 2) / 7 ≈ 1.2857</span><br></pre></td></tr></table></figure>

<hr>
<p>对于不成功的平均查找长度数学代数式中d<sub>i</sub>有必要再细说一下。<br>比如现在要再上表中查找<code>Fiona</code>，这是不存在中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash(&#x27;F&#x27;)  # output 0</span><br></pre></td></tr></table></figure>

<p>然后，就是在 <code>hashTable(0)</code> 存储的单链表中查找<code>Fiona</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次查找， 第一个节点的data存的是Frank，不匹配！</span><br><span class="line"># 并且第一个的指针域为空指针（没有指向下一个节点），这样就成功确定Fiona不在表中，即查找失败！</span><br><span class="line">结果是hash(key)等于0的查找失败长度为1</span><br></pre></td></tr></table></figure>

<p>由上面的例子就可以知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不成功的平均查找长度</span><br><span class="line">hash(key) =&gt; 0: 1</span><br><span class="line">hash(key) =&gt; 1: 1</span><br><span class="line">hash(key) =&gt; 2: 0</span><br><span class="line">hash(key) =&gt; 3: 1</span><br><span class="line">hash(key) =&gt; 4: 0</span><br><span class="line">hash(key) =&gt; 5: 2</span><br><span class="line">hash(key) =&gt; 6: 2</span><br><span class="line"></span><br><span class="line">ASL = (1 + 1 + 0 + 1 + 0 + 2 + 2) / 7 = 1</span><br></pre></td></tr></table></figure>



<h3 id="载荷（装填）因子"><a href="#载荷（装填）因子" class="headerlink" title="载荷（装填）因子"></a>载荷（装填）因子</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>载荷因子指的是哈希表的装满程度，具体计算式是：</p>
<div style="font-weight: bold;">
    <dl style="text-align: center;">α = 表中元素个数 / 哈希表长度</dl>
</div>



<p>从公式中你可以直观地感受到，α 越大下次存入新元素的时候发生冲突的几率越大，因为表中空缺的位置已经很小了！<br>发生冲突的次数越多，也就是意味着查找长度就可能越大！想想哈希表的存在意义：为了方便定位目标查找元素！查找长度足够大时哈希表就不在方便了，也就失去存在意义。而α就可以直观地指明当前哈希表已经不够方便了，那么这个时候就需要对哈希表进行扩容！没错，它就是标示何时应该扩容，比如java中的hashMap则是<code>α &gt; 0.75</code> 时后对当前哈希表进行扩容！</p>
<h2 id="最后写两句"><a href="#最后写两句" class="headerlink" title="最后写两句"></a>最后写两句</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>上文其实已经很早就写好，剩下自己定的两个问题本来想浅析一下，但是由于自身原因一拖再拖，也只能先在此留个坑，希望自己有生之年可以回来填坑（滑稽）</p>
<ul>
<li>如何判断一个哈希表的好坏？</li>
<li>为什么除留余数发中p一般取质数？</li>
</ul>
<p>希望自己一如既往可以对未知的知识保有好奇心~</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的JavaScript实现</title>
    <url>/blog/2020/01/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>1 在数据集之中，选择一个元素作为”基准”（pivot）。<br>2 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>3 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>
</blockquote>
<span id="more"></span>

<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">80</span>, <span class="number">34</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<p><img src="/blog/2020/01/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/36534815-97fd73f2-1802-11e8-9039-36b714dfd2ee.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(list.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> list; &#125;</span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = list[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/blog/2020/01/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/36535646-54302edc-1805-11e8-8fa4-0d0eef8591c6.png"></p>
</blockquote>
<h3 id="quickSort函数解构"><a href="#quickSort函数解构" class="headerlink" title="quickSort函数解构"></a><code>quickSort</code>函数解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> left = [], right = [];</span><br><span class="line"><span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = list[index];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">    left.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分逻辑正是对<strong>基本思想</strong>中的1、2点的实践。</p>
<ul>
<li><h4 id="1-找出基准数"><a href="#1-找出基准数" class="headerlink" title="1 找出基准数"></a>1 找出基准数</h4></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="2-以“基准”二分数组"><a href="#2-以“基准”二分数组" class="headerlink" title="2 以“基准”二分数组"></a>2 以“基准”二分数组</h4></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = list[index];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">    left.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="3-重复1、2点"><a href="#3-重复1、2点" class="headerlink" title="3 重复1、2点"></a>3 重复1、2点</h4></li>
</ul>
<p>在栗子中的数组执行一次1、2点实现后，你会发现此时执行后出现三个结果<br>1）letf &#x3D; [2];<br>2）pivot &#x3D; 3;<br>3）right &#x3D; [9, 6, 80, 34, 7, 8];</p>
<p>然后依次组合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...left, pivot, ...right]</span><br><span class="line"><span class="comment">// [2, 3, 9, 6, 80, 34, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>你会发现<code>left</code>只有一个元素，那就没有必要继续对<code>left</code>排序，所以没有必要再排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(list.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> list; &#125;</span><br></pre></td></tr></table></figure>
<p>然后再看<code>right</code>，并不是有序数组。那要怎么办？继续对<code>right</code>排序，调用<code>quickSort</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">quickSort</span>(right)</span><br><span class="line"><span class="comment">// [...quickSort(left), pivot, ...quickSort(right)];</span></span><br></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)];</span><br></pre></td></tr></table></figure>
<p>正是对第3点的实践。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历的javascript实现</title>
    <url>/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>紧接着上篇  <a href="./%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0.md">二叉树的javascript实现</a> ，来说一下二叉树的遍历。</p>
<span id="more"></span>

<p>本次一本正经的胡说八道，以以下这个二叉树为例子进行遍历：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-3daeb5c545e5c721.png"></p>
<p>接着是要引入二叉树实现的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">show</span> = show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树遍历的分类"><a href="#二叉树遍历的分类" class="headerlink" title="二叉树遍历的分类"></a>二叉树遍历的分类</h1><p>二叉树的遍历分为先序、中序、后序遍历。这里说到的先序、中序、后序是相对于父节点来说。父节点的值先输出就是先序，三者间它在中间输出就是中序，最后输出就是后序。至于那个是父节点是相对而言的，因为除了叶子节点（最底下一层节点），其他每个节点都可以是父节点。</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-ba95130e0738830d.png"></p>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>先序遍历就是，先打印父节点，然后是左子节点（左子树），然后再打印右子节点（子树）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加先序遍历的成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preOrder函数是递归实现的，应该说二叉树的遍历都是递归实现的。可能有些人会因为先序遍历的特征：“先打印父节点，然后是左子节点（左子树），然后再打印右子节点（子树）” 而陷入一个错误的想法，这想法是什么请看下图：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-ce81e216fca99c93.png"></p>
<p>注意红框部分，父节点是10，左子节点是3，右子节点是18，因为上面的结论，可能会错误地认为打印的顺序是<code>10 → 3 → 18 </code>，然而事实并非如此[捂脸]，真是的顺序是：先打印10，然后是打印左子树，打印完左子树的全部节点后，才开始打印以10位父节点的右子树：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-123d7b9722e9a43e.png"></p>
<p>这个时候，你的脑海就该这样想：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-07040be1a2a54793.png"></p>
<p>然后是这样想：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-a48c2ac242f3e007.png"></p>
<p>如此类推打印完以10为父节点的左子树，然后也是以这样的方式打印以10为父节点的右子树，按着这种  <strong>拆分代替的思想</strong>  来理解会更好明白二叉树的遍历。</p>
<p>然后最终，先序遍历改二叉树的顺序是：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-4745ead9a13aaa9d.png"></p>
<p>按图的输出顺序是：<code>10 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 9 -&gt; 8 -&gt; 9 -&gt; 18 -&gt; 13 -&gt; 21</code><br>最后来实践一下，先序遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bst = <span class="keyword">new</span> <span class="title function_">BST</span>();</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    bst.<span class="title function_">insert</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">bst.<span class="title function_">preOrder</span>(bst.<span class="property">root</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-f5173b222f16cec8.png"></p>
<p>这里强调一下，输出顺序和插入顺序有关的，因为你插入顺序不同生成的二叉树也是不同的。有疑问的可以去 <a href="./%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0.md">二叉树的javascript实现</a> 细看一下，有比较明白的说明了二叉树，也可以实验一下：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-da13ca026775f5e5.png"></p>
<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>看完先序遍历，已经可以类推到很多和中序、后序遍历相关的知识点。中序遍历的特征是：先打印左子树（左子节点），接着打印父节点，最后打印右子树（右子节点）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="title function_">inOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">inOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加该成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">inOrder</span> = inOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历的打印顺序：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-c4b8e6b205daf67e.png"></p>
<p>按上图的输出顺序是：<code>2 -&gt; 3 -&gt; 4 -&gt; 8 -&gt; 9 -&gt; 9 -&gt; 10 -&gt; 13 -&gt; 18 -&gt; 21</code><br>接着是，实践一下中序遍历：</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-f7147d8e222cc77c.png"></p>
<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="title function_">postOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="title function_">postOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加该成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">inOrder</span> = inOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">postOrder</span> = postOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历的打印顺序</p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-40ce1a6b62a8dfc2.png"></p>
<p>按上图的输出顺序是：<code>2 -&gt; 8 -&gt; 9 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 13 -&gt; 21 -&gt; 18  -&gt; 10</code></p>
<p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-b98b04bb61c0aa6c.png"></p>
<p>各位观众老爷，文章到此为止，有写的不对的，请斧正！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的javascript实现</title>
    <url>/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/blog/2020/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-a4d05edb6062df13.png"></p>
<span id="more"></span>

<p><strong>二叉树的特点(例图只是二叉树的一种情况，不要尝试用例图推理以下结论)</strong></p>
<ul>
<li>除了最下面一层，每个节点都是父节点，每个节点都有且最多有两个子节点；</li>
<li>除了嘴上面一层，每个节点是子节点，每个节点都会有一个父节点；</li>
<li>最上面一层的节点（即例图中的节点50）为根节点；</li>
</ul>
<img src="2838289-e0e3b9a05871efaa.png" alt="二叉树的javascript实现"/>

<ul>
<li>最下面一层的节点称为叶子节点，他们没有子节点；</li>
</ul>
<img src="2838289-da27d2f6031b1d36.png" alt="二叉树的javascript实现"/>

<ul>
<li>左子节点的值 &lt; 父节点的值 &lt;&#x3D; 右节点的值</li>
</ul>
<p>1 节点的javascript实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">data</span> = data;  <span class="comment">// 节点值</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">left</span> = left;  <span class="comment">// 当前节点的左子节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">right</span> = right;  <span class="comment">// 当前节点的右子节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">show</span> = show;  <span class="comment">// 辅助function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感受下上面实现节点的代码，感觉和链表有点相似不是吗，存着当前值，又存着下个节点（左、右子节点）的引用，下面是一张伪代码的草图：</p>
<img src="2838289-d7aede07576cc831.png" alt="二叉树的javascript实现"/>

<p>2 二叉树的实现<br>实现二叉树，当然就是要插入节点构成二叉树，先看看实现二叉树的js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是看一下伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;  <span class="comment">// 根节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="comment">// 初始化一个节点，为什么要将左右子节点的引用初始化为空呢，因为可能是叶子节点，加入他有子节点，会在下面的代码添加</span></span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (该二叉树是否为空，是空则根节点为空，因此可以用根节点判断二叉树是否为空) &#123;</span><br><span class="line">      <span class="comment">// 将当前节点存为根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里就表示，该二叉树不为空，这里关键的是两句代码：</span></span><br><span class="line">      <span class="comment">// 0.while (true);</span></span><br><span class="line">      <span class="comment">// 1.parent = current；</span></span><br><span class="line">      <span class="comment">// 2.current = current.left;/current = current.right;</span></span><br><span class="line">      <span class="comment">// 3.break;</span></span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;  <span class="comment">// 获得父节点，第一次循环，那么父节点就是根节点</span></span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;  <span class="comment">// 当前节点值小于父节点的值就是存左边，记得二叉树的特点吧，如果真是小于父节点，那么就说明该节点属于，该父节点的左子树。</span></span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其实上面这样写不好理解，可以等价于下面的代码：</span></span><br><span class="line">            <span class="comment">// start</span></span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">left</span> == <span class="literal">null</span>)&#123;  <span class="comment">// 若果左节点空，那么这个空的节点就是我们要插入的位置</span></span><br><span class="line">                current.<span class="property">left</span> = n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 不空则继续往下一层找空节点（插入的位置）</span></span><br><span class="line">                current = current.<span class="property">left</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// end</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右节点的逻辑代码个左节点的一样的</span></span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个更好理解的插入函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="comment">// start change</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">left</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">               current.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               current = current.<span class="property">left</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">right</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">               current.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               current = current.<span class="property">right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>二叉树的实现的三个部件</p>
<ul>
<li>Node对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>BST对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>插入节点函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图的javascript实现</title>
    <url>/blog/2020/01/01/%E5%9B%BE%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>图：关于图的概念就大概说一下基本的，图分成有向和无向。图由若干顶点构成，顶点相连成边，边由顶点对组成，(假设有v1，v2两顶点，(v1,v2)即为一条边)每个顶点有权重，对于图的概念可以自行Google，本文着重对图的实现，上两张“图”的例子：</p>
<span id="more"></span>

<p>有向图：</p>
<p><img src="/blog/2020/01/01/%E5%9B%BE%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-34f3c4e8246fdbfd.png"></p>
<p>无向图：</p>
<p><img src="/blog/2020/01/01/%E5%9B%BE%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-1effeaaa6413bc13.png"></p>
<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><ul>
<li><p>使用邻接表：<br>以顶点值为下标，构建数组，元素为与该顶点相连的顶点值，下面例子就是用邻接表存储。假设有顶点v1、v2、v3，且有边(v1, v2)、(v1, v3)、(v2, v3)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> edges = [];</span><br><span class="line">edges[v1] = [v2, v3];</span><br><span class="line">edges[v2] = [v1, v3];</span><br><span class="line">edges[v3] = [v1, v2];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用邻接矩阵：<br>临界矩阵，简单说是个二维数组，假设有顶点v1、v2，并且v1、v2有边相连，则用邻接矩阵表示为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> edges = [];</span><br><span class="line">edges[v1][v2] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 若无边相连则为</span></span><br><span class="line">edges[v1][v2] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="图的javascript实现"><a href="#图的javascript实现" class="headerlink" title="图的javascript实现"></a>图的javascript实现</h1><p><strong>下面以上文中的无向图为例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Graph</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">edges</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顶点</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">initVertices</span> = <span class="keyword">function</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(toString.<span class="title function_">call</span>(list) !== <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;please init adj with Array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertices</span>[list[item]] = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点的连结（边）</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEdge</span> = <span class="keyword">function</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">vertices</span>[v1] || !<span class="variable language_">this</span>.<span class="property">vertices</span>[v2]) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;vertex that does not exist！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span>[v1].<span class="title function_">push</span>(v2);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span>[v2].<span class="title function_">push</span>(v1);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">edges</span>++; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出存储图的邻接表</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showGraph</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(item <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">vertices</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item+<span class="string">&#x27;: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">vertices</span>[item].<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">graph.<span class="title function_">initVertices</span>(list);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">showGraph</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/blog/2020/01/01/%E5%9B%BE%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/2838289-1e184a4fff1588ef.png"></p>
<p>PS：图当然是没有那么简单的啦，想了解图自己去看书吧</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与防抖</title>
    <url>/blog/2019/12/27/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81">函数节流</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96">函数防抖</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数节流<br>给定时间间隔内只执行一次</p>
<p>函数防抖<br>在连续尝试触发的情况，只有触发的时间间隔大于给定时间才会真正触发。</p>
<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>正如其名，就是为了节流。<br>在实现同样的功能下，尽量使用最少的资源，达到节约的效果！<br>比如，在绑定一个滚动事件，滚轴的位置有一点变化都会触发。然而，人眼可以识别的只有60帧每秒，甚至30帧就够了！<br>所以，让触发频率实在是浪费资源！</p>
<p>先来实现一个节流函数的构造器！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttleCreator</span>(<span class="params">_cb, _time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cacheTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - cacheTime  &gt; _time) &#123;</span><br><span class="line">      cacheTime = now;</span><br><span class="line">      <span class="title function_">_cb</span>(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyEle = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">bodyEle.<span class="property">onscroll</span> = <span class="title function_">throttleCreator</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p>意义在于防止多次触发无意义操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounceCreator</span>(<span class="params">_cb, _time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(_cb.<span class="property">id</span>);</span><br><span class="line">    _cb.<span class="property">id</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      _cb.<span class="title function_">call</span>(ctx, ...rest);</span><br><span class="line">    &#125;, _time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于继承多种实现的笔记</title>
    <url>/blog/2019/12/27/%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">原型链继承</a></li>
<li><a href="#%E5%80%9F%E8%B0%83%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">借调构造函数继承</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">组合继承</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">原型式继承</a></li>
<li><a href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生式继承</a></li>
<li><a href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生组合式继承</a></li>
</ul>
<span id="more"></span>

<h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>先说原型链继承的问题：包含引用类型属性的原型（不想被共享的引用属性）会变成共享。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;color&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">type</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins2.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line">ins2.<span class="title function_">sayType</span>();</span><br><span class="line">ins2.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<img src="http://upload-images.jianshu.io/upload_images/2838289-0ef782193b536392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%" alt="关于继承多种实现的笔记"/>

<p><strong>根据超类，colors应该为每个实例独有、不共享的，但由上面的代码可见，由于原型链继承后，colors变成了共享的属性</strong></p>
<blockquote>
<p>造成此结果的原因是：以SuperType的实例作为了prototype，而每个对象实例都只是指向这个prototype，因此每个实例拥有的colors实际都是同一个colors，换言之ins1.colors和ins2.colors存放都是同一个指针。</p>
</blockquote>
<p>  <strong>原型链继承的问题：无法保证“私有”引用类型继续“私有”</strong></p>
<h1 id="借调构造函数继承"><a href="#借调构造函数继承" class="headerlink" title="借调构造函数继承"></a>借调构造函数继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>为解决原型链本应为实例独有的引用属性变成共享属性的问题，提出借调构造函数继承</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">sub.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<img src="http://upload-images.jianshu.io/upload_images/2838289-1925f395a7a67071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%" alt="关于继承多种实现的笔记"/>

<blockquote>
<p>借调构造函数解决上面提出了的问题，而且接受参数更加的方便</p>
</blockquote>
<p>  <strong>构造函数自身的老问题：</strong></p>
<blockquote>
<p>由于构造函数会将它的把内容创建在一个新的作用域内赋给实例，因此，同样功能的方法就会为每个实例新建一份。这样本应共有的方法一旦多起来，创建的对象实例一旦多起来，就会造成很大冗余，这就是方法无法复用的问题。而且你也看到了，假如父类是使用组合式创建对象（组合原型式和构造函数式），子类是无法继承父类的原型的，因此上面 <code>sub.sayName();</code> 才会抛出异常，因为subType中确实没有这个方法。</p>
</blockquote>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>由上面两种继承的方式可以看出： <strong>原型链继承</strong> 不能保证“私有”引用属性继续“私有”，但是 <strong>借调构造函数</strong> 可以；<strong>借调构造函数继承</strong> 不可以复用方法，但 <strong>原型链继承</strong> 可以。那么可以组合两种方式的长处，使用 <strong>原型链继承</strong> 继承共享属性和方法，使用 <strong>借调构造函数</strong> 继承“私有”属性。</p>
</blockquote>
<p> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">//公用方法和属性要定义后将父对象的实例赋值给SubType对象之后，不然会因为重写prototype而被“抹去”</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SuperType</span>;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ins2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins2.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>要理解组合继承是怎么工作的，要先知道一件事：js会先执行prototype的代码，再执行构造函数的代码。</strong><br>首先是执行 <strong>SubType.prototype &#x3D; new SuperType();</strong> 这句相当于给SubType的原型对象创建了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是涉及的主要部分</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">colors</span>: [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>],</span><br><span class="line">    [[prototype]]: <span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">//包含了SuperType的公有方法和属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在新建SubType对象实例 **var ins1 &#x3D; new SubType(‘a’, 18);**的时候调用构造函数，相当于给ins1对象创建“私有”属性： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我不太会表达下面属性是ins1独有的属性，姑且如下面这样写，但愿不会误导人</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>这些属性会屏蔽原型对象的同名属性，从而达到“私有”。</p>
<p> </p>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>通过封装一个函数来作为继承的媒介</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title function_">object</span>(person);</span><br><span class="line">anthorPerson.<span class="property">name</span> = <span class="string">&#x27;Annd&#x27;</span>;</span><br><span class="line">anthorPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Dda&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在ES5中添加Object.create()方法规范了这种继承，这个方法接受两个参数，一个是原型对象，第二个是需要新增的属性会方法[可选]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anthorPerson.<span class="property">name</span> = <span class="string">&#x27;Annd&#x27;</span>;</span><br><span class="line">anthorPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Dda&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> yetPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;issac&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Object.create()仅在IE9+支持，特别指出IE其他的浏览器就不说了</strong></p>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>寄生式继承是和原型式继承紧密相关的思路。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnthor</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title function_">object</span>(o);</span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi Issac&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title function_">createAnthor</span>(person);</span><br><span class="line">anthorPerson.<span class="title function_">sayHi</span>();  <span class="comment">//Hi Issac</span></span><br></pre></td></tr></table></figure>
<p><strong>寄生的精髓即在原有对象上进行扩展</strong></p>
<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>在说组合继承的时候，已经说过超类是会被调用两次，“私有”属性的继承即通过对象实例的属性对原型对象的屏蔽，显然，原型对象中的“私有”属性是多余了。为解决中多余，提出了 <strong>寄生组合式继承</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    prototype.<span class="property">constructor</span> = superType;</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>));  <span class="comment">//打印一个0~10的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac1&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2838289-4d9d8877c8ca347b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以上代码的执行结果"></p>
</blockquote>
<p><strong>显然，使用寄生组合式继承仅仅调用了一次超类。<br>使用组合继承，会调用2次超类：<br>第一次，以超类的实例作为子类的原型对象（原型链式继承）；<br>第二次，创建子类的对象实例时调用子类构造函数，子类构造函数，通过借调构造函数继承调用超类的构造函数；<br> <br>寄生组合式继承是抹去上面说的第一次调用超类。它是通过直接将超类的原型对象赋值给子类的原型对象，然后子类在此基础上进行个扩充，这样就会不会触发到超类的构造函数。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>New操作符的机制与实现相同功能的方法</title>
    <url>/blog/2019/12/16/New%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%90%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">new操作符做了什么</a><ul>
<li><a href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B">小结一下</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">实现一个new创建实例</a><ul>
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>先来看一个例子，分别用新旧方式创建类，并实例化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">fn</span> = <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property">fn</span> = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别创建两个类的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;isaac&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&#x27;isaac&#x27;</span>);</span><br></pre></td></tr></table></figure>
<img src="62819728-ddf24080-bb8b-11e9-8ebb-97522b8ce822.png" alt="New操作符的机制与实现相同功能的方法"/>

<p>首先，可以看输出结果。很明显两个实例的结构上是基本一致的，类比一下，你可以猜到新语法“class”的实现本质，当然class也确实是传统实现的语法糖。</p>
<p>所以，接下来直接使用Foo的定义方式作为例子讲。</p>
<p>再来看看定义一个类的时候我们做了什么：</p>
<ul>
<li>定义了一个构造函数，将需要属性赋值给了上下文（context，即上文的this）</li>
<li>定义了构造函数的属性prototype，将方法、属性挂载在这个prototype上。</li>
</ul>
<p>最后再对比下实例的结构：</p>
<p>你可以发现，传入Foo的实参被初始化到了对象的第一层属性上：</p>
<img src="62832611-9b039c00-bc63-11e9-9812-f76237cce809.png" alt="New操作符的机制与实现相同功能的方法"/>

<p><strong>说不准这就是构造函数做的事情：通过构造函数将传参，经过逻辑处理，然后初始化到实例上。</strong></p>
<p>在看输出结果，在<code>name</code>属性的下面还有一个<code>__proto__</code>属性，他是一个类对象的结构，你可以发现有两个成员是我们自己定义的：</p>
<blockquote>
<ol>
<li>fn</li>
<li>sayName</li>
</ol>
</blockquote>
<p>这两个属性都是我们在定义类的时候挂载到prototype上的。</p>
<p><strong>说不准这就是我们定义在Foo.prototype属性</strong></p>
<p>最后，我们根据上面两个猜想，再进行推断new做了什么事情：</p>
<ul>
<li>new通过构造函数创建了一个对象foo，并且通过构造函数的逻辑初始化了这个对象的基本成员；</li>
<li>new将foo的原型引用指向了Foo.prototype，从而连接好从<code>foo -&gt; Foo.prototype -&gt; Object.prototype</code>这条原型链。</li>
</ul>
<p>上面即是猜想也是实质，我不去证明，这不是我的主要想写的，我是想根据这个猜测去实现一个方法达到“new”的功能。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>javascript的类的实现分成两部分：</p>
<ul>
<li>Constructor（构造函数）</li>
<li>Proptotype（原型）</li>
</ul>
<p>实例化一个类的实例的本质是：</p>
<ul>
<li>创建一个对象，且在访问该对象成员时，可以向它类指向原型回溯；</li>
<li>对象的成员属性（包含方法）通过Constructor进行初始化；</li>
</ul>
<h1 id="实现一个new创建实例"><a href="#实现一个new创建实例" class="headerlink" title="实现一个new创建实例"></a>实现一个new创建实例</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据上面对new操作符的分析，我们可以这么做：</p>
<ol>
<li>创建一个对象；</li>
<li>将这个对象的原型引用（不是这个对象的原型，是一个内部属性<code>__proto__</code>指向）；</li>
<li>调用构造函数，将上下文（this）绑定到对象。</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>使用<code>setPrototypeOf</code>实现原型指向</li>
</ul>
<p><code>setPrototypeOf</code>是ES6的新方法，具体实现其实就是对对象<code>__proto__</code>的修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">_ctx, _proto</span>) &#123;</span><br><span class="line">  _ctx.<span class="property">__proto__</span> = _proto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> Constructor </span>&#125; ctor 构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newIns</span>(<span class="params">ctor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ins = &#123;&#125;;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(ins, ctor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  ctor.<span class="title function_">apply</span>(ins, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = <span class="title function_">newInsOf</span>(<span class="title class_">Foo</span>, <span class="string">&#x27;isaac&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins);</span><br></pre></td></tr></table></figure>

<img src="62832251-0cd8e700-bc5e-11e9-80c6-578eb9c982e7.png" alt="New操作符的机制与实现相同功能的方法"/>

<ul>
<li>通过<code>Object.create</code>“继承”类</li>
</ul>
<p><code>Object.create</code>是官方对原型式继承的内部实现，具体逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCreate</span>(<span class="params">prototype</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于原型式继承可参考: <a href="https://github.com/isaaxite/blog/issues/253#issuecomment-520214476">原型式继承</a></p>
<p><code>Object.create</code>不但创建了一个对象，并且设置了这个对象的<code>__proto__</code>指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newInsOf</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">const</span> ins = <span class="built_in">Object</span>.create(ctor.prototype);</span></span><br><span class="line"><span class="params">  ctor.apply(ins, <span class="built_in">Array</span>.prototype.slice.call(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ins;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>

<img src="62832679-d357aa00-bc64-11e9-9963-dd2741ad89f9.png" alt="New操作符的机制与实现相同功能的方法"/>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>filter的实现原理</title>
    <url>/blog/2019/12/14/filter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#filter%E4%B8%80%E8%88%AC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%89%E7%A7%8D">filter一般调用方式有三种</a></li>
<li><a href="#_f%E6%98%AF%E4%BB%80%E4%B9%88">_f是什么？</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用如下例子，说明<code>filter</code>作为html属性一部分或元素文本一部分的解析，以及vue对<code>filter</code>解析过程的详细实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:data-filter</span>=<span class="string">&quot;price|decimal(3)|format-unit|test&quot;</span>&gt;</span>&#123;&#123;price|decimal(3)|format-unit|test&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">methodA</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">curcoder</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;isaac&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">position</span>: <span class="string">&#x27;fe&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">email</span>: <span class="string">&#x27;isaacgun@outlook.com&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">price</span>: <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">filters</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">decimal</span>(<span class="params">val, count = <span class="number">2</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(val)) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> val;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(count) || count &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> val.<span class="title function_">toFixed</span>(count);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">formatUnit</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> [<span class="string">&#x27;￥&#x27;</span>, val].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Test</span>(val) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">334</span>, <span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> val;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">methodA</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> &#123; decimal &#125; = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">filters</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> num = <span class="title function_">decimal</span>(<span class="number">120</span>, <span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vm:&#x27;</span>, vm);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="filter一般调用方式有三种"><a href="#filter一般调用方式有三种" class="headerlink" title="filter一般调用方式有三种"></a>filter一般调用方式有三种</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ol>
<li>在双花括号中使用：<code>&lt;span&gt;&#123;&#123;price|unit&#125;&#125;&lt;/span&gt;</code>，在解析模板阶段，使用<code>parseText</code>进行解析；</li>
<li>在 <code>v-bind</code> 中使用：<code>&lt;span :data-format-price=&quot;price|unit&quot;&gt;&lt;/span&gt;</code>，在解析模板阶段，使用<code>processAttrs</code>进行解析；</li>
<li>在钩子或回调函数中使用：<code>this.$options.filters.unit(this.price)</code>。</li>
</ol>
<p>在<code>parseText</code>中解析</p>
<p>path: <code>vue/src/compiler/parser/text-parser.js:20</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `&lt;span&gt;&#123;&#123;price|unit&#125;&#125;&lt;/span&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseText</span> (</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span>,</span><br><span class="line">  delimiters?: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">): <span class="title class_">TextParseResult</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tagRE = delimiters ? <span class="title function_">buildRegex</span>(delimiters) : defaultTagRE</span><br><span class="line">  <span class="keyword">if</span> (!tagRE.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((match = tagRE.<span class="title function_">exec</span>(text))) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">log</span>(match[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> exp = <span class="title function_">parseFilters</span>(match[<span class="number">1</span>].<span class="title function_">trim</span>())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: &quot;price|unit&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<code>processAttrs</code>中解析</p>
<p>path: <code>vue/src/compiler/parser/index.js:765</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `&lt;span :data-format-price=&quot;price|unit&quot;&gt;&lt;/span&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processAttrs</span> (el) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, l = list.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    name = rawName = list[i].<span class="property">name</span></span><br><span class="line">    value = list[i].<span class="property">value</span></span><br><span class="line">    <span class="keyword">if</span> (dirRE.<span class="title function_">test</span>(name)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (bindRE.<span class="title function_">test</span>(name)) &#123; <span class="comment">// v-bind</span></span><br><span class="line">        name = name.<span class="title function_">replace</span>(bindRE, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, value)</span><br><span class="line">        value = <span class="title function_">parseFilters</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: &quot;price|unit&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，以上两种方式去解析filter文本，最后都是调用<code>parseFilters</code>对filter文本进行解析。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `price|decimal(3)|format-unit|test`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseFilters</span> (<span class="attr">exp</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (filters) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filters.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      expression = <span class="title function_">wrapFilter</span>(expression, filters[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">log</span>(expression);</span><br><span class="line">  <span class="keyword">return</span> expression</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapFilter</span> (<span class="attr">exp</span>: <span class="built_in">string</span>, <span class="attr">filter</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> i = filter.<span class="title function_">indexOf</span>(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// _f: resolveFilter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;filter&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span>)`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = filter.<span class="title function_">slice</span>(<span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">const</span> args = filter.<span class="title function_">slice</span>(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;name&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span><span class="subst">$&#123;args !== <span class="string">&#x27;)&#x27;</span> ? <span class="string">&#x27;,&#x27;</span> + args : args&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: `_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))`</span></span><br></pre></td></tr></table></figure>
<p>filter文本最后解析完还是文本！是一串有函数和参数组成的字符串，其中比较突出的就是<code>_f</code>！<br>从<code>_f(&quot;decimal&quot;)(price,3)</code>就可以大致推断<code>_f</code>是一个工厂函数，用来生产filter函数，<code>_f(&quot;decimal&quot;)</code>应该就是获取<code>decimal</code>过滤器，<br>那么大概<code>_f(&quot;decimal&quot;)(price,3)</code>就是，调用<code>decimal</code>过滤器，传入参数<code>this.price,3</code>！</p>
<p>为什么最后解析出的只是一段函数调用的文本？</p>
<p>因为vue的视图渲染分成两步：a. 解析视图模板，生成用于渲染整个视图的函数文本；b. 将函数文本作为视图订阅器（render-watcher）的getter（用于获取watcher的值，watcher.value）。</p>
<p>可以直接打印一下例子中render-watcher的文本：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="title function_">log</span>(code.<span class="property">render</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># output:</span><br><span class="line"></span><br><span class="line">with(this)&#123;return _c(&#x27;main&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#x27;span&#x27;,&#123;attrs:&#123;&quot;data-filter&quot;:_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))&#125;&#125;,[_v(_s(_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))))])])&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见<code>_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))</code>就被包含在其中！</p>
<h1 id="f是什么？"><a href="#f是什么？" class="headerlink" title="_f是什么？"></a>_f是什么？</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>上面推测<code>_f</code>是生产过滤器的工厂，具体看下这个<code>_f</code>是怎么来的！</p>
<p>全局搜索<code>._f</code>，可以在<code>vue/src/core/instance/render-helpers/index.js</code>找到下面的代码！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resolveFilter &#125; <span class="keyword">from</span> <span class="string">&#x27;./resolve-filter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">installRenderHelpers</span> (<span class="attr">target</span>: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.<span class="property">_f</span> = resolveFilter</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向上回溯去找<code>installRenderHelpers</code>在哪里被调用！可以找到<code>renderMixin</code>！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderMixin</span> (<span class="title class_">Vue</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt;) &#123;</span><br><span class="line">  <span class="comment">// install runtime convenience helpers</span></span><br><span class="line">  <span class="title function_">installRenderHelpers</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vue/src/core/instance/render-helpers/index.js</code>中向下寻找<code>resolveFilter</code>的本质逻辑！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identity, resolveAsset &#125; <span class="keyword">from</span> <span class="string">&#x27;core/util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for resolving filters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; id filter的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveFilter</span> (<span class="attr">id</span>: <span class="built_in">string</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>, <span class="string">&#x27;filters&#x27;</span>, id, <span class="literal">true</span>) || identity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve an asset.</span></span><br><span class="line"><span class="comment"> * This function is used because child instances need access</span></span><br><span class="line"><span class="comment"> * to assets defined in its ancestor chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveAsset</span> (</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>,</span><br><span class="line">  warnMissing?: <span class="built_in">boolean</span></span><br><span class="line">): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> assets = options[<span class="keyword">type</span>]</span><br><span class="line">  <span class="comment">// check local registration variations first</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, id)) <span class="keyword">return</span> assets[id]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中划线转驼峰</span></span><br><span class="line">  <span class="keyword">const</span> camelizedId = <span class="title function_">camelize</span>(id)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开头大写化</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">PascalCaseId</span> = <span class="title function_">capitalize</span>(camelizedId)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, <span class="title class_">PascalCaseId</span>)) <span class="keyword">return</span> assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fallback to prototype chain</span></span><br><span class="line">  <span class="comment">// 自然回溯原型链</span></span><br><span class="line">  <span class="keyword">const</span> res = assets[id] || assets[camelizedId] || assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warnMissing &amp;&amp; !res) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;Failed to resolve &#x27;</span> + <span class="keyword">type</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>) + <span class="string">&#x27;: &#x27;</span> + id,</span><br><span class="line">      options</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看<code>_f(&quot;decimal&quot;)</code>，即是<code>resolveFilter (&quot;decimal&quot;)</code>,</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolveAsset(this.$options, &#x27;filters&#x27;, id, true)</span></span><br><span class="line"><span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>, <span class="string">&#x27;filters&#x27;</span>, <span class="string">&#x27;decimal&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>那么对于filter来说，xx的几个参数的意思：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsset</span> (</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">Object</span>,  <span class="comment">// this.$options</span></span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>, <span class="comment">// &#x27;filters&#x27;</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>, <span class="comment">// &#x27;decimal&#x27;(过滤器名)</span></span><br><span class="line">  warnMissing?: <span class="built_in">boolean</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>那么<code>const assets = options[type]</code>中的assets就是filters，<code>return assets[id]</code>就是返回我们自己定义的filter-callback！</p>
<p><code>_f(&quot;decimal&quot;)</code>就返回decimal过滤器回调函数！</p>
<p>从上面<code>resolveAsset</code>的实现，可以看出，filter的使用方式可以兼容以下几种情况：</p>
<ol>
<li>正常调用，<code>&#123;&#123;price|formatUnit&#125;&#125;</code>；</li>
<li>中划线调用，单用驼峰法定义filter，<code>&#123;&#123;price|format-unit&#125;&#125;</code>；</li>
<li>小写开头调用，但定义时用开头大写，<code>&#123;&#123;price|test&#125;&#125;</code>，test对使用Test定义的filter有效；</li>
<li>自然回溯原型链，但对于filter作用不大，除非是与原型链上属性或函数同名！</li>
</ol>
<p>整个流程下来，可以发现：a. filter-callback没有使用bind绑定上下文；b. 没有直接挂在在vue实例上。</p>
<p>这也是有别于<code>methods</code>的不同，看<code>methods</code>的初始化就知道：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initMethods</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>, <span class="attr">methods</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span> ? noop : <span class="title function_">bind</span>(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter的特点</p>
<ol>
<li>filter不会被代理到vm实例上；      </li>
<li>filter不会绑定vm作为上下文。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ul>
<li>filter兼容的调用方式</li>
</ul>
<ol>
<li>正常调用，<code>&#123;&#123;price|formatUnit&#125;&#125;</code>；</li>
<li>中划线调用，单用驼峰法定义filter，<code>&#123;&#123;price|format-unit&#125;&#125;</code>；</li>
<li>小写开头调用，但定义时用开头大写，<code>&#123;&#123;price|test&#125;&#125;</code>，test对使用Test定义的filter有效；</li>
<li>自然回溯原型链，但对于filter作用不大，除非是与原型链上属性或函数同名！</li>
</ol>
<ul>
<li>filter的特点</li>
</ul>
<ol>
<li>filter不会被代理到vm实例上；     </li>
<li>filter不会绑定vm作为上下文。</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>vnode的内部实现</title>
    <url>/blog/2019/11/21/vnode%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>path: vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;vnode.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?<span class="built_in">string</span>; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    tag?: <span class="built_in">string</span>,</span><br><span class="line">    data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">    children?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">    text?: <span class="built_in">string</span>,</span><br><span class="line">    elm?: <span class="title class_">Node</span>,</span><br><span class="line">    context?: <span class="title class_">Component</span>,</span><br><span class="line">    componentOptions?: <span class="title class_">VNodeComponentOptions</span>,</span><br><span class="line">    asyncFactory?: <span class="title class_">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 标签名，小写</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标签上的属性数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 儿子虚拟节点（vnode）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真是元素的引用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点所在vue实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// v-for元素的key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncFactory</span> = asyncFactory</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncMeta</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAsyncPlaceholder</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get child (): <span class="title class_">Component</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createEmptyVNode</span> = (<span class="params">text: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">VNode</span>()</span><br><span class="line">  node.<span class="property">text</span> = text</span><br><span class="line">  node.<span class="property">isComment</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span> (<span class="attr">val</span>: <span class="built_in">string</span> | <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optimized shallow clone</span></span><br><span class="line"><span class="comment">// used for static nodes and slot nodes because they may be reused across</span></span><br><span class="line"><span class="comment">// multiple renders, cloning them avoids errors when DOM manipulations rely</span></span><br><span class="line"><span class="comment">// on their elm reference.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cloneVNode</span> (<span class="attr">vnode</span>: <span class="title class_">VNode</span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    vnode.<span class="property">tag</span>,</span><br><span class="line">    vnode.<span class="property">data</span>,</span><br><span class="line">    <span class="comment">// #7975</span></span><br><span class="line">    <span class="comment">// clone children array to avoid mutating original in case of cloning</span></span><br><span class="line">    <span class="comment">// a child.</span></span><br><span class="line">    vnode.<span class="property">children</span> &amp;&amp; vnode.<span class="property">children</span>.<span class="title function_">slice</span>(),</span><br><span class="line">    vnode.<span class="property">text</span>,</span><br><span class="line">    vnode.<span class="property">elm</span>,</span><br><span class="line">    vnode.<span class="property">context</span>,</span><br><span class="line">    vnode.<span class="property">componentOptions</span>,</span><br><span class="line">    vnode.<span class="property">asyncFactory</span></span><br><span class="line">  )</span><br><span class="line">  cloned.<span class="property">ns</span> = vnode.<span class="property">ns</span></span><br><span class="line">  cloned.<span class="property">isStatic</span> = vnode.<span class="property">isStatic</span></span><br><span class="line">  cloned.<span class="property">key</span> = vnode.<span class="property">key</span></span><br><span class="line">  cloned.<span class="property">isComment</span> = vnode.<span class="property">isComment</span></span><br><span class="line">  cloned.<span class="property">fnContext</span> = vnode.<span class="property">fnContext</span></span><br><span class="line">  cloned.<span class="property">fnOptions</span> = vnode.<span class="property">fnOptions</span></span><br><span class="line">  cloned.<span class="property">fnScopeId</span> = vnode.<span class="property">fnScopeId</span></span><br><span class="line">  cloned.<span class="property">asyncMeta</span> = vnode.<span class="property">asyncMeta</span></span><br><span class="line">  cloned.<span class="property">isCloned</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> cloned</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>nextTick实现原理</title>
    <url>/blog/2019/11/20/nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">nextTick的实现逻辑</a></li>
<li><a href="#timerFunc%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">timerFunc是什么？</a></li>
<li><a href="#timerFunc%E7%9A%84%E5%AE%9E%E7%8E%B0">timerFunc的实现</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>vue版本：<code>2.6.9</code>；</li>
<li>path：<code>vue/src/core/util/next-tick.js</code>；</li>
</ul>
<p>&amp;nbsp;</p>
<h1 id="nextTick的实现逻辑"><a href="#nextTick的实现逻辑" class="headerlink" title="nextTick的实现逻辑"></a>nextTick的实现逻辑</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入nextTick，首先会点cb进行封装，涉及三个控制流！</p>
<ol>
<li>如果存在cb，则调用cb函数：<code>cb.call(ctx)</code>；</li>
<li>如果<code>_resolve</code>存在，则调用 <code>_resolve(ctx)</code>，<code>_resolve</code>是<code>Promise.resolve</code>的引用！这是在当前环境支持<code>Promise</code>；</li>
<li>不做任何处理。</li>
</ol>
<p>在将<code>cb</code>推入<code>callbacks</code>后，判断当前是不是正在执行上次<code>callbacks</code>的回调函数，根据pending（待定）来判断，当前是否要执行新的<code>callbacks</code>的cb！</p>
<p>先假设当前<code>pending = fakse</code>，那么进入<code>if (!pending)</code>，执行<code>timerFunc()</code>！</p>
<p>&amp;nbsp;</p>
<h1 id="timerFunc是什么？"><a href="#timerFunc是什么？" class="headerlink" title="timerFunc是什么？"></a>timerFunc是什么？</h1><p><code>timerFunc</code>，是一个可将当前<code>callbacks</code>作为一个回调函数（这个包裹的函数就是下面的<code>flushCallbacks</code>），入队微&#x2F;宏任务队列中，等待主线程代码执行完毕之后执行！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  <span class="comment">// 立刻执行 “pending = false” 意味着，在主线程代码执行完，</span></span><br><span class="line">  <span class="comment">// 轮到当前这个 “flushCallbacks()” 被放入主线程执行开始</span></span><br><span class="line">  <span class="comment">// 就可以进入 &quot;if (!pending)&quot; 控制流再次执行触发 “timerFunc()”，</span></span><br><span class="line">  <span class="comment">// 将新的“flushCallbacks” 放进微/宏任务队列</span></span><br><span class="line">  <span class="comment">// 而不是等到 上一次 “callbacks” 的所有cb执行完之后</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>timerFunc</code>根据当前环境的支持情况可能用<code>Promise</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code>实现！优先级：<code>Promise</code> &gt; <code>MutationObserver</code> &gt; <code>setImmediate</code> &gt; <code>setTimeout</code>。</p>
<ul>
<li>微任务（micro task）：Promise、MutationObserver；</li>
<li>宏任务（macro task）：setImmediate、setTimeout。</li>
</ul>
<p>任务调用优先级：微任务 &gt; 宏任务。</p>
<p>关于为什么这样的优先级，vue做了说明：</p>
<blockquote>
<p>Here we have async deferring wrappers using microtasks. In 2.5 we used (macro) tasks (in combination with microtasks).However, it has subtle problems when state is changed right before repaint(e.g. #6813, out-in transitions).Also, using (macro) tasks in event handler would cause some weird behaviors that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109). So we now use microtasks everywhere, again.A major drawback of this tradeoff is that there are some scenarios where microtasks have too high a priority and fire in between supposedly sequential events (e.g. #4521, #6690, which have workarounds) or even between bubbling of the same event (#6566).</p>
<p>这里我们使用微任务异步延迟包装器。在2.5中，我们使用了（宏）任务（与微任务结合使用），但是当重新绘制之前状态发生改变时它存在一些细微的问题（例如＃6813，输出转换）。在事件处理程序中使用（宏）任务会导致一些无法避免的怪异行为（例如＃7109，＃7153，＃7546，＃7834，＃8109）。因此，我们现在再次在各处使用微任务。 是在某些情况下，微任务的优先级过高，并且在假定的顺序事件之间（例如＃4521，＃6690，它们具有变通方法）甚至在同一事件冒泡之间也会触发（＃6566）。</p>
</blockquote>
<p>&amp;nbsp;</p>
<h1 id="timerFunc的实现"><a href="#timerFunc的实现" class="headerlink" title="timerFunc的实现"></a>timerFunc的实现</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br></pre></td></tr></table></figure>



<h3 id="Promise实现timerFunc"><a href="#Promise实现timerFunc" class="headerlink" title="Promise实现timerFunc"></a>Promise实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="comment">// 在有问题的UIWebViews中，Promise.then并不会完全中断，但是它可能会陷入一种怪异的状态，</span></span><br><span class="line">    <span class="comment">// 在这种状态中，回调被推送到微任务队列中，但是队列没有被刷新，直到浏览器需要执行其他一些工作，</span></span><br><span class="line">    <span class="comment">// 例如 处理一个计时器。 因此，我们可以通过添加空计时器来“强制”刷新微任务队列。</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MutationObserver实现timerFunc"><a href="#MutationObserver实现timerFunc" class="headerlink" title="MutationObserver实现timerFunc"></a>MutationObserver实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="comment">// 在本地Promise不可用的地方使用MutationObserver，</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// （＃6466 MutationObserver在IE11中不可靠）</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setImmediate实现timerFunc"><a href="#setImmediate实现timerFunc" class="headerlink" title="setImmediate实现timerFunc"></a>setImmediate实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  <span class="comment">// 退回到setImmediate。</span></span><br><span class="line">  <span class="comment">// 从技术上讲，它利用（宏）任务队列，</span></span><br><span class="line">  <span class="comment">// 但它仍然是比setTimeout更好的选择。</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setTimeout实现timerFunc"><a href="#setTimeout实现timerFunc" class="headerlink" title="setTimeout实现timerFunc"></a>setTimeout实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>v-for的原理分析</title>
    <url>/blog/2019/11/19/v-for%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#v-for%E7%9A%84%E5%87%BD%E6%95%B0%E6%96%87%E6%9C%AC">v-for的函数文本</a></li>
<li><a href="#renderList%E7%9A%84%E5%AE%9E%E7%8E%B0">renderList的实现</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>使用<code>parse</code>解析模板生成<code>ast</code>，<code>v-for</code>相关的属性；</li>
<li>使用<code>generate</code>，结合<code>ast</code>生成函数文本（<code>code</code>），包含<code>v-for</code>的函数文本是<code>_l(/* ... */)</code>;</li>
<li>结合<code>code</code>构造<code>render_watcher.update()</code>，从而渲染<code>v-for</code>元素。</li>
</ul>
<p>接下来使用一下例子结合源码进行学习：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">v-for</span>=<span class="string">&quot;(name, idx) in names&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;idx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">names</span>: [<span class="string">&#x27;isaac&#x27;</span>, <span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;rick&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="v-for的函数文本"><a href="#v-for的函数文本" class="headerlink" title="v-for的函数文本"></a>v-for的函数文本</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>解析模板的入口</strong>：<code>vue/src/compiler/index.js</code></p>
<p><code>ast</code>由<code>parse</code>返回，所以先深入去parse是怎么生成<code>v-for</code>的<code>ast</code>!</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="comment">// parse 生产 ast</span></span><br><span class="line">  <span class="title function_">log</span>(<span class="string">&#x27;ast:&#x27;</span>, ast);</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// generate 生产 渲染用的函数文本</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="解析出ast"><a href="#解析出ast" class="headerlink" title="解析出ast"></a>解析出<code>ast</code></h2><p>解析视图模板主要由<code>parseHTML</code>函数实现，而这个函数是比较长，<code>parseHTML</code>对<code>v-for</code>相关信息的解析，先说明用到的函数，以及对应的作用：</p>
<ol>
<li><code>const startTagMatch = parseStartTag()</code>，parseStartTag是解析开始标签，主要是解析：a. 开始标签这段文本在整个html文本的开始和结束位置，b. 标签内的属性文本的位置，比如<code>v-for=&quot;(name, idx) in names&quot;</code>的开始和结束位置。</li>
<li><code>handleStartTag(startTagMatch)</code>，根据位置信息进一步接续出属性值，比如<code>&#123; name: &#39;v-for&#39;, value: &#39;(name, idx) in names&#39; &#125;</code>。<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert HTML string to AST.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span> (</span><br><span class="line">  <span class="attr">template</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">ASTElement</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    start (tag, attrs, unary, start, end) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">element</span>: <span class="title class_">ASTElement</span> = <span class="title function_">createASTElement</span>(tag, attrs, currentParent)</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;element:&#x27;</span>, element);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseHTML</span> (html, options) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (html) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Start tag: 记录属性文本在争端元素字符串开始和结束的位置</span></span><br><span class="line">    <span class="keyword">const</span> startTagMatch = <span class="title function_">parseStartTag</span>()</span><br><span class="line">    <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">      <span class="comment">// 根据 parseStartTag 解析出来的位置信息，进一步将文本解析成对象解构的属性</span></span><br><span class="line">      <span class="title function_">handleStartTag</span>(startTagMatch)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// advance(推进)，更新html文本</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">advance</span> (n) &#123;</span><br><span class="line">    index += n</span><br><span class="line">    html = html.<span class="title function_">substring</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 找出开始标签的start-index和end-index，</span></span><br><span class="line">  <span class="comment">// 比如&lt;span name=&quot;isaac&quot;&gt;&lt;/span&gt;中的开始标签就是&lt;span name=&quot;isaac&quot;&gt;</span></span><br><span class="line">  <span class="comment">// 2. 找出每个属性文本的始和终index</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">parseStartTag</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> start = html.<span class="title function_">match</span>(startTagOpen)</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;html.match(startTagOpen):&#x27;</span>, html);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      <span class="keyword">const</span> match = &#123;</span><br><span class="line">        <span class="attr">tagName</span>: start[<span class="number">1</span>],</span><br><span class="line">        <span class="attr">attrs</span>: [],</span><br><span class="line">        <span class="attr">start</span>: index</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">advance</span>(start[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">let</span> end, attr</span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        !(end = html.<span class="title function_">match</span>(startTagClose))</span><br><span class="line">        &amp;&amp; (</span><br><span class="line">          attr = html.<span class="title function_">match</span>(dynamicArgAttribute)</span><br><span class="line">          || html.<span class="title function_">match</span>(attribute)</span><br><span class="line">        )</span><br><span class="line">      ) &#123;</span><br><span class="line">        attr.<span class="property">start</span> = index</span><br><span class="line">        <span class="title function_">advance</span>(attr[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        attr.<span class="property">end</span> = index</span><br><span class="line">        match.<span class="property">attrs</span>.<span class="title function_">push</span>(attr)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (end) &#123;</span><br><span class="line">        match.<span class="property">unarySlash</span> = end[<span class="number">1</span>]</span><br><span class="line">        <span class="title function_">advance</span>(end[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        match.<span class="property">end</span> = index</span><br><span class="line">        <span class="keyword">return</span> match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 parseStartTag, 得到的文职信息，以及属性的匹配信息</span></span><br><span class="line">  <span class="comment">// 将属性信息从文本解析成对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStartTag</span> (match) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = match.<span class="property">attrs</span>[i]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">const</span> attrItem = &#123;</span><br><span class="line">        <span class="attr">name</span>: args[<span class="number">1</span>],</span><br><span class="line">        <span class="attr">value</span>: <span class="title function_">decodeAttr</span>(value, shouldDecodeNewlines)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;attrItem:&#x27;</span>, attrItem)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * it-1: &quot;attrItem:&quot; &#123;name: &quot;v-for&quot;, value: &quot;(name, idx) in names&quot;&#125;</span></span><br><span class="line"><span class="comment">       * it-2: &quot;attrItem:&quot; &#123;name: &quot;:key&quot;, value: &quot;idx&quot;&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      attrs[i] = attrItem;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log(&#x27;stack:&#x27;, JSON.parse(JSON.stringify(stack)));</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">start</span>) &#123;</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;attrs:&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(attrs)));</span><br><span class="line">      options.<span class="title function_">start</span>(tagName, attrs, unary, match.<span class="property">start</span>, match.<span class="property">end</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedAttr = <span class="regexp">/&amp;(?:lt|gt|quot|amp|#39);/g</span></span><br><span class="line"><span class="keyword">const</span> encodedAttrWithNewLines = <span class="regexp">/&amp;(?:lt|gt|quot|amp|#39|#10|#9);/g</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeAttr</span> (value, shouldDecodeNewlines) &#123;</span><br><span class="line">  <span class="keyword">const</span> re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">replace</span>(re, <span class="function"><span class="params">match</span> =&gt;</span> decodingMap[match])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p><code>log(&#39;attrs:&#39;, JSON.parse(JSON.stringify(attrs)));</code><br><img src="/blog/./asset/attrs.png"></p>
</li>
<li><p><code>log(&#39;element:&#39;, element)</code><br><img src="/blog/./asset/element.jpg"></p>
</li>
<li><p><code>log(&#39;ast:&#39;, ast)</code><br><img src="/blog/./asset/ast.jpg"></p>
</li>
</ul>
<h2 id="根据ast解析出函数文本"><a href="#根据ast解析出函数文本" class="headerlink" title="根据ast解析出函数文本"></a>根据ast解析出函数文本</h2><p>path: vue&#x2F;src&#x2F;compiler&#x2F;codegen&#x2F;index.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">generate</span> (</span><br><span class="line">  <span class="attr">ast</span>: <span class="title class_">ASTElement</span> | <span class="built_in">void</span>,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CodegenResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> <span class="title class_">CodegenState</span>(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? <span class="title function_">genElement</span>(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: state.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="attr">el</span>: <span class="title class_">ASTElement</span>, <span class="attr">state</span>: <span class="title class_">CodegenState</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> forCode = <span class="title function_">genFor</span>(el, state);</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;forCode&#x27;</span>, forCode);</span><br><span class="line">    <span class="comment">// output: &quot;forCode&quot; &quot;_l((names),function(name,idx)&#123;return _c(&#x27;dl&#x27;,&#123;key:idx&#125;,[_c(&#x27;dt&#x27;,[_v(&quot;name:&quot;)]),_v(&quot; &quot;),_c(&#x27;dd&#x27;,[_v(_s(name))])])&#125;)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> forCode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>path: vue&#x2F;src&#x2F;compiler&#x2F;codegen&#x2F;index.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genFor</span> (</span><br><span class="line">  <span class="attr">el</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">CodegenState</span>,</span><br><span class="line">  altGen?: <span class="title class_">Function</span>,</span><br><span class="line">  altHelper?: <span class="built_in">string</span></span><br><span class="line">): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">...rest</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>(), <span class="string">`genFor-<span class="subst">$&#123;rest.shift()&#125;</span>`</span>, ...rest);</span><br><span class="line">  <span class="comment">// exp这名变量名也提醒我们：被遍历的目标，可以直接是变量名，也可以是一段可执行的语句</span></span><br><span class="line">  <span class="keyword">const</span> exp = el.<span class="property">for</span></span><br><span class="line">  <span class="comment">// 成员临时别名</span></span><br><span class="line">  <span class="keyword">const</span> alias = el.<span class="property">alias</span></span><br><span class="line">  <span class="comment">// &lt;div v-for=&quot;(value, name, index) in object&quot;&gt;，中的 name</span></span><br><span class="line">  <span class="keyword">const</span> iterator1 = el.<span class="property">iterator1</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator1&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// &lt;div v-for=&quot;(value, name, index) in object&quot;&gt;，中的 index</span></span><br><span class="line">  <span class="keyword">const</span> iterator2 = el.<span class="property">iterator2</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator2&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">  el.<span class="property">forProcessed</span> = <span class="literal">true</span> <span class="comment">// avoid recursion</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="string">`<span class="subst">$&#123;altHelper || <span class="string">&#x27;_l&#x27;</span>&#125;</span>((<span class="subst">$&#123;exp&#125;</span>),`</span> +</span><br><span class="line">    <span class="string">`function(<span class="subst">$&#123;alias&#125;</span><span class="subst">$&#123;iterator1&#125;</span><span class="subst">$&#123;iterator2&#125;</span>)&#123;`</span> +</span><br><span class="line">      <span class="comment">// genElement递归生成</span></span><br><span class="line">      <span class="string">`return <span class="subst">$&#123;(altGen || genElement)(el, state)&#125;</span>`</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">renderList</span>((names), <span class="keyword">function</span>(<span class="params">name,idx</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;dl&#x27;</span>, &#123;<span class="attr">key</span>:idx&#125;, [</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dt&#x27;</span>, [<span class="title function_">createTextVNode</span>(<span class="string">&quot;name:&quot;</span>)]),</span><br><span class="line">    <span class="title function_">createTextVNode</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dd&#x27;</span>, [<span class="title function_">createTextVNode</span>(<span class="title function_">toString</span>(name))])</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="renderList的实现"><a href="#renderList的实现" class="headerlink" title="renderList的实现"></a>renderList的实现</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>由上面知道最后<code>v-for</code>html段落最后被解析出来的函数文本：<br>解析v-for模板的函数文本</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">_l</span>((names), <span class="keyword">function</span>(<span class="params">name,idx</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;dl&#x27;</span>, &#123;<span class="attr">key</span>:idx&#125;, [</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dt&#x27;</span>, [<span class="title function_">_v</span>(<span class="string">&quot;name:&quot;</span>)]),</span><br><span class="line">    <span class="title function_">_v</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dd&#x27;</span>, [<span class="title function_">_v</span>(<span class="title function_">_s</span>(name))])</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>全局搜索一下<code>_l</code>就可以找到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">installRenderHelpers</span> (<span class="attr">target</span>: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.<span class="property">_l</span> = renderList</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderList函数是<code>vm._l</code>的实现，它的功能是遍历<code>v-for=&quot;item in list&quot;</code>中的list，list可以有多种不同的类型！注意遍历是这个函数功能，元素的渲染则是依赖renderList函数的第二个参数：<code>ender: (val: any, keyOrIndex: string | number, index?: number) =&gt; VNode</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, isDef, hasSymbol &#125; <span class="keyword">from</span> <span class="string">&#x27;core/util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for rendering v-for lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderList</span> (</span><br><span class="line">  <span class="comment">// 遍历的目标</span></span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="comment">// 渲染函数</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">val: <span class="built_in">any</span>, keyOrIndex: <span class="built_in">string</span> | <span class="built_in">number</span>, index?: <span class="built_in">number</span></span>) =&gt;</span> <span class="title class_">VNode</span></span><br><span class="line">): ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ret</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;, i, l, keys, key</span><br><span class="line">  <span class="comment">// 1. 遍历一个数组</span></span><br><span class="line">  <span class="comment">// 2. 遍历一个字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) || <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="title class_">Array</span>(val.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      ret[i] = <span class="title function_">render</span>(val[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 3. 循环 val 次</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="title class_">Array</span>(val)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">      ret[i] = <span class="title function_">render</span>(i + <span class="number">1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 遍历一个对象</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isObject</span>(val)) &#123;</span><br><span class="line">    <span class="comment">// 4.1 遍历迭代器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下内置类型拥有默认的@<span class="doctag">@iterator</span>方法：</span></span><br><span class="line"><span class="comment">     *  Array.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  TypedArray.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  String.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  Map.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  Set.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (hasSymbol &amp;&amp; val[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]) &#123;</span><br><span class="line">      ret = []</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">iterator</span>: <span class="title class_">Iterator</span>&lt;<span class="built_in">any</span>&gt; = val[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">      <span class="keyword">let</span> result = iterator.<span class="title function_">next</span>()</span><br><span class="line">      <span class="keyword">while</span> (!result.<span class="property">done</span>) &#123;</span><br><span class="line">        ret.<span class="title function_">push</span>(<span class="title function_">render</span>(result.<span class="property">value</span>, ret.<span class="property">length</span>))</span><br><span class="line">        result = iterator.<span class="title function_">next</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.2 遍历常规对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="title class_">Array</span>(keys.<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = <span class="title function_">render</span>(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isDef</span>(ret)) &#123;</span><br><span class="line">    ret = []</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="attr">ret</span>: <span class="built_in">any</span>).<span class="property">_isVList</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以知道，<code>v-for</code>可以遍历以下几种类型</p>
<ol>
<li>遍历数组</li>
<li>遍历类数组的字符串</li>
<li>循环指定次数</li>
<li>遍历迭代器</li>
<li>遍历常规对象</li>
</ol>
<p>遍历迭代器可能用得比较少，下面有个不算很好的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>myIterable: <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in myIterable&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;: &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">myIterable</span>: (<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myIterable = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">3</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> myIterable;</span></span><br><span class="line"><span class="language-javascript">      &#125;)()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>迭代器的详细分析参考：<a href="#">什么是迭代器？</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  start (tag, attrs, unary, start, end) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">element</span>: <span class="title class_">ASTElement</span> = <span class="title function_">createASTElement</span>(tag, attrs, currentParent)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!element.<span class="property">processed</span>) &#123;</span><br><span class="line">      <span class="comment">// structural directives</span></span><br><span class="line">      <span class="title function_">processFor</span>(element)</span><br><span class="line">      <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ul>
<li>v-for视图解析到渲染成html文段的过程</li>
</ul>
<ol>
<li>使用<code>parse</code>方法解析视图模板，生成ast，其中主要的三个函数是: a. parseStartTag解析属性等主要信息的位置，b. handleStartTag解析属性，c. createASTElement根据解析出的属性等生成元素的ast；</li>
<li>使用<code>generate</code>将ast转化成函数文本，<code>_l</code>（<code>renderlist</code>）即是<code>v-for</code>视图的文本函数，其中主要函数是<code>genElement</code>，可递归生成后代元素的函数文本；</li>
<li>函数文本作为render-watcher.update方法主逻辑</li>
</ol>
<ul>
<li>从<code>renderlist</code>中可以看出v-for可以遍历以下几种类型</li>
</ul>
<ol>
<li>遍历数组</li>
<li>遍历类数组的字符串</li>
<li>循环指定次数</li>
<li>遍历迭代器</li>
<li>遍历常规对象</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>多角度剖析计算属性的运行机制</title>
    <url>/blog/2019/11/19/%E5%A4%9A%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6">计算属性的更新机制</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96">计算属性如何收集依赖</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<span id="more"></span>

<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性的初始化过程"><a href="#计算属性的初始化过程" class="headerlink" title="计算属性的初始化过程"></a>计算属性的初始化过程</h1><p>在创建Vue实例时调用<code>this._init</code>初始化。</p>
<p>其中就有调用<code>initState</code>初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initState会初始化计算属性：调用<code>initComputed</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>, <span class="attr">computed</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历computed</p>
<p>先创建计算属性的watcher实例，留意<code>computedWatcherOptions</code>这个option决定了计算属性的watcher和普通watcher的不同</p>
<p>然后定义计算属性的属性的getter和setter</p>
<ul>
<li>再来看看watcher的创建</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: <span class="built_in">string</span> | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: <span class="built_in">boolean</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>watcher.lazy = true</code>;</li>
<li><code>watcher.dirty = true</code>;</li>
<li><code>watcher.getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get</code></li>
<li>不会在构造函数内调用watcher.get()&#96;(非计算属性的watcher&#x2F;lazy watcher会在创建watcher实例时调用)</li>
</ol>
<ul>
<li>再来看计算属性defineProperty的定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComputed</span> (</span><br><span class="line">  <span class="attr">target</span>: any,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">userDef</span>: <span class="title class_">Object</span> | <span class="title class_">Function</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !<span class="title function_">isServerRendering</span>()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = shouldCache</span><br><span class="line">      ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">      : <span class="title function_">createGetterInvoker</span>(userDef)</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = userDef.<span class="property">get</span></span><br><span class="line">      ? shouldCache &amp;&amp; userDef.<span class="property">cache</span> !== <span class="literal">false</span></span><br><span class="line">        ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">        : <span class="title function_">createGetterInvoker</span>(userDef.<span class="property">get</span>)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = userDef.<span class="property">set</span> || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shouldCache</code>，浏览器渲染都是 <code>shouldCache = true</code></p>
<p>那么gtter就是由<code>createComputedGetter</code>方法创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span> (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        watcher.<span class="title function_">depend</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是计算属性的的初始化过程。</p>
<p>&amp;nbsp;&amp;nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性被访问时的运行机制"><a href="#计算属性被访问时的运行机制" class="headerlink" title="计算属性被访问时的运行机制"></a>计算属性被访问时的运行机制</h1><p>如上，假设计算属性当前被调用</p>
<p>就是触发计算属性的getter，再次强调：计算属性的getter不是用户定义的回调，而是由<code>createComputedGetter </code>返回的函数（详细参考<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a>的最后一段代码）。<br>用户定义的回调则是在计算属性getter的逻辑中进行调用。</p>
<p>计算属性getter中主要由两个if控制流，<br>这个两个if组合起来就可能由四种可能，<br>对于第二个控制流的逻辑<code>watcher.depend</code>，如果有看到Vue的Dep的功能的话，可以推测这段代码是用于收集依赖，<br>结合以上可以如下推测：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th><code>if (watcher.dirty)</code></th>
<th><code>if (Dep.target)</code></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>N</td>
<td>N</td>
<td>返回旧值</td>
</tr>
<tr>
<td>2</td>
<td>N</td>
<td>Y</td>
<td>收集依赖</td>
</tr>
<tr>
<td>3</td>
<td>Y</td>
<td>N</td>
<td>更新计算属性值（watcher.value）</td>
</tr>
<tr>
<td>4</td>
<td>Y</td>
<td>Y</td>
<td>收集依赖，并更新计算属性值（watcher.value）</td>
</tr>
</tbody></table>
<p>目前掌握的信息有：</p>
<ol>
<li>计算属性的getter是核心功能就是获取计算属性的值，而getter返回的是<code>watcher.value</code>，说明计算属性的值保存在<code>watcher.value</code>；</li>
<li>evaluate可能是用于更新watcher.value;</li>
<li>watcher.depend可能是用于收集依赖，不清楚收集什么；</li>
</ol>
<p>我们先来看第一个控制流：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watcher.dirty = true</span></span><br><span class="line"><span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">  watcher.evaluate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a>中创建计算属性watcher实例时就可以看出，第一次调用watcher.dirty肯定是<code>true</code>。</p>
<p>但不论watcher.dirty是不是“真”，我们都要去看看“evaluate ”时何方神圣，而且肯定会有访问它的时候。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，evaluate确实是用于更新计算属性值（watcher.value）的。</p>
<p>另外，你可以发现在<code>this.value = this.get()</code>执行完后，还执行了一句代码：<code>this.dirty = false</code>。</p>
<p>然后你会发现一个逻辑：</p>
<ol>
<li>初始化计算属性时，watcher.dirty &#x3D; true；</li>
<li>执行evaluate更新后，watcher.dirty &#x3D; false；</li>
<li>watcher.dirty &#x3D; false 时不会去更新计算属性的值。</li>
</ol>
<p>一切说明计算属性是懒加载的，在访问时根据状态值来判断使用缓存数据还是重新计算。</p>
<p>再者，我们还可以再总结一下dirty和lazy的信息：</p>
<p>对比普通的watcher实例创建：</p>
<p>构造函数中的逻辑</p>
<table>
<thead>
<tr>
<th>normal</th>
<th>computed</th>
</tr>
</thead>
<tbody><tr>
<td><code>this.value = this.get()</code></td>
<td><code>this.value = undefined</code></td>
</tr>
<tr>
<td><code>this.lazy = false</code></td>
<td><code>this.lazy = true</code></td>
</tr>
<tr>
<td><code>this.dirty = false</code></td>
<td><code>this.dirty = true</code></td>
</tr>
</tbody></table>
<p> 综上，可以看出<br>lazy的意思</p>
<ul>
<li><p>实例化Watcher时调用get就是非lazy</p>
</li>
<li><p>非实例化Watcher时调用get就是lazy</p>
</li>
</ul>
<p>dirty（脏值）的意思</p>
<ul>
<li><code>watcher.value</code>还是<code>undefined（或者还不是最新值时）</code>就是dirty</li>
<li><code>watcher.value</code>已经存有当前计算的实际值就不是dirty</li>
</ul>
<p>lazy属性只是一个说明性的标志位，主要用来表明当前watcher是惰性模式的。<br>而dirty则是对lazy的实现，作为状态为表示当前是不是脏值状态。</p>
<p>再来看看<code>watcher.get()</code>的调用，其内部的动作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Dep</span>, &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">&#x27;./dep&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在get()函数开头的地方调用<code>pushTarget</code>函数，为了接下来的内容，有必要先说明下<code>pushTarget</code>和结尾处的<code>popTarget</code>，根据字面意思就知道是对什么进行入栈出栈。</p>
<p>你可以看到是该方法来自于dep，具体函数实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="attr">target</span>: ?<span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> () &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，pushTarget和popTarget操作的对象是Watcher，存放在全局变量<code>targetStack</code>中。每次出栈入栈都会更新Dep.target的值，而它值由上可知是targetStack的栈顶元素。</p>
<p>现在就知道<code>pushTarget(this)</code>的意思是：将当前的watcher入栈，并设置Dep.Target为当前watcher。</p>
<p>然后就是执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br></pre></td></tr></table></figure>

<p>计算属性watcher的getter是什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watcher.<span class="property">getter</span> = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="property">get</span></span><br></pre></td></tr></table></figure>

<p>是用户定义的回调函数，计算属性的回调函数。<br>回顾这一节开头的结论：</p>
<blockquote>
<p>用户定义的回调则是在计算属性getter的逻辑中进行调用。</p>
</blockquote>
<p>到此，我们就可以清晰知道：用户定义的getter是在computedWatcher.get()中调用！<br>用一段伪代码表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">computedGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  computedWatcher.<span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    computedWatcher.<span class="property">value</span> = computedWatcher.<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> 用户定义的<span class="title function_">getter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用完getter算是完事没有呢？没有，这里还有一层隐藏的逻辑！</p>
<p>我们知道一般计算属性都依赖于<code>$data</code>的属性，而调用计算属性的回调函数就会访问这些属性，就会触发这些属性的getter。</p>
<p>这些基础属性的getter就是隐藏的逻辑，如果你有看过基础属性的数据劫持就知道他们的getter都是有收集依赖的逻辑。</p>
<p>这些基本属性的getter都是在数据劫持的时候定义的，我们去看看会发生什么！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得刚刚调用了<code>pushTarget</code>吧，现在<code>Dep.target</code>已经不为空，并且<code>Dep.target</code>就是当前计算属性的watcher。</p>
<p>则会执行<code>dep.depend()</code>，dep是每个<code>$data</code>属性关联的（通过闭包关联）。</p>
<p>dep是依赖收集器，收集watcher，用一个数组（dep.subs）存放watcher，</p>
<p>而执行<code>dep.depend()</code>，除了执行其他逻辑，里面还有一个关键逻辑就是将<code>Dep.target</code>push到当前属性关联的dep.subs，言外之意就是，计算属性的访问在条件适合的情况下是会让计算属性所依赖的属性收集它的wathcer，而这个收集操作的作用且听下回分解。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>计算watcher.value：computed-watcher.evaluate()，访问计算属性时，若当前计算属性是脏值状态则调用evaluate计算计算属性的真实值；</li>
<li>在计算计算属性真实值时，合乎条件下会触发它依赖的基础属性收集它的watcher。</li>
</ol>
<p>&amp;nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性的更新机制"><a href="#计算属性的更新机制" class="headerlink" title="计算属性的更新机制"></a>计算属性的更新机制</h1><h3 id="如何通知变动"><a href="#如何通知变动" class="headerlink" title="如何通知变动"></a>如何通知变动</h3><p>计算属性所依赖属性的dep收集computed-watcher的意义何在呢？</p>
<p>假如现在更新计算属性依赖的任一个属性，会发生什么？</p>
<p>更新依赖的属性，当然是触发对应属性的setter，首先来看看基础属性setter的定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dep.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先是在setter里面调用<code>dep.notify()</code>，通知变动。dep当然就是与属性关联的依赖收集器，notfiy必然是去通知订阅者它们订阅的数据之一已经发生变动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在notify方法里面可以看出，遍历了当前收集里面所有（订阅者）watcher，并且调用了他们的update方法。</p>
<p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>已经知道，计算属性的watcher是会被它所依赖属性的dep收集的。因此，<code>notify</code>中的<code>subs</code>肯定也包含了计算属性的watcher。</p>
<p>所以，计算属性所依赖属性变动是通过调用计算属性watcher的update方法通知计算属性的。</p>
<p>接下来，在深入去看看watcher.update是怎么更新计算属性的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中就知道，计算属性watcher是lazy的，所以，comuptedWatcher.update的对应逻辑就是下面这一句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>再回想一下<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中计算属性getter调用evalute()的控制流逻辑（<code>if(watcher.dirty)</code>），这下计算属性的访问和他的被动更新就形成闭环！</p>
<p><strong>每次变化通知都是只更新脏值状态，真是计算还是访问的时候再计算</strong></p>
<h3 id="计算属性如何被更新"><a href="#计算属性如何被更新" class="headerlink" title="计算属性如何被更新"></a>计算属性如何被更新</h3><p>从上面我们就知道通知计算属性“变化”是不会直接引发计算属性的更新！</p>
<p>那么问题就来了，现实我们看到的是：绑定的视图上的计算属性的值，只要它所依赖的属性值更新，会直接响应到视图上。</p>
<p>那就说明在通知完之后，立即访问了计算属性，引起了计算属性值的更新，并且更新了视图。</p>
<p>对于，不是绑定在视图上的计算属性很好理解，毕竟我们也是在有需要的时候才会去访问他，相当于即时计算了（假如是脏值），因此不论是不是即时更新都无所谓，只要在访问时可以拿到最新的实际值就好。</p>
<p>但是对于视图却不一样，要即时反映出来，所以肯定是还有更新视图这一步的，我们现在需要做的测试找出vue是怎么做的。</p>
<p>其实假如你有去看过vue数据劫持的逻辑就知道：<strong>在访问属性时，只要当前的Dep.target（订阅者的引用）不为空，与这个属性关联的dep就会收集这个订阅者</strong></p>
<p>这个订阅者之一是“render-watcher”，它是视图对应的watcher，只要在视图上绑定了的属性都会收集这个render-watcher，所以每个属性的<code>dep.subs</code>都有一个render-watcher。</p>
<p>没错，就是这个render-watcher完成了对计算属性的访问与视图的更新。</p>
<p>到这里我们就可以小结一下计算属性对所依赖属性的响应机制：<br>所依赖属性更新，会通知该属性收集的所有watcher，调用update方法，其中就包含计算属性的watcher（computed-watcher），如果计算属性绑定在视图上，则还包含render-watcher，computed-watcher负责更新计算属性的脏值状态，render-watcher负责更新访问计算属性和更新视图。</p>
<p><strong>但是这里又引出了一个问题！</strong></p>
<p><em>假设现在计算属性就绑定在视图上，那么现在计算属性响应更新就需要两个watcher，分别是computed-watcher和render-watcher。</em></p>
<p><em>你细心点就会发现，要达到预期的效果，对这两个watcher.update()的调用顺序是有要求的！</em></p>
<p>必须要先调用computed-watcher.update()更新脏值状态，然后再调用render-watcher.update()去访问计算属性，才会去重新算计算属性的值，否者只会直接缓存的值watcher.value。</p>
<p>比如说有模板是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123; attr &#125;&#125;&lt;span&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123; computed &#125;&#125;&lt;span&gt;</span><br></pre></td></tr></table></figure>

<p>attr的dep.subs中的watcher顺序就是</p>
<p>情况1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[render-watcher, computed-watcher]</span><br></pre></td></tr></table></figure>

<p>反之就是</p>
<p>情况2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[computed-watcher, render-watcher]</span><br></pre></td></tr></table></figure>

<p>我们知道deo.notify的逻辑遍历调用subs里面的每个watcher.update</p>
<p>假如这个遍历的顺序是按照subs数组的顺序来更新的话，情况1就会有问题</p>
<p>情况1</p>
<p>是先触发视图watcher的更新，他会更新视图上所有绑定的属性，不论属性有没有更新过</p>
<p>然而此时<code>computed-watcher</code>的属性<code>dirty</code> 还是 <code>false</code>，这意味这着这个计算属性不会重新计算，而是使用已有的挂在<code>watcher.value</code>的旧值。</p>
<p>如果真是如此，之后在调用computred-watcher的update也没有意义了，除非重新调用render-watcher的update方法。</p>
<p>很明显，vue不可能那么蠢，肯定会做控制更新顺序的逻辑</p>
<p>我们看看notify方法的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">notify (key) &#123;</span><br><span class="line">  <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">    <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到控制流里面确实做了顺序控制</p>
<p>但是<code>process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async</code> 的输出是false呢</p>
<p>很直观，在生成环境就进不了这个环境！</p>
<p>然而，现实表现出来的结果是，就算没有进入这个控制流里面，视图还是正确更新了</p>
<p>更令人惊异的是：更新的遍历顺序确实是按着<code>[render-watcher, computed-watcher]</code>进行的</p>
<p><img src="https://user-images.githubusercontent.com/25907273/62833220-cbe8ce80-bc6d-11e9-9d4b-47d855bead48.png" alt="image"></p>
<p>你可以看到是先遍历了<code>render-watcher</code>(render-watcher的id肯定是最大的，越往后创建的watcher的id越大，计算属性是在渲染前创建，而render-watcher则是在渲染时)</p>
<p>但是如果你细心的话你可以发现，render-watcher更新回调是在遍历完所有的watcher之后才执行的（白色框）</p>
<p><img src="https://user-images.githubusercontent.com/25907273/62833231-ee7ae780-bc6d-11e9-9904-5e14647aa79a.png" alt="image"></p>
<p>我们再来看看<code>watcher.update</code>的内部逻辑</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;watcher.id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with lazy`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with sync`</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with queueWatcher`</span>)</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;update finish&#x27;</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="string">`this.dirty = <span class="subst">$&#123;<span class="variable language_">this</span>.dirty&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据打印的信息，可以看到render-watcher进入了else的逻辑，调用<code>queueWatcher(this)</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueWatcher</span> (<span class="attr">watcher</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;queueWatcher:&#x27;</span>, queue)</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">        <span class="title function_">flushSchedulerQueue</span>()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数名，可以知道是个watcher的队列</p>
<p>has是一个用于判断待处理watcher是否存在于队列中，并且在队中的每个watcher处理完都会将当前has[watcher.id] &#x3D; null</p>
<p>flushing这个变量是一个标记：是否正在处理队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">  queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">    i--</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是不同的将待处理watcher推入队列的方式。</p>
<p>然后接下来的逻辑，才是处理watcher队列</p>
<p><code>waitting</code>和<code>flushing</code>这两个标志标量大致相同，他们都会在watcher队列处理完之后重置为false</p>
<p>而不同的是waitting在最开始就会置为true，而flushing则是在调用<code>flushSchedulerQueue</code>函数的时候才会置为<code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br></pre></td></tr></table></figure>

<p>这一句是关键，nextTick，可以理解为一个微任务，即会在主线程任务调用完毕之后才会执行回调，</p>
<p>此时回调即是<code>flushSchedulerQueue</code>。</p>
<p>关于nextTick可以参考<a href="#">Vue：深入nextTick的实现</a></p>
<p>这样就可以解析：</p>
<blockquote>
<p>更令人惊异的是：更新的遍历顺序确实是按着<code>[render-watcher, computed-watcher]</code>进行的</p>
<p>但是如果你细心的话你可以发现，render-watcher更新回调是在遍历完所有的watcher之后才执行的（白色框）</p>
</blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>通过遍历调用dep.subs里的watcher.update方法（其中就包含computed-watcher）来通知计算属性基础属性已经更新，在下次访问计算属性时就是做脏值检测，然后重新计算计算属性。绑定在视图上的计算属性的即时更新是通过调用render-watcher的update方法达到，它会访问计算属性，并更新整个视图。</li>
<li>绑定在视图上的计算属性，它所依赖属性的dep.subs中，computed-watcher和render-watcher的顺序不会影响计算属性在视图上的正常更新，因为render-watcher的update方法的主体逻辑是放在微任务中执行，因此render-watcher.update()总是会在computed-watcher.update()之后执行。</li>
</ul>
<p>&amp;nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性如何收集依赖"><a href="#计算属性如何收集依赖" class="headerlink" title="计算属性如何收集依赖"></a>计算属性如何收集依赖</h1><p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6">计算属性的更新机制</a>中我们知道了计算属性所依赖属性的dep是会收集computed-watcher的，目的是为了通知计算属性当前依赖的属性已经发生变化。</p>
<p><em>那么计算属性为什么要收集依赖？是如何收集依赖的？</em></p>
<p>“计算属性所依赖属性的dep具体怎么收集computed-watcher”并没有展开详细说。现在我们来详细看看这部分逻辑。那就必然要从第一次访问计算属性开始， 第一次访问必然会调用<code>watcher.evaluate</code>去算计算属性的值，那就是必然会调用<code>computed-watcher.get()</code>，然后在get方法里面去调用用户定义的回调函数，算计算属性的值，调用用户定义的回调函数就必然会访问计算属性所依赖属性，那就必然触发他们的getter，没错我们就是要从这里开始看详细的逻辑，也是从这里开始收集依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算属性依赖的属性通过<code>dep.depend()</code>收集<code>computed-watcher</code>，展开<code>dep.depend()</code>看看详细逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # dep.js</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然现在的全局watcher就是computed-watcher，而<code>this</code>则是当前计算属性所依赖属性的dep（下面简称：<code>prop-dep</code>），继续展开<code>computed-watcher.addDep(prop-dep)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # watcher.js</span></span><br><span class="line">addDep (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在dep收集watcher的之前（dep.addSub(this)），watcher也在收集dep。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`this.newDeps.push(dep)`</span></span><br></pre></td></tr></table></figure>

<p>watcher收集dep就是接下来我们要说的点之一！</p>
<p>另外，上面的代码中还包含了之前没见过的三个变量<code>this.newDepIds</code>，<code>this.newDeps</code>，<code>this.depIds</code></p>
<p>先看看他们的声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>depIds</code>和<code>newDepIds</code>都是Set的数据结构，结合<code>if (!this.newDepIds.has(id))</code>和<code>!this.depIds.has(id)</code>就可以推断他们的功能是防止重复操作的。</p>
<p>到此，我们知道了<em>计算属性是如何收集依赖的</em>！并且，从上面知道了所收集的依赖是不重复的。</p>
<p>但是，到这里还没有结束！</p>
<p>这个<code>newDeps</code>并不是最终存放存放点，真实的dep存放点是deps，在上面声明你就可以看见它。</p>
<p>在调用<code>computed-watcher.get()</code>的过程中还有一个比较关键的方法没有给出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 在最后调用</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形如其名，就是用来清除dep的，清除newDeps，并且转移newDeps到Deps上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cleanupDeps () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 遍历deps，对比newDeps，看看哪些dep已经没有被当前的watcher收集</span></span><br><span class="line">  <span class="comment">// 如果没有，同样也解除dep对当前watcher的收集</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转存newDepIds到depIds</span></span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转存newDeps到Deps</span></span><br><span class="line">  tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行完<code>computed-watcher.get()</code>后的打印信息：<br><img src="https://user-images.githubusercontent.com/25907273/62833255-53ced880-bc6e-11e9-8c07-722e85c93e62.png"></p>
<p>从上面的分析我们可以知道：<em>计算属性的watcher会在计算值（watcher.evalute()）时，收集每个它依赖属性的dep，并最后存放在<code>watcher.deps</code>中</em></p>
<p>接下来再来探究<em>计算属性为什么要收集依赖</em>。</p>
<p>还记得计算属性的getter中的另一个控制流，一直没有展开细说。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">depend</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码可以知道，只有全局watcher（Dep.target）不为空，才会执行<code>watcher.depend()</code>，这就是要想的第一个问题：什么情况下全局watcher是不为空？</p>
<p>首先来确认下全局watcher的update机制：</p>
<ul>
<li>pushTarget和popTarget是成对出现的；</li>
<li>只有在watcher.get方法中才会入栈非空的watcher；</li>
<li>在执行watcher.get的开头pushTarget(this)，在结尾popTarget()，意味着在get方法调用完成后，全局watcher就变回调用get方法前的全局watcher。</li>
</ul>
<p>还记得computed的getter的逻辑吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">  watcher.evaluate()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">depend</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在脏值状态下会执行<code>watcher.evaluate()</code>，执行完已经完成watcher.get()的调用，所以watcher.evaluate不会影响到下面的<code>if (Dep.target)</code>判断。</p>
<p> pushTarget和popTarget是成对出现的，显然只有在调用完<code>pushTarget</code>后，且未调用popTarget这个时间段内调用计算属性才会执行<code>watcher.depend()</code>。另外，只有watcher.get()才会入栈非空的watcher，所以我们就可以再次缩小范围到：<em>在调用watcher.get()的过程中访问了计算属性</em>！</p>
<p>记得在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中有用表格对比过新建普通watcher和计算属性watcher实例的异同，其中普通watcher的创建就会在实例化的时候调用<code>this.get()</code>。</p>
<p>此刻让我想到了<code>render-watcher</code>，它就是一个普通的watcher，而且render-watcher是会访问绑定在视图上的所用属性，而且它访问视图上属性的过程就是在get方法里面的getter的调用中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="comment">// 那么全局watcer就是render-watcher了</span></span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 视图上的所有属性都在getter方法被访问，包括计算属性</span></span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下展开watcher.depend看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已经很明了，上面已经说过this.deps是计算属性收集的dep（它所依赖的dep），然后现在遍历deps，调用<code>dep.depend()</code>，上面也同样已经说过<code>dep.depend()</code>的功能是收集全局watcher。</p>
<p>所以，<code>watcher.depend()</code>的功能就是让计算属性收集的deps去收集当前的全局watcher。<br>而现在的全局watcher就是render-watcher！</p>
<p>现在我们知道<code>watcher.depend</code>的功能是让prop-dep去收集全局watcher，但是为什么要这么做？<br>不放将问题细化到render-watcher的场景上。为什么prop-watcher要去收集render-watcher？</p>
<p>首先，我要再次强调：<em>一个绑定在视图上的计算属性要即时响应所依赖属性的更新，那么这些依赖属性的dep.subs就必须包含<code>computed-watcher</code>和<code>render-watcher</code>，前者是用来更新计算属性的脏值状态，后者用来访问计算属性，让计算属性重新计算。并更新视图。</em></p>
<p>*计算属性所依赖属性的dep.subs中肯定会包含<code>computed-watcher</code>*，这一点不需要质疑，上面已经证明分析过！</p>
<p>但是，是否会包含<code>render-watcher</code>就不一定了！首先上面也有间接地提过，<em>绑定在视图上的属性，它的dep会收集到render-watcher</em>。那么，计算属性所依赖的属性，有可能存在一些是没有绑定在视图上，而是直接定义在<code>data</code>上而已，对于这些属性，它的dep.subs是肯定没有<code>render-watcher</code>的了。没有<code>render-watcher</code>意味着没有更新视图的能力。那么怎么办？那当然就是去保证它！</p>
<p>而<code>watcher.depend()</code>就起到了这个作用！它让计算属性所依赖的属性</p>
<p>对于这个推测</p>
<blockquote>
<p>绑定在视图上的属性，它的dep会收集到render-watcher</p>
</blockquote>
<p>我们可以探讨一下。</p>
<p>要一个vue.$data属性的dep去收集dep.subs没有的watcher需要具备两个条件：</p>
<ul>
<li>访问这个属性；</li>
<li>全局watcher（Dep.target）不为空;</li>
</ul>
<p>而没有绑定在视图上的属性，在render-watcher.get()调用的过程中就没有访问，没有访问就不会调用<code>dep.depend()</code>去收集<code>render-watcher</code>!</p>
<p>可能有人会问，在访问计算属性的时候不是有调用用户定义的回调吗？不就访问了这些依赖的属性？</p>
<p>是！确实是访问了，那个时候的Dep.target是computed-watcher。</p>
<p>ok，render-watcher这个场景也差不多了。我们该抽离表象看本质！</p>
<p>首先想想属性dep为什么要收集依赖（订阅者），因为有函数依赖了这个属性，希望这个属性在更新的时候通知订阅者。可以以此类比一下计算属性，计算属性的deps为什么需要收集依赖（订阅者），是不是也是因为有函数依赖了计算属性，希望计算属性在更新时通知订阅者，在想深一层：怎么样才算是计算属性更新？不就是它所依赖的属性发生变动吗？计算属性所依赖属性更新 &#x3D; 计算属性更新，计算属性更新就要通知依赖他的订阅者！再想想，计算属性所依赖属性更新就可以直接通知依赖计算属性的订阅者了，那么计算属性所依赖属性的dep直接收集依赖计算属性的订阅者就好了！这不就是<code>watcher.depend()</code>在做的事情吗？！</p>
<p>本质我们知道了，但是怎么才可以实现依赖计算属性！</p>
<p>首先全局watcher不为空！<br>怎么才会让Dep.target不为空！只有一个方法：调用<code>watcher.get()</code>，在vue里面只有这个方法会入栈非空的watcher，另外我们知道pushTarget和popTarget是成对出现的，即要在未调用popTarget前访问计算属性，怎么访问呢？pushTarget和popTarget分别在get方法的一头一尾，中间可以用户定义的只有一个地方！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">popTarget</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是getter，getter是可以由用户定义的~</p>
<p>再来getter具体存储的是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由上可以知道，一个有效的getter是有expOrFn决定，expOrFn如果是<code>Function</code>则getter就是用户传入的函数！如果是<code>String</code>则由parsePath进行构造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个访问vm属性（包含计算属性）的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parsePath</span> (<span class="attr">path</span>: string): any &#123;</span><br><span class="line">  <span class="comment">// 判断是否是一个有效的访问vm属性的路径</span></span><br><span class="line">  <span class="keyword">if</span> (bailRE.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，我们有两种手段可以让getter访问计算属性：<br>并且在此我不做说明，直接说结论，watch一个属性（包含计算属性），包括使用<code>$watch</code>都是会创建一个watcher实例的，而且是普通的watcher，即会在构造函数直接调用<code>watcher.get()</code>。</p>
<ul>
<li><p>直接watch计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;isaac&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">msg</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">msg</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this is computed property <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方法就是在创建实例时传进了一个路径，这个路径就是<code>msg</code>，即expOrFn是<code>String</code>，然后由<code>parsePath</code>构造getter，从而访问到计算属性。</p>
</li>
<li><p>使用<code>$watch</code>监听一个函数，函数中包含计算属性<br>$watch的用法可以参考<a href="https://cn.vuejs.org/v2/api/#vm-watch">vm.$watch</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">msg</span>;</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this is computed property <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法直接就传入一个函数，即expOrFn是<code>Function</code>，就是<code>$watch</code>的第一个参数！同样在getter中访问了计算属性。</p>
</li>
</ul>
<p>上面两种都是在getter中访问了计算属性，从而让deps收集订阅者，计算属性的变动（当然并非真的更新了值，只是进入脏值状态）就会通知依赖他的订阅者，调用<code>watcher.update()</code>，如果没有传入什么特殊的参数，就会调用watch的回调函数，如果在回调函数中有访问计算属性就会重新计算计算属性，更新状态为非脏值！</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>计算属性所依赖的属性的dep会收集computed-watcher，存放在<code>prop-dep.subs</code>中；</li>
<li>computed-watcher也会收集它所依赖的dep，存放在<code>computed-watcher.deps</code>中，为了确保计算属性获得通知依赖他的订阅者可以监听到他的变化，通过<code>watcher.depend()</code>来收集依赖它的订阅者。</li>
</ul>
<p>&amp;nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>计算属性在initState阶段初始化；</li>
<li>计算属性也是会使用defineProperty进行计算属性劫持；</li>
<li>每个计算属性都会关联一个特殊的watcher（lazy）。存放在一个对象中，以计算属性的名字作为键值，挂载在vm._computedWatchers_；</li>
<li>通过让计算属性所依赖属性的dep收集计算属性watcher的行为实现“依赖属性的变动通知计算属性”；</li>
<li>计算属性的watcher是lazy的，不会在创建实例时计算自身的值（即不会调用watcher.get()）；</li>
<li>计算属性是lazy的，调用计算属性的watcher.update不会直接计算值，只是更新标志位（this.dirty &#x3D; true），直到计算属性被访问才会计算值；</li>
<li>dep（依赖收集器）会收集watcher（订阅者），watcher也会收集dep；</li>
<li>计算属性通过watcher.value对其值进行缓存，不会每次访问都从新计算；</li>
<li>计算属性通过<code>watcher.depend()</code>来收集依赖它的订阅者</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数组变异方法的实现原理</title>
    <url>/blog/2019/11/19/%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>path: vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;array.js</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// 原型式继承数组原型对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object.create(arrayProto)的操作等同于下面的操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * arrayMethods = &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * Object.setPrototypeOf(arrayMethods, arrayProto);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给 arrayMethods 变异方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// def，使用defineProperty是定对象属性的value</span></span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span> (...args) &#123;</span><br><span class="line">    <span class="comment">// 指定上下文调用原始的数组方法</span></span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line"></span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">      <span class="comment">// 若有新增元素，则需要对新增元素进行观察，劫持</span></span><br><span class="line">      ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 既然对象成员个数新增，就需要通知订阅者，当前它依赖的数据已经发生变动</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">def</span> (<span class="attr">obj</span>: <span class="title class_">Object</span>, <span class="attr">key</span>: string, <span class="attr">val</span>: any, enumerable?: boolean) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整段代码执行下来，创建了一个对象arrayMethods，它的原型只想数组原型，并且它有这么成员方法：’push’,<br> ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’！</p>
<p>很明显，这样还不够！这样还能直接通过vue数组实例的点操作符调用变异方法！还需要将这些挂在vue实例数组的原型链上！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 通过__proto__将数组的原型指向arrayMethods</span></span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有__proto__，说明不能通过__proto__设置原型指向！</span></span><br><span class="line">        <span class="comment">// 则直接将变异的数组方法作为OwnProperty直接挂载在数组上</span></span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在坚持数组时，会将arrayMethods，根据实际情况挂在到当前这个数组的原型链上！在可以设置原型执行时，直接改变当前数组原型指向，改为arrayMethods；否则，直接将arrayMethods的方法，复制到当前数组上，作为当前数组的成员方法！</p>
<p>回看上面的代码（这一处：<code>def(arrayMethods, method, function mutator (...args)</code>），在这一块代码可以发现<code>this.__ob__</code>！经过以上分析，我们知道arrayMethods最后会挂在到vue数组上，那么这个this指向的就是这个数组，那么<code>__ob__</code>应该就是在vue数组原型链上或数组ownProperties上的！</p>
<p>似曾相似，在哪里遇过~</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Observer实例时，会将当前实例挂在到当前观察数据的<code>__ob__</code>上，对vue数组而言，这个被观察的数据就是它了！</p>
<p>既然<code>__ob__</code>是Observer实例，当然调用劫持数组的方法<code>ob.observeArray(inserted)</code>！这里插一句题外话，虽然新增元素是属于当前数组的，但还是在被劫持这个行为上，他们是相互独立的，所以这里就是不使用ob.ob.observeArray去劫持，而使用<code>inserted.forEach((item) =&gt; observe(it))</code>劫持也是可以的~</p>
<p>这里需要当前数组的<code>__ob__</code>，主要是为了通知到这个数组的订阅者！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>变异方法通过对数组原型方法的拦截对原有方法进行处理，拦截的方式分两种：1. 可以设置原型的情况下，通过改变vue数组的原型指向进行拦截；2. 1不可行的情况下，则在vue数组的ownProperties上创建同名成员方法拦截！</li>
<li>编译数组方法可以通知watche，是因为最后调用<code>ob.dep.notify()</code>，通知了订阅者，这就是本质区别；</li>
<li><code>ob.observeArray(inserted)</code>再次坚持新元素是为了让别的watcher可以订阅新属性。</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS(跨域资源共享)实现与session丢失解决方案详解</title>
    <url>/blog/2019/11/16/CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-%E5%AE%9E%E7%8E%B0%E4%B8%8Esession%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>跨域是什么？只要请求地址与当前地址的<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>其中一个不同都会引起跨域，这是由于浏览器的同源策略导致。</p>
<span id="more"></span>

<p><a href="https://www.zhihu.com/question/31459669">同源策略的存在意义</a></p>
<p>但有时候跨域又是难以避难，目前有很多跨域的方法：</p>
<ol>
<li>JSON-P(安全性不好)；</li>
<li>window.name + iframe(实现的方式恶心)；</li>
<li>window.postMessage(HTML5)；</li>
<li>proxy(麻烦的部署及维护)；</li>
<li>使用同域后端语言作为中转；</li>
<li>跨域资源共享;</li>
<li>…</li>
</ol>
<p>其中我实践过得有1、4、5、6，常用的是4，最近XXX的时候被问到CORS，引申出很多知识，比如其中问到了<strong>复杂请求和简单请求</strong>，我对CORS并没有太多深入，接下来你懂的……</p>
<p>CORS需要服务器端及客户端双方面的更改支持。本编主要基于js和php代码以及session机制介绍如何实现CORS跨域以及解决CORS后的session丢失问题。</p>
<p>以下是本次实现的前后端域名。观两端域名可知会引起跨域问题。</p>
<p>前端域名为：<code>http://dev.github.io</code>；</p>
<p>后端域名：<code>http://php.cn</code> 请求地址为：<code>http://php.cn/cors.php</code>。</p>
<h1 id="CORS的兼容性"><a href="#CORS的兼容性" class="headerlink" title="CORS的兼容性"></a>CORS的兼容性</h1><ul>
<li>Chrome 3+</li>
<li>Firefox 3.5+</li>
<li>Opera 12+</li>
<li>Safari 4+</li>
<li>Internet Explorer 8+</li>
</ul>
<p>#CORS实现跨域</p>
<ul>
<li><p>客服端（Client）</p>
<p>封装一个ajax函数：</p>
<p>path：<code>http://dev.github.io/index.html</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">sender</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">&quot;http://php.cn/cors.php?fn=&quot;</span> + sender.<span class="property">url</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;withCredentials&quot;</span> <span class="keyword">in</span> xhr) &#123;</span><br><span class="line">        <span class="comment">// &quot;withCredentials&quot;属性只存在于XMLHttpRequest2对象中</span></span><br><span class="line">        <span class="comment">// Chrome, Firefox, Opera and Safari</span></span><br><span class="line">        xhr.<span class="title function_">open</span>(sender.<span class="property">method</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">XDomainRequest</span> != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// XDomainRequest对象，兼容IE</span></span><br><span class="line">        xhr = <span class="keyword">new</span> <span class="title class_">XDomainRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(sender.<span class="property">method</span>, url);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sender.<span class="property">header</span>) &#123;</span><br><span class="line">        xhr[key] = sender.<span class="property">header</span>[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> responseText = xhr.<span class="property">responseText</span>;</span><br><span class="line">        sender.<span class="property">callback</span> &amp;&amp; sender.<span class="title function_">callback</span>(responseText);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起一个get请求：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/getData&#x27;</span>,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="keyword">function</span>(<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
<li><p>服务端（Server）</p>
<p>path：<code>http://php.cn/cors.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: *&#x27;);</span></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: http://dev.github.io&#x27;);</span></span><br><span class="line"><span class="variable">$fn</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] ? <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] : <span class="string">&#x27;getData&#x27;</span>;</span><br><span class="line"><span class="variable">$fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnAjax</span>(<span class="params"><span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&quot;getData&quot;</span></span><br><span class="line">	));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备代码写完，先发起一个请求测试：</p>
<p>抛出以下异常</p>
<blockquote>
<p><code>Failed to load http://php.cn/cors.php?fn=getData: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://dev.github.io&#39; is therefore not allowed access.</code></p>
</blockquote>
<p>大致意思就是响应报文中没有指定当前域为可跨域域名。</p>
<p>CORS怎么解决，也是很简单：</p>
<p>回看刚刚的php代码，你发现两行注释代码，取消任意一行都可以解决以上异常</p>
<ul>
<li>使用通配符，表示允许任何来源域名进行跨域；</li>
<li>也可以指定来源域名，比如第二行。</li>
</ul>
<p><strong>ok，取消第一行注释，来实践一下：</strong><br><img src="/blog/01.png"><br><img src="/blog/02.png"></p>
<p><strong>这就这么简单，关键是服务端向响应报文的消息头中指定可进行跨域的源域名</strong></p>
</li>
</ul>
<h1 id="CORS后出现session丢失问题"><a href="#CORS后出现session丢失问题" class="headerlink" title="CORS后出现session丢失问题"></a>CORS后出现session丢失问题</h1><p>先简单介绍一下session机制：</p>
<p>服务端建立session，比如php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>建立session后，session保存的到服务端，生成一个sessionId以cookie形式保存到客户端。</p>
<p>当下一次访问的时候，保存在浏览器cookie的sessionId会被带在请求头中，服务端就会根据请求头中的sessionId去服务端获取对应的sessionId</p>
<p>然后，再来说一下CORS后出现session丢失问题，为什么会出现呢？</p>
<p>这就需要说一下<code>Access-Control-Allow-Credentials</code></p>
<blockquote>
<p><strong>Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
</blockquote>
<p>CORS后默认是不会发送cookie的，在看上面说到的session机制，最后一步是需要发送sessionId的cookie到服务端的，服务端才能获取到对应的session，这就是session丢失的原因。</p>
<p>既然知道原因，那么就好办了！</p>
<p>如上引用中写到，需要服务端向响应头中设置Access-Control-Allow-Credentials为true才能允许浏览器向服务器发送cookie。</p>
<p>另外，在浏览器端也是需要在AJAX请求中打开<code>withCredentials</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>注意：必须浏览器端将<code>withCredentials</code>设为<code>true</code>和服务端将<code>Access-Control-Allow-Credentials</code>设为<code>true</code>才能达到预期效果</p>
<p>ok，现在再来实践一下，首先先做一下代码准备：</p>
<p>html:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/getData&#x27;</span>,</span><br><span class="line">        <span class="attr">header</span>: &#123;</span><br><span class="line">            <span class="attr">withCredentials</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setSession</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/setSession&#x27;</span>,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先发送请求建立一个session，然后在发送一个请求获取刚刚建立的session，若果不为空即session没有丢失</span></span><br><span class="line"><span class="title function_">setSession</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">getData</span>(<span class="keyword">function</span>(<span class="params">resp</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>php：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: *&#x27;);</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin: http://dev.github.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fn</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] ? <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] : <span class="string">&#x27;getData&#x27;</span>;</span><br><span class="line"><span class="variable">$fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnAjax</span>(<span class="params"><span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Credentials: true&quot;</span>); </span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&quot;getData&quot;</span>,</span><br><span class="line">		<span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">	));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSession</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;setSession&#x27;</span></span><br><span class="line">	));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，现在来执行一下</p>
<p><img src="/blog/03.png"></p>
<p><img src="/blog/04.png"></p>
<p>如上，发送第一个请求php代码建立的一个session</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>发送第二个请求，获取该session，并且如上图，确实返回了该session保存的值。</p>
<p>对比第一次实现CORS，你会发现第二次实现CORS的时候，在服务端，没有再用通配符<code>*</code>来配置<code>Access-Control-Allow-Origin</code>而是直接指定为：<code>http://dev.github.io</code>，这也是一个注意点，要发送cookie就必须明确指明可跨域域名，不可以使用通配符，不然则会抛出如下异常：</p>
<blockquote>
<p><code>Failed to load http://php.cn/cors.php?fn=getData: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. Origin &#39;http://dev.github.io&#39; is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</code></p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看得多了，不如试试？！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>$set和$del和方法的实现原理</title>
    <url>/blog/2019/11/09/$set%E5%92%8C$del%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">nextTick的实现逻辑</a></li>
<li><a href="#timerFunc%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">timerFunc是什么？</a></li>
<li><a href="#timerFunc%E7%9A%84%E5%AE%9E%E7%8E%B0">timerFunc的实现</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>vue版本：<code>2.6.9</code>；</li>
<li>path：<code>vue/src/core/util/next-tick.js</code>；</li>
</ul>
<p>&amp;nbsp;</p>
<h1 id="nextTick的实现逻辑"><a href="#nextTick的实现逻辑" class="headerlink" title="nextTick的实现逻辑"></a>nextTick的实现逻辑</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入nextTick，首先会点cb进行封装，涉及三个控制流！</p>
<ol>
<li>如果存在cb，则调用cb函数：<code>cb.call(ctx)</code>；</li>
<li>如果<code>_resolve</code>存在，则调用 <code>_resolve(ctx)</code>，<code>_resolve</code>是<code>Promise.resolve</code>的引用！这是在当前环境支持<code>Promise</code>；</li>
<li>不做任何处理。</li>
</ol>
<p>在将<code>cb</code>推入<code>callbacks</code>后，判断当前是不是正在执行上次<code>callbacks</code>的回调函数，根据pending（待定）来判断，当前是否要执行新的<code>callbacks</code>的cb！</p>
<p>先假设当前<code>pending = fakse</code>，那么进入<code>if (!pending)</code>，执行<code>timerFunc()</code>！</p>
<p>&amp;nbsp;</p>
<h1 id="timerFunc是什么？"><a href="#timerFunc是什么？" class="headerlink" title="timerFunc是什么？"></a>timerFunc是什么？</h1><p><code>timerFunc</code>，是一个可将当前<code>callbacks</code>作为一个回调函数（这个包裹的函数就是下面的<code>flushCallbacks</code>），入队微&#x2F;宏任务队列中，等待主线程代码执行完毕之后执行！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  <span class="comment">// 立刻执行 “pending = false” 意味着，在主线程代码执行完，</span></span><br><span class="line">  <span class="comment">// 轮到当前这个 “flushCallbacks()” 被放入主线程执行开始</span></span><br><span class="line">  <span class="comment">// 就可以进入 &quot;if (!pending)&quot; 控制流再次执行触发 “timerFunc()”，</span></span><br><span class="line">  <span class="comment">// 将新的“flushCallbacks” 放进微/宏任务队列</span></span><br><span class="line">  <span class="comment">// 而不是等到 上一次 “callbacks” 的所有cb执行完之后</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>timerFunc</code>根据当前环境的支持情况可能用<code>Promise</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code>实现！优先级：<code>Promise</code> &gt; <code>MutationObserver</code> &gt; <code>setImmediate</code> &gt; <code>setTimeout</code>。</p>
<ul>
<li>微任务（micro task）：Promise、MutationObserver；</li>
<li>宏任务（macro task）：setImmediate、setTimeout。</li>
</ul>
<p>任务调用优先级：微任务 &gt; 宏任务。</p>
<p>关于为什么这样的优先级，vue做了说明：</p>
<blockquote>
<p>Here we have async deferring wrappers using microtasks. In 2.5 we used (macro) tasks (in combination with microtasks).However, it has subtle problems when state is changed right before repaint(e.g. #6813, out-in transitions).Also, using (macro) tasks in event handler would cause some weird behaviors that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109). So we now use microtasks everywhere, again.A major drawback of this tradeoff is that there are some scenarios where microtasks have too high a priority and fire in between supposedly sequential events (e.g. #4521, #6690, which have workarounds) or even between bubbling of the same event (#6566).</p>
<p>这里我们使用微任务异步延迟包装器。在2.5中，我们使用了（宏）任务（与微任务结合使用），但是当重新绘制之前状态发生改变时它存在一些细微的问题（例如＃6813，输出转换）。在事件处理程序中使用（宏）任务会导致一些无法避免的怪异行为（例如＃7109，＃7153，＃7546，＃7834，＃8109）。因此，我们现在再次在各处使用微任务。 是在某些情况下，微任务的优先级过高，并且在假定的顺序事件之间（例如＃4521，＃6690，它们具有变通方法）甚至在同一事件冒泡之间也会触发（＃6566）。</p>
</blockquote>
<p>&amp;nbsp;</p>
<h1 id="timerFunc的实现"><a href="#timerFunc的实现" class="headerlink" title="timerFunc的实现"></a>timerFunc的实现</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br></pre></td></tr></table></figure>



<h3 id="Promise实现timerFunc"><a href="#Promise实现timerFunc" class="headerlink" title="Promise实现timerFunc"></a>Promise实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="comment">// 在有问题的UIWebViews中，Promise.then并不会完全中断，但是它可能会陷入一种怪异的状态，</span></span><br><span class="line">    <span class="comment">// 在这种状态中，回调被推送到微任务队列中，但是队列没有被刷新，直到浏览器需要执行其他一些工作，</span></span><br><span class="line">    <span class="comment">// 例如 处理一个计时器。 因此，我们可以通过添加空计时器来“强制”刷新微任务队列。</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MutationObserver实现timerFunc"><a href="#MutationObserver实现timerFunc" class="headerlink" title="MutationObserver实现timerFunc"></a>MutationObserver实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="comment">// 在本地Promise不可用的地方使用MutationObserver，</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// （＃6466 MutationObserver在IE11中不可靠）</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setImmediate实现timerFunc"><a href="#setImmediate实现timerFunc" class="headerlink" title="setImmediate实现timerFunc"></a>setImmediate实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  <span class="comment">// 退回到setImmediate。</span></span><br><span class="line">  <span class="comment">// 从技术上讲，它利用（宏）任务队列，</span></span><br><span class="line">  <span class="comment">// 但它仍然是比setTimeout更好的选择。</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setTimeout实现timerFunc"><a href="#setTimeout实现timerFunc" class="headerlink" title="setTimeout实现timerFunc"></a>setTimeout实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Nest如何实现装饰器的路由注册</title>
    <url>/blog/2019/10/09/%E6%B5%85%E6%9E%90Nest%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>在<code>nest</code>中你可以看到使用装饰器实现路由路径。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span>, <span class="title class_">Get</span>, <span class="title class_">Query</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ListAllEntities</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="title function_">findAll</span>(<span class="params"><span class="meta">@Query</span>() query: ListAllEntities</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns all cats (limit: <span class="subst">$&#123;query.limit&#125;</span> items)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>主要就是由<code>Controller</code>和其他<code>http-method</code>装饰器。而实际的路由路径是：</p>
<p>全局前缀（可选） + Controller装饰器的文本参数（可选） + http-method装饰器文本参数（可选）</p>
<h1 id="存储路径数据"><a href="#存储路径数据" class="headerlink" title="存储路径数据"></a>存储路径数据</h1><h2 id="Controller前缀的保存"><a href="#Controller前缀的保存" class="headerlink" title="Controller前缀的保存"></a>Controller前缀的保存</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Controller</span>(<span class="params"></span></span><br><span class="line"><span class="params">  prefixOrOptions?: <span class="built_in">string</span> | ControllerOptions,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ClassDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultPath = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> [path, scopeOptions] = <span class="title function_">isUndefined</span>(prefixOrOptions)</span><br><span class="line">    ? [defaultPath, <span class="literal">undefined</span>]</span><br><span class="line">    : <span class="title function_">isString</span>(prefixOrOptions)</span><br><span class="line">    ? [prefixOrOptions, <span class="literal">undefined</span>]</span><br><span class="line">    : [prefixOrOptions.<span class="property">path</span> || defaultPath, &#123; <span class="attr">scope</span>: prefixOrOptions.<span class="property">scope</span> &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target: <span class="built_in">object</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, target);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">SCOPE_OPTIONS_METADATA</span>, scopeOptions, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Controller</code>装饰器工厂中，首先是获取了path, scopeOptions，然后返回了一个装饰器函数。这个函数主要是保存工厂函数的参数。<br>这里用到了<a href="https://github.com/rbuckton/reflect-metadata"><code>Reflect</code></a>，是一个用来存取元数据的库，数据结构主要是Map和WeakMap。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, target);</span><br></pre></td></tr></table></figure>
<p>将path这个数据<code>WeakMap/target/PATH_METADATA</code>中。所以取的时候也需要<code>target</code>, <code>PATH_METADATA</code>。</p>
<h2 id="http-method前缀的保存"><a href="#http-method前缀的保存" class="headerlink" title="http-method前缀的保存"></a>http-method前缀的保存</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultMetadata = &#123;</span><br><span class="line">  [<span class="variable constant_">PATH_METADATA</span>]: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  [<span class="variable constant_">METHOD_METADATA</span>]: <span class="title class_">RequestMethod</span>.<span class="property">GET</span> <span class="comment">/* GET: 0 */</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">RequestMapping</span> = (</span><br><span class="line">  <span class="attr">metadata</span>: <span class="title class_">RequestMappingMetadata</span> = defaultMetadata,</span><br><span class="line">): <span class="function"><span class="params">MethodDecorator</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pathMetadata = metadata[<span class="variable constant_">PATH_METADATA</span>];</span><br><span class="line">  <span class="keyword">const</span> path = pathMetadata &amp;&amp; pathMetadata.<span class="property">length</span> ? pathMetadata : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> requestMethod = metadata[<span class="variable constant_">METHOD_METADATA</span>] || <span class="title class_">RequestMethod</span>.<span class="property">GET</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key, descriptor: PropertyDescriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, descriptor.<span class="property">value</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">METHOD_METADATA</span>, requestMethod, descriptor.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createMappingDecorator</span> = (<span class="params">method: RequestMethod</span>) =&gt; (</span><br><span class="line">  path?: <span class="built_in">string</span> | <span class="built_in">string</span>[],</span><br><span class="line">): <span class="function"><span class="params">MethodDecorator</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">RequestMapping</span>(&#123;</span><br><span class="line">    [<span class="variable constant_">PATH_METADATA</span>]: path,</span><br><span class="line">    [<span class="variable constant_">METHOD_METADATA</span>]: method,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Get</span> = <span class="title function_">createMappingDecorator</span>(<span class="title class_">RequestMethod</span>.<span class="property">GET</span>);</span><br></pre></td></tr></table></figure>

<p>上面以<code>@Get()</code>装饰器的实现为例。和<code>@Controller</code>的实现大同小异，最终都是将工厂函数的参数使用<code>Reflect</code>保存起来，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, descriptor.<span class="property">value</span>);</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">METHOD_METADATA</span>, requestMethod, descriptor.<span class="property">value</span>);</span><br></pre></td></tr></table></figure>
<p>分别将请求方法和路径保存了起来。</p>
<p>这里就有个问题：为什么要先保存这些路由数据，而不是直接使用？</p>
<p>首先，装饰器实际发挥作用的阶段是紧接着类声明之后，立即就执行装饰器函数。而业务逻辑是在访问路由之后才会被触发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>使用Reflect存放元数据，Reflect由一个外部库<a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a>实现；</li>
<li>target(类的引用，也可以说是构造函数)&#x2F;PATH_METADATA存放<code>Controller</code>部分的路径数据；</li>
<li>descriptor.value（成员方法的引用，即方法本身）&#x2F;PATH_METADATA存放，存放剩余的http-method部分的路径数据；</li>
</ul>
<h1 id="组合路由的路径数据"><a href="#组合路由的路径数据" class="headerlink" title="组合路由的路径数据"></a>组合路由的路径数据</h1><p>下面我们来看nest怎么组合分散的路由路径<code>path</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title function_">registerRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">registerMiddleware</span>(<span class="variable language_">this</span>.<span class="property">httpAdapter</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prefix = <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>();</span><br><span class="line">  <span class="keyword">const</span> basePath = <span class="title function_">validatePath</span>(prefix);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">routesResolver</span>.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">httpAdapter</span>, basePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，获取全局前缀，得到路径的最开头部分：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>() <span class="comment">// 全局前缀</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);  </span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> resolve&lt;T <span class="keyword">extends</span> <span class="title class_">HttpServer</span>&gt;(<span class="attr">applicationRef</span>: T, <span class="attr">basePath</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> modules = <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">getModules</span>();</span><br><span class="line">  modules.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; controllers, metatype &#125;, moduleName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = metatype</span><br><span class="line">      ? <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype)</span><br><span class="line">      : <span class="literal">undefined</span>;</span><br><span class="line">    path = path ? basePath + path : basePath;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">registerRouters</span>(controllers, moduleName, path, applicationRef);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里组合模块部分的路径:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype)  <span class="comment">// 模块部分的前缀</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Controller的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">registerRouters</span>(<span class="params"></span></span><br><span class="line"><span class="params">  routes: <span class="built_in">Map</span>&lt;<span class="built_in">string</span>, InstanceWrapper&lt;Controller&gt;&gt;,</span></span><br><span class="line"><span class="params">  moduleName: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  basePath: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  applicationRef: HttpServer,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">instanceWrapper</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; metatype &#125; = instanceWrapper;</span><br><span class="line">    <span class="keyword">const</span> path = <span class="variable language_">this</span>.<span class="property">routerBuilder</span>.<span class="title function_">extractRouterPath</span>(</span><br><span class="line">      metatype <span class="keyword">as</span> <span class="title class_">Type</span>&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">      basePath,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> controllerName = metatype.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">logger</span>.<span class="title function_">log</span>(<span class="title function_">CONTROLLER_MAPPING_MESSAGE</span>(controllerName, path));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routerBuilder</span>.<span class="title function_">explore</span>(</span><br><span class="line">      instanceWrapper,</span><br><span class="line">      moduleName,</span><br><span class="line">      applicationRef,</span><br><span class="line">      path,</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">extractRouterPath</span>(</span><br><span class="line">  <span class="attr">metatype</span>: <span class="title class_">Type</span>&lt;<span class="title class_">Controller</span>&gt;,</span><br><span class="line">  prefix?: <span class="built_in">string</span>,</span><br><span class="line">): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype);</span><br><span class="line">  <span class="keyword">if</span> (prefix) path = prefix + <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(path);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合<code>Controller</code>部分的路由数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype)  <span class="comment">// Controller`部分的路由数据</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> explore&lt;T <span class="keyword">extends</span> <span class="title class_">HttpServer</span> = <span class="built_in">any</span>&gt;(</span><br><span class="line">  <span class="attr">instanceWrapper</span>: <span class="title class_">InstanceWrapper</span>,</span><br><span class="line">  <span class="attr">module</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">applicationRef</span>: T,</span><br><span class="line">  <span class="attr">basePath</span>: <span class="built_in">string</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; instance &#125; = instanceWrapper;</span><br><span class="line">  <span class="keyword">const</span> routerPaths = <span class="variable language_">this</span>.<span class="title function_">scanForPaths</span>(instance);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">applyPathsToRouterProxy</span>(</span><br><span class="line">    applicationRef,</span><br><span class="line">    routerPaths,</span><br><span class="line">    instanceWrapper,</span><br><span class="line">    <span class="variable language_">module</span>,</span><br><span class="line">    basePath,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">scanForPaths</span>(</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">Controller</span>,</span><br><span class="line">  prototype?: <span class="built_in">any</span>,</span><br><span class="line">): <span class="title class_">RoutePathProperties</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> instancePrototype = <span class="title function_">isUndefined</span>(prototype)</span><br><span class="line">    ? <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(instance)</span><br><span class="line">    : prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">metadataScanner</span>.<span class="property">scanFromPrototype</span>&lt;</span><br><span class="line">    <span class="title class_">Controller</span>,</span><br><span class="line">    <span class="title class_">RoutePathProperties</span></span><br><span class="line">  &gt;(instance, instancePrototype, <span class="function"><span class="params">method</span> =&gt;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">exploreMethodMetadata</span>(instance, instancePrototype, method),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">exploreMethodMetadata</span>(</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">Controller</span>,</span><br><span class="line">  <span class="attr">instancePrototype</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">methodName</span>: <span class="built_in">string</span>,</span><br><span class="line">): <span class="title class_">RoutePathProperties</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> targetCallback = instancePrototype[methodName];</span><br><span class="line">  <span class="keyword">const</span> routePath = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, targetCallback);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndefined</span>(routePath)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">requestMethod</span>: <span class="title class_">RequestMethod</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="variable constant_">METHOD_METADATA</span>,</span><br><span class="line">    targetCallback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> path = <span class="title function_">isString</span>(routePath)</span><br><span class="line">    ? [<span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(routePath)]</span><br><span class="line">    : routePath.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(p));</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    path,</span><br><span class="line">    requestMethod,</span><br><span class="line">    targetCallback,</span><br><span class="line">    methodName,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是剩余的http-method部分路由数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, targetCallback)  <span class="comment">// http-method部分路由数据</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Controller和http-method装饰工厂存储的路径数据在注册路由的时候被访问并组合成完成路径；</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Nest</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Nest</tag>
      </tags>
  </entry>
  <entry>
    <title>功能函数：大数值相加</title>
    <url>/blog/2019/08/24/%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%EF%BC%9A%E5%A4%A7%E6%95%B0%E5%80%BC%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> splitLen = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...rest</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (rest.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> rest[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> num = rest.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">return</span> +<span class="title function_">add</span>(...rest) + (+num) + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(splitLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">splitNum</span> = (<span class="params">numStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> numStrArr = numStr.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">while</span> (numStrArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = numStrArr.<span class="title function_">splice</span>(-splitLen);</span><br><span class="line">    nums.<span class="title function_">push</span>(item.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">classifyAdd</span> = (<span class="params">n1Nums, n2Nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> resNums = [];</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (n1Nums.<span class="property">length</span> &amp;&amp; n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> part;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">add</span>(n1Nums.<span class="title function_">shift</span>(), n2Nums.<span class="title function_">shift</span>(), carry);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">length</span> &gt; splitLen) &#123;</span><br><span class="line">      part = res.<span class="title function_">slice</span>(-splitLen);</span><br><span class="line">      carry = res.<span class="title function_">slice</span>(<span class="number">0</span>, -splitLen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      part = zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -res.<span class="property">length</span>) + res;</span><br><span class="line">      carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resNums.<span class="title function_">push</span>(part);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n1Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> restNums = carry ? <span class="title function_">classifyAdd</span>([carry], n1Nums) : n1Nums;</span><br><span class="line">    resNums = [...resNums, ...restNums];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> restNums = carry ? <span class="title function_">classifyAdd</span>([carry], n2Nums) : n2Nums;</span><br><span class="line">    resNums = [...resNums, ...restNums];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumAdd</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (str1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; str2.<span class="property">length</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">add</span>(str1, str2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> numArr1 = <span class="title function_">splitNum</span>(str1);</span><br><span class="line">  <span class="keyword">const</span> numArr2 = <span class="title function_">splitNum</span>(str2);</span><br><span class="line">  <span class="keyword">const</span> resNums = <span class="title function_">classifyAdd</span>(numArr1, numArr2).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> resStr = resNums.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^0*/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> resStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rest.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> rest[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> str1 = rest.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bigNumAdd</span>(str1, <span class="title function_">bigNumsAdd</span>(...rest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;1111111111&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;444&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">&#x27;00000000000000000000000000000000000000000000000000&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> resNums = <span class="title function_">bigNumsAdd</span>(str1, str2, str3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resNums&#x27;</span>, resNums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resNums &quot;1111111555&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> splitLen = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...rest</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sum = rest.<span class="property">length</span> &lt; <span class="number">2</span> ? rest[<span class="number">0</span>] : +rest.<span class="title function_">pop</span>() + (+<span class="title function_">add</span>(...rest));</span><br><span class="line">  <span class="keyword">return</span> sum + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(splitLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">splitNum</span> = (<span class="params">numStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> numStrArr = numStr.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">while</span> (numStrArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = numStrArr.<span class="title function_">splice</span>(-splitLen);</span><br><span class="line">    nums.<span class="title function_">push</span>(item.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">classifyAdd</span> = (<span class="params">n1Nums, n2Nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> resNums = [];</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (n1Nums.<span class="property">length</span> &amp;&amp; n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="title function_">add</span>(n1Nums.<span class="title function_">shift</span>(), n2Nums.<span class="title function_">shift</span>(), carry);</span><br><span class="line">    <span class="keyword">const</span> part = zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -sum.<span class="property">length</span>) + sum.<span class="title function_">slice</span>(-splitLen);</span><br><span class="line">    carry = sum.<span class="title function_">slice</span>(<span class="number">0</span>, -splitLen);</span><br><span class="line">    resNums.<span class="title function_">push</span>(part);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> restNums = n1Nums.<span class="title function_">concat</span>(n2Nums); </span><br><span class="line">  restNums = carry ? <span class="title function_">classifyAdd</span>([carry], restNums) : restNums;</span><br><span class="line">  <span class="keyword">return</span> [...resNums, ...restNums].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^0*/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bigNumAdd</span> = (<span class="params">str1, str2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; str2.<span class="property">length</span> &lt; <span class="number">16</span></span><br><span class="line">    ? <span class="title function_">add</span>(str1, str2)</span><br><span class="line">    : <span class="title function_">classifyAdd</span>(<span class="title function_">splitNum</span>(str1), <span class="title function_">splitNum</span>(str2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> rest.<span class="property">length</span> &lt; <span class="number">2</span></span><br><span class="line">    ? rest[<span class="number">0</span>]</span><br><span class="line">    : <span class="title function_">bigNumAdd</span>(rest.<span class="title function_">shift</span>(), <span class="title function_">bigNumsAdd</span>(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumAdd</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; s2.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> +s1 + (+s2) + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sArr1 = s1.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> sArr2 = s2.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len1 = sArr1.<span class="property">length</span>, len2 = sArr2.<span class="property">length</span>; (i &lt; len1 &amp;&amp; i &lt; len2) || carry; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num1 = +(sArr1[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> num2 = +(sArr2[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> sum = (num1 + num2 + carry + <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(sum.<span class="title function_">pop</span>());</span><br><span class="line">    carry = sum[<span class="number">0</span>] ? +sum[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bigNumAdd</span>(rest[<span class="number">0</span>], rest.<span class="property">length</span> &lt; <span class="number">3</span> ? rest[<span class="number">1</span>] : <span class="title function_">bigNumsAdd</span>(...rest.<span class="title function_">slice</span>(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bigFloatNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> ints = [];</span><br><span class="line">  <span class="keyword">let</span> radixs = [];</span><br><span class="line">  <span class="keyword">let</span> radixMaxLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> radixStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  rest.<span class="title function_">forEach</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [int, radix] = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    int &amp;&amp; ints.<span class="title function_">push</span>(int);</span><br><span class="line">    <span class="keyword">if</span> (radix) &#123;</span><br><span class="line">      radixMaxLen = radix.<span class="property">length</span> &gt; radixMaxLen ? radix.<span class="property">length</span> : radixMaxLen;</span><br><span class="line">      radixs.<span class="title function_">push</span>(radix);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (radixs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(radixMaxLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    radixs = radixs.<span class="title function_">map</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> str + zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -str.<span class="property">length</span>));</span><br><span class="line">    <span class="keyword">const</span> radixAllStr = <span class="title function_">bigNumsAdd</span>(...radixs);</span><br><span class="line">    <span class="keyword">const</span> exInt = radixAllStr.<span class="title function_">slice</span>(<span class="number">0</span>, -radixMaxLen);</span><br><span class="line">    radixStr = radixAllStr.<span class="title function_">slice</span>(-radixMaxLen);</span><br><span class="line">    exInt &amp;&amp; ints.<span class="title function_">push</span>(exInt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> intStr = <span class="title function_">bigNumsAdd</span>(...ints);</span><br><span class="line">  <span class="keyword">return</span> [intStr, radixStr].<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title function_">bigFloatNumsAdd</span>(<span class="string">&#x27;33333333333333331.123&#x27;</span>, <span class="string">&#x27;2.1234&#x27;</span>, <span class="string">&#x27;3.98765&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;33333333333333337.23405&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>功能函数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题目：变态跳台阶||解法</title>
    <url>/blog/2019/08/17/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%EF%BC%9A%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6-%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<span id="more"></span>

<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpFloorII</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title function_">jumpFloorII</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看程序就知道，这个解法不是单纯依赖平常思维写的，<code>2 * jumpFloorII(n - 1)</code>这句代码明显就是个规律，所以就是找规律！</p>
<p>设有<code>f(n)，n=台阶数</code>为算出“跳上一个n级的台阶总共有多少种跳法”的函数。</p>
<p>只关心第一次跳多少个台阶，剩下的就交给这个<code>f(n)</code>来解决！<br>那么有n个台阶，第一次可以选择跳的台阶数就可以是1级，或2级，或3级，……，或n级。<br>当第一次跳1级时，那么剩下就有n-1级，那么剩下n-1级台阶就有f(n-1)种跳法；<br>当第一次跳2级时，那么剩下就有n-2级，那么剩下n-2级台阶就有f(n-2)种跳法；<br>当第一次跳3级时，那么剩下就有n-3级，那么剩下n-3级台阶就有f(n-3)种跳法；<br>……<br>当第一次跳n-1级时，那么剩下就有n-(n-1)级，那么剩下n-(n-1)级台阶就有f(n-(n-1))种跳法；<br>当第一次跳n级时，那么剩下就有n-n级，那么剩下n-n级台阶就有f(n-n)种跳法。</p>
<p>上面已经将“跳上一个n级的台阶总共有多少种跳法”这个问题做了拆分，拆分为：以第一次跳的级数作为分类，由上面的排比就知道分成了n类方式（是不是很熟悉，排列组合中<a href="https://baike.baidu.com/item/%E5%88%86%E7%B1%BB%E5%8A%A0%E6%B3%95%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/467166">分类加法计数原理</a>）。</p>
<p>显然将这n类方式的跳法加起来就是题目的问题，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span><br></pre></td></tr></table></figure>
<p>整理一下这个代数式就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1) + f(0)</span><br></pre></td></tr></table></figure>
<p>根据这个代数式，你可以推导出f(n-1)的代数式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n-1) = f(n-2) + f(n-3) + ... + f(1) + f(0)</span><br></pre></td></tr></table></figure>
<p>结合一下，就有最终的式子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-1) = 2 * f(n-1)</span><br></pre></td></tr></table></figure>
<p>到现在，只是知道代数关系，还是不知道f(n)这个函数的具体逻辑！但是有这个关系，就可以将问题向下转化！比如我们不知道f(2)等于多少，但是知道<code>f(2) = 2 * f(1)</code>，而f(1)是很轻松就可以知道的！<br>f(1)就是第一次跳了n-1级的台阶，剩下的台阶数就只有1级，显然就只有1种跳法，即<em>f(1) &#x3D; 1</em>!<br>然后就知道f(2) &#x3D; 2；这样就可以将所有未知转化为已知！</p>
<p>然后就有了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpFloorII</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title function_">jumpFloorII</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas实现圆框图片</title>
    <url>/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在html中做圆框图片很容易，只需要简单的 <code>border-radius: 50%;</code> 当然，为了兼容性，还有必要做带前缀的兼容性写法。但总的来说还是很简单。</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">  -webkit-<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  -moz-<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<!-- ![](https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg) -->

<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-bd35ee9e30c8de53.png"></p>
<p><a href="https://jsfiddle.net/issaxite/3gLaoLjy/">[传送门：demo]</a></p>
<p>但是在canvas上做起来就有点麻烦了，在canvas画布上画图片，可以使用canvas的 <code>drawImage</code> 接口，但是这个接口也仅仅是将图片画在画布上，并没有如css那样提供做圆角的接口。</p>
<p>网上google过一下，常看到这样的做法(最先是在<a href="http://www.zhangxinxu.com/study/201406/image-border-radius-canvas.html">张鑫旭的blog上看到的</a>)：</p>
<h1 id="通过纹理实现"><a href="#通过纹理实现" class="headerlink" title="通过纹理实现"></a>通过纹理实现</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">CanvasRenderingContext2D</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">roundRect</span> = <span class="keyword">function</span> (<span class="params">x, y, w, h, r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> min_size = <span class="title class_">Math</span>.<span class="title function_">min</span>(w, h);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (r &gt; min_size / <span class="number">2</span>) r = min_size / <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 开始绘制</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">beginPath</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">moveTo</span>(x + r, y);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x + w, y, x + w, y + h, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x + w, y + h, x, y + h, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x, y + h, x, y, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x, y, x + w, y, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">stroke</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">closePath</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pattern = context.<span class="title function_">createPattern</span>(img, <span class="string">&quot;no-repeat&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">context.<span class="title function_">roundRect</span>(<span class="number">0</span>, <span class="number">0</span>, img.<span class="property">width</span>, img.<span class="property">height</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">context.<span class="property">fillStyle</span> = pattern;</span></span><br><span class="line"><span class="language-javascript">context.<span class="title function_">fill</span>(); </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做是可以的，这个做法的关键道具是<code>createPattern</code> 这是一个专门用来作纹理的API：</p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-2ec590dc132f3067.png"></p>
<p><strong>但是，如果你将该形状右移50px就会发现问题所在，图片没有跟着形状（圆框）一起移动</strong>：</p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-9343063b631f3456.png"></p>
<p>其实，看第二个画布应该可以看出图片是对画布的左上角做定位的。如果图片没有移动，那么想办法移动图片就好啦！然而，可悲的是没有方法。因此，这是一种比较鸡肋的做法。</p>
<p><a href="https://jsfiddle.net/issaxite/3gLaoLjy/1/">[传送门：demo]</a></p>
<h1 id="通过裁剪画布部分区域实现"><a href="#通过裁剪画布部分区域实现" class="headerlink" title="通过裁剪画布部分区域实现"></a>通过裁剪画布部分区域实现</h1><p>这是我最后使用的方法，这个方法的关键道具是<code>clip()</code>API，这个API，可以用你指定的形状在画布上裁剪一部分出来，然后，接下来你在画布上的操作只有在该形状区域内可见，如果还有后续还有对画布的其他地方有操作，可以使用<code>restore()</code>接口恢复，但是必须在使用clip接口前用 <code>save()</code> 接口保存canvas的状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">  img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 首先是先画一个圆形，因为现在我们不是画圆角矩形，所以就不用“张鑫旭”画圆</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 的做法，我们直接使用 `arc` 接口</span></span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">save</span>();</span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 从画布上裁剪出这个圆形</span></span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">clip</span>();</span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">drawImage</span>(img, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-6ae38ef8653024d8.png"></p>
<p>为此，还封装了个简单的方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 封装了一个简单的方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">circleImg</span>(<span class="params">ctx, img, x, y, r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">save</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> d =<span class="number">2</span> * r;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> cx = x + r;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> cy = y + r;</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">arc</span>(cx, cy, r, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">clip</span>();</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">drawImage</span>(img, x, y, d, d);</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">restore</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">  img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> canvas1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> context1 = canvas1.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">circleImg</span>(context1, img, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-b8968aabf0bdc4cb.png"></p>
<p>正如你所见，这个做法可以随意移动圆框和图片的。</p>
<p><a href="https://jsfiddle.net/issaxite/p56fkb9s/1/">[传送门：demo]</a></p>
<h1 id="两个值得注意的点，比较容易让误解的API："><a href="#两个值得注意的点，比较容易让误解的API：" class="headerlink" title="两个值得注意的点，比较容易让误解的API："></a>两个值得注意的点，比较容易让误解的API：</h1><ul>
<li>clip()<br><a href="http://www.w3school.com.cn/tiy/t.asp?f=html5_canvas_clip">这是w3c的例子</a>，或许有部分人（在说自己），会误以为，在使用clip以后，接下来的操作都是相对于这个被剪切出来的部分做定位，特别是下面这张图：</li>
</ul>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-4cb61a8b9522b0ac.png" alt="灰色框是画布"></p>
<p>更加容易让人误以为真是如此，其实不然，其实还是相对画布的左上角做定位，用了clip后只是变成，只有clip区域可见而已。</p>
<ul>
<li>arcTo 一个用来画弧线的api</li>
</ul>
<p>关于这个API的参数说明是这样的：</p>
<p><a href="http://www.w3school.com.cn/tags/canvas_arcto.asp">[传送门：demo]</a></p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-619ed2977b158f5b.png"></p>
<p>上面的参数说明中的起点和终点，比较容易让人误以为是下面两个点：</p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-37eba062c3666da0.png"></p>
<p>然而上面的(x1,y1)和(x2,y2)其实是分别指下图上的上面一点和下面一点：</p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-ba345b172e3ad4b8.png"></p>
<p>继续看下图：</p>
<p><img src="/blog/2019/08/07/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/2838289-f38ace5dbf8d890b.png"></p>
<p><strong>顺道说一下，canvas的坐标，x轴由原点左到右从0开始递增，y轴由原点上到下，从0开始递增。</strong></p>
<p>A点是直线的末点，这个点一般是有lineTo接口写出，或者moveTo接口，比如moveTo(50,50)，而B点则是arcTo中的x1,x2，B(100, 50)， C点则是arcTo中的x2,y2，C(100, 100)，而arcTo中的r则是AB或者CD。</p>
<p><a href="https://jsfiddle.net/issaxite/uqj700yo/">[传送门：demo]</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpha、Beta、RC、GA版本的区别</title>
    <url>/blog/2018/10/09/Alpha%E3%80%81Beta%E3%80%81RC%E3%80%81GA%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>Alpha</strong>：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</p>
<p><strong>Beta</strong>：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</p>
<p><strong>RC</strong>：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</p>
<p><strong>GA</strong>: General Availability,正式发布的版本，在国外都是用GA来说明release版本的。</p>
<p><strong>RTM</strong>：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</p>
<p><strong>OEM</strong>：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。 </p>
<p><strong>RVL</strong>：号称是正式版，其实RVL根本不是版本的名称。它是中文版&#x2F;英文版文档破解出来的。 </p>
<p><strong>EVAL</strong>：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。 </p>
<p><strong>RTL</strong>：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</p>
<p><strong>注意：</strong></p>
<p>α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Composition实现科学文字计数器</title>
    <url>/blog/2018/09/12/Composition%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E6%96%87%E5%AD%97%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="很长的前言"><a href="#很长的前言" class="headerlink" title="很长的前言"></a>很长的前言</h1><p>前端时间需要做一个input组件，组件要求之一是：动态计算input文字并展示出来，大概如下：</p>
<span id="more"></span>


<p>本来就是基于vue来做，想起来也是很简单的事情，就是获取<code>$input.value.length</code>~确实也是如此。</p>
<p>最初我是这么写的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;self-input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">&quot;input&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:input</span>=<span class="string">&quot;handleInput&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:value</span>=<span class="string">&quot;currentValue&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator--current&quot;</span>&gt;</span>&#123;&#123; textCount &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator--max&quot;</span>&gt;</span>&#123;&#123; maxlength &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;SelfInput&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">value</span>: &#123; <span class="attr">type</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>] &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">maxlength</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">currentValue</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">textCount</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">handleInput</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> inputVal =  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        inputVal = inputVal.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">textCount</span> = inputVal.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, inputVal);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line">  .self-input&#123;</span><br><span class="line">    $--calculator-width: 56px;</span><br><span class="line">    </span><br><span class="line">    &amp; &#123; position: relative;display: inline-block; &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;__inner&#123; padding-left: 5px;line-height: 28px;width: 220px;padding-right: $--calculator-width;font-size: 14px; &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;__calculator&#123;</span><br><span class="line">      &amp; &#123;</span><br><span class="line">        position: absolute;top: 0;right: 0;bottom: 0;display: inline-flex;justify-content: flex-end;</span><br><span class="line">        align-items: center;padding-right: 5px;width: $--calculator-width;box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &amp;--current&#123;</span><br><span class="line">        &amp;::after&#123; content: &quot;/&quot;;display: inline-block; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &amp;--max&#123; color: gray; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>如你所见，在中文输入时出现了非预期的文字数目计数（附上 <a href="http://jsfiddle.net/sobq1cn9/33/">Demo1</a> ）~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>看win下的效果就知道，在使用中文输入的时候，直接使用<code>input</code>事件（v-model语法糖就是监听input事件）就出现了非预期的问题！</p>
<p>在看ElementUI源码的时候发现了一个以前没有用过的事件（见识短浅），<em>composition事件</em>。这个事件有三个事件组成，分别是：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart">compositionstart</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionupdate">compositionupdate</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionend">compositionend</a></li>
</ul>
<blockquote>
<p><code>compositionstart</code> 事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）。</p>
</blockquote>
<blockquote>
<p><code>compositionupdate</code> 事件触发于字符被输入到一段文字的时候（这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）</p>
</blockquote>
<blockquote>
<p>当文本段落的组成完成或取消时, <code>compositionend</code> 事件将被触发 (具有特殊字符的触发, 需要一系列键和其他输入, 如语音识别或移动中的字词建议)。</p>
</blockquote>
<p>换言之，在一开始中文输入的时候会触发<code>compositionstart</code>事件，当继续中文输入但未选词前会持续触发<code>compositionupdate</code>事件，然后当选词后则触发<code>compositionend</code>事件（针对当前情况如是说）！</p>
<h2 id="用input事件配合以上三事件优化文字计数器"><a href="#用input事件配合以上三事件优化文字计数器" class="headerlink" title="用input事件配合以上三事件优化文字计数器"></a>用input事件配合以上三事件优化文字计数器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;exValue&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionend</span>=<span class="string">&quot;handleComposition&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;handleInput&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">isOnComposition</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">_setTextCount</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">textCount</span> = val.<span class="property">length</span> || <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleComposition</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">isOnComposition</span> = event.<span class="property">type</span> !== <span class="string">&#x27;compositionend&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      !<span class="variable language_">this</span>.<span class="property">isOnComposition</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">handleInput</span>(event);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleInput</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> value;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">isOnComposition</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">      value = event.<span class="property">target</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">currentValue</span> = value;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">_setTextCount</span>(value);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, value);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里只是用到了Composition事件之一, <code>compositionend</code>。</p>
<p>其实要做得更加健壮应该三个事件都用到！这里的思路也很简单，如果是非中文输入的时候就不会触发<code>compositionend</code>事件，正常执行input事件的回调，</p>
<p>而中文输入的时候，<code>compositionend</code>和<code>input</code>都会同时触发，在未完成选词前，当然是不能执行input回到的真正逻辑，</p>
<p>因此加入一个<code>isOnComposition</code>状态记录当前是否进行中文输入，input回调函数则据此判断是否执行真正的业务逻辑！</p>
<p>附上jsfiddle源码Demo: <a href="http://jsfiddle.net/sobq1cn9/143/">Demo2</a></p>
<h2 id="更加简单的做法"><a href="#更加简单的做法" class="headerlink" title="更加简单的做法"></a>更加简单的做法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;currentValue&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">currentValue</span>: (<span class="variable language_">this</span>.<span class="property">value</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span>.<span class="property">value</span> === <span class="literal">null</span>) ? <span class="string">&#x27;&#x27;</span> : <span class="variable language_">this</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">textCount</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">currentValue</span>.<span class="property">length</span> || <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比上一种做法，将<code>v-bind</code>绑定的<code>value</code>属性，换成<code>v-model</code>，其余去掉的部分一看到<del>，基本就是做了这么一点功夫就搞定了上一种做法的长篇大论</del><br>附上jsfiddle源码Demo: <a href="http://jsfiddle.net/issaxite/wqfhnvc4/1/">另一种简单的实现</a></p>
<!-- 缺陷例子 -->
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>dom事件</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>SCSS字符分割函数获取当前选择器名</title>
    <url>/blog/2018/08/31/SCSS%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%80%89%E6%8B%A9%E5%99%A8%E5%90%8D/</url>
    <content><![CDATA[<h1 id="有点长的前言"><a href="#有点长的前言" class="headerlink" title="有点长的前言"></a>有点长的前言</h1><p>常有这样的情况：比如以下面的一段代码来说，多人开发的情况下，很可能你写了一个<code>.header-icon</code>的css样式描述，你的同事也开发了一个！</p>
<p>并且他的样式优先级比你的高，目前你负责的部分需要你的样式生效！</p>
<span id="more"></span>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这要怎么办？直接想到的有两个方法：</p>
<ul>
<li><p><code>!important</code>；</p>
</li>
<li><p>重复声明选择器，比如 <code>.bar-header-icon.bar-header-icon</code>；</p>
</li>
</ul>
<p>很多时候负责任的开发者都会使用后者，因为后者可以前者覆盖，具备一定的扩展性！</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span><span class="selector-class">.bar-header-icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错这样就ok！</p>
<p>但细想可知，虽然<code>&amp;-header</code>的当前选择器名是和<code>.bar-header-icon</code>的是相等的，但是一旦父选择器名字（<code>.header</code>）改了，就出问题，健壮性过差！</p>
<p>当然如果你不嫌麻烦，可以同时改两个地方。但实际开发时可能就不是两个地方的事了……</p>
<p>聪明如你会想到这样写：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span>&amp;-<span class="attribute">icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你期望输出的是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span><span class="selector-class">.bar-header-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是，实际上输出的是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，在上面的情况中<code>&amp;-icon</code>并不与<code>.bar-header-icon</code>等价，实际上，<code>&amp;</code>编译后的是<code>.side .bar-header</code>。是不是就有点尴尬了~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>scss没有提供获取当前选择器名的方法或者全局变量，那么就自己实现！</p>
<p><code>&amp;</code>输出的字符串是一个选择器名的列表，这些元素名一般以空格分割，还有的就是<code>. &gt; + ~</code>等等，</p>
<p>因此可以通过这些分割字符串，然后”数组“的最后一个元素就是目标选择器名！</p>
<h2 id="字符串分割函数"><a href="#字符串分割函数" class="headerlink" title="字符串分割函数"></a>字符串分割函数</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> str-split(<span class="variable">$str</span>, <span class="variable">$separator</span>) &#123;</span><br><span class="line">  <span class="variable">$splits</span>: ();</span><br><span class="line">  <span class="comment">// 获取下次分割点posituion</span></span><br><span class="line">  <span class="variable">$pos</span> : <span class="built_in">str-index</span>(<span class="variable">$str</span>, <span class="variable">$separator</span>);</span><br><span class="line">  <span class="keyword">@while</span> <span class="variable">$pos</span> != null &#123;</span><br><span class="line">    <span class="comment">// 根据position返回子字符串</span></span><br><span class="line">    <span class="variable">$item</span>: <span class="built_in">str-slice</span>(<span class="variable">$str</span>, <span class="number">1</span>, <span class="variable">$pos</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将切割出的字串push入list中</span></span><br><span class="line">    <span class="variable">$splits</span>: <span class="built_in">append</span>(<span class="variable">$splits</span>, <span class="variable">$item</span>);</span><br><span class="line">    <span class="comment">// 更新源字符串</span></span><br><span class="line">    <span class="variable">$str</span>: <span class="built_in">str-slice</span>(<span class="variable">$str</span>, <span class="variable">$pos</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取下次分割点posituion</span></span><br><span class="line">    <span class="variable">$pos</span> : <span class="built_in">str-index</span>(<span class="variable">$str</span>, <span class="variable">$separator</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$splits</span>: <span class="built_in">append</span>(<span class="variable">$splits</span>, <span class="variable">$str</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$splits</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop函数"><a href="#pop函数" class="headerlink" title="pop函数"></a>pop函数</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> list-pop(<span class="variable">$list</span>) &#123;</span><br><span class="line">  <span class="variable">$len</span>: <span class="built_in">length</span>(<span class="variable">$list</span>);</span><br><span class="line">  <span class="keyword">@return</span> nth(<span class="variable">$list</span>, <span class="variable">$len</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取当前selector"><a href="#获取当前selector" class="headerlink" title="获取当前selector"></a>获取当前selector</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> current-selector(<span class="variable">$str</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> list-pop(str-split(<span class="variable">$str</span>, <span class="string">&#x27; &#x27;</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="增强版的current-selector"><a href="#增强版的current-selector" class="headerlink" title="增强版的current-selector"></a>增强版的<code>current-selector</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> nth-by-flag(<span class="variable">$list</span>, <span class="variable">$flag</span>) &#123;</span><br><span class="line">  <span class="variable">$els</span>: ();</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$item</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">    <span class="keyword">@if</span> str-index(<span class="variable">$item</span>, <span class="variable">$flag</span>) != null &#123;</span><br><span class="line">      <span class="variable">$els</span>: <span class="built_in">append</span>(<span class="variable">$els</span>, <span class="variable">$item</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$els</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@function</span> current-selector(<span class="variable">$str</span>, <span class="variable">$seps</span>: null, <span class="variable">$flag</span>: null) &#123;</span><br><span class="line">  <span class="variable">$current</span>: <span class="variable">$str</span>;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$seps</span> != null &#123;</span><br><span class="line">    <span class="variable">$seps</span>: <span class="built_in">append</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$seps</span>);  </span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="variable">$seps</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$sep</span> in <span class="variable">$seps</span> &#123;</span><br><span class="line">    <span class="variable">$is-exist</span>: <span class="built_in">str-index</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>);</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$is-exist</span> != null &#123;</span><br><span class="line">      <span class="keyword">@if</span> <span class="variable">$flag</span> != null &#123;</span><br><span class="line">        <span class="variable">$current</span>: <span class="built_in">nth-by-flag</span>(<span class="built_in">str-split</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>), <span class="variable">$flag</span>);</span><br><span class="line">      &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="variable">$current</span>: <span class="built_in">list-pop</span>(<span class="built_in">str-split</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>));   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个debug-mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> debug(<span class="variable">$var</span>) &#123;</span><br><span class="line">  <span class="selector-class">.debug</span>&#123; <span class="attribute">content</span>: <span class="variable">$var</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> debug(current-selector(<span class="string">&quot;.a .b .c&quot;</span>)); </span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/blog/2018/08/31/SCSS%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%80%89%E6%8B%A9%E5%99%A8%E5%90%8D/44906193-d0f78b00-ad46-11e8-99f6-060e4ceb1453.png"></p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sep</span>: <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="variable">$current</span>: <span class="variable">$sep</span> + <span class="built_in">current-selector</span>(<span class="string">&quot;.a .b .c.c.c&quot;</span>, <span class="variable">$sep</span>);</span><br><span class="line"><span class="keyword">@include</span> debug(<span class="variable">$current</span>);; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/blog/2018/08/31/SCSS%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%80%89%E6%8B%A9%E5%99%A8%E5%90%8D/44906431-76126380-ad47-11e8-8779-90f5b5b2c8bb.png"></p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> debug(current-selector(<span class="string">&quot;.a .isaac .b .c&quot;</span>, null, <span class="string">&#x27;isaac&#x27;</span>)); </span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/blog/2018/08/31/SCSS%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%80%89%E6%8B%A9%E5%99%A8%E5%90%8D/44906552-cf7a9280-ad47-11e8-8b2a-28e25383bd90.png"></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://sass-lang.com/documentation/modules/string">Sass Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>scss</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>手势视差翻页器</title>
    <url>/blog/2018/02/24/%E6%89%8B%E5%8A%BF%E8%A7%86%E5%B7%AE%E7%BF%BB%E9%A1%B5%E5%99%A8/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>移动端实现一个轮播器，在轮播器上层有一个静止图层，不会随着轮播器翻页而偏移。<br>以下是两个已经实践的两个项目：</p>
<span id="more"></span>

<ul>
<li><a href="https://isaaxite.github.io/parallax_scrolling_flip/example/">Example-1</a></li>
<li><a href="https://isaaxite.github.io/parallax_scrolling_flip/">Example-2</a></li>
</ul>
<p><a href="https://github.com/issaxite/parallax_scrolling_flip">[Github]</a>，欢迎Fork与Star！！！</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="以上需求可以拆分成两个小的需求："><a href="#以上需求可以拆分成两个小的需求：" class="headerlink" title="以上需求可以拆分成两个小的需求："></a>以上需求可以拆分成两个小的需求：</h2><ul>
<li>实现一个轮播器；</li>
<li>做个静止图层。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>轮播器作为一个图层，静止图层是一个。</p>
<p>那么那个图层在上，那个在下？</p>
<ol>
<li>轮播器在上，则静止图层被轮播器遮盖；</li>
<li>静止图层在上，则绑定在轮播器上的手势事件由于被静止图层在上而无法触发。</li>
</ol>
<h2 id="再细分需求"><a href="#再细分需求" class="headerlink" title="再细分需求"></a>再细分需求</h2><p>为了显示静止图层，那么静止图层一定是要在上的。那么就必须解决第2个问题，怎么触发轮播器的手势。<br>我们可以通过监听静止图层或者两图层容器的手势，然后映射到轮播器。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="轮播器"><a href="#轮播器" class="headerlink" title="轮播器"></a>轮播器</h2><p>由于网上的轮播器插件的都是封装好的，触发事件比较麻烦，因此选择自己使用原生js实现一个。</p>
<p>实现轮播器的方案有很多中，比如改变<code>translate</code>属性的，也有先实现一个<code>scroll-view </code>，然后改变<code>scroll-view</code>的<code>scrollLeft</code>。我选用后者（单纯是因为我没有这样做过，而且好像很有趣）。</p>
<h3 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h3><p>一般<code>scroll-view</code>都是纵向的，根据以上需求，我们就需要实现一个横向的<code>scroll-view</code>，具体实现如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123; <span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">::-webkit-scrollbar&#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">position</span>: relative; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &gt; <span class="selector-class">.story</span>&#123; <span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">0</span>;<span class="attribute">right</span>: <span class="number">0</span>;<span class="attribute">bottom</span>: <span class="number">0</span>;<span class="attribute">left</span>: <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &gt; <span class="selector-class">.story</span>&#123; </span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1000</span>; <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;<span class="attribute">overflow-y</span>: hidden; <span class="attribute">white-space</span>: nowrap;<span class="attribute">font-size</span>: <span class="number">0</span>;<span class="attribute">letter-spacing</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* translateZ是是为了开启硬件加速 */</span></span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -o-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">display</span>: inline-block;<span class="attribute">vertical-align</span>: top;<span class="attribute">position</span>: relative; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123; <span class="attribute">background-color</span>: red; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123; <span class="attribute">background-color</span>: orange; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123; <span class="attribute">background-color</span>: yellow; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">4</span>)&#123; <span class="attribute">background-color</span>: green; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">5</span>)&#123; <span class="attribute">background-color</span>: cyan; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">6</span>)&#123; <span class="attribute">background-color</span>: blue; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">7</span>)&#123; <span class="attribute">background-color</span>: purple; &#125;</span><br></pre></td></tr></table></figure>

<p>核心css为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow-x</span>: auto;<span class="attribute">overflow-y</span>: hidden; <span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure>
<p>禁用块级元素的换行，依次达到横排的效果。<br><a href="http://jsbin.com/virecok/1/edit?html,css,output">[查看源码：jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/5/">[查看源码：jsfiddle]</a><br>(ps：要看效果的gay man请点击<a href="http://jsbin.com/virecok/1/edit?html,css,output">[查看源码：jsbin]</a>，并使用移动设备模式查看， 下同)<br><img src="http://ohi69gup6.bkt.clouddn.com/%E8%BD%AE%E6%92%AD-min.gif"></p>
<h2 id="静止图层并监听其上的手势"><a href="#静止图层并监听其上的手势" class="headerlink" title="静止图层并监听其上的手势"></a>静止图层并监听其上的手势</h2><p>先向#app中添加静止图层</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;mash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://ohi69gup6.bkt.clouddn.com/005TGG6vly1fes9jc0kk0g30b40b40tv.gif&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，来分析一下轮播器的功能</p>
<ol>
<li>向左，向右滑动翻页；</li>
<li>轮播器卡片手势跟随。</li>
</ol>
<h3 id="第1点的实现思路"><a href="#第1点的实现思路" class="headerlink" title="第1点的实现思路"></a>第1点的实现思路</h3><p>获取手指 “触碰屏幕那刻” 和 “离开屏幕那刻” 的位置，根据以上两个位置判断翻页方向，要获取这两位置，就需要分别注册<code>touchstart</code>和<code>touchend</code>事件，通过事件的回调参数( <code>event</code> )获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触碰屏幕那刻横向位置</span></span><br><span class="line"><span class="keyword">var</span> touchStartX = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br><span class="line"><span class="comment">// 离开屏幕那刻横向位置</span></span><br><span class="line"><span class="keyword">var</span> touchEndX = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br></pre></td></tr></table></figure>

<p>判断滑动方向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>知道翻页方向就可以进行翻页</p>
<p>翻页如上文所说，通过改变卡片容器的<code>scrollLeft</code>。这里的容器是<code>#app &gt; .story</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .story&quot;</span>).<span class="property">scrollLeft</span></span><br></pre></td></tr></table></figure>
<p>想要实现翻页，还必须知道两个属性：</p>
<ol>
<li>每页宽度：可以通过<code>story.clientWidth</code>获取；</li>
<li>当前页：使用全局变量记录当前是第几页。</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> touchStartX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mash = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .mash&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> story = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .story&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> screenWidth = story.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line"> touchStartX = touch.<span class="property">pageX</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> touchEndX = touch.<span class="property">pageX</span>;</span><br><span class="line">  <span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> oldCurrentPage = currentPage;</span><br><span class="line">  <span class="keyword">var</span> maxPage = story.<span class="property">children</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">var</span> minPage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">  currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">  currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> targetScrollLeft = (currentPage - <span class="number">1</span>) * screenWidth;</span><br><span class="line">  </span><br><span class="line">  story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码基本实现翻页，但是仅仅是通过每次 “增加&#x2F;减少 一个<code>screenWidth</code>的距离” 达到翻页的目的，是不够的，因为你会发现翻页效果很生硬的，仅仅只有一帧。</p>
<p>下面让我们把翻页效果做得更加顺滑。</p>
<p>怎么做，使用定时器(<code>setTimeout</code>)？</p>
<p>不！不！不！当然不会！</p>
<p>我们使用<code>requestAnimationFrame</code>，至于为什么使用<code>requestAnimationFrame</code>而不使用<code>setTimeout</code>？请自行Google。接着，让我们先实现一个动画函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _animate = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> isValid = callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">    isValid &amp;&amp; <span class="title function_">requestAnimationFrame</span>(_animate);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(_animate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>ok，然后要做的就是将它运用到翻页的代码中!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置每帧改变scrollLeft距离</span></span><br><span class="line"><span class="keyword">var</span> step = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">animate</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> scrollLeft = story.<span class="property">scrollLeft</span>;</span><br><span class="line"></span><br><span class="line">    scrollLeft = isNext ? scrollLeft + step : scrollLeft - step;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isNext &amp;&amp; scrollLeft &gt; targetScrollLeft) &#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isNext &amp;&amp; scrollLeft &lt; targetScrollLeft)&#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = scrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><a href="http://jsbin.com/qoqufo/2/edit?html,css,js,output">[查看源码：jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/26/">[查看源码：jsfiddle]</a></p>
<h3 id="第2点的实现思路"><a href="#第2点的实现思路" class="headerlink" title="第2点的实现思路"></a>第2点的实现思路</h3><p>第二点需要实现的功能是：轮播器卡片手势跟随。<br>假如你有试过以上代码实现的轮播器，你会发现一个问题：手指在未离开屏幕前，无论手指怎么滑动都不会有任何响应，这明显不是我们想要的。标准的轮播器应该是：当前卡片应该对手势做出响应，卡片跟随手指移动。</p>
<p>要实现以上效果，就需要监听手指未离开屏幕的前的动作，注册<code>touchmove</code>事件，获取手指每次移动的位置！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moveingfPageX = touch.<span class="property">pageX</span>;</span><br><span class="line">  <span class="keyword">var</span> distance = -(moveingfPageX - touchStartX);</span><br><span class="line">  <span class="keyword">var</span> currentPageScrollLeft = (currentPage - <span class="number">1</span>) * screenWidth;</span><br><span class="line"></span><br><span class="line">  story.<span class="property">scrollLeft</span> = currentPageScrollLeft + distance;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>思路也是比较简单的，监听手指所在位置与初始位置<code>touchStartX</code>的距离，然后动态地改变<code>story.scrollLeft</code>。</p>
<p>另外，现在已经实现卡片的手势跟随，随之又可能有这么一种情况：<br>用户已经滑动卡片，但是在滑动后用户不想翻页了，转而想继续留在当前页，即 “后悔功能”。然后再看看当前我们的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br></pre></td></tr></table></figure>
<p>以上逻辑是：如果不是上一页就是下一页。并没有实现后悔功能。</p>
<p>为实现后悔功能，我做如下修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最小有效翻页距离（在手指离开屏幕时所偏移的横向距离），换言之，偏移距离小于30就触发后悔功能</span></span><br><span class="line"><span class="keyword">var</span> validFlipDistance = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="keyword">var</span> isValid = <span class="title class_">Math</span>.<span class="title function_">abs</span>(touchEndX - touchStartX) &gt;= validFlipDistance;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="keyword">if</span>(isValid) &#123;</span><br><span class="line">    currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">    currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">    currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 触发后悔功能，改变滑动方向，由animate函数将卡片反向滑回初始位置</span></span><br><span class="line">    isNext = !isNext;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a href="http://jsbin.com/qoqufo/edit?css,js,output">[查看源码: jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/29/">[查看源码: jsfiddle]</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析vue语法糖v-model</title>
    <url>/blog/2018/01/25/%E6%B5%85%E6%9E%90vue%E8%AF%AD%E6%B3%95%E7%B3%96v-model/</url>
    <content><![CDATA[<h1 id="input组件的v-model"><a href="#input组件的v-model" class="headerlink" title="input组件的v-model"></a>input组件的v-model</h1><p>关于v-model的实现原理vue文档有描述，是基于vue现有功能二次实现的语法糖。</p>
<span id="more"></span>

<p>vue中input的v-model写法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;something&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过是以下示例的语法糖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = arguments[0].target.value&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;e =&gt; something = e.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>据我们所见，v-model是个双向绑定的实现，这个实现主要是通过下面两个关键实现。</p>
<ul>
<li><p>通过<code>:value</code>&#x2F;<code>v-bind:value</code>是将data的value，即<code>data.something</code>单向绑定到input的value属性，<code>input.value</code>上。因此初始化页面的时候data.value的值会同步到对应input的value上，但如果只是这样的话，当用户通过input输入框改变input的值时并不会将改变后的值同步到data.input上。</p>
</li>
<li><p>通过<code>v-on:input</code>监听input.value的变化，可以监听到变化就可以将值更新到data.value上。通过<code>e =&gt; something = e.target.value</code></p>
<p>​</p>
</li>
</ul>
<p>对于第二点，<code>v-on</code>监听HTML5事件， <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/input">[input事件]</a>。或许有些人会对这个html5事件有点陌生，不知道的，或许还会误以为是vue中开发者自定义的事件。</p>
<p>input事件的描述</p>
<blockquote>
<p>当 <code>&lt;input&gt;</code> 或 <code>&lt;textarea&gt;</code> 元素的值更改时，DOM input 事件会同步触发。(对于 type &#x3D; checkbox 或 type &#x3D; radio 的输入元素，当用户单击控件时，输入事件不会触发，因为value属性不会更改。) 此外，当内容更改时，它会在 contenteditable 的编辑器上触发。在这种情况下，事件目标是编辑主机元素。如果有两个或多个具有 contenteditable 的元素为真，“编辑主机”是其父级不可编辑的最近的祖先元素。同样，它也会在  designMode 编辑器的根元素上触发。</p>
</blockquote>
<p>对v-model的关键句是：<strong>当 <code>&lt;input&gt;</code> 或 <code>&lt;textarea&gt;</code> 元素的值更改时，DOM input 事件会同步触发。</strong></p>
<h2 id="那为什么不使用change事件或者keyup事件实现？"><a href="#那为什么不使用change事件或者keyup事件实现？" class="headerlink" title="那为什么不使用change事件或者keyup事件实现？"></a>那为什么不使用change事件或者keyup事件实现？</h2><ul>
<li>change事件的问题</li>
</ul>
<p>mdn对change的描述</p>
<blockquote>
<p>change事件被<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;textarea&gt;</code>元素触发，访用户提交对元素值的更改时。与input事件不同，change不一定会对元素值的每次更改触发。 </p>
</blockquote>
<p>意思是什么？<br>比如说，你长按键盘输入文字到input框，input的value是一直在变的，但是长按期间的变化是不会触发到change事件的，只有在松开按键的时候并且input的value有变化才会触发。</p>
<p>而input事件则是，只要input的值发生变化都会触发，没有则不触发。</p>
<ul>
<li>key事件的问题</li>
</ul>
<p>keyup事件触发条件就如字面意思，按键松开的时候触发。这不就是和change事件相似？是很相似，但keyup是只要按键松开就会触发，无论value是否有改变，比如你按下方向键也会触发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数据双向绑定（v-model）的的核心是：v-bind同步数据到html元素节点的value;事件监听元素节点的value变化，然后将变化同步到vue.$data中。</p>
<h1 id="自定义组件实现v-model"><a href="#自定义组件实现v-model" class="headerlink" title="自定义组件实现v-model"></a>自定义组件实现v-model</h1><p>对于自定义组件实现双向数据绑定的也是和input实现思路一样，实现方法也是类似。</p>
<ul>
<li>将父组件的data.value通过向子组件传参，将其同步到子组件内部</li>
</ul>
<p>再看vue文档给出的示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// v-model实现</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;something&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">// vue给出的自定义组件中v-model的解析</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;something = arguments[0]&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-input</span> @<span class="attr">input</span>=<span class="string">&quot;something = arguments[0]&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;something&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> customInput <span class="keyword">from</span> <span class="string">&#x27;./_input&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">something</span>: <span class="string">&quot;i am isaac_宝华&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">something</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;custom-input&quot;</span>: customInput</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>子组件（我的意淫）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;updateValue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;customInput&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">value</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateValue</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/blog/2018/01/25/%E6%B5%85%E6%9E%90vue%E8%AF%AD%E6%B3%95%E7%B3%96v-model/35480891-4f1300ca-0453-11e8-9b40-d49d0f45d03d.png" alt="image"></p>
<ul>
<li><p>同样，在父组件在<code>custom-input</code>中绑定<code>something</code>，向<code>custom-input</code>内部传入<code>something</code>。在<code>custom-input</code>内部将传入的value，绑定到真正的input的value上，这样就先实现单向的数据绑定。</p>
</li>
<li><p>然后要做的就是将真正的input.value的变化更新到父组件的<code>something</code>。怎么做？看父组件，在<code>custom-input</code>不是监听了input事件吗？！那么要在<code>custom-input</code>内部更新input.value到父组件，就需要触发这个input事件，就是子组件的这句: <code>$emit(&#39;input&#39;, $event.target.value)</code>。</p>
<p>那后你会发现在<code>custom-input</code>组件内部的input上也同样监听了一个input事件，因为要同步到父组件，首先就要监听到真正的input.value的变化，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>的input事件就会监听到input.value的变化，然后再将变化通过<code>$emit(&#39;input&#39;, $event.target.value)</code>传回父组件。</p>
</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>在这里，只是浅析v-model这个语法糖，正如vue文档中说的</p>
<blockquote>
<p><strong>预期</strong>：随表单控件类型不同而不同。</p>
</blockquote>
<p>所以这里只是简单说了input:text类型控件，而且也只是停留在vue层面浅析v-mode，并没有深入到js层面去分析v-model的实现。虽然如此，但这是有助于我们封住相关的input控件，作为一个自定义组件使用。</p>
<p>另外，不得不说，别看vue文档中将v-model好像说得很简单，但其实是vue中最复杂的组件之一。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
</search>
