<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入浅出 VUE 的 DIFF 算法实现</title>
    <url>/blog/resources/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>vue版本：2.6.10</strong></p>
<p>每次更新视图前都会根据视图模板生成vnode（虚拟的节点树），vnode类似dom树，但更简陋，每个vnode都与页面的上的元素html元素一一对应！为了更好的性能，因此要复用元素。那么就要知道怎么复用！就要对比newVnode（当前生成的vnode）和oldVnode（上次生成的vnode），对比完之后才知道那些是要删除，那些是需要重新创建，那些需要移动、移动到哪里！？<br>而diff算法则是对比的一种比较好的方式，更好的更快地对比，谁被谁复用！</p>
<span id="more"></span>

<p>newVnode和oldVnode的比对仅限于同层级之间对比，兄弟之间相互比较，如下图。不会出现跨层级的对比。</p>
<img src="diff-vnode.png" width="100%" alt="vue中的diff算法实现">


<h1 id="diff算法是什么"><a href="#diff算法是什么" class="headerlink" title="diff算法是什么"></a>diff算法是什么</h1><p><a href="#">回到顶部</a></p>
<p>diff算法不是一种对比的方法，而是一种寻找与当前节点匹配可复用节点的方法；寻找oldVnode.children中那个成员与newVnode.children中那个成员相同。</p>
<p>这种寻找的方法如图可见一斑，主要的方法有5种，辅助的有2种（未画在图上），一共7种。每种寻找方式相互独立！通过循环遍历children，逐一判断，直到循环结束。下面结合代码分别说明其中寻找方式。</p>
<p><strong>ps：无需过于在意图中所表达的逻辑，图只是用于辅助说明下面的源码</strong></p>
<img src="diff-vnode-children.png" width="100%" alt="vue中的diff算法实现">

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentElm,  <span class="comment">// &#123;Element&#125;，父节点的真实html元素</span></span></span><br><span class="line"><span class="params">  oldCh,  <span class="comment">// &#123;Vnode[]&#125;，oldVnode.children</span></span></span><br><span class="line"><span class="params">  newCh,  <span class="comment">// &#123;Vnode[]&#125;，newVnode.children</span></span></span><br><span class="line"><span class="params">  insertedVnodeQueue,   <span class="comment">// &#123;Vnode[]&#125;，插入的节点队列（此时可忽略）</span></span></span><br><span class="line"><span class="params">  removeOnly  <span class="comment">// &#123;Boolean&#125;，是否只可以删除</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立四个指针<code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code>，由<code>updateChildren</code>中的定义可以知道：开始时，他们分别指向<code>oldVnode.children</code>的头部、<code>oldVnode.children</code>的尾部、<code>newVnode.children</code>的头部、<code>newVnode.children</code>的尾部。然后，这四个指针的指向也不是固定的，在循环遍历的过程中，他们的指向也会变动，他们指向会因为以下索引的变动而变动，<code>oldStartIdx</code>、<code>oldEndIdx</code>、<code>newStartIdx</code>、<code>newEndIdx</code>。</p>
<h2 id="1-新头与旧头垂直对比"><a href="#1-新头与旧头垂直对比" class="headerlink" title="1.新头与旧头垂直对比"></a>1.新头与旧头垂直对比</h2><p><a href="#">回到顶部</a></p>
<img src="diff-vnode-children-01.png" width="100%" alt="vue中的diff算法实现">

<p>新旧头部vnode进行对比，判断是否匹配，以复用。sameVnode的功能与实现逻辑参考<a href="#sameVnode%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">附录：sameVnode的功能与实现逻辑</a>，值得一提的是：a.是input元素，更新前后type不一致；b.变动的是key属性；c.元素更新前后将所有属性删除，或从无到有；只要不是以上三种情况之一，不论怎么增删、修改元素上的属性，都不会影响是否匹配的结果！</p>
<p>1.判断新旧头部是匹配的，那么就调用<code>patchVnode</code>，给<code>newStartVnode</code>打补丁！</p>
<p><code>patchVnode</code>函数的主要功能：</p>
<p>a. 复用elm，将oldVnode.elm赋值到newVnode.elm；<br>b. 更新elm上的属性变动；<br>c. 更新newVnode.children，增删或复用，这里的复用就是通过调用<code>updateChildren</code>来实现，没错递归了！</p>
<p>patchVnode函数的主要功能参考：<a href="#patchVnode%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0">附录：patchVnode函数的关键实现</a></p>
<p>2.分别右移<code>oldStartVnode</code>和<code>newStartVnode</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-新尾与旧尾垂直对比"><a href="#2-新尾与旧尾垂直对比" class="headerlink" title="2.新尾与旧尾垂直对比"></a>2.新尾与旧尾垂直对比</h2><p><a href="#">回到顶部</a></p>
<img src="diff-vnode-children-02.png" width="100%" alt="vue中的diff算法实现">

<p>新旧尾部的对比情况和[1新头与旧头垂直对比]类似，再次再累累述，以下实现的逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-新尾与旧头交叉对比"><a href="#3-新尾与旧头交叉对比" class="headerlink" title="3.新尾与旧头交叉对比"></a>3.新尾与旧头交叉对比</h2><p><a href="#">回到顶部</a></p>
<img src="diff-vnode-children-03.png" width="100%" alt="vue中的diff算法实现">

<p>当前情况与[1新头与旧头垂直对比]略有不同！看源码中，多出了下面这句：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br></pre></td></tr></table></figure>

<p>这句代码实现就是图片中移动elm的功能！为什么要移动elm？因为newEndVnode复用了oldStartVnode.elm，复用这一步已经由<code>patchVnode</code>函数实现，然后还需要让elm列的顺序与newVnode的顺序保持一致，所以需要将<code>oldStartVnode.elm</code>移动到正确的位置！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。</span></span><br><span class="line"><span class="comment">       * 如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// canMove &amp;&amp; 在parentElm的nodeOps.nextSibling(oldEndVnode.elm)前面插入oldStartVnode.elm</span></span><br><span class="line">      <span class="comment">// 换言之，在 oldEndVnode.elm 前面插入 oldStartVnode.elm</span></span><br><span class="line">      <span class="comment">// 旧children的 头部真实元素 移动到 尾部真实元素的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-新头与旧尾交叉对比"><a href="#4-新头与旧尾交叉对比" class="headerlink" title="4.新头与旧尾交叉对比"></a>4.新头与旧尾交叉对比</h2><p><a href="#">回到顶部</a></p>
<img src="diff-vnode-children-04.png" width="100%" alt="vue中的diff算法实现">

<p>当前情况与[新尾与旧头交叉对比]类似，不做赘述！配合图片和源码食用口味更佳~</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      <span class="comment">// 将旧children的尾部真实元素移动到头部真实元素的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-当前新vnode与旧头尾之间的vnode对比"><a href="#5-当前新vnode与旧头尾之间的vnode对比" class="headerlink" title="5.当前新vnode与旧头尾之间的vnode对比"></a>5.当前新vnode与旧头尾之间的vnode对比</h2><p><a href="#">回到顶部</a></p>
<p>在本次循环中，前4种控制流都没有进入，就说明一头一尾、两次交叉对比都没有找到可复用的节点！但这并非代表旧children中无可复用，因为头与尾之间的元素还没有比对过，第5种方式即是如此！这第5种方式在有定义<code>key</code>(<code>v-for</code>指令中的<code>key</code>)或没有的情况下又是不同的表现！</p>
<p><strong>注意：在此情况下，是用新头去旧children的头尾之间寻找可复用元素</strong></p>
<h3 id="5-1-构建oldCildren映射表-key-idx"><a href="#5-1-构建oldCildren映射表-key-idx" class="headerlink" title="5-1.构建oldCildren映射表(key &#x3D;&gt; idx)"></a>5-1.构建oldCildren映射表(key &#x3D;&gt; idx)</h3><p>从oldChildren构建一个映射表(key &#x3D;&gt; idx)，这样就可以通过key，结合这个映射表快速找到匹配的可复用的元素。时间复杂度就是<code>O(1)</code>！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 5-1 */</span></span><br><span class="line">      <span class="comment">// 只会执行一次，第一次定义映射表</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) &#123;</span><br><span class="line">        <span class="comment">// 创建对象映射表，children.key =&gt; children.i, i ∈ [oldStartIdx, oldEndIdx]</span></span><br><span class="line">        oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createKeyToOldIdx的实现：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i, key</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].<span class="property">key</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-根据5-1的映射表找到可复用vnode的索引"><a href="#5-2-根据5-1的映射表找到可复用vnode的索引" class="headerlink" title="5-2.根据5-1的映射表找到可复用vnode的索引"></a>5-2.根据5-1的映射表找到可复用vnode的索引</h3><p>列表渲染中不一定会定义<code>key</code>，如果没有定义那么<code>5-1</code>的映射表就没有用了。那么就需要遍历旧children节点寻找与新头匹配的元素（详见下面代码的<code>findIdxInOld</code>方法）！那么时间复杂度就上来了，不再是使用映射表时的<code>O(1)</code>，而是<code>O(n)</code>。由此也可以知道使用<code>key</code>的性能优化优越之所在！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5.2 */</span></span><br><span class="line">      <span class="comment">// 定义key，直接在名射表找，时间复杂度: O(1)</span></span><br><span class="line">      <span class="comment">// 没有定义key，用新vnode与旧vnode数组比对，时间复杂度：O(n)</span></span><br><span class="line">      <span class="comment">// const isDef = (v) =&gt; v !== undefined &amp;&amp; v !== null</span></span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        <span class="comment">// 返回oldCh中与newStartVnode相同（ sameVnode(newStartVnode, oldCh[itIdx]) ）节点(即isDef(oldCh[itIdx].key) 同样是false)的index</span></span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findIdxInOld：时间复杂度<code>O(n)</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findIdxInOld</span> (<span class="params">node, oldCh, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = oldCh[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(c) &amp;&amp; <span class="title function_">sameVnode</span>(node, c)) <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-无可复用旧元素"><a href="#5-3-无可复用旧元素" class="headerlink" title="5-3.无可复用旧元素"></a>5-3.无可复用旧元素</h3><p>在旧children可能会找到也可能找不到可复用的元素，没有找到是什么情况？如图：</p>
<img src="diff-vnode-children-05.png" width="100%" alt="vue中的diff算法实现：在头尾见找可复用元素">

<p>假如现在<code>newStartVnode</code>指向的是<code>key = 1.5</code>的vnode，那么很明显旧children中就没有可以复用的vnode，那么需要做的就是：a.创建一个与<code>newStartVnode</code>对应的newElm(新的真实html元素)；b.然后将newElm插入到旧children中<code>key=02</code>的vnode对应的真实元素的前面！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5.3 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中不存在新节点，无法复用旧元素</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]</span></span><br><span class="line"><span class="comment">       * [ 1 ] [ 2 ] [2.5] [ 3 ] [ 4 ] [ 5 ]</span></span><br><span class="line"><span class="comment">       * [2.5]就是插入的，且就children中没有与之“相同”的vnode</span></span><br><span class="line"><span class="comment">       * 目前 newStartIdx = oldStartIdx = 2</span></span><br><span class="line"><span class="comment">       * 那么现在需要做的是：a.创建一个与[2.5]对应的真实元素；b.将元素插入到 [ 2 ] 后面 [ 3 ]前面</span></span><br><span class="line"><span class="comment">       * nodeOps.insertBefore(parentElm, newElm, oldStartVnode.elm)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建 newStartVnode 对应的elm，将elm插入到parentElm的子元素oldStartVnode.elm的前面（如果oldStartVnode.elm不存在即插入到parentElm的最后）</span></span><br><span class="line">        <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-复用旧元素"><a href="#5-4-复用旧元素" class="headerlink" title="5-4.复用旧元素"></a>5-4.复用旧元素</h3><p>5-3和5-4是互斥的，进入5-4控制流就表示5-2中返回的<code>idxInOld</code>不为空，旧children中存在这匹配的vnode。虽然存在可用的vnode，但如果<code>key</code>并不可信呢？比如<code>v-for=&quot;(item, index) in items&quot;</code>中的索引被用作<code>key</code>！！！因此有了下面的5-4-1和5-4-2。</p>
<h4 id="5-4-1-确实可复用"><a href="#5-4-1-确实可复用" class="headerlink" title="5-4-1.确实可复用"></a>5-4-1.确实可复用</h4><p>使用sameVnode方法二次确认vnodeToMove（在旧children中找到的vnode）时可用的！接下就是类似的操作。但比较明显的不同是：其他都是递增或递减新旧索引，但在5-4-1中则是递增newStartIdx，然后旧vnode置为null(<code>oldCh[idxInOld] = undefined</code>)，这是设计的巧妙之处，当前还没有感受到，再看下<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a>和<a href="#0%E8%B7%B3%E8%BF%87%E5%8F%B3%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">0.跳过右边已经复用的vnode</a>中的内容就会豁然开朗！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5-4 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中存在新节点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 5-4-1 */</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">// 保证节点的key和虚拟节点都相同（ oldKeyToIdx[newStartVnode.key] 获取的idxInOld，指向</span></span><br><span class="line">        <span class="comment">// 的虚拟节点可能与newStartVnode节点不一样(!sameVnode) ）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-虚假的可复用"><a href="#5-4-2-虚假的可复用" class="headerlink" title="5-4-2.虚假的可复用"></a>5-4-2.虚假的可复用</h4><p>5-4-1与5-4-2是互斥的，既然没有元素可以复用到<code>newStartVnode</code>中，那么只能像5-3中那样创建与<code>newStartVnode</code>对应的html元素！！！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 5-4 */</span></span><br><span class="line">      <span class="comment">// 在旧虚拟节点中存在新节点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 5-4-2 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// key相同但虚拟节点不同，newStartVnode当做新元素创建</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-跳过左边已经复用的vnode"><a href="#1-跳过左边已经复用的vnode" class="headerlink" title="-1.跳过左边已经复用的vnode"></a>-1.跳过左边已经复用的vnode</h2><p><a href="#">回到顶部</a></p>
<p>我们知道<code>oldStartVnode</code>这个指针是不断地右移，从下面的代码中的<code>isUndef(oldStartVnode)</code>知道，一旦碰到未定的vnode就会右移一个单位，继续循环比对后面的vnode。为什么会有未定义的vnode？正常来说应该存在，因为vnode都是与页面上的html元素一一对应的！在<a href="#5-4-1%E7%A1%AE%E5%AE%9E%E5%8F%AF%E5%A4%8D%E7%94%A8">5-4-1.确实可复用</a>中，vue确实地将旧children中存在可复用elm的vnode手动置为了undefined：<code>oldCh[idxInOld] = undefined</code>！为什么置空不直接用<code>delete</code>操作符删除？！删了就换了idx顺序！！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">/* -1 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-跳过右边已经复用的vnode"><a href="#0-跳过右边已经复用的vnode" class="headerlink" title="0.跳过右边已经复用的vnode"></a>0.跳过右边已经复用的vnode</h2><p><a href="#">回到顶部</a></p>
<p>参考<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while中的控制流顺序"><a href="#while中的控制流顺序" class="headerlink" title="while中的控制流顺序"></a>while中的控制流顺序</h2><p><a href="#">回到顶部</a></p>
<p>上面为了突出重点去讲，没有按while中控制流的顺序书写，以下是while块总各控制流的顺序：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="comment">/* -1：跳过左边已经复用的vnode */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 0：跳过右边已经复用的vnode */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 1：新头与旧头垂直对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 2：新尾与旧尾垂直对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 3：新尾与旧头交叉对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 4：新头与旧尾交叉对比 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">  <span class="comment">/* 5：当前新vnode与旧头尾之间的vnode对比 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="while之外"><a href="#while之外" class="headerlink" title="while之外"></a>while之外</h1><p><a href="#">回到顶部</a></p>
<p>留意while的循环条件：<code>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx</code>，只要<code>oldStartIdx</code>大于<code>oldEndIdx</code>或<code>newStartIdx</code>大于<code>newEndIdx</code>就会结束循环！换言之，只要遍历完新旧children任意一个就会结束循环！</p>
<p>a. 先遍历完旧children就说明<strong>新children新增了vnode</strong>，那么就要创建与这些vnodes对应的elm；<br>b. 先遍历完新children就说明<strong>新children删除了一些vnode</strong>，那么就要删除多出的vnodes。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  <span class="comment">// 会用调用node.insertBefore插入新元素，现在就是找引用元素，在refElm前面插入新元素</span></span><br><span class="line">  refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>])</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的children没有新增元素（newStartIdx &gt; newEndIdx） </span></span><br><span class="line"><span class="comment">     * 或 后面新增了vnode（newStartIdx &lt;= newEndIdx）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    ? <span class="literal">null</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * newStartIdx &lt;= newEndIdx</span></span><br><span class="line"><span class="comment">     * 新的children新增了元素，但不是在后面！</span></span><br><span class="line"><span class="comment">     * 可能是中间！</span></span><br><span class="line"><span class="comment">     * 也可能是在前面</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环调用 createElm</span></span><br><span class="line">  <span class="title function_">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  <span class="title function_">removeVnodes</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在循环遍历children的时候，startIdx（newStartIdx或oldStartIdx）和endIdx分别会向左和右移动。下面是四个索引移动的情况：</p>
<ul>
<li><p>newStartIdx右移：<a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>、<a href="#5%E5%BD%93%E5%89%8D%E6%96%B0vnode%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%B0%BE%E4%B9%8B%E9%97%B4%E7%9A%84vnode%E5%AF%B9%E6%AF%94">5.当前新vnode与旧头尾之间的vnode对比</a>；</p>
</li>
<li><p>newEndIdx左移：<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>；</p>
</li>
<li><p>oldStartIdx右移：<a href="#-1%E8%B7%B3%E8%BF%87%E5%B7%A6%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">-1.跳过左边已经复用的vnode</a>、<a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>；</p>
</li>
<li><p>ildEndIdx左移：<a href="#0%E8%B7%B3%E8%BF%87%E5%8F%B3%E8%BE%B9%E5%B7%B2%E7%BB%8F%E5%A4%8D%E7%94%A8%E7%9A%84vnode">0.跳过右边已经复用的vnode</a>、<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>；</p>
</li>
</ul>
<h2 id="新children新增了vnode"><a href="#新children新增了vnode" class="headerlink" title="新children新增了vnode"></a>新children新增了vnode</h2><p>根据newStartIdx和newEndIdx的移动情况</p>
<p>1.newStartIdx一直右移，由于新增的vnode都在后面，可以复用的vnode都在前面了，newEndIdx会保持不变，直到遍历完旧children：<br><img src="add-in-after.png" width="100%" alt="vue中的diff算法实现"><br>&nbsp;</p>
<p>2.newStartIdx右移，newEndIdx左移，直到遍历完旧children：</p>
<img src="add-in-middle.png" width="100%" alt="vue中的diff算法实现">

<p>3.新增的vnode都在前面了，由于是新的节点所以存在“newStartIdx右移”的情况，newStartIdx就保持不变了，而可复用的vnode在右边，随着一次次循环，newEndIdx则会左移：</p>
<img src="add-in-before.png" width="100%" alt="vue中的diff算法实现">

<p>新children删除了vnode的情况就不赘述，情况可以从上面的解析类推！</p>
<h1 id="新旧vnode与真实元素elm的关系"><a href="#新旧vnode与真实元素elm的关系" class="headerlink" title="新旧vnode与真实元素elm的关系"></a>新旧vnode与真实元素elm的关系</h1><p><a href="#">回到顶部</a></p>
<p>vnode是和elm一一对应的，vnode的顺序和elm保持这一致，vnode上的属性也是与对应的elm的属性对应。所以，在patch（给oldVnode打补丁）前，可以认为oldVnode树与页面上elm树是对应的！</p>
<p>1.oldVnode.children中vnode的顺序和oldVnode.elm.children(oldVnode对应的elm的子元素列表)的顺序是保持一致的、elm上的属性也是保持一致；</p>
<p>2.diff算法通过对比oldVnode.children与newVnode.children的vnode，找到可以复用的elm，并改变elm的位置，使之与newVnode.children的顺序保持一致！</p>
<h1 id="diff的特点"><a href="#diff的特点" class="headerlink" title="diff的特点"></a>diff的特点</h1><ul>
<li><strong>先垂直，再交叉，最后中间找</strong>，diff在旧vnode.children找可复用vnode，所用比对方式的优先级！</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><strong>只与同级vnode中寻找复用的elm</strong>，由上面的分析可以知道，只会在同级的children中寻找可以复用的vnode。但现实是可以复用的元素可以存在于dom树任意的地方，明显这样是可能回错过实际存在的复用元素，而重新创建元素！这里就是vue或diff的权衡的地方，是不计代价全局去找最优解，还是如当前这般在同级节点中寻找！？</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><strong>定义key属性可以大幅度减少操作数</strong>，在<a href="#5%E5%BD%93%E5%89%8D%E6%96%B0vnode%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%B0%BE%E4%B9%8B%E9%97%B4%E7%9A%84vnode%E5%AF%B9%E6%AF%94">5.当前新vnode与旧头尾之间的vnode对比</a>中，在定义了key的情况下，会创建一个映射表<code>oldKeyToIdx</code>，通过映射表可以快速找到可复用vnode，而没有定义的话，就需要遍历oldVnode.children，逐一使用<code>sameVnode</code>比对！</li>
</ul>
<h1 id="实用主义"><a href="#实用主义" class="headerlink" title="实用主义"></a>实用主义</h1><p><a href="#1%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%A4%B4%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">1.新头与旧头垂直对比</a>、<a href="#2%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%B0%BE%E5%9E%82%E7%9B%B4%E5%AF%B9%E6%AF%94">2.新尾与旧尾垂直对比</a>、<a href="#3%E6%96%B0%E5%B0%BE%E4%B8%8E%E6%97%A7%E5%A4%B4%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">3.新尾与旧头交叉对比</a>、<a href="#4%E6%96%B0%E5%A4%B4%E4%B8%8E%E6%97%A7%E5%B0%BE%E4%BA%A4%E5%8F%89%E5%AF%B9%E6%AF%94">4.新头与旧尾交叉对比</a>，以上四种不论是否定义元素属性key</p>
<ol>
<li>定义了，可以快速判断出不相同（但不完全可靠）</li>
</ol>
<p>使用遍历索引作为key，</p>
<blockquote>
<p>它也可以用于强制替换元素&#x2F;组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<p>完整地触发组件的生命周期钩子<br>触发过渡</p>
</blockquote>
<blockquote>
<p>diff算法默认使用“就地复用”的策略，是一个首尾交叉对比的过程。<br>用index作为key和不加key是一样的，都采用“就地复用”的策略<br>“就地复用”的策略，只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>将与元素唯一对应的值作为key，可以最大化利用dom节点，提升性能</p>
</blockquote>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="#">回到顶部</a></p>
<h2 id="sameVnode的功能与实现逻辑"><a href="#sameVnode的功能与实现逻辑" class="headerlink" title="sameVnode的功能与实现逻辑"></a>sameVnode的功能与实现逻辑</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        <span class="comment">// 标签相同</span></span><br><span class="line">        a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都是注释元素, 或都不是</span></span><br><span class="line">        a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// idDef = (v) =&gt; v !== undefined &amp;&amp; v !== null</span></span><br><span class="line">        <span class="comment">// 都定义了，或都没有定义</span></span><br><span class="line">        <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a = &#123; data: &#123; atttrs: &#123; type: &#x27;xxx&#x27; &#125; &#125; &#125;</span></span><br><span class="line">        <span class="comment">// 1. 两节点的type相同，</span></span><br><span class="line">        <span class="comment">//   i. type存在, 且相同；</span></span><br><span class="line">        <span class="comment">//   ii. 两个type都没有定义，都是undefined；a、b都算是通过</span></span><br><span class="line">        <span class="comment">// 2. a、b节点type都是&#x27;text,number,password,search,email,tel,url&#x27;中之一</span></span><br><span class="line">        <span class="comment">// 换言之 a.type = text, b.type = password，也可以说两个input节点相同</span></span><br><span class="line">        <span class="comment">// 3. a不是input标签</span></span><br><span class="line">        <span class="title function_">sameInputType</span>(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        <span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp;</span><br><span class="line">        a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * makeMap是个工厂函数，生成 isTextInputType = (key) =&gt; &#123;</span></span><br><span class="line"><span class="comment"> *   const map = &#123; text: true, ..., url: true &#125;;</span></span><br><span class="line"><span class="comment"> *   return map[key];</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 类似于 (val) =&gt; [text,number,password,search,email,tel,url].include(val);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">const</span> isTextInputType = <span class="title function_">makeMap</span>(<span class="string">&#x27;text,number,password,search,email,tel,url&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sameInputType</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">tag</span> !== <span class="string">&#x27;input&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> typeA = <span class="title function_">isDef</span>(i = a.<span class="property">data</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">attrs</span>) &amp;&amp; i.<span class="property">type</span></span><br><span class="line">  <span class="keyword">const</span> typeB = <span class="title function_">isDef</span>(i = b.<span class="property">data</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">attrs</span>) &amp;&amp; i.<span class="property">type</span></span><br><span class="line">  <span class="keyword">return</span> typeA === typeB || <span class="title function_">isTextInputType</span>(typeA) &amp;&amp; <span class="title function_">isTextInputType</span>(typeB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patchVnode函数的关键实现"><a href="#patchVnode函数的关键实现" class="headerlink" title="patchVnode函数的关键实现"></a>patchVnode函数的关键实现</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (<span class="params"><span class="comment">/* */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a. 复用elm，将oldVnode.elm赋值到newVnode.elm；</span></span><br><span class="line">  <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// b. 更新elm上的属性变动；</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      cbs.<span class="property">update</span>[i](oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有文本，即是还有子节点等情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// 新旧vnode都有children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// c. 更新newVnode.children，增删或复用，这里的复用就是通过调用`updateChildren`来实现，没错递归了！</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他的更新children的操作：增、删等</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nodeOps-insertBefore实现"><a href="#nodeOps-insertBefore实现" class="headerlink" title="nodeOps.insertBefore实现"></a>nodeOps.insertBefore实现</h2><p>path: src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;node-ops.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">insertBefore</span> (<span class="params"><span class="attr">parentNode</span>: <span class="title class_">Node</span>, <span class="attr">newNode</span>: <span class="title class_">Node</span>, <span class="attr">referenceNode</span>: <span class="title class_">Node</span></span>) &#123;</span><br><span class="line">  parentNode.<span class="title function_">insertBefore</span>(newNode, referenceNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Node.insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点。如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置（在将节点附加到其他节点之前，不需要从其父节点删除该节点）。</p>
</blockquote>
<h2 id="vnode（虚拟节点）的成员属性"><a href="#vnode（虚拟节点）的成员属性" class="headerlink" title="vnode（虚拟节点）的成员属性"></a>vnode（虚拟节点）的成员属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="comment">// 标签</span></span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// elm（Element）的属性</span></span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 子虚拟节点</span></span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 真实dom元素</span></span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 元素命名空间</span></span><br><span class="line">  <span class="attr">ns</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?<span class="built_in">string</span>; <span class="comment">// functional scope id support</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
        <tag>topping</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL搭建丝滑的开发环境</title>
    <url>/blog/resources/WSL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本手册基于已经安装WSL2的前提编写，因此需要将windows系统升级到对应的版本，并已经安装WSL2。若未安装可参考 <a href="https://isaaxite.github.io/blog/resources/%E5%88%9D%E8%AF%86WSL2">初识WSL2</a>。</p>
<p>环境初始化分为三块：编辑器、终端 和 Linux系统。编辑器将使用VSCode；终端使用windows Terminal；Linux使用Debian。</p>
<p>💬 <strong>为什么是 VSCode？</strong></p>
<p>VSCode (Visual Studio Code) 是一款由微软推出的免费、开源的现代化代码编辑器，它具有许多优点，其中一个显著的优点是其对 WSL (Windows Subsystem for Linux) 的支持。</p>
<p>使用 VSCode 连接 WSL的好处包含不限于：</p>
<ul>
<li><p><strong>跨平台使用</strong>，VSCode 支持 Windows、Linux 和 macOS 三种主流操作系统，与 WSL 的结合可以让开发人员在 Windows 操作系统中使用 Linux 环境下的开发工具，无需切换到 Linux 操作系统</p>
</li>
<li><p><strong>编辑 Linux 文件系统</strong>，通过在 VSCode 中使用 WSL，开发人员可以轻松地编辑 Linux 文件系统中的文件，无需在 Windows 和 Linux 操作系统之间切换</p>
</li>
<li><p><strong>与 WSL 集成的终端</strong>，VSCode 提供了一个终端，可以与 WSL 集成。这个终端可以让开发人员在一个窗口中同时运行 Windows 和 WSL 命令，并且可以轻松地切换到不同的 WSL 发行版</p>
</li>
<li><p><strong>支持调试 WSL 中的应用程序</strong>，通过在 VSCode 中配置 WSL，开发人员可以使用 VSCode 的调试器来调试运行在 WSL 中的应用程序，这使得调试变得更加便捷和高效。</p>
</li>
<li><p><strong>对 Docker 的支持</strong>，WSL 支持在 Linux 应用程序中运行 Docker。通过在 VSCode 中使用 WSL，开发人员可以轻松地开发和调试 Docker 容器。</p>
</li>
</ul>
<p>💬 <strong>为什么是 Windows Terminal？</strong></p>
<p>选择的基本原则首先是可以访问WSL无中文编码问题其次是不难看、不需要太多初始化。</p>
<p>windows下好用终端不多，可供选择的个人认为有下面几款：</p>
<table>
<thead>
<tr>
<th>终端模拟器</th>
<th>描述</th>
<th>主要特点</th>
<th>Star 数量</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/microsoft/terminal">Windows Terminal ↗</a></td>
<td>微软官方开发，现代化终端模拟器</td>
<td>多标签页、多窗口、自定义主题</td>
<td>13.1k</td>
</tr>
<tr>
<td><a href="https://github.com/ConEmu-Maximus5/ConEmu">ConEmu ↗</a></td>
<td>免费、开源，多功能终端模拟器</td>
<td>多标签页、自定义主题、自动滚动</td>
<td>8.1k</td>
</tr>
<tr>
<td><a href="https://github.com/vercel/hyper">Hyper ↗</a></td>
<td>基于Electron，支持插件扩展</td>
<td>多标签页、自定义主题、快捷键</td>
<td>33.7k</td>
</tr>
<tr>
<td><a href="https://github.com/Eugeny/terminus">Terminus ↗</a></td>
<td>跨平台，支持插件扩展</td>
<td>多标签页、多窗口、自定义主题</td>
<td>7.4k</td>
</tr>
<tr>
<td><a href="https://mobaxterm.mobatek.net/">MobaXterm ↗</a></td>
<td>支持多种协议，具有多项功能</td>
<td>SSH、Telnet、RDP、文件传输、X11转发、远程桌面</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<p>相比之下，<code>Windows Terminal</code> 天然支持 WSL，不难看，而且无 <code>Cmder</code> 等的中文编码问题。</p>
<p>当然，有更好的选择也可以择优而用。</p>
<p>💬 <strong>为什么是 Debian？</strong></p>
<p>WSL2可供选择linux发行不多，商用推荐使用CentOS但是，WSL2没有，退而求其次选Debian。</p>
<p>这个无太多且别，按个人喜好选择。</p>
<p><strong>📢 本手册说明流程如下：</strong></p>
<ol>
<li><p><a href="#%E5%AE%89%E8%A3%85-Debian">首先会使用WSL2安装Debian</a>；</p>
</li>
<li><p><a href="#VSCode%E8%BF%9E%E6%8E%A5WSL">VSCode安装插件，连接Debian</a>；</p>
</li>
<li><p><a href="#Windows-Terminal%E8%BF%9E%E6%8E%A5Debian">Windows Terminal添加Debian</a>；</p>
</li>
<li><p><a href="#%E6%9B%BF%E6%8D%A2-apt-%E8%BD%AF%E4%BB%B6%E6%BA%90">使用Windows Terminal对Debian进行初始化</a>。</p>
</li>
</ol>
<p>📌 <em>流程种会着重描述对Debian的初始化，初始化的策略是先做必要的，再做可选的。</em></p>
<p><strong>必要的初始化：</strong></p>
<ul>
<li><p><a href="#%E6%9B%BF%E6%8D%A2-apt-%E8%BD%AF%E4%BB%B6%E6%BA%90">替换 apt 软件源</a></p>
</li>
<li><p><a href="#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86">设置Debian全局代理</a></p>
</li>
<li><p><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-NodeJS-%E7%8E%AF%E5%A2%83">NodeJS环境初始化</a></p>
</li>
</ul>
<p><strong>可选的初始化：</strong></p>
<ul>
<li><p><a href="#%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6">Linux基础软件安装</a></p>
</li>
<li><p><a href="#%E4%BF%AE%E6%94%B9Git%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8">修改Git默认编辑器</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5">SSH公约生成</a></p>
</li>
<li><p><a href="#%E6%9B%BF%E6%8D%A2%E9%BB%98%E8%AE%A4Shell">替换默认shell</a></p>
</li>
</ul>
<h1 id="安装-Debian"><a href="#安装-Debian" class="headerlink" title="安装 Debian"></a>安装 Debian</h1><p>在 <code>PowerShell</code> 使用 <code>wsl --list -o</code> 可查看当前支持安装的 linux 发行版本，使用 <code>--install</code> 可安装你需要的 linux 发行版本，更多的 WSL 可选项可以通过 <code>--help</code> 查看 或 阅读 <a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config">Advanced settings configuration in WSL</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --install --distribution Debian</span><br></pre></td></tr></table></figure>

<p>接着是耐心的等待。</p>
<p>安装完成之后，需要初始化账号和密码，然后即可在 Windows Terminal添加Debian。</p>
<p><img src="Snipaste_2023-07-10_10-59-57.png"></p>
<h1 id="VSCode连接WSL"><a href="#VSCode连接WSL" class="headerlink" title="VSCode连接WSL"></a>VSCode连接WSL</h1><p>安装VSCode插件 <code>WSL</code>(ExtentionID: <code>ms-vscode-remote.remote-wsl</code>)，它让我们可以便捷地远程访问WSL安装的Debian</p>
<blockquote>
<p><img src="Snipaste_2023-07-10_15-27-04.png"></p>
</blockquote>
<p>连接Debian</p>
<p><img src="Snipaste_2023-07-10_16-17-01.png"></p>
<h1 id="Windows-Terminal连接Debian"><a href="#Windows-Terminal连接Debian" class="headerlink" title="Windows Terminal连接Debian"></a>Windows Terminal连接Debian</h1><p>📢 Windows Terminal可以直接在 <code>MicroSoft Store</code> 安装。</p>
<p>将 Debian 设为默认：</p>
<p><img src="Snipaste_2023-07-10_16-20-05.png"></p>
<p>修改配置方案：</p>
<p><img src="Snipaste_2023-07-10_16-22-24.png"></p>
<h1 id="替换-apt-软件源"><a href="#替换-apt-软件源" class="headerlink" title="替换 apt 软件源"></a>替换 apt 软件源</h1><p>Debian 12 默认使用的软件管理工具是 <a href="https://manpages.ubuntu.com/manpages/xenial/man8/apt.8.html">apt</a>。为了更快的软件安装速度，首先要做的是把 apt 的软件源从官方源替换为国内源</p>
<p>软件源保存在 <a href="https://manpages.ubuntu.com/manpages/focal/en/man5/sources.list.5.html"><code>/etc/apt/source.list</code></a>，通过编辑此文件内容修改源。</p>
<p>💡 <em>Debian 12 默认支持 <code>vi</code>，因此可使用 <code>vi</code> 编辑。可使用 <code>dpkg -l</code> 查看当前安装的系统软件</em></p>
<h2 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h2><p>国内有好几个软件源，包含但不限于：</p>
<ul>
<li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华源镜像</a></p>
</li>
<li><p><a href="https://mirrors.cloud.tencent.com/">腾讯软件源</a></p>
</li>
<li><p><a href="https://developer.aliyun.com/mirror/">阿里源</a></p>
</li>
<li><p><a href="https://mirrors.huaweicloud.com/home">华为源</a></p>
</li>
<li><p><a href="http://mirrors.ustc.edu.cn/">中科大源</a></p>
</li>
</ul>
<p>下面会使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/">清华源镜像</a>, 它有个 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">help页面</a> 可方便快速生成 Debian 的 apt 源内容。</p>
<blockquote>
<p><img src="Snipaste_2023-07-10_11-42-51.png"></p>
</blockquote>
<h2 id="修改-source-list"><a href="#修改-source-list" class="headerlink" title="修改 source.list"></a>修改 source.list</h2><p>备份旧源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv /etc/apt/source.list /etc/apt/source.list.backup</span><br></pre></td></tr></table></figure>

<p>使用新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/apt/source.list</span><br></pre></td></tr></table></figure>

<p>替换内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span></span></span><br><span class="line"></span><br><span class="line">deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br></pre></td></tr></table></figure>

<h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>接着是耐心的等待。</p>
<p><strong>📢 Debian Buster 以上版本默认支持 HTTPS 源。如果遇到无法拉取 HTTPS 源的情况，请先使用 HTTP 源并安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>

<h1 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h1><p>📢 <em>此为可选操作，若无科学上网方法可跳过</em></p>
<p>由于某些原因访问github资源速度会较慢，假如有梯子的话，可设置代理让访问速度更顺畅！</p>
<p>设置代理的方式是通过添加 <code>http_proxy</code> 和 <code>https_proxy</code> 两个环境变量。添加方式有几个，下面仅通过<code>profile</code> 方式添加。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑profile</span></span><br><span class="line">vi ~/.profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件底部追加</span></span><br><span class="line">export http_proxy=&lt;http_proxy&gt;</span><br><span class="line">export https_proxy=https_proxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line">export https_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存后，重载配置</span></span><br><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>

<h1 id="初始化-NodeJS-环境"><a href="#初始化-NodeJS-环境" class="headerlink" title="初始化 NodeJS 环境"></a>初始化 NodeJS 环境</h1><p>接下来不会直接使用apt安装nodejs，而是使用 nodejs 的版本管理工具，以便后续按需在不同的node版本间切换。</p>
<p>常用的NodeJS版本管理工具有：</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>主要特点</th>
<th>Star 数量</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/nvm-sh/nvm">nvm (Node Version Manager) ↗</a></td>
<td>最受欢迎的版本管理工具之一，可安装和管理多个Node.js版本</td>
<td>可以轻松切换不同版本的Node.js，兼容macOS、Linux和Windows</td>
<td><em>68.4k</em></td>
</tr>
<tr>
<td><a href="https://github.com/tj/n">n (Node.js Version Management) ↗</a></td>
<td>另一种流行的版本管理工具，可以快速安装和切换Node.js版本</td>
<td>命令简单易用，支持在终端中直接安装和升级Node.js</td>
<td><em>17.8k</em></td>
</tr>
<tr>
<td><a href="https://github.com/jasongin/nvs">nvs (Node Version Switcher) ↗</a></td>
<td>具有自动切换Node.js版本的版本管理工具</td>
<td>支持Windows、macOS和Linux，可以自动在不同的项目中使用不同版本的Node.js</td>
<td><em>2.4k</em></td>
</tr>
<tr>
<td><a href="https://github.com/Schniz/fnm">fnm (Fast Node Manager) ↗</a></td>
<td>快速、简单的Node.js版本管理工具</td>
<td>支持在不同的项目中使用不同版本的Node.js，可与 Fish Shell 和 PowerShell 集成</td>
<td><em>12.4k</em></td>
</tr>
</tbody></table>
<h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 <a href="https://github.com/nvm-sh/nvm">nvm</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure>

<h2 id="nvm-常用命令"><a href="#nvm-常用命令" class="headerlink" title="nvm 常用命令"></a>nvm 常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地node版本</span></span><br><span class="line">nvm ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可安装node版本</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">nvm install &lt;node version&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">nvm uninstall &lt;node version&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换</span></span><br><span class="line">nvm use &lt;node version&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认 nodejs 版本</span></span><br><span class="line">nvm alias default &lt;node version&gt;</span><br></pre></td></tr></table></figure>
<p><img src="Snipaste_2023-07-10_12-18-35.png"></p>
<h1 id="基础软件"><a href="#基础软件" class="headerlink" title="基础软件"></a>基础软件</h1><ul>
<li><p><strong>git</strong>：分布式版本控制系统，用于管理和跟踪计算机文件的更改</p>
</li>
<li><p><strong>curl</strong>：用于在命令行中进行数据传输的工具，它可以通过各种协议（包括HTTP、HTTPS、FTP、SMTP等）获取或发送数据</p>
</li>
<li><p><strong>wget</strong>：用于从命令行中下载文件的工具。它可以通过HTTP、HTTPS、FTP等协议下载文件，并支持断点续传和递归下载</p>
</li>
<li><p><strong>vim</strong>：文本编辑器，它是Unix和Linux系统中最常用的编辑器之一。它是vi编辑器的改进版本，因此它的名字也有时解释为”Vi IMproved”</p>
</li>
<li><p><strong>lsof</strong>：用于列出打开文件的工具，它可以显示当前系统中所有正在使用的文件和进程</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install git curl wget vim lsof -y</span><br></pre></td></tr></table></figure>

<h1 id="修改Git默认编辑器"><a href="#修改Git默认编辑器" class="headerlink" title="修改Git默认编辑器"></a>修改Git默认编辑器</h1><p>Git默认编辑器是 <code>nano</code>，使用体验对于来说一言难尽，习惯使用 <code>vim</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vim</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h1 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h1><p>生成SSH公钥以便从Github等代码托管平台clone代码。</p>
<p><strong>生成：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;pc-wsl-debian&quot;</span><br></pre></td></tr></table></figure>

<p><strong>获取：</strong></p>
<p>生成时会输出SSH key的输出文件，公钥默认在 <code>~/.ssh/id_rsa.pub</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h1 id="替换默认Shell"><a href="#替换默认Shell" class="headerlink" title="替换默认Shell"></a>替换默认Shell</h1><p>📢 Debian 默认 shell 是 bash。相比于bash，zsh有更好的自动补全、更强大的模式匹配、更好的可定制性、更好的历史记录和更好的作业控制。</p>
<p>下面将安装 zsh、设为默认的 shell和添加主题。</p>
<p>⚠️ <em>改用 zsh 后，需要将 <a href="#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86">设置代理</a> 中的的环境变量迁移到 <code>~/.zshrc</code> 中</em></p>
<p><strong>使用apt安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh -y</span><br></pre></td></tr></table></figure>

<p><strong>设为默认shell</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前支持的shell</span></span><br><span class="line">cat /etc/shells</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设为默认shell</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前使用的shell</span></span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<p><strong>添加主题（oh-my-zsh）</strong></p>
<p>安装： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>修改 theme：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑配置文件</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ZSH_THEME 属性</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set name of the theme to load --- <span class="keyword">if</span> <span class="built_in">set</span> to <span class="string">&quot;random&quot;</span>, it will</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">load a random theme each <span class="keyword">time</span> oh-my-zsh is loaded, <span class="keyword">in</span> <span class="built_in">which</span> <span class="keyword">case</span>,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to know <span class="built_in">which</span> specific one was loaded, run: <span class="built_in">echo</span> <span class="variable">$RANDOM_THEME</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line">ZSH_THEME=&quot;ys&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看支持的主题</span></span><br><span class="line">ls ~/.oh-my-zsh/themes</span><br></pre></td></tr></table></figure>

<p>主题预览参考：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></p>
<p>重载配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></li>
<li><a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh</a></li>
<li><a href="https://computingforgeeks.com/how-to-set-system-proxy-on-debian-linux/">How To Set System Proxy on Debian 11&#x2F;10&#x2F;9</a></li>
<li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Generating-Your-SSH-Public-Key">Git on the Server - Generating Your SSH Public Key</a></li>
<li><a href="https://github.com/nvm-sh/nvm">nvm (Node Version Manager) </a></li>
<li><a href="https://manpages.ubuntu.com/manpages/xenial/man8/apt.8.html">apt - command-line interface</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/terminal/customize-settings/startup">Startup settings in Windows Terminal</a></li>
</ul>
]]></content>
      <tags>
        <tag>环境配置</tag>
        <tag>NodeJS</tag>
        <tag>VSCode</tag>
        <tag>Linux</tag>
        <tag>Debian</tag>
        <tag>Windows</tag>
        <tag>WSL</tag>
        <tag>Windows Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux 的相关概念与基本使用</title>
    <url>/blog/resources/linux-%E8%BD%AF%E4%BB%B6-tmux/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的首要目的是记录，而非完全性的指南，不免会有缺漏。目标是随时间的推移逐步完善此记录，最终达到指南的程度。将以 tmux 的官方文档为核心其他资料为辅介绍 tmux 的基本概念和术语，让 tmux 的潜在用户对它有基本的了解，以达到无痛入门，降低心智消耗的作用。涉及 tmux 的会话（session）、视窗（window）、窗格（pane）和其他的核心内容的基本使用，以达到开箱即用，为 tmux 拾一根薪火（赞美太阳🔥）。</p>
<span id="more"></span>

<p>下文涉及到的 tmux 相关概念和术语除首次出现外大部分将尽量使用原文，以免产生歧义，以及养成熟悉度方便未来阅读原文。</p>
<p>再次言明，本文系结合 tmux wiki 原文等资料与笔者的实践与理解写就，仅供参考，不具备权威性，请以辩证思维进行阅读。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><blockquote>
<p>System:<br> Kernel: 5.15.0-76-generic x86_64 bits: 64 compiler: gcc v: 11.3.0 <mark>Desktop: Cinnamon 5.8.4</mark><br>   tk: GTK 3.24.33 wm: muffin dm: LightDM <mark>Distro: Linux Mint 21.2 Victoria base: Ubuntu 22.04 jammy</mark></p>
<p>CPU:<br> Info: 8-core <mark>model: AMD Ryzen 7 5800HS Creator Edition bits: 64</mark> type: MT MCP arch: Zen 3 rev: 0<br>   cache: L1: 512 KiB L2: 4 MiB L3: 16 MiB<br> Speed (MHz): avg: 2705 high: 3887 min&#x2F;max: 1200&#x2F;3200 boost: enabled cores: 1: 2938 2: 578<br>   3: 2473 4: 2268 5: 2233 6: 3057 7: 2560 8: 2473 9: 2524 10: 2734 11: 3887 12: 3467 13: 2903<br>   14: 2943 15: 2931 16: 3311 bogomips: 102206<br> Flags: avx avx2 ht lm nx pae sse sse2 sse3 sse4_1 sse4_2 sse4a ssse3 svm</p>
</blockquote>
<h2 id="Tmux-版本"><a href="#Tmux-版本" class="headerlink" title="Tmux 版本"></a>Tmux 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [4:15:33]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux -V</span></span><br><span class="line">tmux 3.2a</span><br></pre></td></tr></table></figure>

<h2 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h2><ul>
<li><p><a href="https://gnunn1.github.io/tilix-web/">Tilix</a>: Tilix is an advanced GTK3 tiling terminal emulator that follows the Gnome Human Interface Guidelines；</p>
</li>
<li><p><a href="https://help.gnome.org/users/gnome-terminal/stable/introduction.html.en">Gnome-Terminal</a>: Terminal is a terminal emulator application for accessing a UNIX shell environment which can be used to run programs available on your system.</p>
</li>
</ul>
<h2 id="终端类型（-TERM）"><a href="#终端类型（-TERM）" class="headerlink" title="终端类型（$TERM）"></a>终端类型（$TERM）</h2><ul>
<li><p>Tilix：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [5:03:08]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$TERM</span></span> </span><br><span class="line">xterm-256color</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gnome-Terminal：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [5:04:25]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$TERM</span></span></span><br><span class="line">xterm-256color</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>图形窗口系统：X11（X Window System）；</li>
<li>shell：zsh</li>
</ul>
<h1 id="关于-Tmux"><a href="#关于-Tmux" class="headerlink" title="关于 Tmux"></a>关于 Tmux</h1><p>Tmux 是一个功能强大的终端复用器，它可以大大提高用户的生产力和工作效率。它的主要特点包括：</p>
<ol>
<li><strong>会话管理</strong>：Tmux 允许用户在同一个终端窗口中创建、管理和切换多个独立的会话。这使得用户可以同时运行和访问多个程序。</li>
<li><strong>窗口和窗格</strong>：每个会话都可以包含多个窗口,每个窗口又可以被分割成多个窗格。这使得用户可以在同一个会话中同时查看和操作多个程序。</li>
<li><strong>持久性</strong>：Tmux 会话可以在用户断开连接后继续运行，当用户重新连接时可以恢复之前的会话状态。这对于长时间运行的任务非常有用。</li>
<li><strong>自定义配置</strong>：Tmux 有一个强大的配置系统，允许用户自定义快捷键、外观和行为,以满足个人需求。</li>
<li><strong>插件系统</strong>：Tmux 有一个丰富的插件生态系统，用户可以安装各种插件来扩展它的功能,如状态栏、窗口管理器等。</li>
<li><strong>跨平台</strong>：Tmux 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows (通过 WSL)。</li>
</ol>
<p>总的来说，Tmux 是一个非常强大和灵活的终端复用器，它可以帮助用户提高工作效率和生产力。通过学习和使用 Tmux 的各种特性，用户可以根据自己的需求定制一个高度个性化的终端工作环境。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="热键组合的使用"><a href="#热键组合的使用" class="headerlink" title="热键组合的使用"></a>热键组合的使用</h2><blockquote>
<p>When the prefix key is pressed, tmux waits for another key press and that determines what tmux command is executed. Keys like this are shown here with a space between them: <mark><code>C-b c</code> means first the prefix key <code>C-b</code> is pressed, then it is released and then the <code>c</code> key is pressed.</mark> Care must be taken to release the <code>Ctrl</code> key after pressing <code>C-b</code> if necessary - <code>C-b c</code> is different from <code>C-b C-c</code>.<br>Refer from <a href="https://github.com/tmux/tmux/wiki/Getting-Started#the-prefix-key">Tmux Wiki | The prefix key</a></p>
</blockquote>
<p>使用 <code>-</code> 连接的按键表示需要同时按住（不需要同一时间点按下，只需全部按住）；使用 <code>+</code> 连接的，表示有前后顺序：先松开 <code>+</code> 左边的按键组合，再按 <code>+</code> 右边的按键组合</p>
<h2 id="热键的书写"><a href="#热键的书写" class="headerlink" title="热键的书写"></a>热键的书写</h2><p>为避免歧义，下文中书写的热键组合均大小写敏感！比如： <code>Ctrl</code> - <code>b</code> + <code>s</code> 中只需按 <code>Ctrl</code>、 <code>b</code> 和 <code>s</code>；而 <code>Ctrl</code> - <code>b</code> + <code>D</code> 则需要按 <code>Ctrl</code>、 <code>b</code> 和 <code>Shift</code>、<code>d</code>。涉及到的非字母符号均为半角的，比如热键：<code>Ctrl-b</code> + <code>?</code>。</p>
<p>tmux 的语境中有按键前缀的概念，默认情况下是 <code>Ctrl</code> - <code>b</code> ，下文不考虑已通过配置文件修改前缀的情况，统一使用<code>Ctrl</code> - <code>b</code> 指代 tmux 的按键前缀，如已修改，请在阅读下文时自行脑内替换。另外，下文会使用 <code>C-b</code> 的简写代替<code>Ctrl</code> - <code>b</code> （参考官方写法）。</p>
<blockquote>
<p>The default prefix key is <code>C-b</code>, which means the <code>Ctrl</code> key and <code>b</code>. <mark>In tmux, modifier keys are shown by prefixing a key with <code>C-</code> for the control key, <code>M-</code> for the meta key (normally <code>Alt</code> on modern computers) and <code>S-</code> for the shift key. </mark>These may be combined together, so <code>C-M-x</code> means pressing the control key, meta key and <code>x</code> together.<br>Refer from <a href="https://github.com/tmux/tmux/wiki/Getting-Started#the-prefix-key">Tmux Wiki | The prefix key</a></p>
</blockquote>
<p>tmux 除了使用频率较高的 <code>C-b</code> 按键前缀中的 <code>C-</code>（<code>Ctrl</code>键） 外，还有 <code>M-</code>（<code>Alt</code> 键，也称为 <code>meta</code> 键） 和 <code>S-</code>（<code>Shift</code> 键）两个。</p>
<h2 id="Tab-自动补全"><a href="#Tab-自动补全" class="headerlink" title="Tab 自动补全"></a><code>Tab</code> 自动补全</h2><p>下文中提到的 <code>tab</code> 键自动补全以及触发选择 prompt 的能力非默认自带，而是安装 <code>zsh</code> shell 带来的。</p>
<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>本章节将介绍 tmux 的相关概念与术语，但仅限于本文涉及到的，非暗示 tmux 仅有以下相关概念与术语。完整的内容请参考原文，<a href="https://github.com/tmux/tmux/wiki/">Tmux Wiki</a>。</p>
<h2 id="命令与热键"><a href="#命令与热键" class="headerlink" title="命令与热键"></a>命令与热键</h2><p>tmux 支持使用命令和热键，它们是为在合适场景下使用 tmux 提供的能力。使用 <code>tmux list-conmands</code> 命令（详细见<a href="#tmux-list-commands">附录</a>）可查看 tmux 支持的命令；使用 <code>C-b</code> + <code>?</code> 热键（详细见<a href="#C-b">附录</a>）可查看 tmux 支持的热键。 </p>
<p>命令与热键部分能力重合，有提高效率的原因，也有因在特定场景下某一方无法使用时进行替换。比如执行的一些植守程序（如启动 hexo 服务：<code>npx hexo s</code>）后无法使用命令，则可使用热键。比如需要使用 <code>tmux choose-session</code> 选择 session，则可以使用热键（<code>C-b</code> + <code>s</code>） 代替。</p>
<p>命令与热键也有各自独有的能力，如用于绑定热键的命令（<code>tmux bind-key</code>）；用于显示 pane 序号的热键（<code>C-b</code> + <code>q</code>）这两都是各自一方所独有。</p>
<p>需要注意：热键仅在 tmux 内部可用。大部分命令于 tmux 内部使用，但也有部分特例，如附着 会话（seesion） 到客户端（client）——<code>tmux attach-session</code>——仅可在外部使用。</p>
<h2 id="tmux-的组成"><a href="#tmux-的组成" class="headerlink" title="tmux 的组成"></a>tmux 的组成</h2><p>这个章节将介绍 tmux-server、客户端（client）、会话（session）、窗口（window）和窗格（pane）的概念以及它们的关系。tmux 的组成可分为两个部分。其一是 client；其二是以 tmux-server 为根节点的，会话（session）、窗口（window）和窗格（pane）为子节点的树。</p>
<h3 id="tmux-server"><a href="#tmux-server" class="headerlink" title="tmux-server"></a>tmux-server</h3><p>tmux-server 如它名称是个服务器，是一个进程（使用 <code>ps -e | grep tmux</code> 即可看到名为 <code>tmux:server</code> 的进程），是 tmux 的根基。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [5:43:03]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -e | grep tmux</span> </span><br><span class="line">  16603 ?        00:00:00 tmux: server</span><br><span class="line">  18950 pts/1    00:00:00 tmux: client</span><br></pre></td></tr></table></figure>

<p>tmux-server 有且仅有一个，无需手动创建。伴随首个 session 的创建（需要 tmux 命令手动新建）tmux-server 便会启动。它的基本单位是 session，由多个 session 组成。因此，当 tmux-server 销毁时，所有 session， 以及 session 下的所有程序都将被销毁。</p>
<h3 id="客户端（client）和会话（session）"><a href="#客户端（client）和会话（session）" class="headerlink" title="客户端（client）和会话（session）"></a>客户端（client）和会话（session）</h3><p>客户端（client）是指各个终端模拟器（terminal）、比如 gnome-terminal。有些 terminal 是可以“分屏”的，比如 tilix，每个子屏对于 tmux 也是一个 client。client 是 tmux 用于“展示” 会话（session）的进程。</p>
<p>session 正如 <a href="#tmux-server">tmux-server</a> 章节所说是 tmux-server 的基本单位。每个 session 都是相互独立且在同一层级，意味着 session 是不可嵌套的。session 默认情况是与 client 无关联的。session 是后台程序，不可见的，因此 session 需要在 client 才能查看与使用，client 可以说是用户与 tmux 交互的工具。</p>
<p>在 client 中使用命令创建 session，默认就会将这个 client 和 session 关联在一起，在 tmux 的语境中，这样的现象叫：这个 session 附着（attach）到这个 client。tmux-server 可以有多个 session，这些 session 都可以 attach 在某个client 上，session 与 client 的附着关系是一对一的，即每次有且仅有一个 session 附着在某个 client 上。client 可以切换 session，指定哪个 seesion 附着在它上。</p>
<p>既然有这种“附着”的情况，也会有将 session 与 client 分离的操作：<code>tmux detach-client</code>，在 tmux 会话中执行此命令就会在不影响当前 session 的情况下回到 client 的默认shell（对 tmux 而言则是“外部shell”）。</p>
<h3 id="窗口（window）和窗格（pane）"><a href="#窗口（window）和窗格（pane）" class="headerlink" title="窗口（window）和窗格（pane）"></a>窗口（window）和窗格（pane）</h3><p>每个 session 在创建时显示的界面就是一个 window ——视觉上类似浏览器的标签页。一个 session 可以创建多个 window，每个 window 从展示的角度上看是相互独立的，不能同时展示，视觉上类似浏览器的各个标签页的展示逻辑。可以在当前会话的 window 执行 <code>tmux new-window</code> 命令创建新的 window ——视觉上类似浏览器新建标签页。</p>
<p>而 pane 则是 与 session 交互的基本单位。每个 window 至少有一个 pane，一个 window 可以创建多个 pane，这些 pane 同时展示，它们的展示区域组成 window 的区域。而每个窗口可以使用热键（水平：<code>C-b</code> + <code>&quot;</code>；竖直：<code>C-b</code> + <code>%</code>）或命令（水平：<code>tmux split-window -h</code>；竖直：<code>tmux split-window -v</code>；）分割（视觉上的分割，类似分屏）为多个 pane 。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>本章节将介绍四种模式：树模式（tree mode）、复制模式（copy mode）、客户端模式（client mode）和缓冲区模式（buffer mode），以及用于消除歧义而特殊说明的查看模式（view mode）。Tmux 非仅有以上几种模式，更多相关模式可参考：<a href="https://github.com/tmux/tmux/wiki/">Tmux Wiki</a>。</p>
<h3 id="树模式（tree-mode）"><a href="#树模式（tree-mode）" class="headerlink" title="树模式（tree mode）"></a>树模式（tree mode）</h3><blockquote>
<p><strong><a href="https://github.com/tmux/tmux/wiki/Getting-Started#choosing-sessions-windows-and-panes">Choosing sessions, windows and panes</a></strong><br><mark>tmux includes a mode where sessions, windows or panes can be chosen from a tree, this is called tree mode.</mark> It can be used to browse sessions, windows and panes;</p>
</blockquote>
<p>树模式（tree mode）是通过热键（ <code>C-b</code> + <code>s</code> 或 <code>C-b</code> + <code>w</code> ）触发的可交互视窗。在视窗中，可以使用方向键等热键选择 session、window 和 pane。</p>
<p>进入 tree mode，用于交互的常用热键见下表：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enter</code></td>
<td>提交（确认）当前选中的 session、window 或 pane</td>
</tr>
<tr>
<td><code>Up</code></td>
<td>切换至上面一个选项</td>
</tr>
<tr>
<td><code>Down</code></td>
<td>切换至下面一个选项</td>
</tr>
<tr>
<td><code>Right</code></td>
<td>展开当前选项</td>
</tr>
<tr>
<td><code>Left</code></td>
<td>折叠当前选项</td>
</tr>
<tr>
<td><code>x</code></td>
<td>删除（kill）当前选项</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出 tree mode</td>
</tr>
</tbody></table>
<p>除了以上的交互热键外，还有更多，可参考：<a href="https://github.com/tmux/tmux/wiki/Getting-Started#choosing-sessions-windows-and-panes">Choosing sessions, windows and panes</a><br><em>注意：tree mode 仅能由热键触发，执行 tmux 命令无法触发。</em></p>
<h3 id="客户端模式（client-mode）"><a href="#客户端模式（client-mode）" class="headerlink" title="客户端模式（client mode）"></a>客户端模式（client mode）</h3><blockquote>
<p><strong><a href="https://github.com/tmux/tmux/wiki/Getting-Started#detaching-other-clients">Detaching other clients</a></strong><br>A list of clients is available by pressing <code>C-b D</code> (that is, <code>C-b S-d</code>). This is similar to tree mode and is called client mode.</p>
</blockquote>
<p>客户端模式（client mode）是类似 tree mode 的视窗，与 tree mode 不同的是它展示一个 client 列表。在 tmux 中通过热键（<code>C-b</code> + <code>D</code>，使用命令——<code>tmux choose-client</code>——亦可，但此命令仅在 tmux 内使用）可以触发 client mode，在此可查看当前的 client，方向键切换高亮的 client 选项，<code>t</code> 切换标记（标记的作用是操作多个client，比如一次性删除多个），<code>Enter</code> 键分离选中的 client 与附着在它上的 session。与其他 mode。</p>
<p>除了上面提到的几个热键外，下表是 client mode 下 tmux 提供的所有热键：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enter</code></td>
<td>分离选中的 client 与附着在其上的 session</td>
</tr>
<tr>
<td><code>d</code></td>
<td>同 <code>Enter</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>分离标记的选项（作用类似 <code>Enter</code>，但它是一次性分离多个）</td>
</tr>
<tr>
<td><code>x</code></td>
<td>分离选中的选项并关闭 client 所在的终端模拟器</td>
</tr>
<tr>
<td><code>X</code></td>
<td>分离标记的选项并关闭 client 所在的终端模拟器</td>
</tr>
</tbody></table>
<h3 id="复制模式（copy-mode）"><a href="#复制模式（copy-mode）" class="headerlink" title="复制模式（copy mode）"></a>复制模式（copy mode）</h3><blockquote>
<p><strong><a href="https://github.com/tmux/tmux/wiki/Getting-Started#copy-and-paste">Copy and paste</a></strong><br>tmux has its own copy and paste system. A piece of copied text is called a paste buffer. Text is copied using copy mode, entered with <code>C-b [</code>, and the most recently copied text is pasted into the active pane with <code>C-b ]</code>.</p>
</blockquote>
<p>复制模式（copy mode）如其名是为了复制 pane 中的内容而存在的。和 tree mode 不同，它不会触发视窗。而是让光标可以在 pane 中内容中移动，对内容选择并复制。</p>
<p>可通过热键（<code>C-b</code> + <code>[</code>） 进入 copy mode。然后，使用方向键等等热键在 pane 的内容中移动，到达目标位置后，使用热键（<code>C-Space</code>）开始选中——锚定选中的起点，接着使用方向键等等热键扩大选中范围——锚定选中结束点。最后使用热键（<code>C-w</code>）复制选中并退出 copy mode。</p>
<p>在 tmux 中可以使用热键（<code>C-b</code> + <code>]</code>）粘贴刚刚复制的选中内容。</p>
<p><em>注意：tmux 自有一套剪切板，它有别于系统剪切板的。因此，默认情况下 copy mode 复制的内容在系统其他软件中无法使用，比如浏览器中（更多信息及解决方案见“<a href="#%E5%A4%8D%E5%88%B6-x2F-%E7%B2%98%E8%B4%B4">复制&#x2F;粘贴</a>”章节）。</em></p>
<p>除了上面提到的几个热键外，更多常用热键见下表：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td><code>Up</code>, <code>Down</code>, <code>Left</code>, <code>Right</code></td>
<td>在 pane 中内容移动光标</td>
</tr>
<tr>
<td><code>C-Space</code></td>
<td>开始选中，锚定选中的起点（在开始选中后，再次使用 <code>C-Space</code> 可取消选中）</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出 copy mode</td>
</tr>
<tr>
<td><code>C-a</code></td>
<td>移动光标到光标所在行的行首</td>
</tr>
<tr>
<td><code>C-e</code></td>
<td>移动光标到光标所在行的行尾</td>
</tr>
<tr>
<td><code>M-f</code></td>
<td>移动光标到下一个词</td>
</tr>
<tr>
<td><code>M-b</code></td>
<td>移动光标到前一个词</td>
</tr>
</tbody></table>
<p>除以上外，其他不太常用的热键可参考：<a href="https://github.com/tmux/tmux/wiki/Getting-Started#copy-and-paste">Copy and paste</a> 的表格。</p>
<h3 id="缓冲区模式（buffer-mode）"><a href="#缓冲区模式（buffer-mode）" class="headerlink" title="缓冲区模式（buffer mode）"></a>缓冲区模式（buffer mode）</h3><blockquote>
<p><mark>Once some text is copied, the most recent may be pasted with <code>C-b ]</code> or an older buffer pasted by using buffer mode, entered with <code>C-b =</code>. </mark>Buffer mode is similar to client mode and tree mode and offers a list of buffers together with a preview of their contents.<br><em>Refer from <a href="https://github.com/tmux/tmux/wiki/Getting-Started#copy-and-paste">Copy and paste</a></em></p>
</blockquote>
<p>缓冲区模式（buffer mode）基于 copy mode 复制的内容，通过热键（<code>C-b</code> + <code>=</code>）可以触发一个类似 tree mode 的视窗。在视窗中，可以查看历史的复制内容，通过热键交互、选择这些内容。</p>
<p>在 buffer mode 中，可使用方向键切换选项。使用 <code>t</code> 键可标记（tagging）选项——在标记状态下按 <code>t</code> 键可取消标记，更多的标记热键参考 <a href="https://github.com/tmux/tmux/wiki/Getting-Started#choosing-sessions-windows-and-panes">Choosing sessions, windows and panes</a> 的表格。同其他模式一样可以使用 <code>q</code> 退出 buffer mode。</p>
<p>除以上提到的热键外，下表是 buffer mode 下 tmux 提供的所有热键：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enter</code></td>
<td>选中，并粘贴该选项的“复制内容”</td>
</tr>
<tr>
<td><code>p</code></td>
<td>同 <code>Enter</code> 的作用</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴标记的选项的“复制内容”，当前无标记的选项则直接退出 buffer mode</td>
</tr>
<tr>
<td><code>d</code></td>
<td>删除当前高亮选项的“复制内容”</td>
</tr>
<tr>
<td><code>D</code></td>
<td>删除标记的选项</td>
</tr>
</tbody></table>
<h3 id="查看模式（view-mode）"><a href="#查看模式（view-mode）" class="headerlink" title="查看模式（view mode）"></a>查看模式（view mode）</h3><p>查看模式（view mode）与 tree mode、client mode 等不同，非某一特定场景下的交互方案。比起交互方案，它更接近一个在 tmux 语境下的术语或词语，表达进入一种仅可阅读的场景，比如热键（<code>C-b</code> + <code>？</code>）查看 tmux 支持的热键的列表。在原文的出现频率也不高，严格说，tmux 的模式中并不包含 view mode——此章节中对 view mode 特殊说明仅为避免歧义，以及阅读原文时引起的误会。</p>
<h2 id="命令输入行（command-prompt）"><a href="#命令输入行（command-prompt）" class="headerlink" title="命令输入行（command prompt）"></a>命令输入行（command prompt）</h2><blockquote>
<p><strong><a href="https://github.com/tmux/tmux/wiki/Getting-Started#the-command-prompt">The command prompt</a></strong><br>tmux has an interactive command prompt. <mark>This can be opened by pressing <code>C-b :</code> and appears instead of the status line</mark>, as shown in this screenshot.</p>
</blockquote>
<p>命令输入行（command prompt）是通过热键（<code>C-b</code> + <code>:</code>）触发命令输入行，它位于视窗的底部（原 status line 位置）。在 command prompt 中，可以输入 tmux 命令，比如输入 <code>tmux choose-session</code> 选择 session，并且它是支持去 “tmux” 前缀的，即输入 <code>choose-session</code> 同样有效。若需要同时输入多个 tmux 命令，使用 <code>;</code> 分隔即可。</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>本章节将介绍 tmux 的 session、window 和 pane 的基本使用，仅列出常用且基本的命令与热键的详细使用，更多请参考 <a href="https://github.com/tmux/tmux/wiki/">tmux wiki</a> 或使用 <code>C-b</code> + <code>?</code>（详细见<a href="#C-b">附录</a>） 和 <code>tmux list-commands</code> （详细见<a href="#tmux-list-commands">附录</a>）查阅。</p>
<h2 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h2><p>session 是 tmux-server 的基本单位，是“后台”程序。它属于任一终端模拟器，需要附着在 client（可以粗俗理解为某一终端）才能被交互。本章节将介绍 session 的新建、查看、删除、切换、进入（附着）、分离和重命名。</p>
<h3 id="新建（new）"><a href="#新建（new）" class="headerlink" title="新建（new）"></a>新建（new）</h3><p>tmux 中是不能会话嵌套的，因此，在 session 内不可使用 <code>tmux new</code> 创建新的会话，只能在外部 shell 中创建，也因此创建会话仅可使用命令创建。</p>
<p><code>tmux / tmux new</code>：创建会话，并自动分配会话名；</p>
<p><code>tmux new -s &lt;session name&gt;</code>：指定会话名并创建；</p>
<h3 id="查看（ls-list-session）"><a href="#查看（ls-list-session）" class="headerlink" title="查看（ls &#x2F; list-session）"></a>查看（ls &#x2F; list-session）</h3><p><code>tmux ls</code> 或 <code>tmux list-session</code>，此命令执行后，将会以文本日志的形式打印出来（不可交互），此命令在 tmux 内、外部均可使用。</p>
<h3 id="删除（kill-session）"><a href="#删除（kill-session）" class="headerlink" title="删除（kill-session）"></a>删除（kill-session）</h3><p>使用 <code>tmux kill-session</code>，使用 <code>tab</code> 按键可以触发更多可选项，不做扩展赘述，下面仅说明删除特定的会话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t &lt;session name&gt;</span><br></pre></td></tr></table></figure>

<p><code>-t</code> 后面可以使用 <code>tab</code> 按键触发选择模式指定会话。 </p>
<p><em>PS：<code>-t</code> 后面的参数值可以和 <code>-t</code> 连在一起。后面同样场景依然如此，不再赘述</em></p>
<p>进入 tree mode（使用热键 <code>C-b</code> + <code>s</code> 或 <code>C-b</code> + <code>w</code> ，也可使用命令：<code>tmux choose-tree</code>），在 tree mode 下切换（方向键）到目标会话选项，再使用 <code>x</code> 键（小写）即可删高亮的会话。</p>
<p>若需一次性删除多个会话，可在 tree mode 下，使用 <code>t</code> 标记待删除的会话选项，然后使用 <code>X</code>键（大写）即可。</p>
<h3 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h3><p>在 tree mode 下，切换至目标 session 的选项，然后使用 <code>Enter</code> 键即可切换至选中的session。</p>
<h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><p>在 tmux 内部，使用热键分离当前 session：<code>C-b</code> + <code>d</code></p>
<p>在 tree mode 下，分离单个 session ：对高亮的 session 选项使用 <code>d</code>；分离多个则，使用 <code>t</code> 标记后，使用 <code>D</code> 键。</p>
<h3 id="进入会话（attach-session）"><a href="#进入会话（attach-session）" class="headerlink" title="进入会话（attach-session）"></a>进入会话（attach-session）</h3><p>在 session 与 client 分离后，若需要从 tmux 外部再次进入（附着）session，只可使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux attach-session -t &lt;session name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="重命名会话（rename-session）"><a href="#重命名会话（rename-session）" class="headerlink" title="重命名会话（rename-session）"></a>重命名会话（rename-session）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux rename -t &lt;old session name&gt; &lt;new session name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="视窗（window）"><a href="#视窗（window）" class="headerlink" title="视窗（window）"></a>视窗（window）</h2><p>在 session 被新建时，即会创建一个 window。换句话说，session 被创建后看到的区域即是 window。每个 session 下可以创建多个 window。window 在视觉上类似浏览器的标签页，同样可创建多个，区域占满软件的可视区域。本章节将介绍 session 下 window 的新建、删除和切换。</p>
<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>使用热键：<code>C-b</code> + <code>c</code>；</p>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new-window</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定在哪个 session 下创建</span></span><br><span class="line">tmux new-window -t &lt;session name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 window 名</span></span><br><span class="line">tmux new-window -n &lt;window name&gt;</span><br></pre></td></tr></table></figure>

<p>创建 window 的命令可在 tmux 内、外部使用，但在外部使用后需要进入 tmux 内才能看到，不会自动进入 tmux 的 session。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用热键：</p>
<ol>
<li><code>C-b</code> + <code>&amp;</code>：删除当前 window；</li>
<li>删除单个：进入 tree mode，使用 <code>x</code> 删除指定 window。</li>
<li>删除多个：进入 tree mode，使用 <code>t</code> 标记待删除的 window 选项，最后使用 <code>X</code> 一次性删除标记的 window。</li>
</ol>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-window &lt;window 的序号或 window name&gt;</span><br></pre></td></tr></table></figure>

<p>注意：命令可在 tmux 内、外部使用。</p>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>使用热键：</p>
<ul>
<li>切换至前一个 window：<code>C-b</code> + <code>p</code>；</li>
<li>切换至后一个 window：<code>C-b</code> + <code>n</code>；</li>
<li>切换至某一window：<ol>
<li>序号为 0～9 的 window：<code>C-b</code> + <code>0</code> | <code>C-b</code> + <code>1</code> | … | <code>C-b</code> + <code>9</code>  ;</li>
<li>进入 tree mode，切换至目标 window 选项，使用 <code>Enter</code> 进入目标 window。</li>
</ol>
</li>
</ul>
<p>除了使用 tree mode 外的其他三个方式仅可在当前 session 内切换 window。</p>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至指定 window</span></span><br><span class="line">tmux select-window -t &lt;window 序号或 window name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至前一个 window</span></span><br><span class="line">tmux select-window -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至后一个 window</span></span><br><span class="line">tmux select-window -n</span><br></pre></td></tr></table></figure>


<h2 id="窗格（pane）"><a href="#窗格（pane）" class="headerlink" title="窗格（pane）"></a>窗格（pane）</h2><p>在 window 被创建时，即会有一个 pane。pane 正如其名——“窗格”，它是用于分割 window 为多个区域，从而产生多个可交互的 shell 区域的。本章节将介绍 window 下 pane 的新建、删除、切换和缩放。</p>
<h3 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a>新建</h3><p>在 tmux 中，可以基于当前 pane 向竖直与水平两个方向进行平均分割，从而创建新的窗格。</p>
<p>使用热键：</p>
<ul>
<li>水平方向（左右分割）：<code>C-b</code> + <code>%</code>；</li>
<li>竖直方向（上下分割）：<code>C-b</code> + <code>&quot;</code> 。</li>
</ul>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">水平方向（左右分割）</span></span><br><span class="line">tmux split-window -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">竖直方向（上下分割）</span></span><br><span class="line">tmux split-window -v</span><br></pre></td></tr></table></figure>

<h3 id="切换-1"><a href="#切换-1" class="headerlink" title="切换"></a>切换</h3><p>下面介绍是在当前 window 下的 pane 之间进行切换。</p>
<p>使用热键：</p>
<ul>
<li>切换至上方 pane：<code>C-b</code> + <code>up</code>；</li>
<li>切换至右方 pane：<code>C-b</code> + <code>right</code>；</li>
<li>切换至下方 pane：<code>C-b</code> + <code>down</code>；</li>
<li>切换至左方 pane：<code>C-b</code> + <code>left</code>。</li>
</ul>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至上方 pane</span></span><br><span class="line">tmux select-pane -U</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至右方 pane</span></span><br><span class="line">tmux select-pane -R</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至下方 pane</span></span><br><span class="line">tmux select-pane -D</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至左方 pane</span></span><br><span class="line">tmux select-pane -L</span><br></pre></td></tr></table></figure>

<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>在某些场景下（比如 pane 区域太小不便查看内容）可以使用缩放功能让当前 pane 的大小占满整个 window 区域。</p>
<p>使用热键：<code>C-b</code> + <code>z</code>，可在占满当前 window 的尺寸与原尺寸间切换。</p>
<p>使用命令：无</p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>下面介绍的是删除（kill）当前的 pane。</p>
<p>使用热键：<code>C-b</code> + <code>x</code></p>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-pane</span><br></pre></td></tr></table></figure>



<h1 id="复制-粘贴"><a href="#复制-粘贴" class="headerlink" title="复制&#x2F;粘贴"></a>复制&#x2F;粘贴</h1><p>tmux 自有一个与系统不同的剪切板，并且他们默认是不同步的。在 <a href="https://github.com/tmux/tmux/wiki/Clipboard">Tmux Wiki | Clipboard</a> 提供了 2 种方案实现 tmux 剪切板与系统剪切板的同步，分别是<a href="https://github.com/tmux/tmux/wiki/Clipboard#the-set-clipboard-option">The set-clipboard option</a> 和 <a href="https://github.com/tmux/tmux/wiki/Clipboard#external-tools">External tools</a>！</p>
<h2 id="使用第三方工具（External-tools）"><a href="#使用第三方工具（External-tools）" class="headerlink" title="使用第三方工具（External tools）"></a>使用第三方工具（External tools）</h2><p>正如 <a href="https://github.com/tmux/tmux/wiki/Clipboard#the-set-clipboard-option">The set-clipboard option</a>  中提到的：<code>set-option</code> 支持不完整并且配置略棘手，实际操作确如其事（配置难度不低，需要一定的 linux 知识储备）。</p>
<blockquote>
<p>tmux supports this through the <code>set-clipboard</code> option. The big advantage of this is that it works over an <em>ssh(1)</em> connection even if X11 forwarding is not configured. <mark>The disadvantages are that it is patchily supported and can be tricky to configure.</mark></p>
</blockquote>
<p>因此，本文不展开讨论  <a href="https://github.com/tmux/tmux/wiki/Clipboard#the-set-clipboard-option">The set-clipboard option</a> 方案。下面将针对  <a href="https://github.com/tmux/tmux/wiki/Clipboard#external-tools">External tools</a> 方案展开。</p>
<p>在  <a href="https://github.com/tmux/tmux/wiki/Clipboard#how-to-configure---tmux-32-and-later">Tmux Wiki | How to configure - tmux 3.2 and later</a> 中可以看到 tmux 给到的配置方案：</p>
<blockquote>
<p><strong>How to configure - tmux 3.2 and later</strong></p>
<p>tmux 3.2 introduced an option called <code>copy-command</code> to set a command to pipe to for all key bindings. This is used when <code>copy-pipe</code> is called with no arguments which is now the default. If the option is empty, the copied text is not piped.</p>
<p>To pipe to <em>xsel(1)</em>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -s copy-command &#x27;xsel -i&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 tmux 3.2 及以后的版本，可以通过 <code>copy-command</code> 监听所有复制行为。使用 <code>set -s copy-command &#39;&lt;script&gt;&#39;</code>，可把监听到的复制的内容写入 <code>&lt;script&gt;</code>，形如：<code>echo &#39;hello world!&#39; | &lt;script&gt;</code> 。</p>
<p>首先，需安装 <code>xsel</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install xsel -y</span><br></pre></td></tr></table></figure>

<p>编辑 <code>～/.tmux.conf</code> 添加配置。具体配置的 <code>xsel</code> 命令视发行版而定，当前发行版本（见背景说明）则使用 <code>xsel -b</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set -s copy-command &#x27;xsel -b&#x27;</span><br></pre></td></tr></table></figure>

<p>保存 <code>～/.tmux.conf</code> 配置文件，并重启 tmux server （<code>tmux kill-server</code>）。</p>
<p><code>xsel --help</code>（<a href="#xsel-%E2%80%93help">见附录</a>）提供了几个可将内容的写入剪切板的可选参数，分别是 <code>-i</code>、<code>-p</code> 、<code>-s</code> 和 <code>-b</code> 。若不清楚应选择那个可选参数，一个简单的验证方法是，执行 <code>echo &#39;test&#39; | xsel &lt;option&gt;</code>（<code>&lt;option&gt;</code> 自行替换），然后使用“系统粘贴”确认那个输出的是与 echo 的内容一致的。</p>
<h2 id="使用-oh-my-tmux"><a href="#使用-oh-my-tmux" class="headerlink" title="使用 oh-my-tmux"></a>使用 oh-my-tmux</h2><p>在 <a href="https://github.com/gpakosz/.tmux">Github repotory | gpakosz&#x2F;.tmux</a> 的特性中指出，<code>on-my-tmux</code> 提供了将复制的内容从 tmux 剪切板同步至系统剪切板的能力：</p>
<blockquote>
<p> <strong>Features</strong></p>
<ul>
<li><code>C-a</code> acts as secondary prefix, while keeping default <code>C-b</code> prefix</li>
<li>visual theme inspired by <a href="https://github.com/Lokaltog/powerline">Powerline</a></li>
<li><a href="http://pempek.net/articles/2013/04/14/maximizing-tmux-pane-new-window/">maximize any pane to a new window with <code>&lt;prefix&gt; +</code></a></li>
<li>SSH&#x2F;Mosh aware username and hostname status line information</li>
<li>mouse mode toggle with <code>&lt;prefix&gt; m</code></li>
<li>laptop battery status line information</li>
<li>uptime status line information</li>
<li>optional highlight of focused pane</li>
<li>configurable new windows and panes behavior (optionally retain current path)</li>
<li>SSH&#x2F;Mosh aware split pane (reconnects to remote server)</li>
<li><mark>copy to OS clipboard (needs <code>xsel</code>, <code>xclip</code>, or <code>wl-copy</code> on Linux)</mark></li>
<li>support for 4-digit hexadecimal Unicode characters</li>
<li><a href="https://facebook.github.io/PathPicker/">Facebook PathPicker</a> integration if available</li>
<li><a href="https://github.com/firecat53/urlscan">Urlscan</a> (preferred) or <a href="https://packages.debian.org/stable/misc/urlview">Urlview</a> integration if available</li>
</ul>
</blockquote>
<p>关于 <code>on-my-tmux</code> 的安装等详细信息在此小节不做展开，请参考下文的 <a href="#%E7%BE%8E%E5%8C%96-tmux">美化 tmux</a> 章节。</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>另外，值得注意的是 tmux 提供的方案是单向的同步——tmux 的复制操作得到内容向系统剪切板，无相反的流向——即会有以下情况：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>tmux 剪切板</th>
<th>系统剪切板</th>
</tr>
</thead>
<tbody><tr>
<td>tmux 复制</td>
<td>同步</td>
<td>同步</td>
</tr>
<tr>
<td>系统复制</td>
<td>未同步</td>
<td>同步</td>
</tr>
</tbody></table>
<p>当然，这样也不影响使用，只需在外部复制内容到 tmux 中是，使用系统的粘贴即可。</p>
<h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p><em>注：这里的“查看日志”非进入 tmux 的日志并查阅的行为。而是在 tmux 会话中，使用者执行的命令（此命令无特指，也非指 tmux 的命令）所输出的内容，比如：<code>ls</code>、<code>tree</code> 等等，这些内容即是当前章节讨论的“日志”。</em></p>
<p>随时间推移累计的内容或者单次输出的内容过多，不免就会需要有“翻页”，“滚动内容”的行为以查看非视窗内的日志。而 tmux 默认情况是不支持 “滚动” 操作（但可配置）。下面将说明“翻页”的使用和“滚动”的配置。</p>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><blockquote>
<p><strong><a href="https://github.com/tmux/tmux/wiki/Getting-Started#using-the-mouse">Using the mouse</a></strong></p>
<p>tmux has rich support for the mouse. It can be used to change the active pane or window, to resize panes, to copy text, or to choose items from menus.</p>
<p>Support for the mouse is enabled with the <code>mouse</code> option; options and the configuration file are described in detail in the next section. To turn the mouse on from the command prompt, use the <code>set-option</code> command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set -g mouse on</span><br></pre></td></tr></table></figure>
</blockquote>
<p>tmux 默认未提供仅用于“滚动”的模式或热键。但可使用 <code>set-option</code> 命令或编辑配置文件添加相关配置项，使“鼠标的滚轮”在 tmux 中生效，从而可以滚动 pane 的内容。</p>
<h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux set-option -g mouse on</span><br></pre></td></tr></table></figure>

<h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>打开 <code>~/.tmux.conf</code>（若无则创建），添加以下内容并保存，然后执行 <code>source ～/.tmux.conf</code> 试配置即使生效，或新建会话也可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>

<p>添加配置后，重载配置即可生效。更多配置相关的内容可查阅 <a href="https://github.com/tmux/tmux/wiki/Getting-Started#configuring-tmux">tmux wiki | Getting-Started | Configuring tmux</a> 获得。</p>
<h2 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h2><p>tmux 未提供仅用于翻页的热键。折中的方案是，进入复制模式（copy mode）：<code>C-b</code> + <code>[</code>， 在复制模式下，可以使用方向键移动光标从而查看视窗外的日志，<code>pageUp</code> 和 <code>pageDown</code> 同样有效。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>此处的“搜索”单指在 pane 输出的内容中进行搜索。tmux 未提供“直接搜索”的能力，需要先进入 copy mode，二次使用热键方可。因此，没有命令可以用于“搜索”，只能使用热键。</p>
<blockquote>
<ul>
<li><code>C-g</code>: Stop selecting without copying, or stop searching;</li>
<li><code>C-r</code>: Search interactively backwards;</li>
<li><code>M-f</code>: Move the cursor to the next word;</li>
<li><code>M-b</code>: Move the cursor to the previous word.</li>
</ul>
<p><em>The above content is excerpted from the table in Chapter <a href="https://github.com/tmux/tmux/wiki/Getting-Started#copy-and-paste">Copy and paste</a></em></p>
</blockquote>
<p>在 copy mode 下，使用 热键（<code>C-r</code> ）进入搜索状态，即可输入搜索的关键词，若内容中存在搜索相关文本则会自动高亮它们。使用热键（<code>M-f</code>）可在高亮的文本间向前切换，使用热键（<code>M-b</code>）则可向后切换。使用热键（<code>C-g</code>）可退出搜索状态，回到 copy mode。</p>
<h1 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h1><h2 id="查看-tmux-版本"><a href="#查看-tmux-版本" class="headerlink" title="查看 tmux 版本"></a>查看 tmux 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux -V</span><br></pre></td></tr></table></figure>

<h2 id="美化-tmux"><a href="#美化-tmux" class="headerlink" title="美化 tmux"></a>美化 tmux</h2><p>本章节将使用 oh-my-tmux（<a href="https://github.com/gpakosz/.tmux">gpakosz&#x2F;.tmux</a>）对 tmux 进行美化。oh-my-tmux 是一个针对 Tmux 的预配置方案，由 Mathieu Merkens (gpakosz) 开发维护。它提供了一个功能丰富、高度可定制的 Tmux 环境，帮助用户提高终端使用效率和生产力。</p>
<p><img src="image-20240409195811769.png"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote>
<p> <strong><a href="https://github.com/gpakosz/.tmux?tab=readme-ov-file#features">Features</a></strong></p>
<ul>
<li><code>C-a</code> acts as secondary prefix, while keeping default <code>C-b</code> prefix</li>
<li>visual theme inspired by <a href="https://github.com/Lokaltog/powerline">Powerline</a></li>
<li><a href="http://pempek.net/articles/2013/04/14/maximizing-tmux-pane-new-window/">maximize any pane to a new window with <code>&lt;prefix&gt; +</code></a></li>
<li>SSH&#x2F;Mosh aware username and hostname status line information</li>
<li>mouse mode toggle with <code>&lt;prefix&gt; m</code></li>
<li>laptop battery status line information</li>
<li>uptime status line information</li>
<li>optional highlight of focused pane</li>
<li>configurable new windows and panes behavior (optionally retain current path)</li>
<li>SSH&#x2F;Mosh aware split pane (reconnects to remote server)</li>
<li>copy to OS clipboard (needs <code>xsel</code>, <code>xclip</code>, or <code>wl-copy</code> on Linux)</li>
<li>support for 4-digit hexadecimal Unicode characters</li>
<li><a href="https://facebook.github.io/PathPicker/">Facebook PathPicker</a> integration if available</li>
<li><a href="https://github.com/firecat53/urlscan">Urlscan</a> (preferred) or <a href="https://packages.debian.org/stable/misc/urlview">Urlview</a> integration if available</li>
</ul>
</blockquote>
<ul>
<li>在保留默认的 <code>C-b</code> 前缀键前提下，增加<code>C-a</code> 作为辅助前缀键；</li>
<li>增加受 <a href="https://github.com/Lokaltog/powerline">Powerline</a> 启发的主题；</li>
<li><a href="http://pempek.net/articles/2013/04/14/maximizing-tmux-pane-new-window/">使用 <code>&lt;prefix&gt; +</code> 键可最大化任何窗格到新窗口</a>；</li>
<li>能感知 SSH&#x2F;Mosh 连接，在状态栏显示当前用户名和主机名信息；</li>
<li>使用 <code>&lt;prefix&gt; m</code> 可快捷切换鼠标模式（Using mouse）；</li>
<li>在状态栏显示笔记本电池状态信息；</li>
<li>在状态栏显示系统运行时间信息；</li>
<li>可选择高亮显示当前聚焦的窗格；</li>
<li>可配置新窗口和窗格的行为（可选择保留当前路径）；</li>
<li>能感知 SSH&#x2F;Mosh 连接，在分割窗格时自动重连到远程服务器；</li>
<li>支持将缓冲区内容复制到操作系统剪贴板（需要 <code>xsel</code>、<code>xclip</code> 或 <code>wl-copy</code> 等工具）；</li>
<li>支持 4 位十六进制 Unicode 字符；</li>
<li>如果可用，集成了 <a href="https://facebook.github.io/PathPicker/">Facebook PathPicker</a> 功能；</li>
<li>如果可用，集成了 <a href="https://github.com/firecat53/urlscan">Urlscan</a> (优先) 或 <a href="https://packages.debian.org/stable/misc/urlview">Urlview</a> 功能。</li>
</ul>
<h3 id="前置必要条件"><a href="#前置必要条件" class="headerlink" title="前置必要条件"></a>前置必要条件</h3><blockquote>
<p>Requirements:</p>
<ul>
<li>tmux <strong><code>&gt;= 2.6</code></strong> running inside Linux, Mac, OpenBSD, Cygwin or WSL</li>
<li>awk, perl and sed</li>
<li>outside of tmux, <code>$TERM</code> must be set to <code>xterm-256color</code></li>
</ul>
<p>—— <a href="https://github.com/gpakosz/.tmux?tab=readme-ov-file#installation">Github Repository | gpakosz&#x2F;.tmux | Installation</a></p>
</blockquote>
<ul>
<li><p>tmux 版本需大于等于 <code>2.6</code>；</p>
</li>
<li><p>系统环境需确保已安装 <code>awk</code>、<code>perl</code> 和 <code>sed</code>；</p>
</li>
<li><p>终端模拟器类型（$TERM）需是 <code>xterm-256color</code>。</p>
</li>
</ul>
<h4 id="awk、perl-和-sed"><a href="#awk、perl-和-sed" class="headerlink" title="awk、perl 和 sed"></a>awk、perl 和 sed</h4><p><code>awk</code>、<code>perl</code> 和 <code>sed</code> 都是命令行工具，这些命令行工具通常在 Linux 和 macOS 系统上都可以使用，但在 Windows 系统上可能需要安装附加的软件包（如 Git Bash 或 WSL）才能使用。</p>
<ul>
<li><p><strong>awk</strong>：Awk 是一种强大的文本处理语言，通常用于格式化和分析文本数据。在这个 Tmux 配置中，awk 可能被用来处理和操作一些文本输出，以实现特定的功能；</p>
</li>
<li><p><strong>perl</strong>：Perl 是一种通用的编程语言，广泛应用于文本处理、系统管理、网络编程等领域。在这个 Tmux 配置中，perl 可能被用来执行一些复杂的字符串操作或脚本逻辑。</p>
</li>
<li><p><strong>sed</strong>：Sed 是一个强大的流编辑器，通常用于对文本进行细粒度的替换、删除和插入操作。在这个 Tmux 配置中，sed 可能被用来执行一些正则表达式匹配和文本替换操作，以实现特定的配置需求。</p>
</li>
</ul>
<p>因此，如果你要使用这个 Tmux 配置文件，确保你的系统上已经安装了这些工具，否则可能会导致配置无法正常工作。</p>
<h4 id="终端模拟器类型（-TERM）"><a href="#终端模拟器类型（-TERM）" class="headerlink" title="终端模拟器类型（$TERM）"></a>终端模拟器类型（$TERM）</h4><p>在 Linux 下，<code>$TERM</code> 是一个环境变量，用于指定当前终端类型或终端仿真器的类型。它告诉操作系统和应用程序如何与终端进行交互和显示输出。</p>
<p><code>$TERM</code> 变量的值通常是一个字符串，代表特定的终端类型。常见的 <code>$TERM</code> 值包括：</p>
<ul>
<li><code>xterm</code>：用于基于 X Window System 的终端仿真器，如 xterm、gnome-terminal 等。</li>
<li><code>xterm-256color</code>：带有 256 色支持的 xterm 终端仿真器。</li>
<li><code>gnome</code>：GNOME 终端仿真器。</li>
<li><code>konsole</code>：KDE Konsole 终端仿真器。</li>
<li><code>rxvt</code>：rxvt 终端仿真器。</li>
<li><code>linux</code>：Linux 虚拟终端。</li>
</ul>
<p>这些只是一些常见的 <code>$TERM</code> 值，实际上还有许多其他终端类型的值可用。</p>
<p>通过检查 <code>$TERM</code> 变量的值，应用程序可以根据终端类型来选择适当的显示方式和功能。例如，某些应用程序可以根据终端类型启用特定的颜色支持或功能键绑定。</p>
<p>可以使用以下命令来查看当前终端的 <code>$TERM</code> 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $TERM</span><br></pre></td></tr></table></figure>

<p>如果它不是 <code>xterm-256color</code>，则需要设置它。具体操作取决于使用的终端和操作系统:</p>
<p><strong>在 Linux&#x2F;macOS 终端中</strong>:</p>
<ul>
<li><p>编辑你的 shell 配置文件(例如 <code>.bashrc</code>、<code>.zshrc</code>)；</p>
</li>
<li><p>添加：<code>export TERM=xterm-256color</code>；</p>
</li>
<li><p>保存文件并重新登录或重启终端以使更改生效。</p>
</li>
</ul>
<p><strong>在 Windows 终端中</strong>：</p>
<ul>
<li><p>如果使用的是 Windows 自带的终端, 可能需要使用第三方终端模拟器,如 Windows Terminal、PuTTY 或 mintty（通过 Git Bash）。这些终端模拟器通常支持 <code>xterm-256color</code> 环境。</p>
</li>
<li><p>在终端的设置或属性中，查找并将 <code>$TERM</code> 环境变量设置为 <code>xterm-256color</code>。具体步骤因终端而异，请参考使用的终端模拟器的文档。</p>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>You can install Oh my tmux! at any of the following locations:</p>
<ul>
<li><code>~</code></li>
<li><code>$XDG_CONFIG_HOME/tmux</code></li>
<li><code>~/.config/tmux</code></li>
</ul>
<p>Installing in <code>~</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd</span><br><span class="line">$ git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">$ ln -s -f .tmux/.tmux.conf</span><br><span class="line">$ cp .tmux/.tmux.conf.local .</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>切换至 <code>～</code> 目录下：<code>cd ～</code>；</li>
<li>克隆 <code>gpakosz/.tmux</code> 至 <code>～</code> 目录下：<code>git clone https://github.com/gpakosz/.tmux.git</code>；</li>
<li>将预配置好的 Tmux 配置文件集成到当前的 Tmux 环境中：<code>ln -s -f .tmux/.tmux.conf</code>；</li>
<li>复制<code>.tmux.conf.local</code> 到 <code>～</code> 目录：<code>cp .tmux/.tmux.conf.local .</code>，这个文件包含了一些可选的 Tmux 配置，可以根据需要进行修改和自定义。</li>
</ol>
<p>到此即完成 oh-my-tmux 的安装，重启 tmux 即可看到“新的” tmux。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p>❗️ You should never alter the main <code>.tmux.conf</code> or <code>tmux.conf</code> file. If you do, you’re on your own. Instead, <mark>every customization should happen in your <code>.tmux.conf.local</code> or <code>tmux.conf.local</code> customization file copy.</mark></p>
</blockquote>
<p>在配置时，oh-my-tmux 建议不可直接修改 <code>.tmux.conf</code> 以免造成不必要的误操作，而应在 <code>.tmux.conf.local</code> 中进行个人配置。</p>
<p>本章节不展开介绍 oh-my-tmux 的所有配置，仅针对 “复制&#x2F;粘贴” 的配置做说明，更多的配置内容可查阅  <a href="https://github.com/gpakosz/.tmux">Github Repository | gpakosz&#x2F;.tmux</a>获取更多信息。</p>
<h4 id="复制-粘贴-1"><a href="#复制-粘贴-1" class="headerlink" title="复制&#x2F;粘贴"></a>复制&#x2F;粘贴</h4><p> oh-my-tmux 提供的 “同步 tmux 复制内容至系统剪切板” 是基于第三方软件的（ <code>xsel</code>、<code>xclip</code> 或 <code>wl-copy</code> 等工具），因此需确保已安装。</p>
<p>在完成 oh-my-tmux 的安装后，可以在 tmux 内部直接使用 热键（<code>C-b</code> + <code>e</code>）打开配置文件。</p>
<p>在配置文件中，找到 <code>tmux_conf_copy_to_os_clipboard=false</code>（见下），修改为  <code>tmux_conf_copy_to_os_clipboard=true</code>，保存。重启 tmux 即可（也可使用 oh-my-tmux 提供的热键——<code>C-b</code> + <code>r</code>——重载配置）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-- clipboard -----------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> copy mode, copying selection also copies to the OS clipboard</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  - <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  - <span class="literal">false</span> (default)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  - disabled</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on Linux, this requires xsel, xclip or wl-copy</span></span><br><span class="line">tmux_conf_copy_to_os_clipboard=false</span><br></pre></td></tr></table></figure>

<h3 id="热键增强"><a href="#热键增强" class="headerlink" title="热键增强"></a>热键增强</h3><p>oh-my-tmux 在 tmux 的基础上增加了许多颇为有用的热键组合，比如：</p>
<ul>
<li><p>在 session 内快捷新建 session（非嵌套）：<code>C-b</code> + <code>c</code>；</p>
</li>
<li><p>快速切换 鼠标的启用（Using mouse）：<code>C-b</code> + <code>m</code>；</p>
</li>
<li><p>快速打开配置文件（<code>.tmux.conf.local</code>）：<code>C-b</code> + <code>e</code>；</p>
</li>
<li><p>重载配置文件：<code>C-b</code> + <code>r</code>；</p>
</li>
</ul>
<p>以上列出的仅是 oh-my-tmux 增加的一部分热键组合，完整内容可查阅 <a href="https://github.com/gpakosz/.tmux?tab=readme-ov-file#bindings">gpakosz&#x2F;.tmux | Bindings</a>。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="树模式的热键"><a href="#树模式的热键" class="headerlink" title="树模式的热键"></a>树模式的热键</h2><p>This is a list of the keys available in tree mode without pressing the prefix key:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enter</code></td>
<td>Change the attached session, current window or active pane</td>
</tr>
<tr>
<td><code>Up</code></td>
<td>Select previous item</td>
</tr>
<tr>
<td><code>Down</code></td>
<td>Select next item</td>
</tr>
<tr>
<td><code>Right</code></td>
<td>Expand item</td>
</tr>
<tr>
<td><code>Left</code></td>
<td>Collapse item</td>
</tr>
<tr>
<td><code>x</code></td>
<td>Kill selected item</td>
</tr>
<tr>
<td><code>X</code></td>
<td>Kill tagged items</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Scroll preview left</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Scroll preview right</td>
</tr>
<tr>
<td><code>C-s</code></td>
<td>Search by name</td>
</tr>
<tr>
<td><code>n</code></td>
<td>Repeat last search</td>
</tr>
<tr>
<td><code>t</code></td>
<td>Toggle if item is tagged</td>
</tr>
<tr>
<td><code>T</code></td>
<td>Tag no items</td>
</tr>
<tr>
<td><code>C-t</code></td>
<td>Tag all items</td>
</tr>
<tr>
<td><code>:</code></td>
<td>Prompt for a command to run for the selected item or each tagged item</td>
</tr>
<tr>
<td><code>O</code></td>
<td>Change sort field</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Reverse sort order</td>
</tr>
<tr>
<td><code>v</code></td>
<td>Toggle preview</td>
</tr>
<tr>
<td><code>q</code></td>
<td>Exit tree mode</td>
</tr>
</tbody></table>
<p>引用自—— <a href="https://github.com/tmux/tmux/wiki/Getting-Started#choosing-sessions-windows-and-panes">Choosing sessions, windows and panes</a></p>
<h2 id="xsel-–help"><a href="#xsel-–help" class="headerlink" title="xsel –help"></a>xsel –help</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [20:22:06]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xsel --<span class="built_in">help</span></span></span><br><span class="line">Usage: xsel [options]</span><br><span class="line">Manipulate the X selection.</span><br><span class="line"></span><br><span class="line">By default the current selection is output and not modified if both</span><br><span class="line">standard input and standard output are terminals (ttys).  Otherwise,</span><br><span class="line">the current selection is output if standard output is not a terminal</span><br><span class="line">(tty), and the selection is set from standard input if standard input</span><br><span class="line">is not a terminal (tty). If any input or output options are given then</span><br><span class="line">the program behaves only in the requested mode.</span><br><span class="line"></span><br><span class="line">If both input and output is required then the previous selection is</span><br><span class="line">output before being replaced by the contents of standard input.</span><br><span class="line"></span><br><span class="line">Input options</span><br><span class="line">  -a, --append          Append standard input to the selection</span><br><span class="line">  -f, --follow          Append to selection as standard input grows</span><br><span class="line">  -z, --zeroflush       Overwrites selection when zero (&#x27;\0&#x27;) is received</span><br><span class="line">  -i, --input           Read standard input into the selection</span><br><span class="line"></span><br><span class="line">Output options</span><br><span class="line">  -o, --output          Write the selection to standard output</span><br><span class="line"></span><br><span class="line">Action options</span><br><span class="line">  -c, --clear           Clear the selection</span><br><span class="line">  -d, --delete          Request that the selection be cleared and that</span><br><span class="line">                        the application owning it delete its contents</span><br><span class="line"></span><br><span class="line">Selection options</span><br><span class="line">  -p, --primary         Operate on the PRIMARY selection (default)</span><br><span class="line">  -s, --secondary       Operate on the SECONDARY selection</span><br><span class="line">  -b, --clipboard       Operate on the CLIPBOARD selection</span><br><span class="line"></span><br><span class="line">  -k, --keep            Do not modify the selections, but make the PRIMARY</span><br><span class="line">                        and SECONDARY selections persist even after the</span><br><span class="line">                        programs they were selected in exit.</span><br><span class="line">  -x, --exchange        Exchange the PRIMARY and SECONDARY selections</span><br><span class="line"></span><br><span class="line">X options</span><br><span class="line">  --display displayname</span><br><span class="line">                        Specify the connection to the X server</span><br><span class="line">  -t ms, --selectionTimeout ms</span><br><span class="line">                        Specify the timeout in milliseconds within which the</span><br><span class="line">                        selection must be retrieved. A value of 0 (zero)</span><br><span class="line">                        specifies no timeout (default)</span><br><span class="line"></span><br><span class="line">Miscellaneous options</span><br><span class="line">  -l, --logfile         Specify file to log errors to when detached.</span><br><span class="line">  -n, --nodetach        Do not detach from the controlling terminal. Without</span><br><span class="line">                        this option, xsel will fork to become a background</span><br><span class="line">                        process in input, exchange and keep modes.</span><br><span class="line"></span><br><span class="line">  -h, --help            Display this help and exit</span><br><span class="line">  -v, --verbose         Print informative messages</span><br><span class="line">  --version             Output version information and exit</span><br><span class="line"></span><br><span class="line">Please report bugs to &lt;conrad@vergenet.net&gt;.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中提到了 PRIMARY、SECONDARY 和 CLIPBOARD，这些术语与 X Window 系统（<a href="#X-Window-%E7%B3%BB%E7%BB%9F">详见附录</a>）中的不同剪贴板选择有关。在 X Window 系统中，存在多个剪贴板选择，每个选择用于不同的目的。</p>
<ol>
<li><p>PRIMARY（主要选择）：PRIMARY 是最常用的剪贴板选择。当你在一个程序中选中文本时，该文本会被自动放入 PRIMARY 选择中。你可以使用鼠标中键来粘贴PRIMARY 选择中的内容，或者使用 <code>xsel</code> 命令来读取和操作 PRIMARY 选择的内容。</p>
</li>
<li><p>SECONDARY（次要选择）：SECONDARY 是另一个剪贴板选择，其使用场景相对较少。它通常不会被程序自动使用，而是需要手动操作。你可以使用鼠标右键菜单或特定的键盘快捷键将文本放入 SECONDARY 选择中，然后使用 <code>xsel</code> 命令来读取和操作 SECONDARY 选择的内容。</p>
</li>
<li><p>CLIPBOARD（剪贴板）：CLIPBOARD 是一个通用的剪贴板选择，可以用于复制和粘贴文本。通过使用鼠标右键菜单或特定的键盘快捷键，你可以将文本放入CLIPBOARD 选择中。与 PRIMARY 和 SECONDARY 不同，CLIPBOARD 的内容可以在不同的程序之间共享。使用 <code>xsel</code> 命令可以读取和操作 CLIPBOARD 选择的内容。</p>
</li>
</ol>
<h2 id="X-Window-系统"><a href="#X-Window-系统" class="headerlink" title="X Window 系统"></a>X Window 系统</h2><p>X Window System（通常简称为X或X11）是一种用于图形界面的开放标准和软件协议。它提供了一个跨平台的图形窗口环境，使得在计算机上可以显示图形界面和处理用户输入。</p>
<p>X Window System最初于1984年由麻省理工学院（MIT）开发，并在之后成为一个开放标准。它的设计目标是将图形显示和用户输入分离，使得可以通过网络远程访问和控制图形界面。X Window System采用了客户端-服务器架构，在这个架构中，图形应用程序（客户端）通过网络连接到X服务器，而X服务器负责处理图形显示和用户输入。</p>
<p>X Window System的主要特点包括：</p>
<ol>
<li><p>跨平台：X Window System是跨平台的，可以在各种操作系统上运行，包括Linux、Unix、BSD等。</p>
</li>
<li><p>网络透明：X Window System的客户端-服务器架构使得可以通过网络进行远程访问和控制。你可以在一台计算机上运行X服务器，然后在另一台计算机上通过网络连接到该服务器并显示图形界面。</p>
</li>
<li><p>窗口管理：X Window System提供了窗口管理功能，允许用户在图形界面中创建、移动、调整大小和关闭窗口。</p>
</li>
<li><p>可扩展性：X Window System的协议和架构具有可扩展性，可以支持不同的图形和输入设备，以及各种窗口管理器和桌面环境。</p>
</li>
<li><p>开放标准：X Window System是一个开放的标准和协议，有许多不同的实现和工具集可供选择，例如X.Org Server、XFree86等。</p>
</li>
</ol>
<p>由于X Window System的灵活性和可扩展性，它成为了许多Unix和Linux系统上默认的图形界面基础，提供了图形应用程序的显示和用户交互能力。</p>
<h2 id="tmux-list-commands"><a href="#tmux-list-commands" class="headerlink" title="tmux list-commands"></a>tmux list-commands</h2><table>
<thead>
<tr>
<th>命令（<code>tmux [cmmmand]</code>）</th>
<th>可选参数</th>
</tr>
</thead>
<tbody><tr>
<td>attach-session (attach)</td>
<td>[-dErx] [-c working-directory] [-f flags] [-t target-session]</td>
</tr>
<tr>
<td>bind-key (bind)</td>
<td>[-nr] [-T key-table] [-N note] key [command [arguments]]</td>
</tr>
<tr>
<td>break-pane (breakp)</td>
<td>[-abdP] [-F format] [-n window-name] [-s src-pane] [-t dst-window]</td>
</tr>
<tr>
<td>capture-pane (capturep)</td>
<td>[-aCeJNpPq] [-b buffer-name] [-E end-line] [-S start-line] [-t target-pane]</td>
</tr>
<tr>
<td>choose-buffer</td>
<td>[-NrZ] [-F format] [-f filter] [-K key-format] [-O sort-order] [-t target-pane] [template]</td>
</tr>
<tr>
<td>choose-client</td>
<td>[-NrZ] [-F format] [-f filter] [-K key-format] [-O sort-order] [-t target-pane] [template]</td>
</tr>
<tr>
<td>choose-tree</td>
<td>[-GNrswZ] [-F format] [-f filter] [-K key-format] [-O sort-order] [-t target-pane] [template]</td>
</tr>
<tr>
<td>clear-history (clearhist)</td>
<td>[-t target-pane]</td>
</tr>
<tr>
<td>clock-mode</td>
<td>[-t target-pane]</td>
</tr>
<tr>
<td>command-prompt</td>
<td>[-1kiNTW] [-I inputs] [-p prompts] [-t target-client] [template]</td>
</tr>
<tr>
<td>confirm-before (confirm)</td>
<td>[-p prompt] [-t target-client] command</td>
</tr>
<tr>
<td>copy-mode</td>
<td>[-eHMuq] [-s src-pane] [-t target-pane]</td>
</tr>
<tr>
<td>customize-mode</td>
<td>[-NZ] [-F format] [-f filter] [-t target-pane]</td>
</tr>
<tr>
<td>delete-buffer (deleteb)</td>
<td>[-b buffer-name]</td>
</tr>
<tr>
<td>detach-client (detach)</td>
<td>[-aP] [-E shell-command] [-s target-session] [-t target-client]</td>
</tr>
<tr>
<td>display-menu (menu)</td>
<td>[-O] [-c target-client] [-t target-pane] [-T title] [-x position] [-y position] name key command …</td>
</tr>
<tr>
<td>display-message (display)</td>
<td>[-aINpv] [-c target-client] [-d delay] [-F format] [-t target-pane] [message]</td>
</tr>
<tr>
<td>display-popup (popup)</td>
<td>[-CE] [-c target-client] [-d start-directory] [-h height] [-t target-pane] [-w width] [-x position] [-y position] [command]</td>
</tr>
<tr>
<td>display-panes (displayp)</td>
<td>[-bN] [-d duration] [-t target-client] [template]</td>
</tr>
<tr>
<td>find-window (findw)</td>
<td>[-CiNrTZ] [-t target-pane] match-string</td>
</tr>
<tr>
<td>has-session (has)</td>
<td>[-t target-session]</td>
</tr>
<tr>
<td>if-shell (if)</td>
<td>[-bF] [-t target-pane] shell-command command [command]</td>
</tr>
<tr>
<td>join-pane (joinp)</td>
<td>[-bdfhv] [-l size] [-s src-pane] [-t dst-pane]</td>
</tr>
<tr>
<td>kill-pane (killp)</td>
<td>[-a] [-t target-pane]</td>
</tr>
<tr>
<td>kill-server</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>kill-session</td>
<td>[-aC] [-t target-session]</td>
</tr>
<tr>
<td>kill-window (killw)</td>
<td>[-a] [-t target-window]</td>
</tr>
<tr>
<td>last-pane (lastp)</td>
<td>[-deZ] [-t target-window]</td>
</tr>
<tr>
<td>last-window (last)</td>
<td>[-t target-session]</td>
</tr>
<tr>
<td>link-window (linkw)</td>
<td>[-abdk] [-s src-window] [-t dst-window]</td>
</tr>
<tr>
<td>list-buffers (lsb)</td>
<td>[-F format] [-f filter]</td>
</tr>
<tr>
<td>list-clients (lsc)</td>
<td>[-F format] [-t target-session]</td>
</tr>
<tr>
<td>list-commands (lscm)</td>
<td>[-F format] [command]</td>
</tr>
<tr>
<td>list-keys (lsk)</td>
<td>[-1aN] [-P prefix-string] [-T key-table] [key]</td>
</tr>
<tr>
<td>list-panes (lsp)</td>
<td>[-as] [-F format] [-f filter] [-t target-window]</td>
</tr>
<tr>
<td>list-sessions (ls)</td>
<td>[-F format] [-f filter]</td>
</tr>
<tr>
<td>list-windows (lsw)</td>
<td>[-a] [-F format] [-f filter] [-t target-session]</td>
</tr>
<tr>
<td>load-buffer (loadb)</td>
<td>[-b buffer-name] [-t target-client] path</td>
</tr>
<tr>
<td>lock-client (lockc)</td>
<td>[-t target-client]</td>
</tr>
<tr>
<td>lock-server (lock)</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>lock-session (locks)</td>
<td>[-t target-session]</td>
</tr>
<tr>
<td>move-pane (movep)</td>
<td>[-bdfhv] [-l size] [-s src-pane] [-t dst-pane]</td>
</tr>
<tr>
<td>move-window (movew)</td>
<td>[-abdkr] [-s src-window] [-t dst-window]</td>
</tr>
<tr>
<td>new-session (new)</td>
<td>[-AdDEPX] [-c start-directory] [-e environment] [-F format] [-f flags] [-n window-name] [-s session-name] [-t target-session] [-x width] [-y height] [command]</td>
</tr>
<tr>
<td>new-window (neww)</td>
<td>[-abdkPS] [-c start-directory] [-e environment] [-F format] [-n window-name] [-t target-window] [command]</td>
</tr>
<tr>
<td>next-layout (nextl)</td>
<td>[-t target-window]</td>
</tr>
<tr>
<td>next-window (next)</td>
<td>[-a] [-t target-session]</td>
</tr>
<tr>
<td>paste-buffer (pasteb)</td>
<td>[-dpr] [-s separator] [-b buffer-name] [-t target-pane]</td>
</tr>
<tr>
<td>pipe-pane (pipep)</td>
<td>[-IOo] [-t target-pane] [command]</td>
</tr>
<tr>
<td>previous-layout (prevl)</td>
<td>[-t target-window]</td>
</tr>
<tr>
<td>previous-window (prev)</td>
<td>[-a] [-t target-session]</td>
</tr>
<tr>
<td>refresh-client (refresh)</td>
<td>[-cDlLRSU] [-A pane:state] [-B name:what:format] [-C XxY] [-f flags] [-t target-client] [adjustment]</td>
</tr>
<tr>
<td>rename-session (rename)</td>
<td>[-t target-session] new-name</td>
</tr>
<tr>
<td>rename-window (renamew)</td>
<td>[-t target-window] new-name</td>
</tr>
<tr>
<td>resize-pane (resizep)</td>
<td>[-DLMRTUZ] [-x width] [-y height] [-t target-pane] [adjustment]</td>
</tr>
<tr>
<td>resize-window (resizew)</td>
<td>[-aADLRU] [-x width] [-y height] [-t target-window] [adjustment]</td>
</tr>
<tr>
<td>respawn-pane (respawnp)</td>
<td>[-k] [-c start-directory] [-e environment] [-t target-pane] [command]</td>
</tr>
<tr>
<td>respawn-window (respawnw)</td>
<td>[-k] [-c start-directory] [-e environment] [-t target-window] [command]</td>
</tr>
<tr>
<td>rotate-window (rotatew)</td>
<td>[-DUZ] [-t target-window]</td>
</tr>
<tr>
<td>run-shell (run)</td>
<td>[-bC] [-d delay] [-t target-pane] [shell-command]</td>
</tr>
<tr>
<td>save-buffer (saveb)</td>
<td>[-a] [-b buffer-name] path</td>
</tr>
<tr>
<td>select-layout (selectl)</td>
<td>[-Enop] [-t target-pane] [layout-name]</td>
</tr>
<tr>
<td>select-pane (selectp)</td>
<td>[-DdeLlMmRUZ] [-T title] [-t target-pane]</td>
</tr>
<tr>
<td>select-window (selectw)</td>
<td>[-lnpT] [-t target-window]</td>
</tr>
<tr>
<td>send-keys (send)</td>
<td>[-FHlMRX] [-N repeat-count] [-t target-pane] key …</td>
</tr>
<tr>
<td>send-prefix</td>
<td>[-2] [-t target-pane]</td>
</tr>
<tr>
<td>set-buffer (setb)</td>
<td>[-aw] [-b buffer-name] [-n new-buffer-name] [-t target-client] data</td>
</tr>
<tr>
<td>set-environment (setenv)</td>
<td>[-Fhgru] [-t target-session] name [value]</td>
</tr>
<tr>
<td>set-hook</td>
<td>[-agpRuw] [-t target-pane] hook [command]</td>
</tr>
<tr>
<td>set-option (set)</td>
<td>[-aFgopqsuUw] [-t target-pane] option [value]</td>
</tr>
<tr>
<td>set-window-option (setw)</td>
<td>[-aFgoqu] [-t target-window] option [value]</td>
</tr>
<tr>
<td>show-buffer (showb)</td>
<td>[-b buffer-name]</td>
</tr>
<tr>
<td>show-environment (showenv)</td>
<td>[-hgs] [-t target-session] [name]</td>
</tr>
<tr>
<td>show-hooks</td>
<td>[-gpw] [-t target-pane]</td>
</tr>
<tr>
<td>show-messages (showmsgs)</td>
<td>[-JT] [-t target-client]</td>
</tr>
<tr>
<td>show-options (show)</td>
<td>[-AgHpqsvw] [-t target-pane] [option]</td>
</tr>
<tr>
<td>show-window-options (showw)</td>
<td>[-gv] [-t target-window] [option]</td>
</tr>
<tr>
<td>source-file (source)</td>
<td>[-Fnqv] path …</td>
</tr>
<tr>
<td>split-window (splitw)</td>
<td>[-bdefhIPvZ] [-c start-directory] [-e environment] [-F format] [-l size] [-t target-pane] [command]</td>
</tr>
<tr>
<td>start-server (start)</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>suspend-client (suspendc)</td>
<td>[-t target-client]</td>
</tr>
<tr>
<td>swap-pane (swapp)</td>
<td>[-dDUZ] [-s src-pane] [-t dst-pane]</td>
</tr>
<tr>
<td>swap-window (swapw)</td>
<td>[-d] [-s src-window] [-t dst-window]</td>
</tr>
<tr>
<td>switch-client (switchc)</td>
<td>[-ElnprZ] [-c target-client] [-t target-session] [-T key-table]</td>
</tr>
<tr>
<td>unbind-key (unbind)</td>
<td>[-anq] [-T key-table] key</td>
</tr>
<tr>
<td>unlink-window (unlinkw)</td>
<td>[-k] [-t target-window]</td>
</tr>
<tr>
<td>wait-for (wait)</td>
<td>[-L|-S|-U] channel</td>
</tr>
</tbody></table>
<h2 id="C-b"><a href="#C-b" class="headerlink" title="C-b + ?"></a>C-b + ?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C-b C-b     Send the prefix key                       </span><br><span class="line">C-b C-o     Rotate through the panes                  </span><br><span class="line">C-b C-z     Suspend the current client                </span><br><span class="line">C-b Space   Select next layout                        </span><br><span class="line">C-b !       Break pane to a new window                </span><br><span class="line">C-b #       List all paste buffers                    </span><br><span class="line">C-b $       Rename current session                    </span><br><span class="line">C-b &amp;       Kill current window                       </span><br><span class="line">C-b &#x27;       Prompt for window index to select             </span><br><span class="line">C-b (       Switch to previous client                 </span><br><span class="line">C-b )       Switch to next client                       </span><br><span class="line">C-b ,       Rename current window</span><br><span class="line">C-b .       Move the current window</span><br><span class="line">C-b /       Describe key binding</span><br><span class="line">C-b 0       Select window 0</span><br><span class="line">C-b 1       Select window 1</span><br><span class="line">C-b 2       Select window 2</span><br><span class="line">C-b 3       Select window 3</span><br><span class="line">C-b 4       Select window 4</span><br><span class="line">C-b 5       Select window 5</span><br><span class="line">C-b 6       Select window 6</span><br><span class="line">C-b 7       Select window 7</span><br><span class="line">C-b 8       Select window 8</span><br><span class="line">C-b 9       Select window 9</span><br><span class="line">C-b :       Prompt for a command</span><br><span class="line">C-b ;       Move to the previously active pane</span><br><span class="line">C-b =       Choose a paste buffer from a list</span><br><span class="line">C-b ?       List key bindings</span><br><span class="line">C-b C       Customize options</span><br><span class="line">C-b D       Choose a client from a list</span><br><span class="line">C-b E       Spread panes out evenly</span><br><span class="line">C-b M       Clear the marked pane</span><br><span class="line">C-b [       Enter copy mode</span><br><span class="line">C-b ]       Paste the most recent paste buffer                          </span><br><span class="line">C-b d       Detach the current client                 </span><br><span class="line">C-b f       Search for a pane                         </span><br><span class="line">C-b i       Display window information                </span><br><span class="line">C-b o       Select the next pane                      </span><br><span class="line">C-b q       Display pane numbers              </span><br><span class="line">C-b s       Choose a session from a list                           </span><br><span class="line">C-b t       Show a clock                              </span><br><span class="line">C-b w       Choose a window from a list               </span><br><span class="line">C-b x       Kill the active pane </span><br><span class="line">C-b z       Zoom the active pane   </span><br><span class="line">C-b &#123;       Swap the active pane with the pane above</span><br><span class="line">C-b &#125;       Swap the active pane with the pane below</span><br><span class="line">C-b ~       Show messages  </span><br><span class="line">C-b DC      Reset so the visible part of the window follows the cursor</span><br><span class="line">C-b PPage   Enter copy mode and scroll up</span><br><span class="line">C-b Up      Select the pane above the active pane</span><br><span class="line">C-b Down    Select the pane below the active pane</span><br><span class="line">C-b Left    Select the pane to the left of the active pane</span><br><span class="line">C-b Right   Select the pane to the right of the active pane</span><br><span class="line">C-b M-1     Set the even-horizontal layout</span><br><span class="line">C-b M-2     Set the even-vertical layout</span><br><span class="line">C-b M-3     Set the main-horizontal layout</span><br><span class="line">C-b M-4     Set the main-vertical layout      </span><br><span class="line">C-b M-5     Select the tiled layout          </span><br><span class="line">C-b M-n     Select the next window with an alert</span><br><span class="line">C-b M-o     Rotate through the panes in reverse</span><br><span class="line">C-b M-p     Select the previous window with an alert</span><br><span class="line">C-b M-Up    Resize the pane up by 5</span><br><span class="line">C-b M-Down  Resize the pane down by 5</span><br><span class="line">C-b M-Left  Resize the pane left by 5</span><br><span class="line">C-b C-Right Resize the pane right              </span><br><span class="line">C-b S-Up    Move the visible part of the window up  </span><br><span class="line">C-b S-Down  Move the visible part of the window down</span><br><span class="line">C-b S-Left  Move the visible part of the window left</span><br><span class="line">C-b S-Right Move the visible part of the window right</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.trackawesomelist.com/rothgar/awesome-tmux/readme/">Awesome Tmux Overview</a></p>
</li>
<li><p><a href="https://github.com/tmux/tmux/wiki/Getting-Started">Github repository | tmux&#x2F;tmux | Wiki | Getting Started</a></p>
</li>
<li><p><a href="https://github.com/tmux/tmux/wiki/Clipboard">Github repository | tmux&#x2F;tmux | Wiki | Clipboard</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/X_Window_System">Wiki | X Window System</a></p>
</li>
<li><p><a href="https://man.openbsd.org/tmux">OpenBSD manual page server | tmux</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux 工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>terminal</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>🚧 Linux-Wechat 体验导向的 Flatpak 探索</title>
    <url>/blog/resources/linux-%E8%BD%AF%E4%BB%B6-wechat-cursor%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我当前使用的大部分软件都有被 Deb（Chromium、VS Code 等） Appimage （Motrix、Qv2ray等）覆盖到，其他一部分使用 WebApp （Neat Reader、Google Translate等）代替，实在无解则使用 win7 虚拟机（微信、迅雷等）。</p>
<p>最近听闻微信发布了 linux 版本，但实际并无较为正式的公告。仅在一些视频网站偶尔刷到 linux 版本微信的演示，才让人对此有了一定的可信度。</p>
<span id="more"></span>

<p>在<a href="https://weixin.qq.com/cgi-bin/readtemplate?lang=zh_CN&t=weixin_faq_list&head=true">微信更新日志</a>中并未提到 linux 版本的发布动作，主页亦无相关下载入口。较为正式的消息来自：</p>
<blockquote>
<p>IT之家 3 月 13 日消息，统信软件和麒麟软件宣布，微信（Universal）UOS 版功能全面革新，体验全新升级，新版本现已上架统信应用商店和麒麟软件商店，UOS 用户可直接在统信应用商店搜索“微信（Universal）”下载体验，银河麒麟用户可在银河麒麟桌面操作系统 V10 安装使用。</p>
<p>据IT之家此前报道，微信将迎来 Linux 原生版重构，支持 X86、ARM、龙芯 LoongArch64 架构，系统方面支持麒麟和统信 UOS。</p>
<p>——<a href="https://www.ithome.com/0/755/450.htm">IT之家 | 微信（Universal）UOS &#x2F; 银河麒麟版全新升级：Linux 原生跨平台方案，现已开放下载</a></p>
</blockquote>
<p>其他的消息来源有：</p>
<ul>
<li><p><a href="https://wiki.archlinuxcn.org/wiki/%E5%BE%AE%E4%BF%A1#%E5%BE%AE%E4%BF%A1_Linux_%E5%8E%9F%E7%94%9F%E7%89%88%E9%87%8D%E6%9E%84">Archlinux Wiki | 微信 | 微信 Linux 原生版重构</a>；</p>
</li>
<li><p><a href="https://www.52pojie.cn/thread-1896902-1-1.html">吾爱破解 | [其他] 【国产系统】史诗级更新Linux 微信wechat-beta_1.0.0.150（快来还热乎）</a>。</p>
</li>
</ul>
<p>从<a href="https://www.spark-app.store/store/sort/chat">星火软件商店</a> 和 <a href="https://aur.archlinux.org/packages/wechat-universal-bwrap">Archlinux wiki</a> 我分别下载了三个版本：微信（Universal）、Freechat 版本微信和 wechat-universal-bwrap 1.0.0.238-13。各有各的问题导致无法使用，不展开。这也是可以预见的，从消息来源中可知，此 linux 版本的微信是面向 UOS 和银河麒麟，目标非我当前所使用的发行版本。当然我估计是可以通过花费时间解决这些使用问题，但私以为性价比过低，因此搁置，抛之脑后。</p>
<p>缘法妙不可言（估计是推荐机制），后面了解到 <a href="https://github.com/web1n">web1n</a> 打包了 <a href="https://github.com/web1n/wechat-universal-flatpak">fatpak 版本的 wechat-universal-flatpak</a>，基于 flatpak 的沙盒特性，我认为可以顺利使用的可能性很大。安装后体验确实如此！基本使用无问题：</p>
<p><img src="ksnip_20240325-144047.png"></p>
<p>直接可见的 bug 是 cursor 的样式异常：</p>
<ul>
<li><p>cursor 的类型（Adwaita）与全局（Bibata-Modern-Classic）的不一致；</p>
</li>
<li><p>尺寸过小，若正常使用的尺寸定位为 10，那么目前的估计是 1；</p>
</li>
</ul>
<p>其他功能性的 bug 按下不讨论。对于这个样式性的 bug，回顾过往使用与安装的 Flatpak 软件，似乎大多是有类似的问题。这是 Flatpak 自身的问题？</p>
<p>以此引出本文讨论与探索的主题：<em>从解决实际问题——wechat-universal-flatpak 的 cursor 样式异常——探索 Flatpak</em>。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><blockquote>
<p>System:<br> Kernel: 5.15.0-76-generic x86_64 bits: 64 compiler: gcc v: 11.3.0 Desktop: Cinnamon 5.8.4<br>   tk: GTK 3.24.33 wm: muffin dm: LightDM Distro: Linux Mint 21.2 Victoria base: Ubuntu 22.04 jammy</p>
<p>Machine:<br> Type: Laptop System: LENOVO product: 82NJ v: Yoga 14sACH 2021 D serial: &lt;superuser required&gt;<br>   Chassis: type: 10 v: Yoga 14sACH 2021 D serial: &lt;superuser required&gt;<br> Mobo: LENOVO model: LNVNB161216 v: SDK0T76479 WIN serial: &lt;superuser required&gt; UEFI: LENOVO<br>   v: HECN23WW date: 10&#x2F;15&#x2F;2021</p>
<p>CPU:<br> Info: 8-core model: AMD Ryzen 7 5800HS Creator Edition bits: 64 type: MT MCP arch: Zen 3 rev: 0<br>   cache: L1: 512 KiB L2: 4 MiB L3: 16 MiB<br> Speed (MHz): avg: 2705 high: 3887 min&#x2F;max: 1200&#x2F;3200 boost: enabled cores: 1: 2938 2: 578<br>   3: 2473 4: 2268 5: 2233 6: 3057 7: 2560 8: 2473 9: 2524 10: 2734 11: 3887 12: 3467 13: 2903<br>   14: 2943 15: 2931 16: 3311 bogomips: 102206<br> Flags: avx avx2 ht lm nx pae sse sse2 sse3 sse4_1 sse4_2 sse4a ssse3 svm</p>
</blockquote>
<h2 id="Flatpak-版本"><a href="#Flatpak-版本" class="headerlink" title="Flatpak 版本"></a>Flatpak 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [11:26:56]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --version</span>                        </span><br><span class="line">Flatpak 1.12.7</span><br></pre></td></tr></table></figure>

<h2 id="Flatpak-Application"><a href="#Flatpak-Application" class="headerlink" title="Flatpak Application"></a>Flatpak Application</h2><p>保持安装 <code>wechat-universal-flatpak</code> 后状态，不新增 Flatpak 软件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~ [13:07:51]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak list</span></span><br><span class="line">Name                         Application ID                 Version   Branch      Origin        Installation</span><br><span class="line">WeChat                       com.tencent.WeChat             1.0.0.238 master      wechat-origin system</span><br><span class="line">Freedesktop Platform         org.freedesktop.Platform       23.08.14  23.08       flathub       system</span><br><span class="line">Mesa                         …eedesktop.Platform.GL.default 23.3.5    22.08       flathub       system</span><br><span class="line">Mesa (Extra)                 …eedesktop.Platform.GL.default 23.3.5    22.08-extra flathub       system</span><br><span class="line">Mesa                         …eedesktop.Platform.GL.default 24.0.3    23.08       flathub       system</span><br><span class="line">Mesa (Extra)                 …eedesktop.Platform.GL.default 24.0.3    23.08-extra flathub       system</span><br><span class="line">openh264                     …freedesktop.Platform.openh264 2.1.0     2.2.0       flathub       system</span><br><span class="line">GNOME Application Platform … org.gnome.Platform                       44          flathub       system</span><br><span class="line">GMetronome                   ….gnome.gitlab.dqpb.GMetronome 0.3.2     stable      flathub       system</span><br><span class="line">Mint-Y-Aqua Gtk Theme        org.gtk.Gtk3theme.Mint-Y-Aqua            3.22        flathub       system</span><br></pre></td></tr></table></figure>

<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>wechat-universal-flatpak 的 cursor 样式异常，这个问题据目前可知的信息，可以推断是与 Flatpak 相关性更大而非微信本身。因此，根据 Flatpak 与 cursor 样式做一定的资料搜集，以及解决方案的搜索。下面是经过滤后较有可行性的方案：</p>
<h2 id="实践一"><a href="#实践一" class="headerlink" title="实践一"></a>实践一</h2><p>从 <a href="https://www.reddit.com/r/flatpak/comments/rxnyh7/flatpak_app_changing_cursor_theme_and_size_is/">Reddit | Flatpak App Changing Cursor Theme And Size (Is This Normal Behavior?)</a> 的一个评论中得到一个解决方案，在此评论的回复中不少人表示有效：</p>
<blockquote>
<p><a href="https://www.reddit.com/user/Relevant_Ferret8075/">@Relevant_Ferret8075</a><br>Try these commands:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flatpak --user override --filesystem=/home/$USER/.icons/:ro</span><br><span class="line">flatpak --user override --filesystem=/usr/share/icons/:ro</span><br></pre></td></tr></table></figure>
</blockquote>
<p>根据评论中给出的 2 条命令在终端执行，结果是顺利执行无报错，但遗憾的是并未解决。</p>
<p>PS：<em>为一定程度的严谨性，在执行命令后会重启微信，后面的每次实践可能的解决方案亦会重复此步骤。</em></p>
<h2 id="实践二"><a href="#实践二" class="headerlink" title="实践二"></a>实践二</h2><p>从 <a href="https://github.com/flatpak/flatpak/issues/709#issuecomment-1381482007">Github issue | flatpak&#x2F;flatpak | Different cursor theme in flatpak apps #709 | the solution too on Linux Mint</a> 得到相对更全面的方案。且评论中的用户使用的发行版与当前实验的接近（见背景说明）。</p>
<blockquote>
<p><a href="https://github.com/garfieldairlines">@garfieldairlines</a> commented on Jan 13, 2023<br>That was the solution too on Linux Mint, thank you I was getting crazy !</p>
<blockquote>
<p>As of Jan 12th, 2023, I ran the following commands (in this order) on Fedora 37 (Gnome 43) and all my Flatpak apps now see the correct cursor icons:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/icons ~/.icons -r</span><br><span class="line">flatpak --user override --filesystem=/home/$USER/.icons/:ro </span><br><span class="line">flatpak --user override --filesystem=/usr/share/icons/:ro</span><br><span class="line">flatpak override --user --env=XCURSOR_PATH=~/.icons</span><br><span class="line">flatpak override --user --filesystem=xdg-config/gtk-3.0:ro</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>这个方案中增加了对 <code>xdg-config/gtk-3.0</code> 目录访问权限的用户级别的覆盖，和设置 <code>XCURSOR_PATH</code> 环境变量。</p>
<p>实践新增内容部分，结果是顺利执行无报错，但遗憾的是并未解决。</p>
<h2 id="实践三"><a href="#实践三" class="headerlink" title="实践三"></a>实践三</h2><p><a href="https://wiki.archlinux.org/title/Flatpak#">Archlinux Wiki | Flatpak</a> 有着关于 Flatpak 较为全面的信息，其中 <a href="https://wiki.archlinux.org/title/Flatpak#Applications_do_not_use_the_correct_cursor_theme">Archlinux Wiki | Flatpak | Troubleshooting  | Applications do not use the correct cursor theme</a> 更是直指 Flatpak 的 cursor 问题，一定程度上也印证了前面关于 cursor 异常的推测。</p>
<blockquote>
<p><strong>5.6 Applications do not use the correct cursor theme</strong><br>Applications do not use the correct cursor theme<br>There is no single standard to set the cursor properly. Some programs only need read access to the cursors directory, others also rely on other mechanisms. For <a href="https://wiki.archlinux.org/title/GTK">GTK</a> applications, ensure that <a href="https://archlinux.org/packages/?name=xdg-desktop-portal-gtk">xdg-desktop-portal-gtk</a> is installed.</p>
<p>Otherwise, the following overrides should work for most common desktop applications.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ flatpak -u override --filesystem=/usr/share/icons/:ro</span><br><span class="line">$ flatpak -u override --filesystem=/home/$USER/.icons/:ro </span><br><span class="line">$ flatpak -u override --filesystem=xdg-config/gtk-3.0:ro</span><br><span class="line">$ flatpak -u override --env=XCURSOR_PATH=~/.icons</span><br></pre></td></tr></table></figure>
<p>In some cases you may also need to override the environment variables <code>XCURSOR_THEME</code> and <code>XCURSOR_SIZE</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ flatpak -u override --env=XCURSOR_THEME=Adwaita</span><br><span class="line">$ flatpak -u override --env=XCURSOR_SIZE=24</span><br></pre></td></tr></table></figure>
<p>See <a href="https://github.com/flatpak/flatpak/issues/709">this discussion</a> for additional details.</p>
</blockquote>
<p>相比实践一、二，增加的是 <code>XCURSOR_THEME</code> 和 <code>XCURSOR_SIZE</code> 环境变量的设置。</p>
<p>实践新增内容部分，结果是顺利执行无报错，但遗憾的是并未解决。</p>
<h2 id="实践四"><a href="#实践四" class="headerlink" title="实践四"></a>实践四</h2><p>以上三个方案是过滤后，目前解决问题可能性最大的，至少当前未发现更加有用的信息。根据以上的资料，做出合理的推论，应大概率可以解决（毕竟已经常见到被明确收录进 Wiki 的问题），但经实践后依然未达预期。此刻当做二次梳理以排除误操作。</p>
<p>实践三中 <code>XCURSOR_THEME</code> 和 <code>XCURSOR_SIZE</code> 根据语义推测应分别是指定 cursor 的类型和尺寸。尝试调整尺寸以判断是否因设置的尺寸太小迷惑导致无效的假象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flatpak --user override --env=XCURSOR_SIZE=48</span><br></pre></td></tr></table></figure>

<p>调整为原来的一倍。结果是顺利执行无报错，但无变化。</p>
<p>再检查前面设置的目录：</p>
<p><code>/usr/share/icons/</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/share/icons/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span>  </span><br><span class="line">.</span><br><span class="line">├── Adwaita</span><br><span class="line">├── Bibata-Modern-Classic</span><br><span class="line">├── ...</span><br><span class="line">└── Yaru-viridian-dark</span><br><span class="line"></span><br><span class="line">88 directories, 2 files</span><br></pre></td></tr></table></figure>

<p><code>/home/$USER/.icons/</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.icons</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">└── icons</span><br><span class="line"></span><br><span class="line">1 directory, 0 files</span><br></pre></td></tr></table></figure>

<p>此目录下仅 <code>icons</code> 一个。回顾<strong>实践二</strong>中执行的其中一条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/share/icons ~/.icons -r</span><br></pre></td></tr></table></figure>

<p><code>icons</code> 目录是由 <code>/usr/share/icons</code> 拷贝而来，说明 <code>～/.icons/</code> 原本是空的。 </p>
<p><strong>实践二</strong>中执行的其中另外一条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flatpak override --user --env=XCURSOR_PATH=~/.icons</span><br></pre></td></tr></table></figure>

<p>打印 <code>wechat-universal-flatpak</code> 的状态信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>    </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;xdg-config/gtk-3.0:ro;\</span><br><span class="line">  /home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=~/.icons</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=48</span><br></pre></td></tr></table></figure>

<p>确实已经成功设置 <code>XCURSOR_PATH</code>，根据语义推断是 cursor 的主题类型目录。结合以上信息，<code>XCURSOR_PATH</code> 应设置为 <code>XCURSOR_PATH=~/.icons/icons/</code> 或 将 <code>~/.icons/icons/</code> 目录的内容转移到 <code>~/.icons/</code> 目录下。</p>
<p>此处为保持统一，选择后者。实践变动的部分，结果是顺利执行无报错，重启微信后，确实生效！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [21:45:54]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ~/.icons/icons/* ~/.icons/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [21:46:32] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf icons</span></span><br></pre></td></tr></table></figure>
<p><img src="ksnip_20240325-143839.png"></p>
<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><p>虽然在实践四中问题得到了解决，但实际导致异常的原因仍然未明了，那些是有效的、那些是无效的设置。逐步回溯。</p>
<h2 id="回溯“实践三”"><a href="#回溯“实践三”" class="headerlink" title="回溯“实践三”"></a>回溯“实践三”</h2><p>在实践三中，设置了两个环境变量：<code>XCURSOR_THEME</code> 和 <code>XCURSOR_SIZE</code>。因此，需对此进行撤销。从 <code>flatpak override --help</code>（<a href="#flatpak-override-help">见附录</a>）可以得到撤销的方法：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak override --<span class="built_in">help</span></span></span><br><span class="line">Usage:</span><br><span class="line"> flatpak override [OPTION…] [APP] - Override settings [for application]</span><br><span class="line">  ...</span><br><span class="line">Application Options:</span><br><span class="line">  ...</span><br><span class="line">  --unset-env=VAR                         Remove variable from environment</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由此可得：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --unset-env=XCURSOR_THEME</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --unset-env=XCURSOR_SIZE</span></span><br></pre></td></tr></table></figure>

<p>执行以上命令，结果是顺利执行无报错。打印状态确认已生效，见：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>                 </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;xdg-config/gtk-3.0:ro;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=XCURSOR_THEME;QT_QPA_PLATFORM;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=~/.icons/icons/</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br></pre></td></tr></table></figure>
<p>重启微信的结果：异常出现。</p>
<p>为避免默认的 cursor 尺寸过小导致误判，重设 <code>XCURSOR_SIZE</code> 为 <code>48</code>。设置后，重启微信，异常依旧。</p>
<p><em>可以判断 <code>XCURSOR_THEME</code> 无默认值，且需要手动设置。</em></p>
<p>撤销以上，仅设置 <code>XCURSOR_THEME=Adwaita</code>。重启微信的结果：异常消失，cursor 大小正常。</p>
<p><em>可以判断 <code>XCURSOR_SIZE</code> 有默认值，无需要手动设置。</em></p>
<h2 id="回溯“实践二”"><a href="#回溯“实践二”" class="headerlink" title="回溯“实践二”"></a>回溯“实践二”</h2><p>在实践二中，覆盖了 <code>xdg-config/gtk-3.0</code> 目录，以及设置了 <code>XCURSOR_PATH</code> 环境变量。</p>
<p>接下来将保留<strong>回溯“实践三”</strong>的结果分别撤销二者，以判断覆盖 <code>xdg-config/gtk-3.0</code> 目录的必要性，以及 <code>XCURSOR_PATH</code> 是否有默认值且为 <code>/home/$USER/.icons/</code> 或 <code>/usr/share/icons/</code> 两者之一。</p>
<p>撤销环境变量的方法见上，撤销目录覆盖的方法参考 <code>flatpak override --help</code>（<a href="#flatpak-override-help">见附录</a>），并无撤销的方法，但存在可选参数——<code>--nofilesystem</code>，根据参数的描述可知，此参数类似禁用的作用。如此亦不影响实验目的。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak override --<span class="built_in">help</span></span></span><br><span class="line">Usage:</span><br><span class="line"> flatpak override [OPTION…] [APP] - Override settings [for application]</span><br><span class="line"> ...</span><br><span class="line">Application Options:</span><br><span class="line"> ...</span><br><span class="line"> --filesystem=FILESYSTEM[:ro]            Expose filesystem to app (:ro for read-only)</span><br><span class="line"> --nofilesystem=FILESYSTEM               Don&#x27;t expose filesystem to app</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>撤销 <code>XCURSOR_PATH</code>，撤销成功（已打印状态确认，见<a href="#%E6%92%A4%E9%94%80%E2%80%9C%E8%AE%BE%E7%BD%AE-XCURSOR-PATH%E2%80%9D">附录-撤销“设置 XCURSOR_PATH”</a>），重启微信的结果：无异常。</p>
<p><em>可以判断 <code>XCURSOR_PATH</code> 有默认值，且为 <code>/home/$USER/.icons/</code> 或 <code>/usr/share/icons/</code> 两者之一，<code>XCURSOR_PATH</code> 无需手动设置。</em></p>
<p><em>另外也进一步确认 <code>--unset-env</code> 的作用是撤销而非禁用。</em></p>
<p>撤销覆盖 <code>xdg-config/gtk-3.0</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --nofilesystem=xdg-config/gtk-3.0</span></span><br></pre></td></tr></table></figure>

<p>据打印的状态（详细见<a href="#%E7%A6%81%E7%94%A8%E2%80%9Cxdg-config-x2F-gtk-3-0%E2%80%9D%E7%9B%AE%E5%BD%95">附录-禁用“xdg-config-x2F-gtk-3-0”目录</a>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;!xdg-config/gtk-3.0;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br></pre></td></tr></table></figure>

<p>确为“禁用”操作，且已禁用成功。重启微信的结果：无异常。</p>
<p><em>可以判断无需覆盖 <code>xdg-config/gtk-3.0</code> 目录。</em></p>
<h2 id="回溯“实践一”"><a href="#回溯“实践一”" class="headerlink" title="回溯“实践一”"></a>回溯“实践一”</h2><p>实践一中分别覆盖了 <code>/home/$USER/.icons/</code> 和 <code>/usr/share/icons/</code>，由以上可知，这两目录都是主题相关的。</p>
<p>由<a href="#%E5%9B%9E%E6%BA%AF%E2%80%9C%E5%AE%9E%E8%B7%B5%E4%B8%89%E2%80%9D"><strong>回溯“实践三”</strong></a>中的结论——<code>XCURSOR_THEME</code> 无默认值，且需要手动设置——且 <code>--nofilesystem</code> 的作用是禁用而非撤销（见<a href="#%E5%9B%9E%E6%BA%AF%E2%80%9C%E5%AE%9E%E8%B7%B5%E4%BA%8C%E2%80%9D">回溯“实践二”</a>），因此当前暂无方案验证仅仅设置 <code>XCURSOR_THEME</code> 即可解决异常（可以使用虚拟机隔离或重装 Flatpak 环境，但性价比过大，搁置之）。</p>
<p>下面将通过分别禁用以上两个目录，以验证那个目录是非必要覆盖的，同样验证 <code>XCURSOR_PATH</code> 默认值。</p>
<p>仅禁用 <code>/usr/share/icons/</code>，确认禁用成功，详见<a href="#%E7%A6%81%E7%94%A8%E2%80%9C-x2F-usr-x2F-share-x2F-icons-x2F-%E2%80%9D%E7%9B%AE%E5%BD%95">附录-禁用 “&#x2F;usr&#x2F;share&#x2F;icons&#x2F;” 目录</a>，重启微信的结果：无异常。</p>
<p>仅禁用 <code>/home/$USER/.icons/</code>，使用 <code>--filesystem</code> 再次覆盖 <code>/usr/share/icons/</code>，以撤销上面的操作，确认禁用 <code>/home/$USER/.icons/</code> 成功，详见<a href="#%E4%BB%85%E7%A6%81%E7%94%A8%E2%80%9C-x2F-home-x2F-USER-x2F-icons-x2F-%E2%80%9D%E7%9B%AE%E5%BD%95">仅禁用 “&#x2F;home&#x2F;$USER&#x2F;.icons&#x2F;” 目录</a>），重启微信的结果：无异常。</p>
<p><em>出现了意料之外的情况（预期以上两次操作之一会导致异常再次出现）！</em></p>
<p>根据目前情况有以下推测：</p>
<ol>
<li><p><code>XCURSOR_PATH</code> 的默认值非 <code>/home/$USER/.icons/</code> 或 <code>/usr/share/icons/</code>，而是存在第三个路径；</p>
</li>
<li><p><code>XCURSOR_THEME</code> 的默认值非单一固定值，可能是一个由 <code>/home/$USER/.icons/</code> 和 <code>/usr/share/icons/</code> 组成的具有优先级的队列；</p>
</li>
<li><p><code>--nofilesystem</code> 不是预期的禁用效果，而是其他。</p>
</li>
</ol>
<h3 id="验证“推测-1”"><a href="#验证“推测-1”" class="headerlink" title="验证“推测 1”"></a>验证“推测 1”</h3><p>由于不确定 <code>--nofilesystem</code> 的作用，当前选择“删除法”，分别删除 <code>/home/$USER/.icons/</code> 或 <code>/usr/share/icons/</code> 以验证 推测 1，若删除两者依然无异常则推测 1 成立。</p>






<p>为避免多余干扰，先使用 <code>--filesystem</code> 撤销 <code>--nofilesystem</code> 下的作用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flatpak --user override --filesystem=/home/$USER/.icons/:ro </span><br><span class="line">flatpak --user override --filesystem=/usr/share/icons/:ro</span><br></pre></td></tr></table></figure>
<p>首先删除 <code>/home/$USER/.icons/icons/</code> 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [16:36:10]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf ~/.icons/icons</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [16:39:01]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">0 directories, 0 files</span><br></pre></td></tr></table></figure>

<p>重启微信的结果：无异常。</p>
<p>接着删除 <code>/usr/share/icons/</code>目录。由于 <code>/usr/share/icons/</code> 目录是 root 层级的，直接删除为危险操作，不可取！</p>
<p>由以上信息知，cursor 使用主题是 <code>Adwaita</code>，因此可通过备份且移除 <code>/usr/share/icons/</code> 下的 <code>Adwaita</code> 目录，模拟“删除”的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [16:39:06]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/backup/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> /usr/share/icons [16:41:18]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./Adwaita ~/backup/</span></span><br><span class="line">[sudo] password for isaac: *******</span><br></pre></td></tr></table></figure>

<p>重启微信的结果：异常复现。</p>
<p><em>可以推翻推测 1，XCURSOR_PATH 的默认值在 <code>/home/$USER/.icons/icons/</code> 和<code>/usr/share/icons/</code> 中，而非第三路径。</em></p>
<h3 id="验证“推测-2”"><a href="#验证“推测-2”" class="headerlink" title="验证“推测 2”"></a>验证“推测 2”</h3><p>基于<a href="#%E9%AA%8C%E8%AF%81%E2%80%9C%E6%8E%A8%E6%B5%8B-1%E2%80%9D">验证“推测 1”</a>的实验状态，验证推测 2。保持 <code>/usr/share/icons/</code> 下缺少 <code>Adwaita</code> 目录。并拷贝 <code>Adwaita</code> 目录至 <code>/home/$USER/.icons/icons/</code> 目录下。若异常消失，则推论 2 成立。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> /usr/share/icons [17:16:27] C:130</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r ~/backup/Adwaita ~/.icons/icons/Adwaita/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> /usr/share/icons [17:16:44]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.icons/icons</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons/icons [17:16:55]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">└── Adwaita</span><br><span class="line"></span><br><span class="line">1 directory, 0 files</span><br></pre></td></tr></table></figure>

<p>重启微信的结果：无明显变化，异常依旧。</p>
<p><em>至此，可以推翻推测 2。<code>XCURSOR_THEME</code> 的默认值非是一个由 <code>/home/$USER/.icons/</code> 和 <code>/usr/share/icons/</code> 组成的具有优先级的队列。结合 <a href="#%E9%AA%8C%E8%AF%81%E2%80%9C%E6%8E%A8%E6%B5%8B-1%E2%80%9D">验证“推测 1”</a> 的结论，可以确认 <code>XCURSOR_THEME</code> 的默认值是单一值，且为 <code>/usr/share/icons/</code>。</em></p>
<p>基于此结论，同时可确认：<em>无需覆盖 <code>/home/$USER/.icons/</code> 目录。</em></p>
<h3 id="验证“推测-3”"><a href="#验证“推测-3”" class="headerlink" title="验证“推测 3”"></a>验证“推测 3”</h3><p>从 <a href="#%E9%AA%8C%E8%AF%81%E2%80%9C%E6%8E%A8%E6%B5%8B-2%E2%80%9D">验证“推测 2”</a>已知 <code>XCURSOR_THEME</code> 的默认值是 <code>/usr/share/icons/</code>。在恢复 <code>/usr/share/icons/</code> 下的 <code>Adwaita</code> （异常消失）的前提下使用 <code>--nofilesystem</code> “禁用” <code>/usr/share/icons/</code>，若无异常出现，则推测成立。</p>
<p>拷贝 <code>Adwaita</code> 目录至 <code>/home/$USER/.icons/</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons/icons [17:34:35]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r ~/backup/Adwaita /usr/share/icons/Adwaita/</span>      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> /usr/share/icons [17:35:37]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── Adwaita</span><br><span class="line">├── ...</span><br><span class="line">└── Yaru-viridian-dark</span><br><span class="line"></span><br><span class="line">88 directories, 2 files</span><br></pre></td></tr></table></figure>

<p>重启微信的结果：无明显变化，无异常。</p>
<p>至此，可以确定： <em><code>--nofilesystem</code> 不是预期的禁用效果，而是其他。</em></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>综合三个验证实验可知：导致<a href>回溯“实践一”</a>操作未达预期的原因是：<code>--nofilesystem</code> 不是预期的禁用效果，而是其他。</p>
<p>若 <code>--nofilesystem</code> 不是预期的禁用效果，那么 <a href="#%E5%9B%9E%E6%BA%AF%E2%80%9C%E5%AE%9E%E8%B7%B5%E4%BA%8C%E2%80%9D">回溯“实践二”</a>中的推论——可以判断无需覆盖 <code>xdg-config/gtk-3.0</code> 目录——也将失效。</p>
<p>另外，三个验证实验的结果也可确定以下两点：</p>
<ol>
<li><p><code>XCURSOR_PATH</code> 的默认值是 <code>/usr/share/icons/</code> 而非 <code>/home/$USER/.icons/</code> 或 <code>/usr/share/icons/</code> 外的第三者；</p>
</li>
<li><p><code>XCURSOR_PATH</code> 的默认值是单一值，而非优先级队列。</p>
</li>
</ol>
<p>回顾<a href="#%E5%9B%9E%E6%BA%AF%E2%80%9C%E5%AE%9E%E8%B7%B5%E4%B8%80%E2%80%9D">回溯“实践一”</a>的目的：是为确定以下两条命令是否必要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flatpak --user override --filesystem=/home/$USER/.icons/:ro</span><br><span class="line">flatpak --user override --filesystem=/usr/share/icons/:ro</span><br></pre></td></tr></table></figure>

<p>由第 1 点可以断定：<em>针对 <code>/home/$USER/.icons/</code> 目录的覆盖，在当前环境下是没有必要的。</em></p>
<p>由于 <code>--nofilesystem</code> 的作用未达预期，且暂无其他方式撤销对 <code>/usr/share/icons/</code> 目录的覆盖，因此暂无法确定。</p>
<p>根据 <a href="https://wiki.archlinux.org/title/Flatpak#Override_sandbox_permissions_of_applications">Archlinux Wiki | Flatpak | Managing runtimes and applications | Override sandbox permissions of applications</a> 中提到的应该有阻止应用访问目标目录：</p>
<blockquote>
<p><strong>3.12 Override sandbox permissions of applications</strong><br>If you find the predefined permissions of the application too lax or too restrictive you can change to anything you want using flatpak override command. For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flatpak override --nofilesystem=home name</span><br></pre></td></tr></table></figure>
<p><mark>This will prevent the application access to your home folder.</mark></p>
</blockquote>
<h2 id="使用-reset-参数"><a href="#使用-reset-参数" class="headerlink" title="使用 --reset 参数"></a>使用 <code>--reset</code> 参数</h2><p>在 <code>flatpak override --help</code> 中存在可选参数：<code>--reset</code>，根据描述可知它的作用是移除所有的覆盖操作（详见<a href="#flatpak-override-help">附录</a>）。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak override --<span class="built_in">help</span></span></span><br><span class="line">Usage:</span><br><span class="line"> flatpak override [OPTION…] [APP] - Override settings [for application]</span><br><span class="line"> ...</span><br><span class="line">Application Options:</span><br><span class="line"> ...</span><br><span class="line"> --reset                                 Remove existing overrides</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但 <code>--reset</code> 实际效果未知，为避免破坏原有的实验状态，故前面使用了回溯法进行实验。就目前情况而言，是时候使用 <code>--reset</code>。</p>
<p><code>--reset</code> 实验将在<a href="#%E5%AE%9E%E8%B7%B5">实践</a>结果（已解决 cursor 异常）的前提下进行，以一定程度上检验 <code>--reset</code> 的作用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [22:00:17] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --reset</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [22:00:27]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>    </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;xdg-config/fontconfig:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br></pre></td></tr></table></figure>
<p>重启微信的结果：异常出现。</p>
<p><em>从打印的状态信息（实践过程中覆盖的目录和设置的环境变量都从状态信息中消失）和异常再现的现象可以一定程度上认为，<code>--reset</code> 具备重置的作用。</em></p>
<p>下面将在认定 <code>--reset</code> 将状态重置成功的前提下，进行正向实验：做最小程度的操作解决异常——设置 <code>XCURSOR_THEME=Adwaita</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --<span class="built_in">env</span>=XCURSOR_THEME=Adwaita</span></span><br></pre></td></tr></table></figure>

<p>重启微信的结果：异常消失。</p>
<p><em>可以判断在当前环境下，仅需设置 <code>XCURSOR_THEME=Adwaita</code> 即可解决 wechat-universal-flatpak 的 cursor 样式异常。</em></p>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>由于无法完全确定 <code>--reset</code> 的作用，将按 <code>--reset</code> 是否达预期重置作用进行总结。</p>
<p>当 <code>--reset</code> 达预期重置，则在当前环境下，仅需设置 <code>XCURSOR_THEME=Adwaita</code> 即可解决异常；</p>
<p>当 <code>--reset</code> 未达预期重置，则可能需要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --filesystem=/usr/share/icons/:ro</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --filesystem=xdg-config/gtk-3.0:ro</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --<span class="built_in">env</span>=XCURSOR_THEME=Adwaita</span></span><br></pre></td></tr></table></figure>

<p>下面对实践一至四操作结果进行分析。</p>
<ul>
<li><p><strong>实践一</strong>：覆盖了 <code>/home/$USER/.icons/</code> 和 <code>/usr/share/icons/</code>，但未设置 <code>XCURSOR_THEME=Adwaita</code>， 因此未解决异常；</p>
</li>
<li><p><strong>实践二</strong>：增量覆盖了 <code>xdg-config/gtk-3.0</code> 和 设置 <code>XCURSOR_PATH=~/.icons</code>，未设置 <code>XCURSOR_THEME=Adwaita</code>， 因此未解决异常；</p>
</li>
<li><p><strong>实践三</strong>：增量设置了 <code>XCURSOR_THEME=Adwaita</code> 和 <code>XCURSOR_SIZE=24</code>，前者是有效操作，后者则是冗余的。仍然失败的原因是因实践二中设置了 <code>XCURSOR_PATH=~/.icons</code>，指向了空目录(<code>~/.icons/Adwaita/</code> 是空目录)；</p>
</li>
<li><p><strong>实践四</strong>：成功的原因是解决了实践三中的问题——<code>~/.icons/Adwaita/</code> 是空目录。</p>
</li>
</ul>
<h1 id="扩展（todo）"><a href="#扩展（todo）" class="headerlink" title="扩展（todo）"></a>扩展（todo）</h1><ul>
<li><p>GTK？</p>
</li>
<li><p>reddit？</p>
</li>
<li><p>archlinux wiki？</p>
</li>
<li><p>全文阅读archlinux wiki for flatpak，从中挑选值得记录学习的知识点</p>
</li>
<li><p>如何查看 flatpak app 的已经被授予的权限（推荐查阅官方文档，可以参考 <a href="https://man.archlinux.org/man/flatpak-override.1%EF%BC%8C">https://man.archlinux.org/man/flatpak-override.1，</a> 但需对比官方文档）</p>
</li>
<li><p><a href="https://docs.flatpak.org/en/latest/sandbox-permissions-reference.html">Flatpak documentation | Sandbox Permissions Reference</a>有提到 <code>--nofilesystem</code> 的作用</p>
</li>
<li><p>使用 docker 创建隔离环境以实验</p>
</li>
<li><p><a href="https://flathub.org/apps/com.github.tchx84.Flatseal">Flathub | Flatseal</a> 安装，它是什么？</p>
</li>
<li><p><a href="https://github.com/tchx84/Flatseal">Github Repository | tchx84&#x2F;Flatseal</a></p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="flatpak-override-help"><a href="#flatpak-override-help" class="headerlink" title="flatpak override --help"></a><code>flatpak override --help</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak override --<span class="built_in">help</span></span></span><br><span class="line">Usage:</span><br><span class="line">  flatpak override [OPTION…] [APP] - Override settings [for application]</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --help                              Show help options</span><br><span class="line">  --help-all                              Show all help options</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  --user                                  Work on the user installation</span><br><span class="line">  --system                                Work on the system-wide installation (default)</span><br><span class="line">  --installation=NAME                     Work on a non-default system-wide installation</span><br><span class="line">  --reset                                 Remove existing overrides</span><br><span class="line">  --show                                  Show existing overrides</span><br><span class="line">  -v, --verbose                           Show debug information, -vv for more detail</span><br><span class="line">  --ostree-verbose                        Show OSTree debug information</span><br><span class="line">  --share=SHARE                           Share with host</span><br><span class="line">  --unshare=SHARE                         Unshare with host</span><br><span class="line">  --socket=SOCKET                         Expose socket to app</span><br><span class="line">  --nosocket=SOCKET                       Don&#x27;t expose socket to app</span><br><span class="line">  --device=DEVICE                         Expose device to app</span><br><span class="line">  --nodevice=DEVICE                       Don&#x27;t expose device to app</span><br><span class="line">  --allow=FEATURE                         Allow feature</span><br><span class="line">  --disallow=FEATURE                      Don&#x27;t allow feature</span><br><span class="line">  --filesystem=FILESYSTEM[:ro]            Expose filesystem to app (:ro for read-only)</span><br><span class="line">  --nofilesystem=FILESYSTEM               Don&#x27;t expose filesystem to app</span><br><span class="line">  --env=VAR=VALUE                         Set environment variable</span><br><span class="line">  --env-fd=FD                             Read environment variables in env -0 format from FD</span><br><span class="line">  --unset-env=VAR                         Remove variable from environment</span><br><span class="line">  --own-name=DBUS_NAME                    Allow app to own name on the session bus</span><br><span class="line">  --talk-name=DBUS_NAME                   Allow app to talk to name on the session bus</span><br><span class="line">  --no-talk-name=DBUS_NAME                Don&#x27;t allow app to talk to name on the session bus</span><br><span class="line">  --system-own-name=DBUS_NAME             Allow app to own name on the system bus</span><br><span class="line">  --system-talk-name=DBUS_NAME            Allow app to talk to name on the system bus</span><br><span class="line">  --system-no-talk-name=DBUS_NAME         Don&#x27;t allow app to talk to name on the system bus</span><br><span class="line">  --add-policy=SUBSYSTEM.KEY=VALUE        Add generic policy option</span><br><span class="line">  --remove-policy=SUBSYSTEM.KEY=VALUE     Remove generic policy option</span><br><span class="line">  --persist=FILENAME                      Persist home directory subpath</span><br></pre></td></tr></table></figure>

<h2 id="撤销“设置-XCURSOR-PATH”"><a href="#撤销“设置-XCURSOR-PATH”" class="headerlink" title="撤销“设置 XCURSOR_PATH”"></a>撤销“设置 XCURSOR_PATH”</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [17:11:23]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --unset-env=XCURSOR_PATH</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [17:12:42] C:130</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>       </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;xdg-config/gtk-3.0:ro;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;XCURSOR_PATH;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br></pre></td></tr></table></figure>

<h2 id="禁用“xdg-config-gtk-3-0”目录"><a href="#禁用“xdg-config-gtk-3-0”目录" class="headerlink" title="禁用“xdg-config&#x2F;gtk-3.0”目录"></a>禁用“xdg-config&#x2F;gtk-3.0”目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [17:12:43]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --nofilesystem=xdg-config/gtk-3.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [17:27:34]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>                </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;!xdg-config/gtk-3.0;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons:ro;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;XCURSOR_PATH;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br></pre></td></tr></table></figure>

<h2 id="禁用“-usr-share-icons-”目录"><a href="#禁用“-usr-share-icons-”目录" class="headerlink" title="禁用“&#x2F;usr&#x2F;share&#x2F;icons&#x2F;”目录"></a>禁用“&#x2F;usr&#x2F;share&#x2F;icons&#x2F;”目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:37:58]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --nofilesystem=/usr/share/icons/</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:39:04]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>               </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;!xdg-config/gtk-3.0;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;!/usr/share/icons;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;XCURSOR_PATH;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br></pre></td></tr></table></figure>

<h2 id="仅禁用“-home-USER-icons-”目录"><a href="#仅禁用“-home-USER-icons-”目录" class="headerlink" title="仅禁用“&#x2F;home&#x2F;$USER&#x2F;.icons&#x2F;”目录"></a>仅禁用“&#x2F;home&#x2F;$USER&#x2F;.icons&#x2F;”目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:39:09]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --filesystem=/usr/share/icons/</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:43:36]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>             </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;!xdg-config/gtk-3.0;/home/isaac/.icons:ro;xdg-config/fontconfig:ro;/usr/share/icons;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;XCURSOR_PATH;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:43:40]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak --user override --nofilesystem=/home/<span class="variable">$USER</span>/.icons/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ Mint-Yoga <span class="keyword">in</span> ~/.icons [20:44:26]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak info -M com.tencent.WeChat master</span>                 </span><br><span class="line">[Context]</span><br><span class="line">shared=network;ipc;</span><br><span class="line">sockets=x11;pulseaudio;</span><br><span class="line">devices=all;</span><br><span class="line">features=devel;</span><br><span class="line">filesystems=xdg-download;xdg-pictures;xdg-music;!xdg-config/gtk-3.0;!/home/isaac/.icons;xdg-config/fontconfig:ro;/usr/share/icons;</span><br><span class="line">persistent=.xwechat;xwechat_files;</span><br><span class="line">unset-environment=QT_QPA_PLATFORM;XCURSOR_PATH;XCURSOR_SIZE;</span><br><span class="line"></span><br><span class="line">[Session Bus Policy]</span><br><span class="line">org.kde.StatusNotifierWatcher=talk</span><br><span class="line">org.freedesktop.Notifications=talk</span><br><span class="line">org.kde.*=own</span><br><span class="line"></span><br><span class="line">[Environment]</span><br><span class="line">XCURSOR_THEME=Adwaita</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">XCURSOR_PATH=</span><br><span class="line">QT_AUTO_SCREEN_SCALE_FACTOR=1</span><br><span class="line">XCURSOR_SIZE=</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://github.com/flatpak/flatpak/issues/709">Github issue | flatpak&#x2F;flatpak | Different cursor theme in flatpak apps #709</a></p>
</li>
<li><p><a href="https://github.com/flatpak/flatpak/issues/709#issuecomment-1381482007">Github issue | flatpak&#x2F;flatpak | Different cursor theme in flatpak apps #709 | the solution too on Linux Mint</a></p>
</li>
<li><p><a href="https://www.reddit.com/r/flatpak/comments/rxnyh7/flatpak_app_changing_cursor_theme_and_size_is/">Reddit | Flatpak App Changing Cursor Theme And Size (Is This Normal Behavior?)</a></p>
</li>
<li><p><a href="https://wiki.archlinux.org/title/Flatpak#Applications_do_not_use_the_correct_cursor_theme">Archlinux Wiki | Flatpak | Troubleshooting  | Applications do not use the correct cursor theme</a></p>
</li>
<li><p><a href="https://wiki.archlinux.org/title/Flatpak#Override_sandbox_permissions_of_applications">Archlinux Wiki | Flatpak | Managing runtimes and applications | Override sandbox permissions of applications</a></p>
</li>
</ul>


<ul>
<li><p><a href="https://docs.flatpak.org/en/latest/index.html">Official | Flatpak documentation</a></p>
</li>
<li><p><a href="https://archlinux.org/packages/extra/x86_64/xdg-desktop-portal-gtk/">Archlinux Wiki | xdg-desktop-portal-gtk 1.15.1-1</a></p>
</li>
<li><p><a href="https://github.com/flatpak/xdg-desktop-portal-gtk">Github repository | flatpak&#x2F;xdg-desktop-portal-gtk</a></p>
</li>
<li><p><a href="https://wiki.archlinux.org/title/XDG_Desktop_Portal">Archlinux Wiki | XDG Desktop Portal</a></p>
</li>
<li><p><a href="https://wiki.archlinux.org/title/Flatpak#Flatpak_applications_not_picking_up_the_default_system_theme">Archlinux Wiki | Flatpak | Flatpak applications not picking up the default system theme</a></p>
</li>
<li><p><a href="https://github.com/flatpak/flatpak/issues/114">Github issue | flatpak&#x2F;flatpak | Apps are not aware of desktop themes #114</a></p>
</li>
<li><p><a href="https://aur.archlinux.org/packages/stylepak-git">Archlinux Wiki | stylepak-git 16.124fbdc-1</a></p>
</li>
<li><p><a href="https://www.reddit.com/r/flatpak/comments/uv7nqb/is_there_any_way_to_manually_installcopy_themes/">Reddit | Is there any way to manually install&#x2F;copy themes into flatpak, that aren’t available via flathub?</a></p>
</li>
<li><p><a href="https://github.com/refi64/stylepak">Github repository | refi64&#x2F;stylepak</a></p>
</li>
<li><p><a href="https://weixin.qq.com/cgi-bin/readtemplate?lang=zh_CN&t=weixin_faq_list&head=true">微信更新日志</a></p>
</li>
<li><p><a href="https://www.ithome.com/0/755/450.htm">IT之家 | 微信（Universal）UOS &#x2F; 银河麒麟版全新升级：Linux 原生跨平台方案，现已开放下载</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>Flatpak</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下刚刚好的终端模拟器 - Tilix</title>
    <url>/blog/resources/Linux-Terminal-Emulator-Tilix/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 Linux 很久，用过多个发行版本，每个版本都有内置的终端模拟器。有 Gnome Terminal、Konsole、GUAKE 等等。使用 MacOS 时遇到了让我觉得刚刚好的终端模拟器 - Iterm2，各种原因下，我不再使用 MacOS，后来就很少让我觉得趁手的终端模拟器。后来，一直使用 Windows 和 Linux。Windows 下用的是 Windows Terminal（这是应用名），配合 WSL2，够用也漂亮，知道在开发中遇到 WSL2 无法解决的情况，再次投身到 Linux 的海洋中。目前使用 Linux Mint 21，它是个漂亮且好用的发行版本。Linux 下的终端始终是我内心深处的刺呢，一直在尝试着其他终端：Konsole、Kitty、tmux、Tabby、Terminator、Tilda等等，花了不少的时间安装、配置，遇到不少的问题，都没有达到心目中期望的样子。直到遇到了 Tilix。</p>
<span id="more"></span>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>该文章首先介绍了 Tilix 终端模拟器的基本信息和特点。它强调了 Tilix 的配置简单性，通过直观的图形界面使得用户可以轻松地自定义终端的外观和行为。此外，文章还强调了 Tilix 的原生分屏功能，允许用户在一个终端窗口中同时运行多个程序或命令。</p>
<p>接下来，文章详细介绍了 Tilix 的特性和功能。它强调了 Tilix 的分屏功能对于多任务处理的便利性，用户可以轻松地在一个窗口中切换和管理多个终端会话。文章还提到了 Tilix 支持的其他功能，如标签页、会话管理、快捷键等，这些功能使得 Tilix 成为一个强大而灵活的终端模拟器。</p>
<p>此外，文章还探讨了 Tilix 的外观定制性。它介绍了 Tilix 提供的丰富的配色方案和字体选项，以及与桌面环境整体外观风格一致的 GTK 主题集成。这使得用户可以根据自己的喜好和需求来个性化定制终端的外观。</p>
<p>最后，文章总结了 Tilix 的优点，并提到了它与其他终端模拟器（如 kitty、tmux、gnome-terminal 和 konsole）的比较。它强调了 Tilix 在配置简单性、原生分屏支持和外观美观性方面的优势，使得 Tilix 成为一个备受欢迎的终端模拟器。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">System:</span><br><span class="line">  Kernel: 5.15.0-86-generic x86_64 bits: 64 compiler: gcc v: 11.4.0 Desktop: Cinnamon 5.8.4</span><br><span class="line">    tk: GTK 3.24.33 wm: muffin dm: LightDM Distro: Linux Mint 21.2 Victoria base: Ubuntu 22.04 jammy</span><br><span class="line">Machine:</span><br><span class="line">  Type: Desktop Mobo: ASUSTeK model: TUF B360M-PLUS GAMING S v: Rev X.0x</span><br><span class="line">    serial: &lt;superuser required&gt; UEFI: American Megatrends v: 2418 date: 06/04/2019</span><br><span class="line">CPU:</span><br><span class="line">  Info: 6-core model: Intel Core i5-8600K bits: 64 type: MCP arch: Coffee Lake rev: A cache:</span><br><span class="line">    L1: 384 KiB L2: 1.5 MiB L3: 9 MiB</span><br><span class="line">  Speed (MHz): avg: 4100 min/max: 800/4300 cores: 1: 4100 2: 4100 3: 4100 4: 4100 5: 4100</span><br><span class="line">    6: 4100 bogomips: 43200</span><br><span class="line">  Flags: avx avx2 ht lm nx pae sse sse2 sse3 sse4_1 sse4_2 ssse3 vmx</span><br></pre></td></tr></table></figure>
<h1 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h1><p><img src="2023-10-15_11-14.png" alt="Tmux + Gnome Terminal"></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Tmux 是一个终端复用器，可以在一个终端窗口中同时运行多个终端会话。它允许用户在一个终端中创建、管理和切换多个虚拟终端，从而提高工作效率。</p>
<p>使用 tmux，你可以在一个终端窗口中创建多个窗格和标签页，每个窗格和标签页都可以运行独立的终端会话。这意味着你可以同时查看和操作多个终端，而无需打开多个终端窗口。</p>
<p>tmux 提供了一系列命令和快捷键，用于管理和控制终端会话。你可以轻松地创建、关闭、切换和重命名窗格和标签页，调整它们的大小和布局，以适应你的工作需求。你还可以在不同的窗格和标签页之间进行复制粘贴操作，共享剪贴板内容。</p>
<p>另外，tmux 还支持会话的分离和附加功能。这意味着你可以在一个tmux会话中运行命令，然后将会话分离，保持命令在后台运行。稍后，你可以重新附加到该会话，恢复之前的终端会话状态。</p>
<p>tmux 是一个强大的工具，特别适用于需要同时处理多个终端会话的情况，如远程服务器管理、开发调试等。它提供了灵活的配置选项，允许用户自定义外观、键绑定和其他行为。</p>
<p>它功能丰富、灵活且强大的终端复用器，为用户提供了更高效地管理和控制终端会话的能力。它是命令行界面的一个有用工具，广泛应用于Unix-like系统中。</p>
<h2 id="为什么选择了-Tmux"><a href="#为什么选择了-Tmux" class="headerlink" title="为什么选择了 Tmux"></a>为什么选择了 Tmux</h2><p>实话说，我会使用 Tmux 是看中了他分屏的功能。在经历多多个终端模拟器的试用无果后，我也倦怠于此。我打算着使用 Mint 自带的 Gnome Terminal（不支持分屏） 配合 Tmux 使用。</p>
<p>距离上次使用 Tmux 已经是 4、5 年前，现在 Tmux 已经变得更加优秀，更好的鼠标指针支持，让我惊艳的是它已经支持右键菜单，分屏、关闭、切换都已经很轻松，一句话的配置就已经解决了大部分的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.tmux.conf</span></span><br><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>

<p><img src="image-1.png" alt="Tmux"></p>
<h2 id="放弃的原因"><a href="#放弃的原因" class="headerlink" title="放弃的原因"></a>放弃的原因</h2><p>最大的问题来源于剪切板。Tmux 自有一套剪切板，并且它与系统剪切板并不是双向共享的。这让我难受，可以想像：你执行某个命令是出现了异常，提供了异常信息。你发现你解决不了，因此你打算复制异常信息到浏览器或其他地方以寻找答案。此时你发现此路不通！你只好手打了异常信息关键字进行搜索。天可怜见，你找到了答案。你复制答案的解决命令尝试解决，突然你发现你复制的内容在终端内变了样！此时此刻，你只想数数天上的草泥马。</p>
<p>因此，我花了不少的时间尝试去解决这个问题。安装 xclip，编辑配置文件尝试让 tmux 剪切板自动写入系统的剪切板。但是都不尽如人意，最终，我选择后退一步，编写了 2 个 shell 命令，以在有需要时手动写入对应的剪切板：</p>
<p><em>读取 tmux 的剪切板内容，写入 xclip，<code>sysclip-read-tmux</code></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">tmux show-buffer | xclip -selection clipboard</span><br></pre></td></tr></table></figure>

<p>在 tmux 中复制内容后，执行 <code>sysclip-read-tmux</code>。</p>
<p><em>读取系统剪切板，写入 tmux，<code>sysclip-write-tmux</code></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;$(xclip -o -selection clipboard)&quot; | tmux load-buffer -</span><br></pre></td></tr></table></figure>

<p>在非 tmux 中复制内容后，在 tmux 下执行 <code>sysclip-write-tmux</code>。</p>
<p>以上这个解决方案是我最后可以使用的解决方案，是我最后的倔强。</p>
<p>除了剪切板问题外，有几个审美上的问题，我可以接受，但是希望更好的是：</p>
<ol>
<li><p>窗口分割线，分割窗口后的分割线不符合我的审美，并且未找到方案修改。我也不愿意继续花更多时间寻找它的解决方案；</p>
</li>
<li><p>右键菜单，虽然支持右键菜单，功能更好了，但是难看是不争的事实；</p>
</li>
<li><p>底部状态栏，同上。</p>
</li>
</ol>
<h1 id="Konsole"><a href="#Konsole" class="headerlink" title="Konsole"></a>Konsole</h1><p><img src="konsolefancy.png" alt="Konsole"></p>
<h2 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h2><p>Konsole 是一个流行的终端模拟器，用于在 Linux 和其他 UNIX-like 操作系统上提供命令行界面。它是 KDE 桌面环境的一部分，并且是 Konqueror 项目的一部分。</p>
<p>Konsole 提供了一个功能丰富的用户界面，使用户可以通过命令行与计算机系统进行交互。它支持多标签页，允许用户同时打开多个终端会话，并在它们之间轻松切换。每个标签页可以独立设置，包括配色方案、字体、背景图像等。</p>
<p>Konsole 还具有许多其他功能，如自动完成、命令历史记录、拖放文本等。它支持多种终端模拟协议，包括本地终端、远程 SSH、Telnet 和串口连接，使用户能够通过网络或串口访问和管理其他计算机或设备。</p>
<p>除了基本的终端功能外，Konsole 还支持一些高级特性，如分屏显示和垂直拆分，使用户可以在同一个终端窗口中同时查看和操作多个终端会话。</p>
<h2 id="为什么选择了-Konsole"><a href="#为什么选择了-Konsole" class="headerlink" title="为什么选择了 Konsole"></a>为什么选择了 Konsole</h2><p>最开始接触 Konsole 是安装 Manjora（KDE） 时，也是我第一次安装 KDE 桌面环境。Konsole 是它自带的终端模拟器。它自带的分屏的功能实在是让我惊艳。在使用其他发行版本时，Konsole 一直是我首选的终端模拟器。</p>
<h2 id="放弃的原因-1"><a href="#放弃的原因-1" class="headerlink" title="放弃的原因"></a>放弃的原因</h2><p>成也 KDE，败也 KDE。正如文章前面的背景所见，我当前使用的 Cinnamon，KDE 虽然不错，但是 Cinnamon 的更让我爱不释手。而 Konsole 作为 KDE 所设计的终端模拟器，它自身常见的问题被放大！</p>
<p>尽管 Konsole 是一个稳定且功能强大的终端模拟器，但在某些情况下，用户可能会遇到一些常见的问题。以下是一些可能出现的问题和解决方法：</p>
<ol>
<li><p>字符编码问题：有时候，Konsole 可能无法正确显示特定字符或文本文件。这可能是由于字符编码设置不正确导致的。解决方法是确保 Konsole 的字符编码与所使用的文本文件或终端环境的字符编码一致。</p>
</li>
<li><p>配色方案问题：Konsole 提供了自定义配色方案的功能，但有时用户可能会遇到配色方案无法正常加载或显示的问题。这可能是由于配色方案文件的格式错误或不兼容导致的。解决方法是检查配色方案文件的格式，并确保它与 Konsole 的版本兼容。</p>
</li>
<li><p>快捷键冲突：Konsole 允许用户自定义键盘快捷键，但有时可能会出现与系统或其他应用程序的快捷键冲突的问题。这可能导致快捷键无法正常工作或产生意外的结果。解决方法是检查和调整 Konsole 的快捷键设置，避免与其他应用程序的快捷键冲突。</p>
</li>
<li><p>闪烁或屏幕损坏：在某些情况下，Konsole 的窗口可能出现闪烁或显示异常的情况。这可能是由于图形驱动程序或 Konsole 本身的兼容性问题引起的。解决方法包括更新图形驱动程序、升级 Konsole 到最新版本或尝试其他终端模拟器。</p>
</li>
<li><p>远程连接问题：如果使用 Konsole 进行远程连接（如 SSH），可能会遇到连接失败、断开或延迟等问题。这可能是由于网络问题、远程服务器配置或安全设置等原因引起的。解决方法包括检查网络连接、确认远程服务器设置正确并调整Konsole的连接参数。</p>
</li>
</ol>
<p>这些问题在 Cinnamon 桌面环境下变得更加常见，并且一些样式也走形。它的这些劣质化现象，让我宁愿使用 Gnome Terminal + Tmux，也不使用它。在安装它 1 小时后就被我扔进了垃圾桶。另外，在 KDE 下可以忍受的问题也变得如眼中刺，比如它“常在”的滚动条，在分屏后更加让人无法忍受的丑陋！</p>
<h1 id="Kitty"><a href="#Kitty" class="headerlink" title="Kitty"></a>Kitty</h1><p><img src="FQ4WtHKVgAAPx3I.jpeg" alt="Kitty"></p>
<h2 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h2><p>Kitty 是一个现代化的终端模拟器，设计用于提供强大的命令行界面和丰富的功能。它是一个跨平台的终端模拟器，可在 Linux、macOS 和 Windows 等操作系统上使用。</p>
<p>Kitty 的目标是提供高性能和可定制性。它采用 GPU 加速技术，可以处理大量字符和图形渲染，从而实现流畅的终端体验。此外，Kitty 还支持像素级的渲染，使用户可以在终端中显示高分辨率的图像和图标。</p>
<p>Kitty 具有许多先进的功能，包括多标签页和分屏显示，使用户可以同时管理多个终端会话。它支持自动完成、命令历史记录、滚动回放等常见的终端功能。Kitty 还支持基于鼠标的交互，用户可以使用鼠标选择文本、复制粘贴内容等。</p>
<p>除此之外，Kitty 还提供了丰富的自定义选项，用户可以自定义配色方案、字体、键盘快捷键等，以满足个人偏好和需求。它还支持脚本扩展和插件，允许用户根据自己的需求添加额外的功能和扩展。</p>
<h2 id="为什么选择了-Kitty"><a href="#为什么选择了-Kitty" class="headerlink" title="为什么选择了 Kitty"></a>为什么选择了 Kitty</h2><p>正如简述中提到的，“它采用 GPU 加速技术”，因此它渲染出来而文字以及色彩，让人眼前一量，打开两个终端就可以看到肉眼可见的差距。仿如你第一次看到苹果视网膜屏幕的惊艳。在阅读文档后，我知道它支持分屏的功能，更加让我认定它了！它渲染的细腻程度更甚于我推崇的 Tilix！尽管它的配置方式（通过配置文件）让我觉得麻烦，但是我还是愿意花更多时间去阅读文档研究它，设置好了配色方案、分屏对应的快捷键等等。欣喜地在接下来几天都在使用它。</p>
<h2 id="放弃的原因-2"><a href="#放弃的原因-2" class="headerlink" title="放弃的原因"></a>放弃的原因</h2><p>Kitty 默认不支持 Fctix，我无法在 Kitty 中切换输入法，中文无法输入！我本以为这只是个不难解决问题。但经历一天的煎熬之下，我依然无法解决这个问题。</p>
<p>在看到 <a href="https://github.com/kovidgoyal/kitty/issues/469"> kitten for IME input #469 </a> 后得知 Kitty 天然对 IME 是不友好的。Kitty 的作者  kovidgoyal 明言，为了输入速度和优化，已经默认关闭 IME 的支持！</p>
<p>在 issue 中你可以看到一些人通过设置环境变量（<code>GLFW_IM_MODULE=ibus</code>）解决了，但也有同样操作而无效的人，这无疑是相当于开盲盒。像个美丽而脆弱的工艺品，只能说 Kitty 不适合 IME 的用户，不适合中文开发者。</p>
<p>抛开 Kitty 细腻的渲染不谈，它也是有一些让我不喜欢的点：</p>
<ol>
<li><p>窗口分割，虽然支持，但是仅能在子窗口中进行分割；</p>
</li>
<li><p>配置方式，仅仅支持通过配置文件配置，无图形界面，主要它的默认功能也没满足我需求；</p>
</li>
<li><p>无右键菜单；</p>
</li>
</ol>
<p>虽然 Kitty 漂亮，但得承认它是个需要折腾，并且不容易折腾的工具！</p>
<h1 id="Tilix"><a href="#Tilix" class="headerlink" title="Tilix"></a>Tilix</h1><p><img src="2023-10-15_11-07.png" alt="Tilix"></p>
<h2 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h2><p>Tilix 是一个功能强大的终端模拟器，旨在提供先进的功能和用户友好的界面。它是为 GNOME 桌面环境设计的，但也可以在其他桌面环境中使用。</p>
<p>Tilix 具有多标签页和分屏显示功能，允许用户在一个窗口中同时打开和管理多个终端会话。这使得在同一界面中同时进行多个任务变得更加方便。用户可以自定义标签页和窗格的布局、大小和外观，以适应个人工作流程和偏好。</p>
<p>Tilix 还支持配置文件和会话管理功能，允许用户保存和加载特定的终端会话设置。这对于经常需要在不同项目或工作环境之间切换的用户来说非常有用。</p>
<p>除了基本的终端功能外，Tilix 提供了许多其他实用的特性。它支持拆分窗格、滚动回放和自动隐藏等功能，使用户能够更灵活地管理和浏览终端输出。Tilix 还支持自定义命令、快捷键和配色方案，以满足用户的个性化需求。</p>
<p>Tilix 还具有一些高级功能，如书签、自动完成、透明度调节和跨平台支持等。它还支持标签页间的拖放操作，方便用户在不同标签页之间移动终端会话。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install tilix -y</span><br></pre></td></tr></table></figure>

<h2 id="为什么选择了-Tilix"><a href="#为什么选择了-Tilix" class="headerlink" title="为什么选择了 Tilix"></a>为什么选择了 Tilix</h2><p>正如文章的标题，一切都是刚刚好，它准确戳中了我的 G 点上。分屏、配置都不用花费什么功夫即可达到我期望的模样！</p>
<h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><p><img src="Peek_2023-10-15_15-10.gif"></p>
<p>Tilix 原生支持分屏功能。各个分屏窗口相互独立，不会相互影响，至少目前没有发现类似 tmux 旧版的“选中内容跨窗口”的现象。</p>
<ul>
<li><p><strong>调用分屏功能</strong>：调用分屏功能使用简单方便。在顶部 menu 栏左边分别包含“水平左右分屏”和“竖直上下分屏”按钮。另外，在内容区域内，使用鼠标右键激活的菜单中同上包含上面 2 个分屏选项。</p>
</li>
<li><p><strong>调节分屏窗口大小</strong>：各个分屏窗口的分割线支持使用鼠标进行拖动以调节分屏窗口的大小。</p>
</li>
<li><p><strong>分屏位置</strong>：不像 Kitty 那样只能在子窗口中分割，Tilix 支持基于任意窗口中进行上下、左右分割。</p>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Tilix 支持可以可视化配置，基本功能的配置都可以通过此方式配置，只需要右击右上菜单按钮的 <code>preferences</code> 即可进入设置面板！。是不想折腾人的福音，如我，并不打算花大量的时间在配置、调节上。这样做对于我来说是本末倒置。花费的时间不一定获得好的结果。退一步说，假如是好的结果。在新的环境中，我不得不继续花大量的时间配置才能获得相同的体验。</p>
<p><img src="Peek_2023-10-15_14-59.gif"></p>
<p>下面是我所关注的几个配置：</p>
<ul>
<li><p><strong>配色方案</strong>：Tilix 提供 9 个可选的配色方案选择。另外，亦可以自定义配色方案；</p>
</li>
<li><p><strong>字体设置</strong>：可视化配置 font family 和 font size；</p>
</li>
</ul>
<p>除了上面 2 个配置项外，还支持更多的。其他则交由你自己去探索了。</p>
<h3 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h3><ul>
<li>聪明的滚动条：适时地出现，不如 konsole 那样，不可设置地固定常驻，并且是丑陋的拉老旧样式；鼠标指针悬浮时有“激活”的交互效果以便更容易拖动；</li>
</ul>
<p><img src="Peek_2023-10-15_14-54.gif"></p>
<ul>
<li><p><strong>Quake 模式</strong>：Tilix 原生支持 Quake 模式，通过快捷键即可快捷弹出终端窗口；</p>
</li>
<li><p><strong>漂亮的分割线</strong>：这个只能说是我个人审美。并且提供宽、窄两种尺寸的供选择。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在与其他终端模拟器（kitty、tmux、gnome-terminal、konsole）进行比较时，Tilix 突出的优点主要体现在以下几个方面：</p>
<ol>
<li><p><strong>简单易用的配置</strong>：Tilix 提供了直观的图形界面，使得配置终端外观和行为变得简单明了。与其他终端模拟器相比，Tilix 的配置选项更易于理解和操作，无需深入了解复杂的配置文件。</p>
</li>
<li><p><strong>原生支持分屏</strong>：Tilix 内置了强大的分屏功能，允许在一个终端窗口中分割出多个面板，每个面板可以运行不同的程序或命令。这使得在一个窗口中同时进行多个操作或监视多个任务变得非常方便，而无需额外的终端复用工具。</p>
</li>
<li><p><strong>外观好看</strong>：Tilix 提供了吸引人的外观选项，可以自定义终端的颜色、字体、透明度等。此外，它还支持与桌面环境的整体外观风格保持一致的 GTK 主题集成，使得终端在视觉上更加美观、一致且个性化。</p>
</li>
</ol>
<p>相比之下：</p>
<ul>
<li><p>kitty 是一个快速、跨平台的终端模拟器，它支持 GPU 加速和高度可定制的配置。然而，Tilix 提供更简单的配置界面和原生的分屏支持，使得初学者更容易上手并使用分屏功能。</p>
</li>
<li><p>tmux 是一个功能强大的终端复用器，可以在一个终端窗口中管理多个会话和窗格。但是，Tilix 提供了直观的图形界面和对分屏的原生支持，无需额外的终端复用工具。</p>
</li>
<li><p>gnome-terminal 是 GNOME 桌面环境的默认终端模拟器，它提供基本的终端功能和配置选项。与之相比，Tilix 提供了更丰富的功能，特别是分屏和外观定制方面的选项，使得 Tilix 在多任务处理和个性化方面更具优势。</p>
</li>
<li><p>konsole 是 KDE 桌面环境的默认终端模拟器，它也提供一些高级功能和配置选项。然而，Tilix 的配置界面更加直观，同时也更好地与 GNOME 桌面环境集成，适合在 GNOME 环境下使用。</p>
</li>
</ul>
<p>综上所述，Tilix 在配置简单易用、原生支持分屏和外观美观方面表现出色。这使得 Tilix 成为一个强大且受欢迎的终端模拟器，无论是新手还是有经验的用户，都可以从 Tilix 的功能和可定制性中受益。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tilix</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>从 eslint-plugin-security 看前端安全</title>
    <url>/blog/resources/Using-eslint-plugin-security/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来，主要的研究课题是 JavaScript 代码的静态分析。在研究期间用到 Eslint 对此做实践，了解到它的一个插件，<code>eslint-plugin-security</code>。如其名，它的作用是安全相关方面的代码扫描。在看了它的配置规则后，觉得甚是有趣，不少规则都涉及到常见的前端安全的问题。故有了想法，为什么不以它为引子，来个管中窥豹。</p>
<span id="more"></span>

<p>背景：</p>
<ul>
<li><p>系统：WSL2 - Debian 12；</p>
</li>
<li><p>仓库：<a href="https://github.com/isaaxite/practices/tree/main/packages/eslint-security">isaaxite&#x2F;practices - eslint-security</a>；</p>
</li>
<li><p>包管理器：pnpm；</p>
</li>
<li><p>已安装的包：</p>
<ul>
<li>eslint <code>8.48.0</code></li>
<li>eslint-config-airbnb-base <code>15.0.0</code></li>
<li>eslint-plugin-import <code>2.28.1</code></li>
</ul>
</li>
</ul>
<h1 id="eslint-plugin-security"><a href="#eslint-plugin-security" class="headerlink" title="eslint-plugin-security"></a>eslint-plugin-security</h1><p><code>eslint-plugin-security</code> 是一个 ESLint 插件，用于检测 JavaScript 代码中的常见安全问题。</p>
<p>这里给出它的一个简要概述:</p>
<ul>
<li><p><strong>名称</strong>：eslint-plugin-security</p>
</li>
<li><p><strong>作用</strong>：通过 ESLint 规则检查 JavaScript 代码中的安全隐患</p>
</li>
<li><p><strong>检测项</strong>：</p>
<ul>
<li><p>XSS（跨站脚本）；</p>
</li>
<li><p>SQL 注入；</p>
</li>
<li><p>缓冲区溢出；</p>
</li>
<li><p>XXE；</p>
</li>
<li><p>敏感数据泄漏；</p>
</li>
<li><p>引用不安全模块；</p>
</li>
<li><p>文件操作权限；</p>
</li>
<li><p>随机数生成；</p>
</li>
<li><p>CRLF注入；</p>
</li>
<li><p>点击劫持；</p>
</li>
<li><p>暴露详细错误信息。</p>
</li>
</ul>
</li>
<li><p><strong>使用步骤</strong>：</p>
<ol>
<li><p>安装插件；</p>
</li>
<li><p>在 Eslint 配置文件中配置 <code>plugins</code> 和 <code>rules</code>；</p>
</li>
<li><p>运行ESLint扫描代码。</p>
</li>
</ol>
</li>
<li><p><strong>规则可配置</strong>：</p>
<p>可以针对不同的检测项单独开启或者关闭相关规则。</p>
</li>
<li><p><strong>输出结果</strong>：</p>
<p>标注出代码中的潜在安全问题位置和类型。</p>
</li>
<li><p><strong>目的</strong>：</p>
<p>在开发阶段早期发现安全隐患，帮助编写更安全的代码。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Order</th>
<th align="left">Name</th>
<th align="left">Description</th>
<th align="left">Rules</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-bidi-characters.md">detect-bidi-characters</a></td>
<td align="left">检测双向字符攻击,可能注入代码</td>
<td align="left"><code>security/detect-bidi-characters</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-buffer-noassert.md">detect-buffer-noassert</a></td>
<td align="left">检测Buffer使用noAssert可能导致溢出</td>
<td align="left"><code>security/detect-buffer-noassert</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-child-process.md">detect-child-process</a></td>
<td align="left">检测child_process调用是否安全</td>
<td align="left"><code>security/detect-child-process</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-disable-mustache-escape.md">detect-disable-mustache-escape</a></td>
<td align="left">检测模板引擎是否关闭转义功能</td>
<td align="left"><code>security/detect-disable-mustache-escape</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-eval-with-expression.md">detect-eval-with-expression</a></td>
<td align="left">检测eval是否使用可控参数</td>
<td align="left"><code>security/detect-eval-with-expression</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-new-buffer.md">detect-new-buffer</a></td>
<td align="left">检测Buffer构造是否使用可控参数</td>
<td align="left"><code>security/detect-new-buffer</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-no-csrf-before-method-override.md">detect-no-csrf-before-method-override</a></td>
<td align="left">检测CSRF顺序设置是否正确</td>
<td align="left"><code>security/detect-no-csrf-before-method-override</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-fs-filename.md">detect-non-literal-fs-filename</a></td>
<td align="left">检测文件操作是否使用可控文件名</td>
<td align="left"><code>security/detect-non-literal-fs-filename</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-regexp.md">detect-non-literal-regexp</a></td>
<td align="left">检测正则是否使用可控参数可能导致DOS</td>
<td align="left"><code>security/detect-non-literal-regexp</code></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-non-literal-require.md">detect-non-literal-require</a></td>
<td align="left">检测require是否使用可控参数</td>
<td align="left"><code>security/detect-non-literal-require</code></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-object-injection.md">detect-object-injection</a></td>
<td align="left">检测对象属性注入</td>
<td align="left"><code>security/detect-object-injection</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-possible-timing-attacks.md">detect-possible-timing-attacks</a></td>
<td align="left">检测时间攻击</td>
<td align="left"><code>security/detect-possible-timing-attacks</code></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-pseudoRandomBytes.md">detect-pseudoRandomBytes</a></td>
<td align="left">检测随机数是否真随机</td>
<td align="left"><code>security/detect-pseudoRandomBytes</code></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/rules/detect-unsafe-regex.md">detect-unsafe-regex</a></td>
<td align="left">检测正则表达式安全问题</td>
<td align="left"><code>security/detect-unsafe-regex</code></td>
</tr>
</tbody></table>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eslint-plugin-security 1.7.1</span></span><br><span class="line"></span><br><span class="line">pnpm add eslint-plugin-security --save-dev</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在安装 <code>eslint-plugin-security</code> 后，<code>eslint-plugin-security</code> 已经内置上面表格中的所有规则，并且设置告警等级为 <code>warn</code>。因此无需手动配置规则，除非需要修改告警等级。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">+   <span class="string">&#x27;plugin:security/recommended&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">overrides</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">files</span>: [</span><br><span class="line">        <span class="string">&#x27;.eslintrc.&#123;js,cjs&#125;&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="detect-bidi-characters"><a href="#detect-bidi-characters" class="headerlink" title="detect-bidi-characters"></a>detect-bidi-characters</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-bidi-characters&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>检测利用 unicode bidi（”bidirectional”的缩写，是指双向书写或双向格式的意思） 攻击注入恶意代码的 <a href="https://trojansource.codes/">trojan source attacks</a> 案例。</p>
<details open>
  <summary><strong>什么是 <code>trojan source attacks</code> ？</strong></summary>
  <blockquote>
    <br>
    <p>trojan source attacks 是一种利用双向书写系统中的特殊字符实现隐藏代码注入的攻击方式。</p>
    <p>具体来说:</p>
    <ul>
    <li><p>双向书写系统指阿拉伯数字和希伯来字母可以从右到左或者从左到右流畅书写的语言。</p>
    </li>
    <li><p>这些语言中的部分字符既可以作为一般字符显示,也可以用于控制书写方向。</p>
    </li>
    <li><p>攻击者会利用这些特殊字符在源代码中隐藏恶意代码段。</p>
    </li>
    <li><p>正常阅读源代码时无法发现隐藏段,但在特定环境中执行时被触发执行。</p>
    </li>
    <li><p>比如利用Unicode字符格式控制(LRE/RLE)在源码中间插入JavaScript代码。</p>
    </li>
    <li><p>当页面使用这种双向书写格式解析源码时,控制字符会触发隐藏代码执行。</p>
    </li>
    </ul>
    <p>此类攻击很难通过简单查看源代码发现,通常需要专门的检测工具分析可能存在的隐藏代码段。</p>
    <br>
  </blockquote>
</details>
<br>

<p>这里给一个利用双向书写格式控制字符隐藏注入代码的 JavaScript 示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向书写格式左到右控制码插入隐藏代码</span></span><br><span class="line">\u202a</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;被注入的代码!&#x27;</span>);</span><br><span class="line">\u202c </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当使用支持双向书写的浏览器&#x2F;环境解析此源码时,会出现如下效果：</p>
<ol>
<li><p>首先正常显示”正常源码…”日志；</p>
</li>
<li><p>然后遇到 <code>\u202a</code> 控制码,切换解释方向从右到左；</p>
</li>
<li><p>这会导致 <code>alert(&#39;被注入的代码!&#39;);</code> 这段码变成隐藏状态,在源码中不可见；</p>
</li>
<li><p>再遇到 <code>\u202c</code> 控制码后切换回正常左到右方向；</p>
</li>
<li><p>最后再正常显示尾部”正常源码…”日志。</p>
</li>
</ol>
<p>而普通浏览器直接查看源码只会看到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正常源码...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>中间隐藏的 <code>alert</code> 调用无法见到，从而实现了代码注入的攻击目的。</p>
<details open>
  <summary><strong><code>\u202a</code> 和 <code>\u202c</code> 这两个控制码的作用是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p><code>\u202a</code> 和 <code>\u202c</code> 是 <code>Unicode</code> 的双向格式控制字符。</p>
    <p>它们的作用是控制文本书写的方向：</p>
    <ul>
    <li><p><code>\u202a</code> 是 <code>Unicode</code> 左到右标记(LRE)。它可以切换当前文本流的书写方向为从右到左；</p>
    </li>
    <li><p><code>\u202c</code> 是 <code>Unicode</code> 弹性冲突终止(PDF)。它可以把当前文本流的书写方向切换回正常的左到右。</p>
    </li>
    </ul>
    <p>这两个控制字符常被用在支持双向书写的语言环境中，以控制阿拉伯数字和希伯来字母等文本的流向。</p>
    <p>在 trojan source attacks 中，攻击者会利用它们来隐藏代码注入：</p>
    <ul>
    <li><p>使用 <code>\u202a</code> 指令切换流向右到左；</p>
    </li>
    <li><p>在这段流中插入要隐藏的代码，因为流向右到左，代码就会处于隐藏状态；</p>
    </li>
    <li><p>再使用 <code>\u202c</code> 指令切换流向回正常左到右。</p>
    </li>
    </ul>
    <p>这样一来，正常查看源代码就看不见被隐藏的代码段了。但在支持双向的运行环境中，隐藏代码依然会被执行。</p>
    <p>所以说,<code>\u202a</code> 和 <code>\u202c</code> 具有控制文本显示方向的关键作用，能很好地实现源代码层面的&quot;隐写术&quot;攻击手法。</p>
    <br>
  </blockquote>
</details>
<br>

<p>除了上面 2 个 Unicode 的双向格式控制字符外，还有其他的。以下是相关 Unicode 双向格式字符的表格及描述：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">缩写</th>
<th align="left">Unicode字符</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">LRE</td>
<td align="left">U+202A</td>
<td align="left">左到右嵌入</td>
<td align="left">将以下文本处理为从左到右</td>
</tr>
<tr>
<td>2</td>
<td align="left">RLE</td>
<td align="left">U+202B</td>
<td align="left">右到左嵌入</td>
<td align="left">将以下文本处理为从右到左</td>
</tr>
<tr>
<td>3</td>
<td align="left">LRO</td>
<td align="left">U+202D</td>
<td align="left">左到右重写</td>
<td align="left">强制将以下文本作为从左到右处理</td>
</tr>
<tr>
<td>4</td>
<td align="left">RLO</td>
<td align="left">U+202E</td>
<td align="left">右到左重写</td>
<td align="left">强制将以下文本作为从右到左处理</td>
</tr>
<tr>
<td>5</td>
<td align="left">LRI</td>
<td align="left">U+2066</td>
<td align="left">左到右隔离</td>
<td align="left">将以下文本作为从左到右处理,不影响相邻文本</td>
</tr>
<tr>
<td>6</td>
<td align="left">RLI</td>
<td align="left">U+2067</td>
<td align="left">右到左隔离</td>
<td align="left">将以下文本作为从右到左处理,不影响相邻文本</td>
</tr>
<tr>
<td>7</td>
<td align="left">FSI</td>
<td align="left">U+2068</td>
<td align="left">首个强隔离</td>
<td align="left">根据接下来的字符强制处理以下文本的方向</td>
</tr>
<tr>
<td>8</td>
<td align="left">PDF</td>
<td align="left">U+202C</td>
<td align="left">弹出方向格式</td>
<td align="left">终止最近的 LRE、RLE、LRO 或 RLO</td>
</tr>
<tr>
<td>9</td>
<td align="left">PDI</td>
<td align="left">U+2069</td>
<td align="left">弹出方向隔离</td>
<td align="left">终止最近的 LRI 或 RLI</td>
</tr>
</tbody></table>
<p>trojan source attacks 属于源代码层面的攻击，需要攻击者能获取和修改受保护源代码，一般来说这需要内部人员参与恶意行为才行。</p>
<p>更具体地说:</p>
<ul>
<li><p>如果源代码完全开源，任何人都可以下载和修改，那么外部人也可能进行这种攻击；</p>
</li>
<li><p>但如果源代码受到良好控制和管理，只有内部开发和维护人员可以访问和提交代码，那么进行 trojan 源代码改动的就很可能是内部人员之一；</p>
</li>
<li><p>除非通过其他漏洞获得源代码写入权限，否则外部人很难直接进行源代码层面改动；</p>
</li>
<li><p>所以大多数情况下，这种攻击更可能源自内部人员的恶意行为，如内鬼、骇客入侵内部系统等。</p>
</li>
</ul>
<p>所以总之，trojan source attacks 强调源代码方面的改动，这更需要内部人员的参与进行，而不太可能是外部直接攻击。这也是它与其他类型攻击的一个区别。</p>
<h1 id="detect-buffer-noassert"><a href="#detect-buffer-noassert" class="headerlink" title="detect-buffer-noassert"></a>detect-buffer-noassert</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-buffer-noassert&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用于检测代码中没有做边界检查直接调用 buffer 的情况，这可能会导致缓冲区溢出漏洞。<code>noAssert</code> 标志禁用了边界检查，所以使用这个标志调用 buffer 是危险的做法。</p>
<p>主要的检测逻辑是：</p>
<ol>
<li><p>检测对 <code>buffer()</code> 的调用；</p>
</li>
<li><p>检查调用是否设置了 <code>noAssert</code> 标志；</p>
</li>
<li><p>如果同时满足以上两点，则报告警告</p>
</li>
</ol>
<p>这可以帮助开发者发现危险的 buffer 调用，进行修改以避免引入安全漏洞。总体来说,这个规则通过静态分析提高了代码安全性,防止缓冲区溢出等问题的产生。</p>
<p>下面是一个使用 <code>noAssert</code> 标志调用 <code>buffer()</code> 的错误示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">buf.<span class="title function_">write</span>(<span class="string">&#x27;some data&#x27;</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="string">&#x27;ascii&#x27;</span>, noAssert);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line">buf.<span class="title function_">write</span>(<span class="string">&#x27;some data&#x27;</span>, <span class="number">0</span>, buf.<span class="property">length</span>, <span class="string">&#x27;ascii&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>write()</code> 方法可能会向 buf 缓冲区写入超过其长度的数据，因为传入的长度参数为 120，大于 buf 的长度 100。而且使用了 <code>noAssert</code> 标志来禁用长度检查。</p>
<p>这就可能导致缓冲区溢出，造成内存污染、崩溃或安全漏洞。</p>
<p><code>security/detect-buffer-noassert</code> 规则会捕获像这样危险的 <code>noAssert</code> 调用，从而帮助发现并修复类似的问题。</p>
<h1 id="detect-child-process"><a href="#detect-child-process" class="headerlink" title="detect-child-process"></a>detect-child-process</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-child-process&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这条规则用来检测代码中是否存在潜在的子进程命令注入漏洞。</p>
<p>子进程模块 <code>child_process</code> 可以用来生成子进程，如果拼接用户输入到子进程命令中，可能会导致 <em>命令注入攻击</em>。</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> userInput = process.<span class="property">argv</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br></pre></td></tr></table></figure>

<p>如果用户输入包含特殊字符，可能会造成命令注入。</p>
<p>detect-child-process 规则会检查代码中是否：</p>
<ol>
<li><p>使用了 child_process 模块；</p>
</li>
<li><p>构造子进程命令时，拼接了用户可控变量。</p>
</li>
</ol>
<p>如果同时满足上述条件，则会报告高优先级警告,提示这里存在潜在的命令注入风险。</p>
<p><strong>如果实在需要拼接用户的输入，可以参考以下常见的安全措施：</strong></p>
<ol>
<li><p>使用白名单过滤用户输入，只允许安全的字符，过滤掉特殊字符；</p>
</li>
<li><p>对用户输入进行转义，防止特殊字符被解析为命令语法；</p>
</li>
<li><p>使用参数数组传入用户输入，而不是直接拼接字符串；</p>
</li>
<li><p>设置子进程的用户权限，限制它可以执行的命令；</p>
</li>
<li><p>使用沙箱机制限制子进程访问系统资源；</p>
</li>
<li><p>不直接使用用户输入，而是根据白名单映射为内部命令；</p>
</li>
<li><p>监控子进程的执行情况，设置超时时间，防止阻塞；</p>
</li>
<li><p>如果可能，避免直接使用用户输入，使用预定义的命令集合；</p>
</li>
<li><p>其他输入验证和输出编码等手段。</p>
</li>
</ol>
<p>在确认已经确认采取防范措施，可以使用内联的规则忽略方式去掉警告，如下：</p>
<ol>
<li><p>单行注释</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line security/detect-child-process</span></span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围注释</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safeExec</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* eslint-disable security/detect-child-process */</span></span><br><span class="line"></span><br><span class="line">  cp.<span class="title function_">exec</span>(<span class="string">&#x27;ping &#x27;</span> + userInput);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* eslint-enable security/detect-child-process */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<details open>
  <summary><strong>命令注入攻击是什么？</strong></summary>
  <blockquote>
    <br>
    <p>命令注入攻击（Command Injection）是一种常见的代码注入攻击，其方法是将操作系统命令通过利用程序漏洞注入到执行环境中。</p>
    <p>攻击场景通常是：</p>
    <ul>
    <li><p>应用程序将用户输入当作命令参数执行；</p>
    </li>
    <li><p>但没有对用户输入进行足够验证和过滤；</p>
    </li>
    <li><p>攻击者通过特殊字符注入额外的命令。</p>
    </li>
    </ul>
    <p>例如在未过滤用户输入的情况下执行：</p>
    <pre><code class="lang-js"><span class="hljs-function"><span class="hljs-title">runProgram</span><span class="hljs-params">(‘ls ‘ + userInput)</span></span>
    </code></pre>
    <p>攻击者可以通过 <code>userInput</code> 注入额外命令：</p>
    <pre><code class="lang-js"><span class="hljs-attribute">userInput</span> = ‘-la<span class="hljs-comment">; rm *’</span>
    </code></pre>
    <p>从而读取目录内容并删除文件。</p>
    <p>防范命令注入需要：</p>
    <ul>
    <li><p>对用户所有输入进行校验过滤，移除特殊字符；</p>
    </li>
    <li><p>使用参数化接口避免直接拼接命令字符串；</p>
    </li>
    <li><p>为子进程设置最少特权原则；</p>
    </li>
    <li><p>采用沙箱机制限制子进程权限。</p>
    </li>
    </ul>
    <p>命令注入是常见且危险的攻击方式，开发人员必须警惕。</p>
    <p>更多信息可参考：<a href="https://owasp.org/www-community/attacks/Command_Injection">OWASP - Command Injection</a></p>
    <br>
  </blockquote> 
</details>
<br>

<h1 id="detect-disable-mustache-escape"><a href="#detect-disable-mustache-escape" class="headerlink" title="detect-disable-mustache-escape"></a>detect-disable-mustache-escape</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-disable-mustache-escape&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>它用于检测是否在使用 <a href="http://mustache.github.io/">Mustache 模板引擎</a> 时关闭了 HTML 转义，这可能会导致 <em>XSS 漏洞</em>。</p>
<p>这个规则的主要逻辑是：</p>
<ol>
<li><p>检查代码中是否使用了 <a href="http://mustache.github.io/">Mustache 模板引擎</a>；</p>
</li>
<li><p>检查 <code>Mustache</code> 的调用是否通过 <code>disableEscape</code> 选项关闭了 HTML 转义；</p>
</li>
<li><p>如果同时满足上述两个条件，则会报告警告；</p>
</li>
</ol>
<p>示例危险代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Mustache</span> = <span class="built_in">require</span>(<span class="string">&#x27;mustache&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">text</span>: <span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用转义,导致 XSS 漏洞</span></span><br><span class="line"><span class="title class_">Mustache</span>.<span class="title function_">render</span>(<span class="string">&#x27;&lt;p&gt;&#123;&#123;&#123;text&#125;&#125;&#125;&lt;/p&gt;&#x27;</span>, data); </span><br></pre></td></tr></table></figure>

<p>关闭转义后，用户输入的数据就可能包含恶意代码而没有被过滤。</p>
<p>这个规则可以帮助开发者识别 Mustache 模板中关闭转义的危险用法，修正为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Mustache</span>.<span class="title function_">render</span>(<span class="string">&#x27;&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt;&#x27;</span>, data);</span><br></pre></td></tr></table></figure>

<details open>
  <summary><strong>XSS 是什么？</strong></summary>
  <blockquote>
    <br>
    <p>XSS（Cross-Site Scripting，跨站脚本）攻击是一种代码注入攻击，它允许攻击者将恶意脚本注入到易受攻击的 Web 应用程序中。</p>
    <p>简单来说，XSS 攻击的过程是：</p>
    <ol>
    <li><p>攻击者构造出特殊的恶意代码（通常是 JavaScript）。</p>
    </li>
    <li><p>恶意代码被提交到易受攻击的网站，并保存在服务器端（比如用户提交表单，注入恶意 JavaScript 代码）。</p>
    </li>
    <li><p>网站将未过滤的恶意代码发送给其他用户（比如在结果页面直接输出用户输入的内容）。</p>
    </li>
    <li><p>其他用户的浏览器执行了这段恶意 JavaScript 代码，导致账号被盗用、页面被篡改等后果。</p>
    </li>
    </ol>
    <p>XSS 因此可以让攻击者得到目标用户的敏感信息，篡改页面内容，以受害者的身份执行操作等。</p>
    <p>防范 XSS 需要对用户输入进行校验和输出编码，避免直接暴露给浏览器，即输入验证和输出编码。现在也有许多静态扫描工具可以检测 XSS 漏洞。</p>
    <p>关于更多 XSS 的内容可参考：<a href="https://owasp.org/www-community/attacks/xss/">Cross Site Scripting (XSS)</a></p>
    <br>
  </blockquote> 
</details>
<br>

<details open>
  <summary><strong>Mustache 模板引擎是什么？</strong></summary>
  <blockquote>
    <br>
    <p>Mustache 是一种流行的 JavaScript 模板引擎，它可以用来根据视图模板和数据渲染 HTML。</p>
    <p>Mustache 的一些关键特点包括：</p>
    <ul>
    <li><p>语法简单，双大括号表示变量插入点。如：<code>Hello &#123;&#123;name&#125;&#125;</code>；</p>
    </li>
    <li><p>不需要预编译，在客户端实时渲染模板；</p>
    </li>
    <li><p>支持主流前端框架，可以配合 React、Vue 等使用；</p>
    </li>
    <li><p>默认进行 HTML 转义，防止 XSS 攻击；</p>
    </li>
    <li><p>支持自定义语法扩展；</p>
    </li>
    <li><p>无依赖，体积小。</p>
    </li>
    </ul>
    <p>Mustache 的用法示例:</p>
    <pre>
<code class="lang-js"><span class="hljs-comment">// 定义模板 </span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">template</span> = <span class="hljs-string">"Hello &#123;&#123;name&#125;&#125;"</span>; 
<span class="hljs-comment">// 渲染函数</span>
<span class="hljs-keyword">const</span> render = Mustache.render(<span class="hljs-keyword">template</span>, &#123;name: <span class="hljs-string">"Jack"</span>&#125;);
<span class="hljs-comment">// 得到渲染结果</span>
render; <span class="hljs-comment">// "Hello Jack"</span>
</code></pre>
    <p>必须注意的是，在使用 Mustache 时不要关闭 HTML 转义选项，否则可能会导致XSS漏洞。建议配合 ESLint 的 <code>detect-disable-mustache-escape</code> 规则进行静态检查。</p>
    <p>总体上，Mustache是一个轻量简单的模板引擎，可以快速实现数据渲染，但需要注意安全性。</p>
    <p>保持默认的转义打开，然后再根据需要通过白名单等手段过滤用户输入数据，从而避免 XSS 漏洞。</p>
    <br>
  </blockquote>
</details>
<br>

<p>目前常见的前端框架大多<strong>基于或可以集成</strong> Mustache 模板引擎，比如：</p>
<ul>
<li><p>React - 可以通过 react-mustache 这个库集成 Mustache；</p>
</li>
<li><p>Vue - 可以通过 vue-mustache 这个库集成 Mustache；</p>
</li>
<li><p>Angular - 可以通过 ngx-mustache 库集成；</p>
</li>
<li><p>Ember - Ember 内置对 Mustache 的支持；</p>
</li>
<li><p>Backbone - Backbone 推荐的模板引擎就是 Mustache；</p>
</li>
<li><p>Meteor - Meteor 提供了空间风格(Spacebars)模板，语法与 Mustache 类似；</p>
</li>
<li><p>Node.js - 可以通过 mustache 模块在后端使用；</p>
</li>
<li><p>Vanilla JS - 直接通过嵌入式 JS 或从 CDN 引入 Mustache。</p>
</li>
</ul>
<p>支持多种语言，其中 JavaScript 由 <a href="https://github.com/janl/mustache.js">mustache.js</a> 支持。</p>
<h1 id="detect-eval-with-expression"><a href="#detect-eval-with-expression" class="headerlink" title="detect-eval-with-expression"></a>detect-eval-with-expression</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-eval-with-expression&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>检测代码中调用 <code>eval()</code> 时是否传入了表达式，这可能会导致代码注入漏洞。</p>
<p>这个规则的主要逻辑是：</p>
<ol>
<li><p>检查代码中是否调用了 <code>eval()</code> 函数；</p>
</li>
<li><p>检查 <code>eval()</code> 调用时的参数是否是一个表达式，而不是 <code>String</code> 类型的代码文本；</p>
</li>
<li><p>如果同时满足上述两个条件，则会报告高级别的警告。</p>
</li>
</ol>
<p>因为直接传入表达式给 <code>eval</code> 可能会执行用户可控制的代码。示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;&#123;&quot;foo&quot;: 1&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">eval</span>(userInput); </span><br></pre></td></tr></table></figure>

<p>这里用户可以输入任意 JavaScript 表达式。</p>
<p>建议的更安全写法是:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;&#123;&quot;foo&quot;: 1&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span> + userInput + <span class="string">&#x27;)&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>把输入包装为字符串，限制为表达式形式。</p>
<p>这个规则通过静态分析帮助发现可能的 <code>eval</code> 注入漏洞，提高代码的安全性。但如果输入来源可信，或者有其他安全保障措施，也可以通过配置忽略该规则。</p>
<p>更多关于 <code>eval</code> 可能引起的问题可参考：<a href="http://security.stackexchange.com/questions/94017/what-are-the-security-issues-with-eval-in-javascript">What are the security issues with eval in JavaScript?</a></p>
<h1 id="detect-new-buffer"><a href="#detect-new-buffer" class="headerlink" title="detect-new-buffer"></a>detect-new-buffer</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-new-buffer&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用于检测代码直接通过 <code>new Buffer()</code> 创建 Buffer 的情况,推荐使用 <code>Buffer.from()</code> 来替代。</p>
<p>主要原因是:</p>
<ol>
<li><p><code>new Buffer()</code> 已被 Node.js 废弃（v6.0.0开始，v15.0.0完全废弃），可能会导致应用出现警告；</p>
</li>
<li><p><code>new Buffer()</code> 在处理参数时有一定风险；比如：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">Buffer</span>(userInput);</span><br></pre></td></tr></table></figure>

<p> 如果 <code>userInput</code> 是数字，可能会分配非常大的内存空间， 造成 <em>DoS 攻击</em>。</p>
</li>
<li><p><code>Buffer.from()</code> 在处理参数时更安全可靠。</p>
</li>
</ol>
<p>所以该规则会对 <code>new Buffer()</code> 的使用报出警告，推荐更安全的 <code>Buffer.from()</code>，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果业务需要兼容旧版本 Node.js，可以通过注释或配置的方式忽略此规则，但需要注意风险。</p>
<p>总之该规则推荐使用新的 Buffer API 来避免潜在问题，提升代码质量和安全性。</p>
<details open>
  <summary><strong>DoS 攻击是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>DoS（Denial of Service，拒绝服务）攻击是一种使目标失去提供正常服务能力的攻击。常见的 DoS 攻击有：</p>
    <ol>
    <li><p>带宽攻击：通过大量流量淹没目标，消耗网络带宽。比如 UDP flood，ICMP flood 等；</p>
    </li>
    <li><p>资源攻击：消耗关键系统资源如 CPU、内存等。比如 fork bomb；</p>
    </li>
    <li><p>协议攻击：利用网络协议漏洞进行攻击。比如 SYN flood 利用 TCP 三次握手漏洞；</p>
    </li>
    <li><p>应用层攻击：针对应用程序漏洞进行攻击。比如 HTTP flood；</p>
    </li>
    <li><p>分布式 DoS：使用多台攻击源同时进行攻击。</p>
    </li>
    </ol>
    <p>DoS 攻击的目的是使服务暂时不可用。与 DoS 类似但有差别的是 DDoS 攻击，它利用了大量的分布式节点参与攻击，造成更大的威胁。 </p>
    <p>预防 DoS 攻击需要从网络架构、系统资源、应用程序等不同层面进行保护，比如使用过滤、限速、负载均衡、堆栈随机化等技术。</p>
    <br>
  </blockquote>
</details>
<br>

<h1 id="detect-no-csrf-before-method-override"><a href="#detect-no-csrf-before-method-override" class="headerlink" title="detect-no-csrf-before-method-override"></a>detect-no-csrf-before-method-override</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-no-csrf-before-method-override&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用于检测 Node.js <strong>Express</strong> 应用中是否在 <a href="https://github.com/expressjs/method-override">method-override</a> 中间件之前使用了 csrf 中间件。</p>
<p>在 Express 应用中，<a href="https://github.com/expressjs/method-override">method-override</a> 中间件允许通过查询参数或者请求体改变 HTTP 请求方法。</p>
<p><strong>如果在 method override 之前没有 csrf 保护，那么攻击者可以通过构造查询参数轻易地绕过 csrf 防护，以 POST 的权限调用敏感的 GET 操作。</strong></p>
<p>例如，正常的 csrf 校验路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">csrf</span>()) <span class="comment">// csrf中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">methodOverride</span>()) <span class="comment">// 方法重写中间件</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/transfer&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 转账逻辑</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>攻击者可以直接构造查询参数执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/transfer?_method=<span class="variable constant_">POST</span></span><br></pre></td></tr></table></figure>

<p>绕过 csrf 防护，以 POST 权限调用转账接口。</p>
<p>所以该规则会检测 <a href="https://github.com/expressjs/method-override">method-override</a> 是否在 csrf 之前，以发现这个潜在的问题。解决方式是确保 csrf 中间件在 <a href="https://github.com/expressjs/method-override">method-override</a> 之前。</p>
<p>detect-no-csrf-before-method-override 规则不仅可以检测 Express 的中间件使用顺序，也可以检测其他框架中的类似用法。</p>
<p>该规则的基本检测逻辑是：</p>
<ol>
<li><p>检测是否使用了方法覆盖（method override）功能；</p>
</li>
<li><p>检测方法覆盖是否在 CSRF 防护之前。</p>
</li>
</ol>
<p>只要代码中具有这种“方法覆盖先于 CSRF 防护”的结构，该规则都能检测出来。</p>
<p>除了 Express 路由之外，它也能够检测：</p>
<ul>
<li><a href="https://fastify.dev/">Fastify ↗</a> 中类似的中间件使用顺序；</li>
<li><a href="https://koajs.com/">Koa ↗</a> 中间件注册顺序；</li>
<li><a href="https://nestjs.com/">NestJS ↗</a> 中间件顺序；</li>
<li>其他类框架的中间件&#x2F;拦截器顺序。</li>
</ul>
<p>只要框架提供了方法覆盖和 CSRF 防护机制，并可能存在方法覆盖先于 CSRF 校验的情况，该规则就可以起到检测作用。</p>
<p>所以更准确地说，这条规则是框架无关的，只要保证方法覆盖不会绕过 CSRF 即可。</p>
<details open>
  <summary><strong>CSRF 是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络攻击，它冒充受信任用户的身份，在目标网站上执行未授权的命令。</p>
    <p>CSRF攻击的过程通常如下：</p>
    <ol>
    <li><p>用户登录受信任网站 A，并在本地生成了 cookie；</p>
    </li>
    <li><p>用户打开另一个网站 B，网站 B 包含了点击链接、提交表单等向网站 A 发起请求的操作；</p>
    </li>
    <li><p>用户被诱导在网站 B 上触发了操作，同时利用用户本地的 cookie，在网站A中完成了未授权的动作。</p>
    </li>
    </ol>
    <p>例如：</p>
    <p>网站 B 包含了向网站 A 转账的表单，利用用户本地 cookie 可以完成转账动作。</p>
    <p>常见的CSRF防御手段有：</p>
    <ul>
    <li><p>检查 HTTP Referer，拒绝外域请求；</p>
    </li>
    <li><p>在请求中设置 token，并验证 token 是否合法；</p>
    </li>
    <li><p>在提交敏感请求时重新验证用户身份；</p>
    </li>
    <li><p>GET 请求不对数据进行修改；</p>
    </li>
    <li><p>关键操作使用 POST 请求，并进行 token 验证。</p>
    </li>
    </ul>
    <p>CSRF 攻击依赖于用户认证状态，可以进行敏感操作篡改或数据窃取。正确的防范手段可以有效防止 CSRF 攻击。</p>
    <br>
  </blockquote>
</details>
<br>

<h1 id="detect-non-literal-fs-filename"><a href="#detect-non-literal-fs-filename" class="headerlink" title="detect-non-literal-fs-filename"></a>detect-non-literal-fs-filename</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-fs-filename&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用于检测代码中是否向 fs 模块的文件操作方法传入了非字面量的文件名参数。</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> filename = <span class="title function_">getFilenameFromUser</span>(); </span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(filename, ...);</span><br></pre></td></tr></table></figure>

<p>传入可以由用户控制的 filename 变量是危险的，可能会导致 <em>路径遍历（<a href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a>） 攻击</em> 。</p>
<p>攻击者可以通过 <code>../</code> 构造文件名，访问任意文件。</p>
<p>所以该规则会检测以下情况：</p>
<ol>
<li><p>调用了 fs 模块的文件操作函数（readFile 等）；</p>
</li>
<li><p>文件名参数不是字符串字面量，可能是变量或表达式计算；</p>
</li>
</ol>
<p>一旦满足上述条件，就会报出警告。</p>
<p>建议的更安全写法是使用字面量文件名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./somefile.txt&#x27;</span>, ...); </span><br></pre></td></tr></table></figure>

<p>或者进行文件名校验：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">validateFilename</span>(filename);</span><br><span class="line">fs.<span class="title function_">readFile</span>(filename, ...);</span><br></pre></td></tr></table></figure>

<p>该规则通过静态分析帮助发现路径遍历问题，提升了代码安全性。</p>
<details open>
  <summary><strong>路径遍历（Path Traversal）攻击是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>路径遍历（Path Traversal）漏洞允许攻击者通过操纵目标文件的路径字符串访问超出预定范围的文件系统区域。</p>
    <p>常见的攻击手法包括：</p>
    <ul>
    <li><p>使用 <code>../</code> 绕过文件系统限制，访问任意文件；</p>
    </li>
    <li><p>利用可替换组件如用户名访问其他文件名；</p>
    </li>
    <li><p>乱码等绕过过滤。</p>
    </li>
    </ul>
    <p>该漏洞常见于将用户输入直接用于文件读取的函数，例如 <code>fs.readFile()</code>。</p>
    <p>影响范围从信息泄露到远程代码执行不等。</p>
    <p>防范措施：</p>
    <ul>
    <li><p>对用户输入进行校验，过滤特殊字符；</p>
    </li>
    <li><p>使用白名单验证文件名；</p>
    </li>
    <li><p>Restrict file system access；</p>
    </li>
    <li><p>使用不包含用户输入的随机文件名；</p>
    </li>
    <li><p>对路径组件进行标准化处理；</p>
    </li>
    <li><p>CDN 或存储服务器的访问控制；</p>
    </li>
    <li><p>其他输入验证方式。</p>
    </li>
    </ul>
    <p>开发人员应该意识到这样的风险，在代码中采取防范措施，避免导致路径遍历漏洞。</p>
    <br>
  </blockquote>
</details>
<br>


<h1 id="detect-non-literal-regexp"><a href="#detect-non-literal-regexp" class="headerlink" title="detect-non-literal-regexp"></a>detect-non-literal-regexp</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-regexp&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用于检测代码中是否构造正则表达式时使用了非字面量的参数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(userInput);</span><br></pre></td></tr></table></figure>

<p>如果用户输入是正则特殊字符，可能会导致 <em>ReDoS（正则拒绝服务）</em> 攻击。</p>
<p>攻击者可以构造谐音回退、组合重复等看似合法的正则，但处理非常缓慢。这可能占用大量 CPU 资源，成为 DoS 攻击。</p>
<p>所以该规则会检测以下情况：</p>
<ol>
<li>构造了正则表达式；</li>
<li>参数不是字符串字面量。</li>
</ol>
<p>建议的更安全写法是使用字面量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure>

<p>如果必须使用变量，也需要先对其进行过滤，移除危险的正则特殊字符。</p>
<p>该规则通过静态分析帮助发现潜在的 ReDoS 问题，提升了代码安全性。但如果有其他防范手段，也可以通过配置忽略该规则。</p>
<details open>
  <summary><strong>ReDoS（正则拒绝服务）攻击是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>ReDoS（Regular expression Denial of Service）即正则拒绝服务攻击，是一种对目标应用程序正则表达式引擎进行的拒绝服务攻击。</p>
    <p>攻击方式是构造非常复杂的正则表达式，这些正则语法上合法，但是处理会非常缓慢。这样就可以让目标服务器 cpu 耗尽，无法响应正常请求。</p>
    <p>例如：</p>
    <ul>
    <li><p>重复高次方数：<code>/(a+)+/</code>；</p>
    </li>
    <li><p>谐音回退：<code>/([a-z]+)*/</code>；</p>
    </li>
    </ul>
    <p>防范 ReDoS 攻击的方法：</p>
    <ul>
    <li><p>使用简单正则，避免递归、重复、回溯等高危结构；</p>
    </li>
    <li><p>对用户输入正则进行过滤和限制；</p>
    </li>
    <li><p>设置正则处理超时；</p>
    </li>
    <li><p>使用安全的正则引擎，如 Rust 的 Regex；</p>
    </li>
    <li><p>限制正则复杂度，如匹配长度、分支数等</p>
    </li>
    <li><p>提高应用异步容错能力，避免全局阻塞。</p>
    </li>
    </ul>
    <p>开发者需要谨慎处理用户提供的正则表达式，识别 ReDoS 攻击模式，采取防御措施。</p>
    <p>更多关于 ReDoS 的信息可参考：<a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">Regular expression Denial of Service - ReDoS</a></p>
    <br>
  </blockquote>
</details>
<br>


<h1 id="detect-non-literal-require"><a href="#detect-non-literal-require" class="headerlink" title="detect-non-literal-require"></a>detect-non-literal-require</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-non-literal-require&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用于检测代码中是否使用非字面量的参数调用了 <code>require()</code> 函数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleName = <span class="title function_">getModuleName</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(moduleName); </span><br></pre></td></tr></table></figure>

<p>allow 攻击者通过 <code>moduleName</code> 变量控制引入的模块。</p>
<p>攻击者可能利用这个漏洞执行任意代码。</p>
<p>所以该规则会检测以下情况：</p>
<ol>
<li><p>调用了 <code>require()</code> 函数；</p>
</li>
<li><p>参数不是字符串字面量。</p>
</li>
</ol>
<p>一旦同时满足上述条件，就会报出警告。</p>
<p>建议的更安全写法是使用字面量模块路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./modules/module&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>或者事先校验模块名称：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">validateModuleName</span>(moduleName); </span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(moduleName);</span><br></pre></td></tr></table></figure>

<p>该规则通过静态分析帮助发现非字面量 <code>require</code> 的风险，提升了代码安全性。</p>
<details open>
  <summary><strong>allow 攻击是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>allow 攻击（Arbitrary Code Execution）是一种通过植入恶意代码并执行来进行的攻击方式。</p>
    <p>常见的 allow 攻击形式包括：</p>
    <ul>
    <li><p>代码/命令注入（Code/Command Injection）：通过注入漏洞向应用传入恶意代码并执行；</p>
    </li>
    <li><p>目录遍历/文件包含（Path Traversal/File Include）：访问恶意文件并作为代码运行；</p>
    </li>
    <li><p>不安全的反序列化（Unsafe Deserialization）：通过反序列化运行恶意构造的对象；</p>
    </li>
    <li><p>权限提升（Privilege Escalation）：利用漏洞提权，执行未授权的代码；</p>
    </li>
    <li><p>库/依赖注入（Dependency Injection）：通过依赖关系执行恶意代码；</p>
    </li>
    <li><p>服务器端请求伪造（SSRF）：利用内网请求漏洞执行任意代码；</p>
    </li>
    <li><p>诱导用户运行附件/程序（User Execution）：诱使用户自行运行恶意程序。</p>
    </li>
    </ul>
    <p>防范allow攻击的方法包括：</p>
    <ul>
    <li><p>输入验证和输出编码；</p>
    </li>
    <li><p>最少特权原则；</p>
    </li>
    <li><p>安全的反序列化和依赖管理； </p>
    </li>
    <li><p>配额限制和沙箱隔离；</p>
    </li>
    <li><p>强化认证和授权模型。</p>
    </li>
    </ul>
    <p>开发人员必须谨防用户非法输入，避免代码执行漏洞。</p>
    <br>
  </blockquote>
</details>
<br>


<h1 id="detect-object-injection"><a href="#detect-object-injection" class="headerlink" title="detect-object-injection"></a>detect-object-injection</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-object-injection&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用于检测代码中可能存在的对象注入漏洞。</p>
<p>对象注入漏洞形成的原因是将用户输入直接用于对象构造，用户可以修改对象原型行为。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInput = <span class="string">&#x27;constructor&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [userInput]: <span class="string">&#x27;test&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>用户可以通过输入 <code>constructor</code> 来改写原型，进而可能执行任意代码。</p>
<p>所以该规则检测以下情况：</p>
<ol>
<li><p>从外部输入构造了对象字面量；</p>
</li>
<li><p>字面量中可能包含危险属性名，如 <code>constructor</code>、<code>prototype</code>、<code>proto</code> 等。</p>
</li>
</ol>
<p>一旦同时满足上述条件，就会报出警告。</p>
<p>建议的安全写法是先校验用户输入，过滤危险属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">filterInput</span>(userInput);</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [userInput]: <span class="string">&#x27;test&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>也可以通过 <code>Proto.freeze()</code> 冻结原型防止扩展。</p>
<p>该规则通过静态分析帮助发现对象注入问题，提升了代码安全性。但有时候可能会产生误报，需要结合业务逻辑处理。</p>
<p>更多关于对象注入漏洞的信息可参考：<a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/the-dangers-of-square-bracket-notation.md">The Dangers of Square Bracket Notation</a></p>
<h1 id="detect-possible-timing-attacks"><a href="#detect-possible-timing-attacks" class="headerlink" title="detect-possible-timing-attacks"></a>detect-possible-timing-attacks</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-possible-timing-attacks&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则是用来检测代码中可能存在的 <em>计时攻击</em> 风险的。</p>
<p>计时攻击是一种侧信道攻击，通过比较操作时间差异来猜测敏感信息。</p>
<p>例如下面的登录验证逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">login</span>(<span class="params">user, password</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (password === secretPassword) &#123; </span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 登录失败  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以通过测量验证时间的不同来猜测密码。</p>
<p>因此，该规则会检测</p>
<ol>
<li><p>代码中是否存在涉及秘密的基于时序的比较；</p>
</li>
<li><p>这个时序是否可以被外部观测到。</p>
</li>
</ol>
<p>如果检测到这样的模式，则会报出警告。</p>
<p>修复方式是避免基于时序的密码学比较，改用定时算法等加密方法。</p>
<p>该规则可以帮助开发者提前发现这类风险，防止将来被计时攻击利用。</p>
<details open>
  <summary><strong>计时攻击是什么 ？</strong></summary>
  <blockquote>
    <br>
    <p>计时攻击（Timing Attack）是一种侧信道攻击，它通过分析代码执行时间的不同来获取敏感信息。</p>
    <p>计时攻击的基本原理是：</p>
    <ul>
    <li><p>程序中的加密验证等算法，时序会随着输入的不同而有细微变化；</p>
    </li>
    <li><p>通过观测大量运行时间，可以统计出时间与输入值的关联性；</p>
    </li>
    <li><p>最终可以推导出敏感信息，如密码、密钥等。</p>
    </li>
    </ul>
    <p>例如在登录验证过程中，验证时间随密码的不同而变化，这可以被利用来破解密码。</p>
    <p>常见的计时攻击场景还包括：</p>
    <ul>
    <li><p>比较密码哈希时的时间差异；</p>
    </li>
    <li><p>加解密运算时间微差；</p>
    </li>
    <li><p>TCP 序列号预测等。</p>
    </li>
    </ul>
    <p>防范计时攻击的方法：</p>
    <ul>
    <li><p>使用定时算法，避免时序依据；</p>
    </li>
    <li><p>在非密文区添加随机等待；</p>
    </li>
    <li><p>防止外部精确计时；</p>
    </li>
    <li><p>整体设计上避免秘密相关的时序依据。</p>
    </li>
    </ul>
    <p>计时攻击有时效性较差，但成功可能导致严重后果。识别时序依据并采取防范措施非常重要。</p>
    <br>
  </blockquote>
</details>
<br>


<h1 id="detect-pseudoRandomBytes"><a href="#detect-pseudoRandomBytes" class="headerlink" title="detect-pseudoRandomBytes"></a>detect-pseudoRandomBytes</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-pseudoRandomBytes&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用来检测代码中是否使用了伪随机数生成函数 <code>Math.random()</code>。</p>
<p><code>Math.random()</code> 这个函数生成的随机数质量较差，存在确定性，不适用于要求高强度随机数的场景，比如生成密码或密钥。</p>
<p>该规则会检测调用了 <code>Math.random()</code> 的情况，并给出警告。</p>
<p>需要随机数的更好选择是使用 Node.js 中的 <code>crypto</code> 模块，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bytes = crypto.<span class="title function_">randomBytes</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p><code>crypto.randomBytes</code> 使用更强的随机数生成器，可以应对密码学和安全场景。</p>
<p>该规则提醒开发者不要使用 <code>Math.random()</code>，而是考虑使用 <code>crypto.randomBytes()</code> 来获取更强质量的随机数。</p>
<p>当然，如果不是用于安全相关的随机数，用 <code>Math.random()</code> 也可以接受。可以通过注释或配置的方式绕过该规则。</p>
<p>在 Web 场景中，也存在一些需要高质量随机数的 case，比如：</p>
<ul>
<li><p>生成用户登录、注册等的验证码；</p>
</li>
<li><p>生成安全令牌和会话 ID；</p>
</li>
<li><p>加密通信中的初始化向量；</p>
</li>
<li><p>在浏览器中生成密码或密钥。</p>
</li>
</ul>
<p>这时使用 <code>Math.random()</code> 都是不合适的。更好的处理方式是：</p>
<ul>
<li><p>使用浏览器提供的加密安全随机数生成器：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues">crypto.getRandomValues()</a>，它利用系统熵源。</p>
</li>
<li><p>将随机数生成服务端化，由后端生成并提供给前端。</p>
</li>
<li><p>使用第三方的加密库，如 <a href="https://github.com/bitwiseshiftleft/sjcl">Stanford Javascript Crypto Library</a>。</p>
</li>
<li><p>对 <code>Math.random()</code> 进行种子混淆、hash 运算等提升随机性。</p>
</li>
<li><p>根据业务场景允许弱随机性，但注明其限制。</p>
</li>
</ul>
<p>Web 前端中如果需要高安全性的随机数，要注意不要直接使用 <code>Math.random()</code>，而要考虑浏览器&#x2F;服务端的加密安全替代方案。</p>
<p>同时，也要明确什么场景可以接受弱随机，什么场景要强随机，针对性应用正确的随机数源。</p>
<details open>
  <summary><strong>为什么说 <code>Math.random()</code> 这个函数生成的随机数质量较差，存在确定性？</strong></summary>
  <blockquote>
    <br>
    <p><code>Math.random()</code> 生成的随机数质量较差，主要有以下原因：</p>
    <ol>
    <li><p>确定性：<code>Math.random()</code> 的种子通常是基于时间戳的，在同一毫秒内会生成同样的序列，有确定性。</p>
    </li>
    <li><p>复现性：种子是可预测的，给定种子可以复现整个随机数序列。</p>
    </li>
    <li><p>周期性：序列会重复循环使用，较短的周期。</p>
    </li>
    <li><p>随机性缺陷：统计测试结果不达标，比如游程测试。</p>
    </li>
    <li><p>算法缺陷：线性同余或类似的伪随机算法。</p>
    </li>
    <li><p>语言运行时缺陷：部分语言运行时 <code>Math.random()</code> 实现存在缺陷。</p>
    </li>
    <li><p>环境固有缺陷：比如虚拟机可预测的熵源。</p>
    </li>
    </ol>
    <p>相比之下，像 Node.js 的 <code>crypto.randomBytes()</code> 使用杂凑和系统熵源，可以生成不可预测的加密安全随机数，适用于对安全和随机性要求非常高的场景。</p>
    <p>所以 <code>Math.random()</code> 不应被滥用于密码学和安全相关场景中。</p>
    <br>
    <p>关于更多不应使用<code>Math.random()</code>的信息可参考：<a href="https://security.stackexchange.com/questions/181580/why-is-math-random-not-designed-to-be-cryptographically-secure">Why is Math.random() not designed to be cryptographically secure?</a></p>
    <br>
  </blockquote>
</details>
<br>

<h1 id="detect-unsafe-regex"><a href="#detect-unsafe-regex" class="headerlink" title="detect-unsafe-regex"></a>detect-unsafe-regex</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;security/detect-unsafe-regex&#x27;</span>: <span class="string">&#x27;warn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个规则用来检测代码中是否存在潜在的不安全正则表达式。</p>
<p>不安全正则表达式的典型问题有：</p>
<ul>
<li><p>具有指数级别复杂度的正则，可能成为 ReDoS 攻击的受害者；</p>
</li>
<li><p>容易回溯的正则，如递归正则，也可能导致复杂度爆炸；</p>
</li>
<li><p>利用特殊字符做键控注入的正则。</p>
</li>
</ul>
<p>该规则通过匹配一些模式,来检测像 <code>(a+)+</code> 这样复杂度高的正则，以及像 <code>/[Designer match Sajon]/</code> 这样可能存在注入风险的正则。一旦匹配到则会给出警告。</p>
<p>更安全的做法是：</p>
<ul>
<li><p>尽量使用简单的正则;</p>
</li>
<li><p>对用户输入的正则进行过滤和转义;  </p>
</li>
<li><p>设置正则处理的超时和长度限制;</p>
</li>
<li><p>使用正则引擎的安全匹配模式。</p>
</li>
</ul>
<p>这个规则可以帮助开发者提前发现不安全的正则表达式，防止被利用为 DoS 攻击的向量。但有时也会误报，需要结合业务场景处理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面通过安装 <code>eslint-plugin-security</code>，实践了它所支持的 14 个规则。对每个规则都站来了较为详尽的描述，了解规则的配置方式、起到的作用，涉及到的安全问题。并以此简述了规则所预防的网络攻击。</p>
<p>通过本次实践，了解以下网络攻击：</p>
<ul>
<li><p>trojan source attacks：利用双向书写系统中的特殊字符实现隐藏代码注入的攻击方式；</p>
</li>
<li><p>以 <code>noAsset</code> 标志使用 <code>Buffer</code> 引发的缓冲区溢出，造成内存污染、崩溃或安全漏洞；</p>
</li>
<li><p>命令注入攻击（Command Injection）：将操作系统命令通过利用程序漏洞注入到执行环境中的代码注入攻击；</p>
</li>
<li><p>XSS（Cross-Site Scripting，跨站脚本）攻击；</p>
</li>
<li><p>DoS（Denial of Service，拒绝服务）攻击；</p>
</li>
<li><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）；</p>
</li>
<li><p>路径遍历（Path Traversal）漏洞；</p>
</li>
<li><p>ReDoS（Regular expression Denial of Service）即正则拒绝服务攻击；</p>
</li>
<li><p>allow 攻击（Arbitrary Code Execution）；</p>
</li>
<li><p>对象注入漏洞；</p>
</li>
<li><p>计时攻击（Timing Attack）：是一种侧信道攻击，它通过分析代码执行时间的不同来获取敏感信息；</p>
</li>
<li><p>伪随机数生成函数引发的密码类安全问题；</p>
</li>
<li><p>不安全正则表达式引发的 ReDoS 攻击 或 DoS 攻击；</p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="完整规则"><a href="#完整规则" class="headerlink" title="完整规则"></a>完整规则</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;security/detect-buffer-noassert&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-child-process&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-disable-mustache-escape&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-eval-with-expression&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-new-buffer&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-no-csrf-before-method-override&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-fs-filename&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-regexp&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-non-literal-require&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-object-injection&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-possible-timing-attacks&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-pseudoRandomBytes&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-unsafe-regex&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;security/detect-bidi-characters&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.wikiwand.com/zh-hans/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF">双向文稿</a></li>
<li><a href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal</a></li>
<li><a href="https://www.wikiwand.com/en/Denial-of-service_attack">Denial-of-service attack</a></li>
<li><a href="https://www.wikiwand.com/en/Timing_attack">Wikiwand - Timing attack</a></li>
<li><a href="https://owasp.org/www-community/attacks/xss/">Cross Site Scripting (XSS)</a></li>
<li><a href="https://owasp.org/www-community/attacks/Command_Injection">OWASP - Command Injection</a></li>
<li><a href="https://www.wikiwand.com/en/Denial-of-service_attack">Wikiwand - Denial-of-service attack</a></li>
<li><a href="https://www.wikiwand.com/en/Arbitrary_code_execution">Wikiwand - Arbitrary code execution</a></li>
<li><a href="https://owasp.org/www-community/attacks/csrf">Cross Site Request Forgery (CSRF)</a></li>
<li><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/regular-expression-dos-and-node.md">Regular Expression DoS and Node.js</a></li>
<li><a href="https://github.com/eslint-community/eslint-plugin-security/blob/main/docs/the-dangers-of-square-bracket-notation.md">The Dangers of Square Bracket Notation</a></li>
<li><a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">Regular expression Denial of Service - ReDoS</a></li>
<li><a href="http://security.stackexchange.com/questions/94017/what-are-the-security-issues-with-eval-in-javascript">What are the security issues with eval in JavaScript?</a></li>
<li><a href="https://www.bennadel.com/blog/2169-where-does-node-js-and-require-look-for-modules.htm">Where Does Node.js And Require() Look For Modules?</a></li>
<li><a href="https://pvs-studio.com/en/blog/posts/cpp/0933/">Trojan Source attack for introducing invisible vulnerabilities</a></li>
<li><a href="https://security.stackexchange.com/questions/181580/why-is-math-random-not-designed-to-be-cryptographically-secure">Why is Math.random() not designed to be cryptographically secure?</a></li>
</ul>

]]></content>
      <categories>
        <category>静态代码分析</category>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>eslint-plugin-security</tag>
        <tag>实践</tag>
        <tag>trojan source attacks</tag>
        <tag>安全漏洞</tag>
        <tag>命令注入攻击</tag>
        <tag>XSS</tag>
        <tag>DoS</tag>
        <tag>CSRF</tag>
        <tag>路径遍历</tag>
        <tag>ReDoS</tag>
        <tag>allow 攻击</tag>
        <tag>对象注入漏洞</tag>
        <tag>计时攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 包管理器 - APT</title>
    <url>/blog/resources/Linux-Package-Manager-Apt/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将介绍 Advanced Packaging Tool (APT) 包管理器，以及其在 Debian 系统及其衍生发行版（如 Ubuntu）中的配置方式和使用方法。我们将探讨如何配置 APT，包括软件源的设置和更新策略。我们还将深入了解 APT 的使用方式，包括通过命令行工具 apt 进行软件包的安装、升级和移除等操作。通过本文，读者将能够全面了解 APT 的功能和特性，并能够有效地使用 APT 管理软件包，提升系统的稳定性和安全性。</p>
<span id="more"></span>

<p>背景：</p>
<ul>
<li>系统：Debian 12；</li>
</ul>
<h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>APT 是一个命令行工具，也是 Debian 系统和基于 Debian 的发行版（如 Ubuntu）中常用的软件包管理工具之一。它是 Advanced Packaging Tool（高级软件包工具）的缩写，旨在简化软件包的安装、升级和移除等操作。</p>
<h1 id="常见的包管理器"><a href="#常见的包管理器" class="headerlink" title="常见的包管理器"></a>常见的包管理器</h1><table>
<thead>
<tr>
<th>包管理器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://wiki.debian.org/Apt"><strong>Advanced Packaging Tool (APT)</strong></a></td>
<td>APT 是 Debian 系统及其衍生发行版（如 Ubuntu）中的包管理器。它通过命令行工具 <code>apt</code> 提供软件包的安装、升级和移除等功能。</td>
</tr>
<tr>
<td><a href="https://dnf.readthedocs.io/en/latest/"><strong>dnf&#x2F;yum</strong></a></td>
<td>dnf（Dandified Yum）是 Fedora 系统及其衍生发行版中的包管理器，取代了旧的 Yum 包管理器。在较旧的 Fedora 和 CentOS 系统中，仍然可以使用 Yum 来进行包管理。</td>
</tr>
<tr>
<td><a href="https://wiki.archlinux.org/index.php/Pacman"><strong>Pacman</strong></a></td>
<td>Pacman 是 Arch Linux 及其衍生发行版（如 Manjaro）中的包管理器。它使用简单的命令行工具来管理软件包，具有轻量且高效的特点。</td>
</tr>
<tr>
<td><a href="https://brew.sh/"><strong>Homebrew</strong></a></td>
<td>Homebrew 是 macOS 系统上的包管理器，用于安装、更新和管理各种开源软件包。它具有简单易用的命令行界面，并提供了大量的软件包供用户选择。</td>
</tr>
<tr>
<td><a href="https://chocolatey.org/"><strong>Chocolatey</strong></a></td>
<td>Chocolatey 是 Windows 系统上的包管理器，类似于 Linux 系统中的包管理器。它允许用户通过命令行界面来安装、升级和管理软件包。</td>
</tr>
<tr>
<td><a href="https://snapcraft.io/"><strong>Snap</strong></a></td>
<td>Snap 是一种通用的软件打包和分发格式，可在多个 Linux 发行版上使用。Snap 提供了一个命令行工具来管理软件包，使得安装和更新软件变得更加简单和可靠。</td>
</tr>
</tbody></table>
<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p>第三种命令是<code>apt</code>，它是APT的一种更简洁的命令行工具，自动处理软件包之间的依赖关系。它在一些较新的Debian和Ubuntu发行版中取代了<code>apt-get</code>命令，提供了更直观和用户友好的界面。</p>
<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install &lt;package&gt;</span><br></pre></td></tr></table></figure>
<p>该命令用于安装指定的软件包。它会自动解析并安装所需的依赖关系。</p>
<h2 id="升级已安装的软件包"><a href="#升级已安装的软件包" class="headerlink" title="升级已安装的软件包"></a>升级已安装的软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<p>该命令用于升级系统中已安装的软件包。它会检查可用的软件包更新并升级到最新版本。</p>
<h2 id="移除软件包"><a href="#移除软件包" class="headerlink" title="移除软件包"></a>移除软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>该命令用于移除指定的软件包。它会将软件包及其相关的配置文件从系统中删除。</p>
<h2 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt search &lt;keyword&gt;</span><br></pre></td></tr></table></figure>

<p>该命令用于搜索包含指定关键字的软件包。它会列出与关键字相关的软件包名称和描述。</p>
<h2 id="显示软件包信息"><a href="#显示软件包信息" class="headerlink" title="显示软件包信息"></a>显示软件包信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt show &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>该命令用于显示指定软件包的详细信息，包括版本号、依赖关系、描述等。</p>
<h2 id="更新软件包源列表"><a href="#更新软件包源列表" class="headerlink" title="更新软件包源列表"></a>更新软件包源列表</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudp apt update</span><br></pre></td></tr></table></figure>
<p>它是在使用APT进行软件包管理时非常重要的一步。当你运行apt update命令时，APT会连接到配置的软件包源服务器，并下载最新的软件包列表信息。这些软件包列表包含了可用的软件包和它们的版本信息。</p>
<p>下面是 <code>apt update</code> 命令的作用：</p>
<ul>
<li><p><strong>更新软件包列表</strong>：apt update命令会更新本地系统中的软件包列表。软件包列表是一个包含可用软件包的索引，它包含了软件包的名称、版本、依赖关系等重要信息。通过更新软件包列表，你可以了解到最新的软件包和版本信息。</p>
</li>
<li><p><strong>获取最新的软件包版本</strong>：通过运行apt update命令，你可以获取最新的软件包版本信息。APT会检查软件包源服务器上的软件包，并比较本地系统中已安装的软件包版本与软件包源上的最新版本。这有助于确定是否有可用的更新版本供你安装。</p>
</li>
<li><p><strong>解决软件包依赖关系</strong>：软件包之间存在依赖关系，即某些软件包需要依赖其他软件包才能正常工作。通过运行apt update命令，APT会检查软件包源上的依赖关系并更新本地系统的软件包列表。这有助于确保软件包的依赖关系得到满足，以便正确地安装和更新软件包。</p>
</li>
</ul>
<p>使用<code>apt</code>命令时，不需要在命令后面添加<code>sudo apt-get</code>中常见的<code>sudo</code>和<code>get</code>关键字。它提供了更简洁的语法，并且在处理依赖关系时更加智能和自动化。这使得软件包的安装和管理过程更加便捷和高效。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ debian <span class="keyword">in</span> /etc/apt/apt.conf.d [18:34:28]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt --<span class="built_in">help</span></span></span><br><span class="line">apt 2.6.1 (amd64)</span><br><span class="line">Usage: apt [options] command</span><br><span class="line"></span><br><span class="line">apt is a commandline package manager and provides commands for</span><br><span class="line">searching and managing as well as querying information about packages.</span><br><span class="line">It provides the same functionality as the specialized APT tools,</span><br><span class="line">like apt-get and apt-cache, but enables options more suitable for</span><br><span class="line">interactive use by default.</span><br><span class="line"></span><br><span class="line">Most used commands:</span><br><span class="line">  list - list packages based on package names</span><br><span class="line">  search - search in package descriptions</span><br><span class="line">  show - show package details</span><br><span class="line">  install - install packages</span><br><span class="line">  reinstall - reinstall packages</span><br><span class="line">  remove - remove packages</span><br><span class="line">  autoremove - automatically remove all unused packages</span><br><span class="line">  update - update list of available packages</span><br><span class="line">  upgrade - upgrade the system by installing/upgrading packages</span><br><span class="line">  full-upgrade - upgrade the system by removing/installing/upgrading packages</span><br><span class="line">  edit-sources - edit the source information file</span><br><span class="line">  satisfy - satisfy dependency strings</span><br><span class="line"></span><br><span class="line">See apt(8) for more information about the available commands.</span><br><span class="line">Configuration options and syntax is detailed in apt.conf(5).</span><br><span class="line">Information about how to configure sources can be found in sources.list(5).</span><br><span class="line">Package and version choices can be expressed via apt_preferences(5).</span><br><span class="line">Security details are available in apt-secure(8).</span><br><span class="line">                                        This APT has Super Cow Powers.</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在上面有提到使用 <code>apt install &lt;package&gt;</code> 安装软件，对此不禁有疑问：所安装的软件的来源是那里获取的？</p>
<p>实际上，APT（Advanced Packaging Tool）通过软件源（Software Repository）来获取和安装软件包。软件源是一个集中存储软件包的远程服务器，APT通过访问这些服务器来搜索、下载和安装软件包。</p>
<p>在系统中配置了软件源列表（source list）后，APT 会根据列表中的地址和设置来确定可用的软件源服务器。</p>
<h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>软件源是存储软件包和更新的服务器或存储库。它是用户获取并安装软件的主要来源之一。软件源提供了一个集中的位置，用户可以从中获取各种软件包、应用程序和系统组件，以满足其Linux操作系统的需求。</p>
<p>以下是一些常见的软件源类型，它们广泛用于不同的Linux发行版：</p>
<ul>
<li><p>官方软件源；</p>
</li>
<li><p>第三方软件源；</p>
</li>
<li><p>Snap Store；</p>
</li>
<li><p>Flatpak。</p>
</li>
</ul>
<h3 id="官方软件源"><a href="#官方软件源" class="headerlink" title="官方软件源"></a>官方软件源</h3><p>各Linux发行版都维护了自己的官方软件源，提供了核心软件包和更新。例如：</p>
<ul>
<li><p>Ubuntu：<a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/</a></p>
</li>
<li><p>Debian：<a href="https://packages.debian.org/">https://packages.debian.org/</a></p>
</li>
<li><p>Fedora：<a href="https://apps.fedoraproject.org/packages/">https://apps.fedoraproject.org/packages/</a></p>
</li>
<li><p>CentOS：<a href="https://www.centos.org/packages/">https://www.centos.org/packages/</a></p>
</li>
<li><p>Arch Linux：<a href="https://archlinux.org/packages/">https://archlinux.org/packages/</a></p>
</li>
<li><p>openSUSE：<a href="https://software.opensuse.org/">https://software.opensuse.org/</a></p>
</li>
<li><p>Mageia：<a href="https://madb.mageia.org/">https://madb.mageia.org/</a></p>
</li>
<li><p>Gentoo：<a href="https://packages.gentoo.org/">https://packages.gentoo.org/</a></p>
</li>
</ul>
<p>这些链接将带你到相应发行版的官方软件源的网页，你可以使用这些网页来搜索和浏览软件包列表。请注意，这些链接可能会随着时间变化而更新，所以最好通过搜索引擎或官方网站来获取最新的软件源链接。</p>
<h3 id="第三方软件源"><a href="#第三方软件源" class="headerlink" title="第三方软件源"></a>第三方软件源</h3><p>许多开发者、社区和组织维护自己的软件源，提供特定软件的最新版本和增强功能。这些第三方软件源可以是针对特定软件的官方源，也可以是由社区维护的源。常见的第三方软件源如：</p>
<ul>
<li><p><a href="https://launchpad.net/ubuntu/+ppas">Ubuntu PPA（Personal Package Archive）</a>：个人软件仓库，由Ubuntu用户创建和维护。提供了额外的软件包和更新。</p>
</li>
<li><p><a href="https://rpmfusion.org/">RPM Fusion（适用于Fedora和CentOS）</a>：提供了一些常用软件的补充包，包括多媒体相关的软件和驱动程序。</p>
</li>
<li><p><a href="https://aur.archlinux.org/">Arch User Repository（AUR）</a>（适用于Arch Linux）：由Arch Linux社区维护的软件仓库，允许用户共享和安装自定义软件包。</p>
</li>
<li><p><a href="https://build.opensuse.org/">OBS（Open Build Service）</a>（适用于多个发行版）：一个开放的软件构建服务，允许开发者构建和发布软件包。支持多个Linux发行版。</p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/EPEL">EPEL（Extra Packages for Enterprise Linux）</a>（适用于CentOS和RHEL）：为企业级Linux发行版提供额外的软件包，以满足更广泛的需求。</p>
</li>
<li><p><a href="https://nixos.org/nixpkgs/">Nixpkgs（适用于NixOS）</a>：NixOS的官方软件仓库，提供了丰富的软件包和配置管理工具。</p>
</li>
<li><p><a href="https://brew.sh/">Homebrew</a>（适用于macOS）：macOS上的包管理器，提供了易于安装和管理的软件包。</p>
</li>
</ul>
<p>这些第三方软件源提供了额外的软件包和功能，使用户能够获取更多的选择和定制性。请注意，使用第三方软件源时应谨慎，确保了解源的可信度和安全性，并遵循它们的使用指南。</p>
<h3 id="Snap-Store"><a href="#Snap-Store" class="headerlink" title="Snap Store"></a>Snap Store</h3><p><a href="https://snapcraft.io/store">Snap Store</a> 是一个官方的软件分发平台，它提供了广泛的应用程序和工具，适用于基于 Linux 的各种发行版，如 Ubuntu、Fedora、CentOS、Arch Linux等。Snap Store基于Snap包管理系统，这是一种跨发行版的软件打包和分发格式。</p>
<p>Snap Store的特点包括：</p>
<ol>
<li><p>跨发行版支持：Snap Store的软件包可以在多种不同的Linux发行版上安装和运行，无需担心依赖关系或兼容性问题。</p>
</li>
<li><p>安全性：Snap包采用沙箱技术，提供了额外的安全层，确保软件的隔离性和安全性。每个Snap应用程序都有自己的依赖和运行环境，不会干扰系统的其他部分。</p>
</li>
<li><p>自动更新：Snap Store中的软件包会自动更新到最新版本，确保用户始终使用最新的功能和修复的bug。</p>
</li>
<li><p>宽广的应用程序库：Snap Store提供了各种类型的应用程序，包括办公套件、多媒体工具、开发工具、游戏等，使用户能够方便地找到并安装他们所需的软件。</p>
</li>
</ol>
<p>在Snap Store中，你可以浏览不同类别的软件，搜索特定的应用程序，并通过简单的几个步骤安装和管理它们。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 snapd</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install snapd</span><br><span class="line">sudo snap install core</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line">sudo snap install &lt;package&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除软件</span></span><br><span class="line">sudo snap remove &lt;package&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已安装软件</span></span><br><span class="line">sudo snap list</span><br></pre></td></tr></table></figure>

<h3 id="Flatpak"><a href="#Flatpak" class="headerlink" title="Flatpak"></a>Flatpak</h3><p><a href="https://flathub.org/">Flatpak</a> 是一个用于Linux发行版的软件打包和分发系统，类似于Snap。它提供了一种跨发行版的方式，允许开发者打包应用程序及其依赖项，并在不同的Linux发行版上以沙箱环境中运行。</p>
<p>Flatpak的特点包括：</p>
<ol>
<li><p>跨发行版支持：Flatpak允许开发者将应用程序打包为独立的容器，与底层系统无关。这使得应用程序可以在各种不同的Linux发行版上运行，无需重新打包。</p>
</li>
<li><p>沙箱环境：Flatpak应用程序运行在沙箱环境中，与系统其他部分隔离。这提供了额外的安全性，防止应用程序对系统造成潜在的影响。</p>
</li>
<li><p>应用程序库：Flatpak通过Flathub提供了一个中央应用程序库，其中包含了大量的应用程序供用户选择。你可以在Flathub上浏览各种类别的应用程序，并通过几个简单的步骤安装它们。</p>
</li>
<li><p>更新管理：Flatpak应用程序可以自动更新，确保用户始终使用最新的版本和修复的漏洞。</p>
</li>
</ol>
<p>使用Flatpak，你可以浏览Flathub上的应用程序，搜索特定的应用程序，并使用Flatpak命令行工具或图形界面工具进行安装、更新和管理。Flatpak提供了一种简便的方式，使用户能够轻松地获取和运行各种Linux应用程序。</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 flatpak 完成后，重启生效</span></span><br><span class="line">sudo apt install flatpak</span><br><span class="line">flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line">flatpak install flathub &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>这些软件源的地址被配置在 <code>/etc/apt/sources.list</code> 或 <code>/etc/apt/sources.list.d/</code>目录下的<code>*.list</code>文件中。</p>
<ul>
<li><p><code>source.list</code> 文件定义了一个或多个软件源的URL，软件包管理器将从这些源中下载软件包。每个源的URL通常指向一个包含软件包的软件存储库。</p>
</li>
<li><p><code>source.list.d/</code> 目录是 <code>/etc/apt/</code> 目录下的另一个目录，用于存放以 <code>.list</code> 为扩展名的软件源文件。这个目录允许用户和软件包管理器将软件源的配置拆分为多个文件，以便更好地组织和管理。可以通过简单地在该目录中创建一个新的.list文件来添加新的软件源。这种分割的方式使得在不影响source.list文件的情况下添加、删除或修改软件源变得更加方便，而无需修改单个大文件。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── sources.list</span><br><span class="line">└── sources.list.d</span><br><span class="line">    ├── cloudflare-client.list</span><br><span class="line">    ├── microsoft-edge.list</span><br><span class="line">    └── vscode.list</span><br></pre></td></tr></table></figure>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>在 Debian 和 Ubuntu 等 Linux 发行版中，<code>source.list</code>文件和<code>source.list.d/</code>目录下的<code>.list</code>文件中的配置具有以下优先级：</p>
<ol>
<li><p><code>source.list.d/</code>目录下的<code>.list</code>文件的优先级高于<code>source.list</code>文件。这意味着如果在<code>source.list.d/</code>目录中存在与<code>source.list</code>中相同的软件源配置，将使用<code>source.list.d/</code>目录中的配置。</p>
</li>
<li><p>当存在多个<code>source.list.d/</code>目录下的<code>.list</code>文件时，它们的加载顺序是按照文件名的字母顺序进行的。较早加载的文件中的配置将被后续加载的文件中的配置覆盖。</p>
</li>
<li><p>如果存在相同软件源的重复配置，后面加载的配置将覆盖先前加载的配置。因此，在<code>source.list.d/</code>目录中的较晚加载的<code>.list</code>文件中的配置将覆盖较早加载的文件中相同软件源的配置。</p>
</li>
</ol>
<p>需要注意的是，优先级仅适用于软件源配置。对于其他APT设置（如代理配置、密钥管理等），在<code>source.list</code>中配置的设置将始终具有最高优先级。</p>
<h2 id="配置格式"><a href="#配置格式" class="headerlink" title="配置格式"></a>配置格式</h2><p>下面是 Debian 12 的 <code>source.list</code> 配置内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ debian <span class="keyword">in</span> /etc/apt [13:26:09] C:130</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sources.list</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="line">deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span><br></pre></td></tr></table></figure>

<p>以上面的 <code>sources.list</code> 文件的第一行为例说明一个软件源的配置格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line">&lt;软件源关键词&gt; &lt;软件源地址&gt; &lt;发行版名称&gt; &lt;组件1&gt; &lt;组件2&gt; ...</span><br></pre></td></tr></table></figure>

<p>它指定了一个名为”bookworm”的发行版，使用了清华大学开源软件镜像站（<a href="https://mirrors.tuna.tsinghua.edu.cn/debian/%EF%BC%89%E4%BD%9C%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%BA%90%E3%80%82">https://mirrors.tuna.tsinghua.edu.cn/debian/）作为软件源。</a></p>
<h3 id="软件源关键词"><a href="#软件源关键词" class="headerlink" title="软件源关键词"></a>软件源关键词</h3><p><code>deb</code>：这是APT软件源配置中的关键词，表示这是一个二进制包的软件源。</p>
<p>软件源配置中常用的关键词有以下几个：</p>
<ol>
<li><p><strong>deb</strong>：表示这是一个二进制包的软件源。</p>
</li>
<li><p><strong>deb-src</strong>：表示这是一个源代码包的软件源。</p>
</li>
</ol>
<p>这两个关键词用于不同类型的软件源，前者用于获取和安装二进制包，后者用于获取和构建源代码包。</p>
<h3 id="软件源地址"><a href="#软件源地址" class="headerlink" title="软件源地址"></a>软件源地址</h3><p><code>https://mirrors.tuna.tsinghua.edu.cn/debian/</code>：这是软件源的URL地址，指向清华大学开源软件镜像站的 Debian 软件源。</p>
<p>这里的清华源并非默认的源，默认的官方源是 <code>http://deb.debian.org/debian/</code>，由于访问官网源在国内比较慢等原因，因此上面使用了国内的源。除了清华源外，国内还有其他 Debian APT 源，常见的有：</p>
<ul>
<li><p><a href="https://mirrors.cloud.tencent.com/">腾讯软件源</a></p>
</li>
<li><p><a href="https://developer.aliyun.com/mirror/">阿里源</a></p>
</li>
<li><p><a href="https://mirrors.huaweicloud.com/home">华为源</a></p>
</li>
<li><p><a href="http://mirrors.ustc.edu.cn/">中科大源</a></p>
</li>
</ul>
<h3 id="发行版名称"><a href="#发行版名称" class="headerlink" title="发行版名称"></a>发行版名称</h3><p><code>bookworm</code>：这是发行版的名称，表示这个软件源适用于 Debian 12（代码名称为”Bookworm”）。</p>
<p>更多的 Debian 的发行版本名称见 <a href="#Debian-%E7%9A%84%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E5%90%8D%E7%A7%B0">附录</a></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><code>main contrib non-free non-free-firmware</code>： 这是软件源中的组件。不同的组件包含了不同类型的软件包。</p>
<ul>
<li><p><strong>main</strong>：Debian 发行版的核心组件，包含了自由的开源软件包。</p>
</li>
<li><p><strong>contrib</strong>：这是非必需的软件包组件，包含了依赖于main组件的一些软件包。</p>
</li>
<li><p><strong>non-free</strong>：这是非自由软件包组件，包含了不符合自由软件定义的软件包。</p>
</li>
<li><p><strong>non-free-firmware</strong>：这是非自由的硬件固件组件，包含了一些设备所需的非自由固件。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>软件源列表（Source List）是一个文本文件，用于配置系统中软件包管理器（如APT）的软件源服务器信息。它包含了系统用于下载和安装软件包的网络地址。</p>
<p>在 Debian 系及其衍生发行版（如Ubuntu）中，软件源列表文件通常位于<code>/etc/apt/sources.list</code>或<code>/etc/apt/sources.list.d/</code>目录下。这个文件中列出了各种软件源服务器的地址，以及与每个软件源相关的软件包分发渠道和组件。</p>
<p>软件源列表文件的内容可以根据用户的需求进行自定义。用户可以根据自己的地理位置、网络速度和软件需求来选择合适的软件源服务器。通过编辑软件源列表文件，用户可以添加、删除或更改软件源，以便获取所需的软件包。</p>
<p>在使用APT进行软件包管理时，软件源列表起到关键作用。通过配置正确的软件源，系统可以正确地下载和安装软件包，保持系统的更新和安全。因此，了解软件源列表的概念并正确配置它是非常重要的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一篇关于 Linux 系统中 APT 包管理器的使用指南。本文主要内容如下:</p>
<p>第一部分介绍了 APT 的基本概念，它是 Debian 系统及其衍生发行版中的常用包管理工具，通过 apt 命令提供软件包管理功能。</p>
<p>第二部分详细解释了 APT 的各种常用命令，包括安装、升级、删除、搜索、显示软件包信息等，并给出了具体的命令格式和使用示例，便于读者快速掌握。 </p>
<p>第三部分着重讲解了 APT 的软件源配置，包括不同类型软件源、它们之间的优先级关系、sources.list 文件的格式等内容。正确配置软件源对 APT 的正常使用非常关键。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Debian-的发行版本名称"><a href="#Debian-的发行版本名称" class="headerlink" title="Debian 的发行版本名称"></a>Debian 的发行版本名称</h2><p>Debian 发行版通常使用代号来标识各个版本，这些代号通常以动画电影《玩具总动员》中的角色命名。以下是一些常见的Debian 发行版代号及其对应的版本：</p>
<ol>
<li>Debian 1.1 “Buzz”</li>
<li>Debian 1.2 “Rex”</li>
<li>Debian 1.3 “Bo”</li>
<li>Debian 2.0 “Hamm”</li>
<li>Debian 2.1 “Slink”</li>
<li>Debian 2.2 “Potato”</li>
<li>Debian 3.0 “Woody”</li>
<li>Debian 3.1 “Sarge”</li>
<li>Debian 4.0 “Etch”</li>
<li>Debian 5.0 “Lenny”</li>
<li>Debian 6.0 “Squeeze”</li>
<li>Debian 7.0 “Wheezy”</li>
<li>Debian 8.0 “Jessie”</li>
<li>Debian 9.0 “Stretch”</li>
<li>Debian 10 “Buster”</li>
<li>Debian 11 “Bullseye”</li>
</ol>
<p>这些代号是根据《玩具总动员》系列电影的角色（如Buzz、Rex等）命名的，并按照字母顺序进行命名，每个新版本都使用下一个字母的角色名称作为代号。这些代号主要用于标识特定版本的Debian发行版，使用户和开发者可以更方便地引用和讨论特定版本的Debian。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.debian.org/distrib/packages">debian &#x2F; 获取 debian &#x2F; 软件包</a></li>
<li><a href="https://en.wikipedia.org/wiki/APT_(software)">wikipeida - APT (software)</a></li>
<li><a href="https://ubuntu.com/server/docs/package-management">Ubuntu - Package management</a></li>
<li><a href="https://manpages.ubuntu.com/manpages/xenial/man8/apt.8.html">apt - command-line interface</a></li>
<li><a href="https://snapcraft.io/docs">Snap documentation</a></li>
<li><a href="https://docs.flatpak.org/en/latest/introduction.html">Introduction to Flatpak</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>apt</tag>
        <tag>linux包管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Action 入门指南</title>
    <url>/blog/resources/Get-Start-Of-Github-Action/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>最近持续迭代的 npm 包，<a href="https://github.com/isaaxite/deploy-posts-to-github-issue">isubo</a>。功能已经完成得七七八八，因此开始逐渐完善与之相关的基本设施，比如自动化的能力。该项目代码使用 Github 管理，在它启动之初已经略有了解 GitHub-Actions，模糊地知道Gtihub Actions 是 Github 提供的 CI&#x2F;CD 工具。由于各种原因的将此增加自动化能力的工作置后到最近。</p>
<p>本文将围绕 Github Actions 展开，了解 Gtihub Actions、CI&#x2F;CD概念以及常见的CI&#x2F;CD工具或平台。接着回归实际问题，详细了解 Github Actions 的使用、配置文件的常用配置项。最后，再实践上面提到的 <a href="https://github.com/isaaxite/deploy-posts-to-github-issue">isubo</a> 的自动化能力。通过实践让我们具备一定的，使用 Gtihub Actions 实现CI&#x2F;CD的能力；具备解决新的Github Actions 相关新的需求点的能力，比如在工作流中增加代码静态分析能力。</p>
<span id="more"></span>

<details>
  <summary><strong>☕️ isubo 是什么？</strong></summary>
  <blockquote>
    <br>
    <p>As we known, a lost of developer use github isses as their blog which is so great. However, the bad experience of writing articles on the issue page of github is really hard to describe. And Isubo was born for this 💪.

</p><p>Isubo is a CLI tool to publish markdown content to github issues. It allows you to focus on writing posts in the local environment to obtain a comfortable experience, and gracefully solve the storage and publishing of posts and resources for you 🤟.</p><br>  </blockquote>
</details>


<h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h1><p>CI&#x2F;CD（持续集成和持续交付&#x2F;部署）是一种软件开发实践，旨在通过自动化构建、测试和部署过程来加快软件交付的速度和质量。CI&#x2F;CD 流程通常与版本控制系统（如 Git）和自动化工具（如 Jenkins、Travis CI、CircleCI、GitLab CI&#x2F;CD 等）结合使用。</p>
<p>以下是一个基本的 CI&#x2F;CD 流程的示例：</p>
<ol>
<li><p>代码托管：将代码存储在版本控制系统中，如 Git。</p>
</li>
<li><p>触发构建：当代码被推送到特定的分支（如主分支）或提交到特定的分支时，CI&#x2F;CD 工具会自动触发构建过程。</p>
</li>
<li><p>构建：CI&#x2F;CD 工具会从代码仓库中获取最新的代码，并执行构建过程。构建过程可以包括编译代码、运行单元测试、生成构建产物等。</p>
</li>
<li><p>测试：构建完成后，自动化测试工具会运行各种测试，包括单元测试、集成测试、端到端测试等。测试的目的是确保代码的质量和功能的稳定性。</p>
</li>
<li><p>静态分析：可以使用静态代码分析工具来检查代码质量，并提供反馈和建议以改善代码。</p>
</li>
<li><p>部署：如果构建和测试成功，CI&#x2F;CD 工具会自动将构建产物部署到目标环境，如开发、测试或生产环境。部署可以包括将代码复制到服务器、配置环境变量、启动服务等操作。</p>
</li>
<li><p>自动化流程：整个 CI&#x2F;CD 过程可以通过配置和脚本自动化执行，以确保一致性和可重复性。</p>
</li>
<li><p>监控和反馈：在部署完成后，可以设置监控和日志记录系统来跟踪应用程序的性能和行为。如果出现问题，可以通过集成警报系统发送通知。</p>
</li>
</ol>
<p>CI&#x2F;CD 的好处包括减少手动操作、提高开发团队的效率、加速软件交付、提高代码质量和稳定性等。</p>
<p>具体的 CI&#x2F;CD 流程会因组织和项目的需求而有所不同，可以根据团队的实际情况进行定制和扩展。常见的 CI&#x2F;CD 工具提供了丰富的功能和配置选项，使您能够根据项目的特定需求来创建自定义的 CI&#x2F;CD 流程。</p>
<h1 id="常见的CI-CD"><a href="#常见的CI-CD" class="headerlink" title="常见的CI&#x2F;CD"></a>常见的CI&#x2F;CD</h1><table>
<thead>
<tr>
<th>工具&#x2F;平台</th>
<th>描述</th>
<th>特点</th>
<th>出现时间</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.jenkins.io/">Jenkins</a></td>
<td>开源的 CI&#x2F;CD 工具，提供丰富的插件和扩展性</td>
<td>可扩展性强，支持各种复杂构建和部署场景</td>
<td>2004年</td>
</tr>
<tr>
<td><a href="https://www.atlassian.com/software/bamboo">Bamboo</a></td>
<td>Atlassian 公司提供的 CI&#x2F;CD 工具，适用于大型企业和团队</td>
<td>与其他 Atlassian 产品无缝集成，适用于复杂的开发和部署需求</td>
<td>2007年</td>
</tr>
<tr>
<td><a href="https://www.jetbrains.com/teamcity/">TeamCity</a></td>
<td>JetBrains 公司提供的 CI&#x2F;CD 工具，具有简单易用的界面和强大的可扩展性</td>
<td>提供易用的界面和强大的可扩展性，适用于各种构建、测试和部署场景</td>
<td>2006年</td>
</tr>
<tr>
<td><a href="https://www.travis-ci.com/">Travis CI</a></td>
<td>托管的 CI&#x2F;CD 平台，与 GitHub 集成紧密</td>
<td>简单易用，广泛用于开源项目</td>
<td>2011年</td>
</tr>
<tr>
<td><a href="https://circleci.com/">CircleCI</a></td>
<td>基于云的 CI&#x2F;CD 平台，适用于小型和中型项目</td>
<td>配置简单，提供快速的构建和部署</td>
<td>2011年</td>
</tr>
<tr>
<td><a href="https://docs.gitlab.com/ee/ci/">GitLab CI&#x2F;CD</a></td>
<td>GitLab 内置的 CI&#x2F;CD 工具，与 GitLab 代码托管平台紧密结合</td>
<td>与 GitLab 紧密集成，便于代码管理和版本控制</td>
<td>2011年</td>
</tr>
<tr>
<td><a href="https://azure.microsoft.com/en-us/products/devops">Azure DevOps</a></td>
<td>Microsoft 提供的全面开发和交付工具，适用于云原生应用程序开发和部署</td>
<td>提供完整的开发和交付生命周期管理，与 Microsoft 技术生态紧密集成</td>
<td>2018年</td>
</tr>
<tr>
<td><a href="https://github.com/features/actions">GitHub Actions</a></td>
<td>GitHub 提供的集成 CI&#x2F;CD 服务，与 GitHub 代码仓库紧密结合</td>
<td>与 GitHub 紧密集成，提供丰富的操作库和工作流程定义</td>
<td>2019年</td>
</tr>
</tbody></table>
<h1 id="Git-Actions"><a href="#Git-Actions" class="headerlink" title="Git Actions"></a>Git Actions</h1><blockquote>
<p>GitHub Actions 是一种持续集成和持续交付 (CI&#x2F;CD) 平台，可用于自动执行生成、测试和部署管道。 您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。</p>
<p>GitHub Actions 不仅仅是 DevOps，还允许您在存储库中发生其他事件时运行工作流程。 例如，您可以运行工作流程，以便在有人在您的存储库中创建新问题时自动添加相应的标签。</p>
</blockquote>
<p>GitHub 提供 Linux、Windows 和 macOS 虚拟机来运行工作流程，或者您可以在自己的数据中心或云基础架构中托管自己的自托管运行器。</p>
<p>Git Actions是一个GitHub提供的持续集成和持续部署（CI&#x2F;CD）工具。它允许开发团队在代码存储库中配置自动化的工作流程，以响应不同的事件触发器。</p>
<p>使用Git Actions，您可以在代码提交、分支创建、问题提出等事件发生时触发自定义的工作流程。这些工作流程由一个或多个任务（称为“作业”）组成，可以在不同的操作系统和环境中执行，例如Linux、Windows、macOS等。每个作业可以包含多个步骤，用于执行特定的操作，例如构建项目、运行测试、部署应用程序等。</p>
<p>通过在存储库中创建一个名为<code>.github/workflows</code>的目录，并在其中定义一个或多个YAML文件，您可以配置Git Actions工作流程。这些YAML文件指定了工作流程的触发条件、作业和步骤，并可以使用丰富的内置操作和自定义脚本来执行各种任务。</p>
<p>Git Actions提供了强大的自动化能力，可以显著简化软件开发过程中的工作流程。它与GitHub的紧密集成使得团队可以更轻松地构建、测试和部署他们的应用程序，并且可以与其他工具和服务（如Docker、AWS、Azure等）无缝集成，以满足各种需求。</p>
<h1 id="Github-Actions-的原理"><a href="#Github-Actions-的原理" class="headerlink" title="Github Actions 的原理"></a>Github Actions 的原理</h1><p><img src="Snipaste_2023-08-18_03-04-03.png"></p>
<p>GitHub Actions的工作原理可以简单概括为以下几个步骤：</p>
<ol>
<li><p><strong>触发事件</strong>：GitHub Actions会根据代码库中的事件触发工作流程。事件可以是代码提交、分支创建、问题更新等，或者可以通过API手动触发。</p>
</li>
<li><p><strong>选择工作流程</strong>：一旦触发了事件，GitHub会根据库中的配置文件（例如<code>.github/workflows</code>目录下的YAML文件）来确定要执行的工作流程。一个库可以定义多个工作流程。</p>
</li>
<li><p><strong>创建作业（Jobs）</strong>：每个工作流程由一个或多个作业（job）组成。作业是指一系列要执行的任务。一个工作流程可以包含并行或顺序运行的多个作业。</p>
</li>
<li><p><strong>运行步骤（Steps）</strong>：每个作业由一个或多个步骤（step）组成。步骤是要在作业中执行的独立任务。每个步骤可以运行特定的命令、脚本或操作。</p>
</li>
</ol>
<p>在每个作业中，需要执行作业运行的执行环境（Runner），GitHub Actions提供了托管的执行环境（称为Runner），用于运行工作流程中的作业和步骤。Runner可以是GitHub托管的虚拟机器，也可以是自己托管的物理机器、虚拟机器或容器。</p>
<p>GitHub Actions会监视工作流程的执行，并生成相应的日志记录。开发者可以在Github项目的Action面板查看日志，了解每个步骤的执行情况，以及发现和解决任何潜在的问题。</p>
<h1 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h1><p>通过 Github 的 Actions 面板创建发布npm包的工作流配置模板。下面将通过这个模板，逐步了解配置文件的使用、相关语法以及相关知识。</p>
<p><img src="Snipaste_2023-08-18_09-50-26.png"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This workflow will run tests using node and then publish a package to GitHub Packages when a release is created</span></span><br><span class="line"><span class="comment"># For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">Package</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span> [<span class="string">created</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">publish-npm:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">          <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在工作流中，它会按顺序从上到下执行配置文件中的内容。</p>
<h2 id="name-Node-js-Package"><a href="#name-Node-js-Package" class="headerlink" title="name: Node.js Package"></a><code>name: Node.js Package</code></h2><p>工作流程的名称是”Node.js Package”。</p>
<h2 id="on-release"><a href="#on-release" class="headerlink" title="on: release"></a><code>on: release</code></h2><p>指定了触发工作流程的事件。在这种情况下，当创建一个新的发布时触发工作流程。</p>
<p>使用 <code>on</code> 监听工作流事件。</p>
<p>除了 <code>release</code> 事件外，Github Actions还支持其他更多的事件，详细参考：<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">Events that trigger workflows</a></p>
<p>在指定完事件后，还支持通过设置事件属性<code>types</code>继续细化地约束事件的触发条件，如上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">release:</span></span><br><span class="line">  <span class="attr">types:</span> [<span class="string">created</span>]</span><br></pre></td></tr></table></figure>

<p>指定了触发工作流程的发布类型。在这种情况下，只有在创建发布时才会触发工作流程。</p>
<p>在 <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">Events that trigger workflows</a> 中，可以查阅对应事件支持的 <code>types</code>（Activity types）：</p>
<p><img src="image.png" alt="release事件"></p>
<h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a><code>jobs</code></h2><p>定义了工作流程中的作业。</p>
<p>它是一个数组，成员是一系列具名的作业组成，比如上面的 <code>build</code> 和 <code>publish-npm</code></p>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h2><p><em>第一个作业的名称是”build”，用于构建和测试Node.js代码。</em></p>
<p>在这个作业中，分别定义了 <code>runs-on</code> 和 <code>steps</code> 两个属性。</p>
<p>作业的详细配置可参考：<a href="https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow">Using jobs in a workflow</a></p>
<h2 id="runs-on-ubuntu-latest"><a href="#runs-on-ubuntu-latest" class="headerlink" title="runs-on: ubuntu-latest"></a><code>runs-on: ubuntu-latest</code></h2><p><em>指定作业在Ubuntu操作系统上运行。</em></p>
<p>使用 <code>run-on</code> 指定作业运行的环境，</p>
<p>Github Actions支持的作业环境有下面这些，详细参考：<a href="https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job#choosing-github-hosted-runners">Choosing GitHub-hosted runners</a></p>
<table>
<thead>
<tr>
<th>Runner image</th>
<th>YAML workflow label</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Windows Server 2022</td>
<td><code>windows-latest</code> or <code>windows-2022</code></td>
<td>The windows-latest label currently uses the Windows Server 2022 runner image.</td>
</tr>
<tr>
<td>Windows Server 2019</td>
<td><code>windows-2019</code></td>
<td>None</td>
</tr>
<tr>
<td>Ubuntu 22.04</td>
<td><code>ubuntu-latest</code> or <code>ubuntu-22.04</code></td>
<td>The ubuntu-latest label currently uses the Ubuntu 22.04 runner image.</td>
</tr>
<tr>
<td>Ubuntu 20.04</td>
<td><code>ubuntu-20.04</code></td>
<td>None</td>
</tr>
<tr>
<td>macOS 13 Ventura <code>[Beta]</code></td>
<td><code>macos-13</code> or <code>macos-13-xl</code></td>
<td>None</td>
</tr>
<tr>
<td>macOS 12 Monterey</td>
<td><code>macos-latest</code>, <code>macos-12</code>, <code>macos-latest-xl</code> or <code>macos-12-xl</code></td>
<td>The macos-latest and macos-latest-xl workflow labels currently uses the macOS 12 runner image.</td>
</tr>
<tr>
<td>macOS 11 Big Sur</td>
<td><code>macos-11</code></td>
<td>None</td>
</tr>
</tbody></table>
<h2 id="steps"><a href="#steps" class="headerlink" title="steps"></a><code>steps</code></h2><p><em>定义了作业中的步骤。</em></p>
<p>在 GitHub Actions 中，steps 是一个用于定义工作流程中步骤的部分。steps 部分包含一个或多个步骤，每个步骤定义了要执行的特定任务或操作。</p>
<p>每个步骤由一个唯一的名称、一个或多个操作以及可选的其他属性组成。操作可以是官方操作、自定义操作或命令行命令。</p>
<p>在这个 <code>steps</code> 中，定义了4个数组元素，分别是两个 <code>uses</code> 和 两个 <code>run</code>:</p>
<ul>
<li><p><code>uses: actions/checkout@v3</code>：使用GitHub官方的”checkout”操作，用于检查代码库。</p>
</li>
<li><p><code>uses: actions/setup-node@v3</code>：使用GitHub官方的”setup-node”操作来设置Node.js运行时环境。</p>
<ul>
<li><code>with: node-version: 16</code>：指定要使用的Node.js版本为16。</li>
</ul>
</li>
<li><p><code>run: npm ci</code>：运行<code>npm ci</code>命令，用于安装项目的依赖项。</p>
</li>
<li><p><code>run: npm test</code>：运行<code>npm test</code>命令，用于运行测试。</p>
</li>
</ul>
<details open>
  <summary><strong>☕️ <code>npm ci</code> 是什么？</strong></summary>
  <blockquote>
    <br>
    <p><code>npm ci</code> 是 npm（Node Package Manager）命令的一种形式，用于执行项目的快速、干净的安装过程。它的作用如下：</p>
<ol>
<li><p><strong>确定性安装：</strong> <code>npm ci</code> 的主要目的是在项目中进行确定性的依赖项安装。它会根据 <code>package-lock.json</code>（或 <code>npm-shrinkwrap.json</code>）文件中记录的确切依赖项版本，安装项目所需的依赖项。这样可以确保在不同环境下的安装结果始终一致，减少了可能出现的依赖项版本冲突问题。</p>
</li>
<li><p><strong>忽略 package.json：</strong> 与 <code>npm install</code> 不同，<code>npm ci</code> 在安装依赖时忽略 <code>package.json</code> 文件，而是直接使用 <code>package-lock.json</code>（或 <code>npm-shrinkwrap.json</code>）作为依赖项清单。这样可以确保只安装指定版本的依赖项，而不考虑 <code>package.json</code> 中可能存在的不精确或不确定的版本范围。</p>
</li>
<li><p><strong>快速安装：</strong> <code>npm ci</code> 在执行时会进行一些优化，以提高安装速度。它会跳过创建或更新 <code>node_modules</code> 目录中的符号链接，而是直接将依赖项从 <code>package-lock.json</code>（或 <code>npm-shrinkwrap.json</code>）解析并安装到适当的位置。这种简化的安装过程使得安装速度更快。</p>
</li>
</ol>
<p>需要注意的是，<code>npm ci</code> 命令要求项目中必须存在 <code>package-lock.json</code>（或 <code>npm-shrinkwrap.json</code>）文件，以确保安装的依赖项版本的确定性。因此，它通常用于生产环境或持续集成（CI）环境中，以确保在不同的环境中构建和部署项目时使用相同的依赖项版本。对于开发环境，通常使用 <code>npm install</code> 命令来安装依赖项，以便可以更灵活地处理版本范围和开发依赖项的安装。</p>
    <br>
  </blockquote>
</details>


<h3 id="uses"><a href="#uses" class="headerlink" title="uses"></a><code>uses</code></h3><p>在 GitHub Actions 中，<code>uses</code> 是一个关键字，用于指定在工作流程中使用的操作（action）或容器（container）。它指定了要运行的操作或容器的位置，可以是一个 GitHub 存储库、一个公共操作或一个 Docker 容器。</p>
<p>使用 <code>uses</code> 可以通过以下方式指定操作或容器：</p>
<ol>
<li><p>GitHub 存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: &lt;owner&gt;/&lt;repo&gt;@&lt;ref&gt;</span><br></pre></td></tr></table></figure>

<p>这将从指定的 GitHub 存储库中获取操作或容器。<code>&lt;owner&gt;</code> 是存储库的所有者，<code>&lt;repo&gt;</code> 是存储库的名称，<code>&lt;ref&gt;</code> 是存储库的引用（分支、标签或提交哈希）。</p>
</li>
<li><p>公共操作（Public Actions）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: &lt;owner&gt;/&lt;repo&gt;/&lt;path&gt;@&lt;ref&gt;</span><br></pre></td></tr></table></figure>

<p>这将从 GitHub Marketplace 或其他公共存储库中获取公共操作。<code>&lt;owner&gt;</code> 是操作的所有者，<code>&lt;repo&gt;</code> 是存储库的名称，<code>&lt;path&gt;</code> 是操作的路径，<code>&lt;ref&gt;</code> 是操作的引用。</p>
</li>
<li><p>Docker 容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: docker://&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>这将从 Docker Hub 中获取指定的容器镜像。<code>&lt;image&gt;</code> 是容器镜像的名称，<code>&lt;tag&gt;</code> 是镜像的标签。</p>
</li>
</ol>
<p>例如，以下是使用 <code>uses</code> 指定操作或容器的示例：</p>
<ul>
<li><p>使用 GitHub 存储库中的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: actions/checkout@v3</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用公共操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: actions/setup-node@v3</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Docker 容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uses: docker://node:14</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些示例演示了如何在工作流程中使用 <code>uses</code> 来引用所需的操作或容器。在 <a href="https://github.com/marketplace?type=actions">Github Marketplace</a> 可以搜索相关的 actions，上面使用到的 <code>actions/checkout@v3</code> 和 <code>actions/setup-node@v3</code> 都是 Github 官方的 action，同样可以在 <a href="https://github.com/marketplace?type=actions">Github Marketplace</a> 中搜到。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h3><p>在 GitHub Actions 中，<code>run</code> 是一个用于执行命令或脚本的步骤。它允许你在工作流程中运行自定义的命令或脚本来完成特定的任务。</p>
<p>下面是一个使用 <code>run</code> 步骤的简单示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>run</code> 步骤被命名为 “Run a command”，并使用 <code>echo</code> 命令输出 “Hello, world!”。</p>
<p>你也可以运行多个命令或脚本，只需将它们放在同一个 <code>run</code> 步骤中，并使用换行符或分号进行分隔。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">multiple</span> <span class="string">commands</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      echo &quot;Command 1&quot;</span></span><br><span class="line"><span class="string">      echo &quot;Command 2&quot;</span></span><br><span class="line"><span class="string">      echo &quot;Command 3&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外，<code>run</code> 步骤还支持在不同的操作系统上运行不同的命令。你可以使用 <code>if</code> 条件来指定特定操作系统下要运行的命令。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">commands</span> <span class="string">based</span> <span class="string">on</span> <span class="string">the</span> <span class="string">operating</span> <span class="string">system</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      if [ &quot;$OSTYPE&quot; == &quot;linux-gnu&quot; ]; then</span></span><br><span class="line"><span class="string">        echo &quot;Running on Linux&quot;</span></span><br><span class="line"><span class="string">        # Linux commands here</span></span><br><span class="line"><span class="string">      elif [ &quot;$OSTYPE&quot; == &quot;darwin&quot;* ]; then</span></span><br><span class="line"><span class="string">        echo &quot;Running on macOS&quot;</span></span><br><span class="line"><span class="string">        # macOS commands here</span></span><br><span class="line"><span class="string">      else</span></span><br><span class="line"><span class="string">        echo &quot;Running on Windows&quot;</span></span><br><span class="line"><span class="string">        # Windows commands here</span></span><br><span class="line"><span class="string">      fi</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据操作系统类型运行不同的命令。</p>
<h2 id="needs-build"><a href="#needs-build" class="headerlink" title="needs: build"></a><code>needs: build</code></h2><p>在 GitHub Actions 中，needs 是一个用于指定工作流程中步骤之间依赖关系的关键字。它允许你定义一个步骤需要依赖其他步骤的完成状态，以确保正确的顺序和并发控制。</p>
<p>通过使用 needs，你可以指定一个步骤依赖于另一个或多个步骤。这意味着，只有在所依赖的步骤执行成功后，才会执行当前步骤。</p>
<p>通过使用 needs 关键字，你可以控制步骤之间的执行顺序，并确保依赖关系正确地处理。这对于有多个步骤需要按照特定顺序执行的复杂工作流程非常有用。</p>
<p><code>needs: build</code> 被定义在第二个作业<code>publish-npm</code>，含义即是这个作业依赖前面的 <code>build</code> 作业。</p>
<p>以下是一个示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;This is step 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;This is step 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，Step 2 步骤使用 needs 关键字指定它依赖于 Step 1 步骤。这意味着只有在 Step 1 执行成功后，才会执行 Step 2。</p>
<p>你还可以指定多个依赖项，以确保多个步骤的完成状态。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;This is step 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;This is step 2&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">needs:</span> [<span class="string">Step</span> <span class="number">1</span>, <span class="string">Step</span> <span class="number">2</span>]</span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;This is step 3&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，Step 3 步骤指定它依赖于 Step 1 和 Step 2 步骤。只有在这两个步骤成功完成后，才会执行 Step 3。</p>
<h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>设置一个名为 <code>NODE_AUTH_TOKEN</code> 的环境变量，该变量的值从 GitHub 存储库的 secrets 中获取。这个令牌用于进行身份验证，以便将包发布到npm注册表。</em></p>
<p>在 GitHub Actions 中，<code>env</code> 是一个用于定义环境变量的关键字。通过在工作流程中使用 <code>env</code>，你可以设置和传递环境变量给步骤，以供步骤中的命令或操作使用。</p>
<p>以下是一个示例，演示如何在步骤中使用 <code>env</code> 定义环境变量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">environment</span> <span class="string">variables</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">ENV_VAR1:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">      <span class="attr">ENV_VAR2:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Environment variables are set&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>env</code> 部分定义了两个环境变量 <code>ENV_VAR1</code> 和 <code>ENV_VAR2</code>，分别设置为 <code>&quot;value1&quot;</code> 和 <code>&quot;value2&quot;</code>。<code>run</code> 步骤中的命令可以使用这些环境变量。</p>
<p>你可以在同一个步骤中定义多个环境变量，通过键值对的形式指定变量名和值。这些环境变量在步骤中的所有命令或操作中都可用。你还可以在不同的步骤中定义和使用环境变量。</p>
<p>以下示例演示了在不同步骤中使用环境变量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">environment</span> <span class="string">variables</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">ENV_VAR1:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Environment variable ENV_VAR1 is set&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">environment</span> <span class="string">variable</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;The value of ENV_VAR1 is $<span class="template-variable">&#123;&#123; env.ENV_VAR1 &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，第一个步骤设置了环境变量 <code>ENV_VAR1</code>，第二个步骤使用了该环境变量并打印出其值。</p>
<p>使用环境变量可以方便地传递配置信息、密钥、API 凭据等敏感或特定于环境的值，从而使你的工作流程更灵活和可配置。</p>
<p>需要注意的是，环境变量的值可以通过 <code>$&#123;&#123; ... &#125;&#125;</code> 语法进行引用。在表达式中使用 <code>env</code> 关键字和点表示法来引用特定的环境变量值。例如，<code>$&#123;&#123; env.ENV_VAR1 &#125;&#125;</code> 表示引用 <code>ENV_VAR1</code> 环境变量的值。</p>
<p>通过使用 <code>env</code> 关键字，你可以在 GitHub Actions 的工作流程中轻松定义和使用环境变量。</p>
<h2 id="secrets-npm-token"><a href="#secrets-npm-token" class="headerlink" title="secrets.npm_token"></a>secrets.npm_token</h2><p>在 <code>$&#123;&#123; secrets.npm_token &#125;&#125;</code> 中，secrets 是一个表示 GitHub 仓库 “Secrets” 的对象，npm_token 是你在 “Secrets” 中定义的一个具体的密钥。</p>
<p>需要注意的是，<code>$&#123;&#123; secrets.npm_token &#125;&#125;</code> 只能在 GitHub Actions 的上下文中使用，而不能在其他环境中直接使用。它是 GitHub Actions 提供的一种安全访问敏感信息的方式。</p>
<p>这个 npm_token 并非自动生成的（GITHUB_TOKEN是自动生成的）。它需要你在当前项目的setting中配置名为 npm_token 的secrets变量，变量值则是从npm中获取。</p>
<p><img src="Snipaste_2023-08-18_16-31-22.png"></p>
<p>值得注意的是，<code>secrets</code> 是 Github Actions 提供的 Contexts （上下文）之一，除了它之外还有更多，比如 <code>github</code>，它可以获取工作流程中任何作业或步骤期间可用的顶层上下文，通过 <code>github.workflow</code> 可以获取工作流的名称，更多的 Contexts 可以参考：<a href="https://docs.github.com/zh/actions/learn-github-actions/contexts">GitHub Actions &#x2F; Learn GitHub Actions &#x2F; Contexts</a></p>
<table>
<thead>
<tr>
<th>上下文名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>github</code></td>
<td><code>object</code></td>
<td>工作流程运行的相关信息。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#github-context">github 上下文</a>。</td>
</tr>
<tr>
<td><code>env</code></td>
<td><code>object</code></td>
<td>包含工作流、作业或步骤中设置的变量。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#env-context">env 上下文</a>。</td>
</tr>
<tr>
<td><code>vars</code></td>
<td><code>object</code></td>
<td>包含存储库、组织或环境级别设置的变量。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#vars-context">vars 上下文</a>。</td>
</tr>
<tr>
<td><code>job</code></td>
<td><code>object</code></td>
<td>有关当前运行的作业的信息。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#job-context"><code>job</code> 上下文</a>。</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td><code>object</code></td>
<td>仅适用于可重用工作流，包含可重用工作流中的作业输出。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#jobs-context">jobs 上下文</a>。</td>
</tr>
<tr>
<td><code>steps</code></td>
<td><code>object</code></td>
<td>有关当前作业中已运行的步骤的信息。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#steps-context">steps 上下文</a>。</td>
</tr>
<tr>
<td><code>runner</code></td>
<td><code>object</code></td>
<td>有关运行当前作业的运行器的信息。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#runner-context">runner 上下文</a>。</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td><code>object</code></td>
<td>包含可用于工作流运行的机密的名称和值。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#secrets-context">secrets 上下文</a>。</td>
</tr>
<tr>
<td><code>strategy</code></td>
<td><code>object</code></td>
<td>有关当前作业的矩阵执行策略的信息。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#strategy-context">strategy 上下文</a>。</td>
</tr>
<tr>
<td><code>matrix</code></td>
<td><code>object</code></td>
<td>包含在工作流中定义的应用于当前作业的矩阵属性。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#matrix-context">matrix 上下文</a>。</td>
</tr>
<tr>
<td><code>needs</code></td>
<td><code>object</code></td>
<td>包含定义为当前作业依赖项的所有作业的输出。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#needs-context">needs 上下文</a>。</td>
</tr>
<tr>
<td><code>inputs</code></td>
<td><code>object</code></td>
<td>包含可重用或手动触发的工作流的输入。有关更多信息，请参阅 <a href="https://docs.github.com/zh/actions/learn-github-actions/contexts#inputs-context">inputs 上下文</a>。</td>
</tr>
</tbody></table>
<h2 id="监视与故障排查"><a href="#监视与故障排查" class="headerlink" title="监视与故障排查"></a>监视与故障排查</h2><p>参考：<a href="https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/about-monitoring-and-troubleshooting">https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/about-monitoring-and-troubleshooting</a></p>
<p><img src="Snipaste_2023-08-19_10-22-00.png"></p>
<p>在 GitHub 仓库页面的 “Actions” 选项卡中，你可以访问 GitHub Actions Dashboard。在 Dashboard 上，你可以查看最近执行的工作流程列表。点击工作流程进入详细页面后，你将看到工作流程的执行历史和每个作业的执行状态。</p>
<h2 id="执行日志"><a href="#执行日志" class="headerlink" title="执行日志"></a>执行日志</h2><p>GitHub Actions 会为每个工作流程和作业生成执行日志。你可以查看执行日志以了解工作流程的执行情况、步骤的输出和错误信息。执行日志可以帮助你快速定位问题并进行故障排查。</p>
<p>每个步骤和作业都有一个状态，可以指示其执行结果。你可以检查每个步骤和作业的状态以确定是否成功完成。如果有步骤或作业失败，你可以查看相关的错误信息和日志以找出问题所在。</p>
<p><img src="Snipaste_2023-08-19_10-29-37.png" alt="workflow log"></p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>下面将创建工作流将源码打包并发布到npm，为此会创建工作流配置文件。通过推送新tag到github创库触发工作流。在工作流中会做以下几件事：</p>
<ol>
<li><p>build 源码，生成用于发布的代码包；</p>
</li>
<li><p>发布到npm；</p>
</li>
</ol>
<h2 id="配置触发事件"><a href="#配置触发事件" class="headerlink" title="配置触发事件"></a>配置触发事件</h2><p>首先，在项目目录下创建工作流配置文件 <code>.github/workflows/npm-publish.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">create:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>当创建一个新的 Git 标签时，将会触发该工作流程。而在tags部分，”*”表示适用于所有的标签。换句话说，无论创建什么样的标签，都会触发该工作流程的执行</p>
<h2 id="添加-build-作业"><a href="#添加-build-作业" class="headerlink" title="添加 build 作业"></a>添加 build 作业</h2><p>添加 build 作业，安装前置依赖，然后执行build脚本，打包源码。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">node</span> <span class="string">./scripts/build.js</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>指定了执行环境，前置安装了 <code>pnpm</code>，可见作业中，各个步骤默认是同步而非异步执行；</p>
</li>
<li><p>指定了node版本；</p>
</li>
<li><p>执行了 <code>./scripts/build.js</code>，将源码打包至 <code>./dist</code></p>
</li>
</ul>
<h2 id="添加-publish-npm-作业"><a href="#添加-publish-npm-作业" class="headerlink" title="添加 publish-npm 作业"></a>添加 publish-npm 作业</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publish-npm:</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">        <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">artifact</span> <span class="string">to</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npx</span> <span class="string">isubo-publish</span> <span class="string">--skin-login</span> <span class="string">--skin-build</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>声明依赖build作业；</p>
</li>
<li><p>使用 isubo-publish 发布在 <code>./dist</code> 的包。<code>isubo-publish</code> 是 cli 工具，它默认以<code>./dist</code>作为工作目录，可以解析<code>package.json</code>的 <code>version</code>值，生成发布命令并执行，例如 <code>version: &quot;0.0.1-alpha.0&quot;</code> 将会生成 <code>npm publish --tag alpha</code>。它默认会执行 <code>npm login</code> 登录，以及执行在 <code>package.json</code>中的<code>scripts.build</code>脚本，因此增加了两个相关的<code>skin</code>可选项。</p>
</li>
</ul>
<h2 id="添加-npm-token"><a href="#添加-npm-token" class="headerlink" title="添加 npm_token"></a>添加 npm_token</h2><p>在 publish-npm作业 中使用了 <code>secrets.npm_token</code>，这个 <code>secrets</code> 有别于 <code>GITHUB_TOKEN</code>，需要手动添加这个变量。</p>
<p>首先，是获得 npm 的 Access Tokens</p>
<p><img src="Snipaste_2023-08-19_18-55-58.png"></p>
<p>接着，配置<code>secrets.npm_token</code>变量</p>
<p><img src="Snipaste_2023-08-18_16-31-22.png"></p>
<h2 id="推送-git-tag"><a href="#推送-git-tag" class="headerlink" title="推送 git-tag"></a>推送 git-tag</h2><p><img src="Snipaste_2023-08-19_20-34-36.png" alt="push tag"></p>
<p><img src="Snipaste_2023-08-19_19-18-41.png" alt="publish-npm"></p>
<p>从提示来看，没有安装 <code>isubo-publish</code> 包。在build作业的依赖安装并没有在publish-npm作业中发挥作用，看来在依赖安装上，两个作业之间是相互独立的。</p>
<h2 id="添加手动触发"><a href="#添加手动触发" class="headerlink" title="添加手动触发"></a>添加手动触发</h2><p>为了方便调试，增加手动触发工作流的事件。默认情况下 Github 没有提供手动触发的入口，需要在配置文件中添加 <a href="https://docs.github.com/zh/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch"><code>workflow_dispatch</code> 事件</a>。</p>
<p>在推送配置文件后，Github 仓库的 Actions 卡片，对应工作流面板便会出现 <code>Run workflow</code> 按钮，见下入，如此便无需重复创建 git-tag 以触发工作流。</p>
<p><img src="Snipaste_2023-08-19_13-52-51.png"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="string">+</span> <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">create:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="添加依赖安装步骤"><a href="#添加依赖安装步骤" class="headerlink" title="添加依赖安装步骤"></a>添加依赖安装步骤</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publish-npm:</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">        <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">artifact</span> <span class="string">to</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npx</span> <span class="string">isubo-publish</span> <span class="string">--skin-login</span> <span class="string">--skin-build</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>出现新的问题，在build作业中，将源码打包到了<code>./dist</code>目录。工作流执行到publish-npm的<code>npx isubo-publish --skin-login --skin-build</code>命令时，提示缺少<code>./dist</code>目录了。</p>
<p>看起来是和上面的问题一样，作业间的独立性！</p>
<p><img src="Snipaste_2023-08-19_18-24-50.png" alt="publish-npm"></p>
<h2 id="共享作业产物"><a href="#共享作业产物" class="headerlink" title="共享作业产物"></a>共享作业产物</h2><p>需要让两个作业共享dist的产物，或者将两个作业合并为一个。合并在实践的目的下是下策，先尝试前者。我想到的是“定义作业的输出”</p>
<p>在 build 作业中定义 <code>outputs</code>，然后在 publish-npm 作业中获取。</p>
<p>下面是官网文档给出的示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># Map a step output to a job output</span></span><br><span class="line">    <span class="attr">outputs:</span></span><br><span class="line">      <span class="attr">output1:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step1.outputs.test</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">output2:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step2.outputs.test</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">step1</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;test=hello&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">&quot;$GITHUB_OUTPUT&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">step2</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;test=world&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">&quot;$GITHUB_OUTPUT&quot;</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">          <span class="attr">OUTPUT1:</span> <span class="string">$&#123;&#123;needs.job1.outputs.output1&#125;&#125;</span></span><br><span class="line">          <span class="attr">OUTPUT2:</span> <span class="string">$&#123;&#123;needs.job1.outputs.output2&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;$OUTPUT1 $OUTPUT2&quot;</span></span><br></pre></td></tr></table></figure>

<p>从示例来看，<code>outputs</code> 保存的像是字符串。</p>
<blockquote>
<p>可以使用 <code>jobs.&lt;job_id&gt;.outputs</code> 为作业创建输出的 map。 作业输出可用于所有依赖此作业的下游作业。 有关定义作业依赖项的详细信息，请参阅 <code>jobs.&lt;job_id&gt;.needs</code>。</p>
<p>输出是 Unicode 字符串，最大为 1 MB。 工作流运行中所有输出的总和最大为 50 MB。</p>
</blockquote>
<p>从上面的官网信息可知，单个output的存储量仅仅1MB，这不满足上面<code>./dist</code>大小，并且实际上<code>./dist</code>是目录而非单个压缩文件，要写入单个标量显然不容易！</p>
<p>得改用其他方案。文档中有提到“<a href="https://docs.github.com/zh/actions/learn-github-actions/essential-features-of-github-actions#sharing-data-between-jobs">工作流程级别的共享文件（Artifacts）</a>”！</p>
<ul>
<li><p><strong><a href="https://github.com/marketplace/actions/upload-a-build-artifact">Upload-Artifact</a></strong>: 这将上传工作流程的产物，允许您在作业之间共享数据，并在工作流程完成后存储数据。</p>
<blockquote>
<p><img src="Snipaste_2023-08-20_20-48-09.png"></p>
</blockquote>
<p>Upload an Entire Directory:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-artifact</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">path/to/artifact/</span> <span class="comment"># or path/to/artifact</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><a href="https://github.com/marketplace/actions/download-a-build-artifact">Download-Artifact</a></strong>: 这将从您的构建中下载产物。</p>
<blockquote>
<p><img src="Snipaste_2023-08-20_20-49-48.png"></p>
</blockquote>
<p>Download to a specific directory:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/download-artifact@v3</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my-artifact</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">path/to/artifact</span></span><br><span class="line">      </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Display</span> <span class="string">structure</span> <span class="string">of</span> <span class="string">downloaded</span> <span class="string">files</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">ls</span> <span class="string">-R</span></span><br><span class="line">    <span class="attr">working-directory:</span> <span class="string">path/to/artifact</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>分别添加上面 2 个 actions 到 build 和 publish-npm 作业。</em></p>
<h3 id="修改-build-作业"><a href="#修改-build-作业" class="headerlink" title="修改 build 作业"></a>修改 build 作业</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">node</span> <span class="string">./scripts/build.js</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">with:</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">path:</span> <span class="string">./dist</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-publish-npm-作业"><a href="#修改-publish-npm-作业" class="headerlink" title="修改 publish-npm 作业"></a>修改 publish-npm 作业</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publish-npm:</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">        <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">uses:</span> <span class="string">actions/download-artifact@v3</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">with:</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">path:</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">artifact</span> <span class="string">to</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npx</span> <span class="string">isubo-publish</span> <span class="string">--skin-login</span> <span class="string">--skin-build</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="上传-artifact-成功"><a href="#上传-artifact-成功" class="headerlink" title="上传 artifact 成功"></a>上传 artifact 成功</h3><p><img src="Snipaste_2023-08-20_02-15-28.png" alt="Upload build artifact"></p>
<h3 id="下载-artifact-成功"><a href="#下载-artifact-成功" class="headerlink" title="下载 artifact 成功"></a>下载 artifact 成功</h3><p><img src="Snipaste_2023-08-20_02-14-17.png" alt="Download build artifact"></p>
<h3 id="发布成功"><a href="#发布成功" class="headerlink" title="发布成功"></a>发布成功</h3><p><img src="Snipaste_2023-08-20_02-38-41.png" alt="Publish artifact to npm"></p>
<p><img src="Snipaste_2023-08-20_02-39-58.png" alt="Artifact in npm"></p>
<h3 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">Package</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">create:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">artifact</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">node</span> <span class="string">./scripts/build.js</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">publish-npm:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">          <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/download-artifact@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">artifact</span> <span class="string">to</span> <span class="string">npm</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npx</span> <span class="string">isubo-publish</span> <span class="string">--skin-login</span> <span class="string">--skin-build</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="优化依赖安装"><a href="#优化依赖安装" class="headerlink" title="优化依赖安装"></a>优化依赖安装</h2><p>在上面实践中可以看到，build 作业和 publish-npm 作业重复安装 pnpm 和 package.json 中的依赖。</p>
<p>下面将使用 actions&#x2F;cache 在作业 build 缓存依赖，然后在 publish-npm 作业中直接使用缓存的依赖。以此，避免重复的安装，从而加快工作流的进度。</p>
<blockquote>
<p><img src="Snipaste_2023-08-20_20-45-58.png"></p>
</blockquote>
<h3 id="build-作业缓存依赖"><a href="#build-作业缓存依赖" class="headerlink" title="build 作业缓存依赖"></a>build 作业缓存依赖</h3><ul>
<li><p>合并pnpm与依赖的安装；</p>
</li>
<li><p>缓存依赖；</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"><span class="bullet">-</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line"><span class="bullet">-</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet">-</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="bullet">-</span>     <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span> <span class="string">&amp;&amp;</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">dependencies</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">with:</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">path:</span> <span class="string">./node_modules</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;./pnpm-lock.yaml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">node</span> <span class="string">./scripts/build.js</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">./dist</span></span><br></pre></td></tr></table></figure>

<h3 id="publish-npm-作业使用缓存"><a href="#publish-npm-作业使用缓存" class="headerlink" title="publish-npm 作业使用缓存"></a>publish-npm 作业使用缓存</h3><ul>
<li><p>删除原有的依赖安装；</p>
</li>
<li><p>命中缓存，恢复依赖；</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publish-npm:</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">        <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pnpm</span></span><br><span class="line"><span class="bullet">-</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet">-</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="bullet">-</span>     <span class="attr">run:</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restore</span> <span class="string">dependencies</span> <span class="string">cache</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">with:</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">path:</span> <span class="string">./node_modules</span></span><br><span class="line"><span class="string">+</span>       <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;./pnpm-lock.yaml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/download-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">artifact</span> <span class="string">to</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npx</span> <span class="string">isubo-publish</span> <span class="string">--skin-login</span> <span class="string">--skin-build</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="publish-npm-作业的日志"><a href="#publish-npm-作业的日志" class="headerlink" title="publish-npm 作业的日志"></a>publish-npm 作业的日志</h3><p>下面是 publish-npm 作业的日志截图。</p>
<p>可以看到在“Restore dependencies cache”中，依赖被成功从缓存中恢复。在 “Publish artifact to npm” 中，<code>isubo-publish</code> 被正常使用无异常。</p>
<p><img src="Snipaste_2023-08-20_20-42-23.png" alt="Restore dependencies cache"></p>
<h3 id="减少依赖重复安装"><a href="#减少依赖重复安装" class="headerlink" title="减少依赖重复安装"></a>减少依赖重复安装</h3><p>从上面的工作流配置中，可以看到，build 作业每次执行都会安装依赖，然后再缓存依赖以供 publish-npm 作业使用。接下来是优化 build 作业的安装，让 build 作业也可以使用缓存。</p>
<blockquote>
<p><strong>Skipping steps based on cache-hit</strong><br>Using the <mark>cache-hit</mark> output, subsequent steps (such as install or build) can be skipped when a cache hit occurs on the key. It is recommended to install missing&#x2F;updated dependencies in case of a partial key match when the key is dependent on the hash of the package file.</p>
<p>Example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">path/to/dependencies</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/lockfiles&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">  <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">/install.sh</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>从 <a href="https://github.com/marketplace/actions/cache">actions&#x2F;cache &gt; Skipping steps based on cache-hit</a> 中知道，可以通过判断 <code>cache-hit</code> 是否为 <code>&#39;true&#39;</code> 来判断缓存可用与否。缓存可用的话就可以跳过依赖的安装！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="bullet">-</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span> <span class="string">&amp;&amp;</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">dependencies</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">id:</span> <span class="string">cache-dependencies</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">./node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;./pnpm-lock.yaml&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span>   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">if:</span> <span class="string">steps.cache-dependencies.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">pnpm</span> <span class="string">&amp;&amp;</span> <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">node</span> <span class="string">./scripts/build.js</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">build</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">build-artifact</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">./dist</span></span><br></pre></td></tr></table></figure>

<p>从 build 作业的日志可见：</p>
<ul>
<li><p><code>Cache dependencies</code> 步骤中，由于前面几次的工作流执行已经缓存依赖，因此当前依赖如期从缓存中恢复；</p>
</li>
<li><p><code>Install dependencies</code> 步骤已经被跳过。尽管跳过，但整个作业是完成的，因此从缓存中恢复的依赖确实有效。</p>
</li>
</ul>
<p><img src="Snipaste_2023-08-20_21-42-41.png" alt="Using cache for build job"></p>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><ul>
<li><p><a href="https://docs.github.com/zh/actions/learn-github-actions/expressions">表达式</a></p>
</li>
<li><p><a href="https://docs.github.com/zh/actions/guides#%E6%89%98%E7%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%90%E8%A1%8C%E5%99%A8">托管自己的运行器</a></p>
</li>
<li><p><a href="https://docs.github.com/zh/actions/guides#%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C">创建操作</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GitHub Actions 是 GitHub 的持续集成和持续部署(CI&#x2F;CD)平台，允许开发者在 GitHub 上自动化他们的软件开发工作流程。它众多常见的 CI&#x2F;CD 平台之一，比如Jenkins、Travis CI、CircleCI等等。</p>
<p>要使用这个能力需要在项目根目录下创建 <code>.github/workflows</code> 目录，并在此目录中添加 yml 后缀的配置文件。</p>
<p>在配置文件中需要配置触发条件，以及自动化逻辑。</p>
<p>触发条件通过 <code>on</code> 属性声明监听事件定义，Github 有多种事件供使用，比如上文中的 <code>workflow_dispatch</code>、<code>create</code>事件， 它们可以在 <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">Events that trigger workflows</a> 中查阅。</p>
<p>自动化逻辑由一个或多个作业（job）组成，作业则是由一个或多个步骤（step）组成。每个作业都是相对独立的存在，作业中需要使用 <code>run-on</code> 指定运行环境，Github 提供了一系列可供使用的环境，比如上文中的 <code>ubuntu-latest</code>，更多可查阅 <a href="https://docs.github.com/zh/actions/using-jobs/choosing-the-runner-for-a-job#%E9%80%89%E6%8B%A9-github-%E6%89%98%E7%AE%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E5%99%A8">选择 GitHub 托管的运行器</a>。作业下的步骤在所指定的环境执行。作业和步骤在默认情况下都是自上向下同步执行。在作业中，可以定义自动化的细节，比如通过 <code>uses</code> 调用 actions，actions 是官方或第三方发布的工作自动化逻辑；通过 <code>run</code> 调用 shell 命令或自定义的脚本。</p>
<p>从上文中，先是通过一个例子展开，了解工作流配置的构成。除了上面的基本概念外，还了解到环境变量、上下文、密钥的配置和使用、工作流的监视和执行日志的查看。</p>
<p>然后实践工作流的使用，通过工作流build源码，并将源码发布到npm。在实践中，配置个人访问令牌以发布源码；使用<code>actions/upload-artifact</code> 和 <code>actions/download-artifact</code> 两个 actions实现作业间共享目录；添加 <code>actions/cache</code> actions 缓存依赖，从而优化工作流执行速度。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.github.com/zh/actions/learn-github-actions/essential-features-of-github-actions">GitHub Actions 的基本功能</a></li>
<li><a href="https://docs.github.com/zh/actions/learn-github-actions/expressions">表达式</a></li>
<li><a href="https://docs.github.com/zh/actions/learn-github-actions/contexts">上下文</a></li>
<li><a href="https://docs.github.com/zh/actions/using-workflows/triggering-a-workflow">触发工作流程</a></li>
<li><a href="https://docs.github.com/zh/actions/using-workflows/manually-running-a-workflow">手动运行工作流程</a></li>
<li><a href="https://docs.github.com/zh/actions/using-workflows/events-that-trigger-workflows">触发工作流的事件</a></li>
<li><a href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions">GitHub Actions 的工作流语法</a></li>
<li><a href="https://docs.github.com/zh/actions/using-jobs/choosing-the-runner-for-a-job">选择作业的运行器</a></li>
<li><a href="https://docs.github.com/zh/actions/using-jobs/using-conditions-to-control-job-execution">使用条件控制作业执行</a></li>
<li><a href="https://docs.github.com/zh/actions/publishing-packages/publishing-nodejs-packages">发布 Node.js 包</a></li>
<li><a href="https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/using-the-visualization-graph">使用可视化图表</a></li>
<li><a href="https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs">使用工作流运行日志</a></li>
<li><a href="https://github.com/marketplace/actions/upload-a-build-artifact">Marketplace &#x2F; Actions &#x2F; Upload a Build Artifact</a></li>
<li><a href="https://github.com/marketplace/actions/download-a-build-artifact">Marketplace &#x2F; Actions &#x2F; Download a Build Artifact</a></li>
<li><a href="https://github.com/marketplace/actions/cache">Marketplace &#x2F; Actions &#x2F; Cache</a></li>
<li><a href="https://docs.github.com/zh/actions/learn-github-actions/essential-features-of-github-actions#sharing-data-between-jobs">在作业之间共享数据</a></li>
<li><a href="https://docs.github.com/zh/actions/using-workflows/caching-dependencies-to-speed-up-workflows">缓存依赖项以加快工作流程</a></li>
</ul>

]]></content>
      <categories>
        <category>CI/CD</category>
        <category>程序员手册</category>
      </categories>
      <tags>
        <tag>Github Actions</tag>
        <tag>自动化发布node.js</tag>
        <tag>入门指南</tag>
        <tag>actions/cache</tag>
        <tag>actions/upload-artifact</tag>
        <tag>actions/download</tag>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化CHANGELOG，持续集成</title>
    <url>/blog/resources/Automated-Changelog-Manual/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发使用 Github Issue 编写 blog 的项目。目前还在持续开发中，已经 300+ commits，npm 上已经发布的版本迭代有 9个。后面仍然会继续维护，有许多准备增加的能供，需要优化的点，以及已知的需要重构的逻辑，应该还会有相当的bug需要修复。</p>
<p>抱着负责任的态度，个人认为需要一个渠道使得 Isubo 的使用者获知这些一系列的变动。因此，需要编写 CHANGELOG 记录每个项目版本的变动。</p>
<p>但是，由于目前还是一个人在开发此项目，精力有限，需要更多地聚焦在功能新增、优化、重构和Bug修复。</p>
<p><em>CHANGELOG 自动化是最终的答案！</em></p>
<span id="more"></span>

<h2 id="自动化的优点"><a href="#自动化的优点" class="headerlink" title="自动化的优点"></a>自动化的优点</h2><ul>
<li><p><strong>简化了 changelog 的创建流程</strong>：手动创建 changelog 可能需要花费大量的时间和精力，特别是对于大型项目来说。自动化创建 changelog 可以减少这种繁琐的工作，允许开发者更专注于编写代码和解决问题。</p>
</li>
<li><p><strong>提高了 changelog 的准确性</strong>：手动创建 changelog 可能会出现遗漏或错误，因为开发者需要手动记录每个版本的更改。自动化创建 changelog 可以消除这些错误，因为它们会自动从版本控制系统中提取信息。</p>
</li>
<li><p><strong>帮助团队更好地协作</strong>：自动化创建 changelog 可以帮助团队更好地协作和沟通。开发者可以更轻松地了解项目的演变历史和当前状态，从而更好地协调和分配任务。</p>
</li>
<li><p><strong>提高了项目的可维护性</strong>：自动化创建 changelog 可以提高项目的可维护性。由于 changelog 可以自动生成，因此开发者可以更容易地了解每个版本的更改，从而更好地维护和更新代码。</p>
</li>
</ul>
<p>总之，自动化创建 changelog 可以提高项目的开发效率、降低错误率、加强团队协作，从而提高项目的可维护性和稳定性。</p>
<h2 id="CHANGELOG-的预期"><a href="#CHANGELOG-的预期" class="headerlink" title="CHANGELOG 的预期"></a>CHANGELOG 的预期</h2><p>页面是列表的结构，列表的子项是版本变动说明。下面是子项的结构：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">// 标题</span><br><span class="line"><span class="section"># 版本号-1</span></span><br><span class="line"></span><br><span class="line">// 内容</span><br><span class="line"><span class="bullet">-</span> 新增的功能 1</span><br><span class="line"><span class="bullet">-</span> 修复的bug</span><br><span class="line"><span class="bullet">-</span> 优化</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure>

<p>主要由标题和内容两部分构成：</p>
<ul>
<li>标题：版本号</li>
<li>内容：子列表描述变动，包含但不限于功能新增、Bug修复等等</li>
</ul>
<h2 id="自动化思路"><a href="#自动化思路" class="headerlink" title="自动化思路"></a>自动化思路</h2><p><strong>1. Commits 规范</strong></p>
<p>所谓巧妇难为无米之炊，所以得先有“米”才有 CHANGELOG，这里的“米”就是commits。</p>
<p>既然要描述新增的功能、修复的bug 和 优化等不同类型的实现，那些就要让这些实现对应的 commits 符合规范。</p>
<p>因此，第一步是了解现有那些 commits 的规范。选择需要遵循的规范或者基于它们指定符合预期的规范。</p>
<p><em>下面将分别详细介绍：Angular规范、Conventional Commits规范 和 Gitmoji规范。</em></p>
<p><strong>2. 约束 Commit 编写</strong></p>
<p>既有规范，则需要有 commit msg 的校验逻辑。使用 <code>git-hooks</code> 钩子拦截开发者输入的 commit msg，然后对其进行校验，打回或通过后提交commit到 <code>git-log</code>。</p>
<p><em>下文将使用 husky 拦截 <code>commit-msg</code> 钩子，然后使用 <code>Commitlint</code> 校验。</em></p>
<p><strong>3. 优化 Commit 编写</strong></p>
<p>校验终归是校验而已。如果对所遵循的规范不熟悉，编写格式正确的 commit 存在一定的心智成本。或许该增加辅助工具降低心智成本，无需数值规范，按着步骤输入即可。</p>
<p><em>下文将分别介绍 2 款 prompt 工具辅助commit的编写，它们分别是 <a href="https://www.npmjs.com/package/@commitlint/prompt-cli">@commitlint&#x2F;prompt-cli ↗</a> 和 <a href="cz-cli">Commitizen ↗</a>。</em></p>
<p><strong>4. 版本管理</strong></p>
<p>CHANGELOG 的生成节点是版本的创建。由创建版本这个行为，产生 CHANGELOG 这个结果，因此得先处理如何进行版本管理这个问题。</p>
<p>制定合理的版本管理策略前，同样需要了解现有的版本管理规范，在前人路上汲取养分。同样是需要工具去约束，以版本创建的结果符合规范。</p>
<p><em>下文将介绍SemVer规范，版本管理工具 <code>npm-version</code> 和 <code>standard-version</code>。包含2个工具的使用和各自工作的生命周期</em></p>
<p><strong>5. CHANGELOG自动化</strong></p>
<p>结合前面提到的 2 个版本管理工具，利用它们各自的生命周期，适时触发 CHANGELOG 的生成。</p>
<p><code>standard-version</code> 的功能不限于版本管理，还兼具 CHANGELOG 的生成。以及与 <code>standard-version</code> 来自同一个工具集的 <code>conventional-changelog-cli</code>。2 个都是比较常用的工具。</p>
<p><em>下文将 <a href="#CHANGELOG%E8%87%AA%E5%8A%A8%E5%8C%96">CHANGELOG自动化</a> 详细价绍它们的安装、使用、配置。</em></p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><em>1. 基于 main 分支创建 develop 分支（feat&#x2F;xxx、fix&#x2F;xxx、…）；</em></p>
<p><em>2. commit 变动；</em></p>
<p><em>3. develop 分支内容开发完成，push分支；</em></p>
<p><em>4. 合并 develop 分支，触发 <code>post-merge</code> Git 钩子；</em></p>
<p><em>5. 创建版本、创建 git-tag 和生成 CHANGELOG</em></p>
<p><em>6. 发布 git-tag 和 CHANGELOG 变动、build 源码并发布至 npm</em></p>
<h1 id="Git-Commit-规范"><a href="#Git-Commit-规范" class="headerlink" title="Git Commit 规范"></a>Git Commit 规范</h1><p>首先要解决的问题是</p>
<table>
<thead>
<tr>
<th>规范名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit">Angular规范 ↗</a></td>
<td>Angular规范是非常流行的Git Commit规范之一，拥有众多的用户和贡献者。它提供了一套完整的Git Commit规范。Angular规范要求Commit message必须包含三个部分：类型、范围和描述。类型可以是feat、fix、docs、style、refactor、test、chore等。范围是可选的，用于表示代码变更的影响范围。描述应该清晰地描述代码变更的内容。</td>
</tr>
<tr>
<td><a href="https://www.conventionalcommits.org/">Conventional Commits规范 ↗</a></td>
<td>Conventional Commits是一种通用的Git Commit规范，它要求Commit message必须包含三个部分：类型、作用域和描述。类型可以是feat、fix、docs、style、refactor、test、build等。作用域是可选的，用于表示代码变更的影响范围。描述应该清晰地描述代码变更的内容。Conventional Commits还支持关键词，用于表示代码变更的重要性，例如：BREAKING CHANGE表示这个Commit会破坏向后兼容性。</td>
</tr>
<tr>
<td><a href="https://github.com/carloscuesta/gitmoji">Gitmoji规范 ↗</a></td>
<td>Gitmoji是一种基于Emoji表情符号的Git Commit规范，它要求Commit message必须包含一个Emoji表情符号，用于表示代码变更的类型。例如：:sparkles:表示新增功能，:bug:表示修复Bug，:pencil2:表示修改文档等等。Gitmoji规范还支持在Emoji后面添加一个简短的描述，用于更详细地描述代码变更的内容。</td>
</tr>
</tbody></table>
<p>下面是每种规范的格式的列表：</p>
<h2 id="Angular-规范"><a href="#Angular-规范" class="headerlink" title="Angular 规范"></a>Angular 规范</h2><p>Angular 规范要求每个 commit message 都包含三个部分：Header、Body 和 Footer。其中，Header 包含一个必填字段和一个可选字段，必填字段为 Type，可选字段为 Scope。Body 和 Footer 都是可选的，用于提供更详细的信息。</p>
<p><strong>Type 字段包含以下值：</strong></p>
<ul>
<li><code>feat</code>：新功能</li>
<li><code>fix</code>：修复问题</li>
<li><code>docs</code>：文档修改</li>
<li><code>style</code>：代码格式修改，不影响代码逻辑</li>
<li><code>refactor</code>：重构代码，既不修复错误也不添加功能</li>
<li><code>perf</code>：性能优化</li>
<li><code>test</code>：添加或修改测试代码</li>
<li><code>build</code>：构建系统或外部依赖项修改</li>
<li><code>ci</code>：持续集成修改</li>
<li><code>chore</code>：其他修改，如修改构建流程或辅助工具等</li>
<li><code>revert</code>：回滚到之前的提交</li>
</ul>
<p><strong>Angular 规范的格式为：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;[(scope)]: &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">[body]</span><br><span class="line"></span><br><span class="line">[footer]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slim</span></span><br><span class="line">feat: add user management module</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fully</span></span><br><span class="line">feat(users): add user management module</span><br><span class="line"></span><br><span class="line">This commit adds the user management module to the project.</span><br><span class="line"></span><br><span class="line">Closes #123</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;type&gt;</code> 表示 commit 的类型，<code>[scope]</code> 表示 commit 的影响范围，<code>&lt;subject&gt;</code> 表示 commit 的简短描述，<code>[body]</code> 表示 commit 的详细描述，<code>&lt;footer&gt;</code> 表示 commit 的元信息，如关闭 issue、引入变更等。</p>
<h2 id="Conventional-Commits-规范"><a href="#Conventional-Commits-规范" class="headerlink" title="Conventional Commits 规范"></a>Conventional Commits 规范</h2><p>Conventional Commits 规范要求每个 commit message 都包含三个部分：Type、Scope 和 Subject。其中，Type 和 Subject 是必填的，Scope 是可选的。</p>
<p><strong>Type 包含以下值：</strong></p>
<ul>
<li><code>feat</code>：新功能</li>
<li><code>fix</code>：修复问题</li>
<li><code>docs</code>：文档修改</li>
<li><code>style</code>：代码格式修改，不影响代码逻辑</li>
<li><code>refactor</code>：重构代码，既不修复错误也不添加功能</li>
<li><code>perf</code>：性能优化</li>
<li><code>test</code>：添加或修改测试代码</li>
<li><code>build</code>：构建系统或外部依赖项修改</li>
<li><code>ci</code>：持续集成修改</li>
<li><code>chore</code>：其他修改，如修改构建流程或辅助工具等</li>
<li><code>revert</code>：回滚到之前的提交</li>
<li><code>feat!</code>: 不兼容的新功能</li>
<li><code>fix!</code>: 不兼容的修复问题</li>
<li><code>docs!</code>: 不兼容的文档修改</li>
<li><code>style!</code>: 不兼容的代码格式修改</li>
<li><code>refactor!</code>: 不兼容的重构代码</li>
<li><code>perf!</code>: 不兼容的性能优化</li>
<li><code>test!</code>: 不兼容的添加或修改测试代码</li>
<li><code>build!</code>: 不兼容的构建系统或外部依赖项修改</li>
<li><code>ci!</code>: 不兼容的持续集成修改</li>
<li><code>chore!</code>: 不兼容的其他修改，如修改构建流程或辅助工具等</li>
</ul>
<p><strong>Conventional Commits 规范的格式为：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;[scope]: &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">[body]</span><br><span class="line"></span><br><span class="line">[footer]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slim</span></span><br><span class="line">feat: add user management module</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fully</span></span><br><span class="line">feat(users): add user management module</span><br><span class="line"></span><br><span class="line">This commit adds the user management module to the project.</span><br><span class="line"></span><br><span class="line">Closes #123</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;type&gt;</code> 表示 commit 的类型，<code>[scope]</code> 表示 commit 的影响范围，<code>&lt;subject&gt;</code> 表示 commit 的简短描述，<code>[body]</code> 表示 commit 的详细描述，<code>[footer]</code> 表示 commit 的元信息。</p>
<h2 id="Gitmoji-规范"><a href="#Gitmoji-规范" class="headerlink" title="Gitmoji 规范"></a>Gitmoji 规范</h2><p>以下是 Gitmoji 规范中一些常用的 emoji 和它们的含义：</p>
<ul>
<li>✨ <code>:sparkles:</code>：新增功能</li>
<li>🐛  <code>:bug:</code>：修复 bug</li>
<li>📚 <code>:books:</code>：修改文档</li>
<li>💄 <code>:lipstick:</code>：修改样式</li>
<li>♻️ <code>:recycle:</code>：重构代码。</li>
<li>✅ <code>:white_check_mark:</code>：修改测试用例</li>
<li>🔧 <code>:wrench:</code>：修改构建过程或工具</li>
<li>🚀 <code>:rocket:</code>：优化性能</li>
<li>💚 <code>:green_heart:</code>：修改持续集成流程</li>
<li>📦 <code>:package:</code>：修改构建过程</li>
<li>⏪ <code>:rewind:</code>：撤销之前的提交</li>
</ul>
<p>Gitmoji 规范的格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;gitmoji&gt; &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[body]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slim</span></span><br><span class="line">✨ add user management module</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fully</span></span><br><span class="line">✨ add user management module</span><br><span class="line"></span><br><span class="line">This commit adds the user management module to the project.</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;gitmoji&gt;</code> 是一个表情符号，表示 commit 的类型和含义，<code>&lt;description&gt;</code> 表示 commit 的简短描述 ,<code>[body]</code>?: commit 的详细描述。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从以上可以看出 Conventional Commits 规范 与 Angular 规范有比较多的相同之处。是的，Conventional Commits 规范借鉴了 Angular 规范。</p>
<p>事实上，Conventional Commits 规范的创始人 Tim Pope 是 Karma 团队的成员，他在开发 Karma 过程中使用了 Angular 规范，认为这个规范非常有用。因此，他在 Angular 规范的基础上，扩充和修改了一些内容，提出了 Conventional Commits 规范。可以说，Conventional Commits 规范是在 Angular 规范的基础上发展而来的，但是相对于 Angular 规范，Conventional Commits 规范更加通用，可以适用于更多的项目和开发语言。</p>
<p><em>以下是 Angular 规范和 Conventional Commits 规范在某些方面存在的一些差异，具体如下：</em></p>
<ul>
<li><p><strong>Header 格式不同</strong>：Angular 规范要求 Header 必须包含 Type 字段和可选的 Scope 字段，如 “feat(core): add new feature”；而 Conventional Commits 规范要求 Header 必须包含 Type 和 Subject 字段，Scope 字段是可选的，如 “feat: add new feature”。</p>
</li>
<li><p><strong>Type 值的定义略有不同</strong>：Angular 规范和 Conventional Commits 规范都定义了一些 Type 值，但有些值的含义略有不同。例如，Conventional Commits 规范将 “build” 和 “ci” 两个 Type 值分别定义为构建和持续集成修改，而 Angular 规范将它们合并为 “build”。</p>
</li>
<li><p><strong>Conventional Commits 规范定义了特殊的 Type 值</strong>：Conventional Commits 规范定义了一些特殊的 Type 值，如 “feat!” 和 “fix!”，用于表示不兼容的新功能或修复问题。而 Angular 规范没有这样的定义。</p>
</li>
</ul>
<p>Gitmoji 规范的显著特点是供了大量的 emoji 来描述不同类型和目的的 Git 提交，这使得开发者可以更加准确地描述自己的 Git 提交，简单易懂，具有很强的可读性。Commit的格式在一定程度上与前两者有相似之处，从提出时间上看，它算是采百家之长的集大成者了。</p>
<p>Gitmoji 规范的制定者 Carlos Cuesta 在规范的 Github 页面上并没有明确提到他借鉴了哪些规范。然而，从 Gitmoji 规范的内容来看，它借鉴了一些其他的规范和标准，例如：</p>
<ul>
<li><p><strong>Emoji</strong>：Gitmoji 规范使用 Emoji 表情符号来表示不同类型的提交，这一做法和 Slack、微信等工具中使用 Emoji 表情符号的方式类似。</p>
</li>
<li><p><strong>Semantic Versioning</strong>：Gitmoji 规范中使用了类似 Semantic Versioning 的方式来表示版本，例如 “:bookmark:” 表示打标签，”:bookmark: v1.0.0” 表示打了一个 v1.0.0 的标签。</p>
</li>
<li><p><strong>Conventional Commits</strong>：Gitmoji 规范和 Conventional Commits 规范类似，都是使用 commit message 来描述代码库的变化。不过，Gitmoji 规范使用 Emoji 表情符号来表示不同类型的提交，而 Conventional Commits 规范使用文本标识符来表示。</p>
</li>
</ul>
<h1 id="Commit-语法检测"><a href="#Commit-语法检测" class="headerlink" title="Commit 语法检测"></a>Commit 语法检测</h1><p><a href="https://commitlint.js.org/#/?id=getting-started">Commitlint ↗</a> 是一个用于检查 commit message 是否符合规范的工具，可以自定义规则和配置。它支持多种规范，如 Angular 规范、Conventional Commits 规范、ESLint 规范等。</p>
<p><a href="https://commitlint.js.org/#/?id=getting-started">Commitlint ↗</a> 的作用仅仅是检测 Commit 语法。还需要使用 Git Hook （<code>commit-msg</code>）拦截 <code>git commit</code> 动作以达到强制执行规范的目的。</p>
<blockquote>
<p><strong>commit-msg</strong><br>This hook is invoked by <a href="https://git-scm.com/docs/git-commit">git-commit[1]</a> and <a href="https://git-scm.com/docs/git-merge">git-merge[1]</a>, and can be bypassed with the <code>--no-verify</code> option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</p>
<p><mark>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</mark></p>
<p>The default commit-msg hook, when enabled, detects duplicate <code>Signed-off-by</code> trailers, and aborts the commit if one is found.</p>
<p>Refenrence: <a href="https://git-scm.com/docs/githooks#_commit_msg">githooks - Hooks used by Git</a></p>
</blockquote>
<p><a href="https://typicode.github.io/husky/">Husky ↗</a> 是一个 Git hook 工具，它可以在 Git 执行特定操作时自动触发预定义的脚本。常用于配合 Commitlint 进行 commit message 的校验。与原生的 Git hook 相比，Husky 有以下优点：</p>
<ul>
<li><p><strong>易于使用</strong>：Husky 提供了简单易用的 API，可以轻松地在项目中添加和配置 Git hook。与原生的 Git hook 相比，Husky 的配置更加直观和简单，不需要手动编写脚本。</p>
</li>
<li><p><strong>跨平台支持</strong>：Husky 可以在 Windows、Linux、macOS 等多个平台上运行，而原生的 Git hook 可能会因为操作系统和 shell 的不同而产生兼容性问题。</p>
</li>
<li><p><strong>更强大的功能</strong>：Husky 支持多个 Git hook，可以在不同的 Git 操作时自动触发相应的任务。而原生的 Git hook 只支持有限的几个 hook，需要手动编写脚本来实现更复杂的功能。</p>
</li>
<li><p><strong>安全性</strong>：Husky 的配置文件存储在项目的 package.json 文件中，这意味着可以将配置文件提交到代码仓库中进行版本控制，保证配置的安全性和一致性。而原生的 Git hook 需要手动将 hook 脚本添加到 .git&#x2F;hooks 目录中，容易被意外覆盖或删除。</p>
</li>
</ul>
<p><em>因此，接下来需要做的事情是，安装 Husky，配置 <code>commit-msg</code> 拦截<code>git commit</code> 动作，再安装 Commitlint 对拦截到的 commit 信息进行校验。</em></p>
<h2 id="安装-Husky"><a href="#安装-Husky" class="headerlink" title="安装 Husky"></a>安装 Husky</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm</span></span><br><span class="line">npm install husky --save-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pnpm</span></span><br><span class="line">pnpm add husky --save-dev</span><br></pre></td></tr></table></figure>

<p>使用 Husky 安装 Git Hooks</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npx 调用 局部命令 husky</span> </span><br><span class="line">npx husky install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接路径访问局部命令 husky</span></span><br><span class="line">./node_modules/.bin/husky install</span><br></pre></td></tr></table></figure>

<details open>
  <summary><strong>💡 npx 是什么？</strong></summary>
  <blockquote>
    <br>
    <p><code>npx</code>是一个Node.js命令行工具，它提供了一种方便的方式来运行本地安装的Node.js包中的可执行文件。npx的作用是在不全局安装包的情况下，运行这些包中的命令。</p>
    <p>通常情况下，在运行命令行工具时，需要全局安装相关的包和依赖项。但是，这种方式可能会导致一些问题，例如不同版本的包之间的冲突，或者需要手动更新全局安装的包等。<code>npx</code>提供了一个解决方案，可以在不全局安装包的情况下，运行这些包中的命令。</p>
    <p>使用<code>npx</code>，可以直接在命令行中指定需要运行的包和命令，<code>npx</code>将会自动查找并运行该包中的命令。例如，可以使用以下命令运行&quot;<code>create-react-app</code>&quot;包中的命令来创建一个新的React应用程序：</p>
    <pre><code>npx create-react-app my-app</code></pre>
    <p>在这个例子中，<code>npx</code>将在本地查找&quot;<code>create-react-app</code>&quot;包，并运行它中的&quot;<code>create-react-app</code>&quot;命令，然后使用&quot;<code>my-app</code>&quot;作为应用程序的名称创建一个新的React应用程序。</p>
    <p>更多 npx 相关信息可参考：<a href="https://docs.npmjs.com/cli/v9/commands/npx">Npx | Run a command from a local or remote npm package</a></p>
    <br>
  </blockquote>
</details>
<br>

<p>添加 <code>prepare</code> 脚本到 <code>package.json</code> 的 <code>scripts</code> 中，使得在新环境初始化项目时，自动安装 Git Hooks。</p>
<p>📢 <em>此为可选操作，不做也不影响后续操作，但是推荐执行</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm pkg set scripts.prepare=&quot;husky install&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行以上命令得到的结果是：</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">+    &quot;prepare&quot;: &quot;husky install&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>prepare (since <a href="mailto:npm@4.0.0">&#x6e;&#x70;&#x6d;&#64;&#52;&#x2e;&#x30;&#x2e;&#x30;</a>)</strong></p>
<p>Runs BEFORE the package is packed<br>Runs BEFORE the package is published<br><mark>Runs on local “npm install” without any arguments</mark><br>Run AFTER <code>prepublish</code>, but BEFORE <code>prepublishOnly</code><br>NOTE: If a package being installed through git contains a <code>prepare</code> script, its <code>dependencies</code> and <code>devDependencies</code> will be installed, and the prepare script will be run, before the package is packaged and installed.</p>
<p>Refenrence: <a href="https://docs.npmjs.com/cli/v9/using-npm/scripts">How npm handles the “scripts” field</a></p>
</blockquote>
<p>Husky 配置 Hooks 的方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky add .husky/&lt;git hook&gt; &quot;&lt;command that needs to be executed when the hook is triggered&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将在 `git commit` 执行前触发 `npm <span class="built_in">test</span>` 命令</span></span><br><span class="line">npx husky add .husky/pre-commit &quot;npm test&quot;</span><br></pre></td></tr></table></figure>


<p>至此，Git Hooks 的准备工作已经完成，<code>commit-msg</code> 钩子的配置要在 commitlint 安装完成后配置。</p>
<h2 id="安装-Commitlint"><a href="#安装-Commitlint" class="headerlink" title="安装 Commitlint"></a>安装 Commitlint</h2><p><code>@commitlint</code> 是一个由多个相关包组成的集合，可以根据需要安装和配置这些包来实现不同的功能。</p>
<p><code>@commitlint</code> 的核心包是<code>@commitlint/cli</code>，它提供了命令行工具，用于检查提交信息是否符合规范。<code>@commitlint/cli</code>可以通过命令行参数来指定规范，也可以通过配置文件来指定规范。例如，可以使用<code>@commitlint/config-conventional</code>包来定义一个常规的提交信息规范，然后使用<code>@commitlint/cli</code>来检查提交信息是否符合该规范。</p>
<p>除了<code>@commitlint/cli</code>之外，@commitlint还提供了其他几个相关包，包括：</p>
<ul>
<li><code>@commitlint/load</code>: 提供了一个函数，用于加载配置文件并解析它们，以便<code>@commitlint/cli</code>可以使用它们进行检查。</li>
<li><code>@commitlint/config-conventional</code>: 提供了一组常见的规范，用于检查常规的Git提交信息格式。</li>
<li><code>@commitlint/config-angular</code>: 提供了一个用于检查Angular项目的提交信息规范。</li>
<li><code>@commitlint/config-lerna-scopes</code>: 提供了一个用于检查Lerna项目的提交信息规范。</li>
<li><a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint">更多相关包…</a></li>
</ul>
<p>这些包可以根据具体需要进行安装和配置。</p>
<hr>
<p>📢 <em>根据当前的需求，接下来则安装 <code>@commitlint/cli</code> 和 <code>@commitlint/config-conventional</code>(Conventional Commits 规范)</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm</span></span><br><span class="line">npm install --save-dev @commitlint/config-conventional @commitlint/cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pnpm</span></span><br><span class="line">pnpm add --save-dev @commitlint/config-conventional @commitlint/cli</span><br></pre></td></tr></table></figure>

<p>添加 配置文件</p>
<p><code>@commitlint/cli</code> 支持以下这些默认的配置文件名：</p>
<ul>
<li><code>commitlint.config.js</code></li>
<li><code>.commitlintrc.js</code></li>
<li><code>.commitlintrc</code></li>
<li><code>.commitlintrc.json</code></li>
<li><code>.commitlintrc.yml</code></li>
</ul>
<p>为了避免切换模块化语法问题，接下来使用 <code>.commitlintrc.yml</code> 作为配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .commitlintrc.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 extends 引用 @commitlint/config-conventional 规范</span></span><br><span class="line"><span class="attr">extends:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;@commitlint/config-conventional&#x27;</span></span><br></pre></td></tr></table></figure>

<p>更多的配置项参考：<a href="https://commitlint.js.org/#/reference-configuration?id=configuration">Commitlint &gt; Configuration</a></p>
<p><img src="test_commitlint.gif" alt="Test Commitlint-CLI"></p>
<h2 id="Husky-Commitlint"><a href="#Husky-Commitlint" class="headerlink" title="Husky + Commitlint"></a>Husky + Commitlint</h2><p>使用 Husky 设置 <code>commit-msg</code> 钩子执行 <code>commitlint-cli</code>, 对 <code>git commit</code> 动作提交的信息进行校验。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky add .husky/commit-msg  &#x27;npx --no -- commitlint --edit $&#123;1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>--no</code> 参数是用来禁用 <code>npx</code> 的默认行为的。</p>
<p>默认情况下，<code>npx</code> 会在运行目标命令之前检查本地是否已经安装了目标命令所在的包，如果没有安装，则会先安装该包，然后再运行目标命令。这种行为通常是有用的，因为它可以确保运行的命令使用的是最新的包版本，并且可以避免不同版本之间的兼容性问题。</p>
<p>但是，在某些情况下，我们可能不想让 <code>npx</code> 自动安装包，而是希望使用本地已经安装的包。在这种情况下，可以使用 <code>--no</code> 参数来禁用 <code>npx</code> 的默认行为，以便直接使用本地安装的包。</p>
<p>在这个具体的命令中，<code>--no</code> 参数用来禁用 <code>npx</code> 自动安装 <code>commitlint</code> 包，而是使用本地已经安装的 <code>commitlint</code> 包。</p>
<p><code>--edit $&#123;1&#125;</code> 是用来编辑指定文件的第一个参数的提交信息，<code>$&#123;1&#125;</code> 代表第一个参数的值，通常是一个文件路径。这个命令的作用是使用本地安装的 <code>commitlint</code> 包来检查指定文件的提交信息是否符合规范，并在编辑器中打开该文件，以便修改提交信息。</p>
<p><img src="commitlint_by_hook.gif" alt="Commitlint by hook"></p>
<h2 id="半自动编写-Commit"><a href="#半自动编写-Commit" class="headerlink" title="半自动编写 Commit"></a>半自动编写 Commit</h2><p>以下是使用 Markdown 表格输出 @commitlint&#x2F;prompt-cli 和 Commitizen 的信息：</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>npm周下载量（2023&#x2F;07&#x2F;17）</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.npmjs.com/package/@commitlint/prompt-cli">@commitlint&#x2F;prompt-cli ↗</a></td>
<td>一个命令行交互式工具，用于帮助开发人员规范化提交信息。它使用 <code>commitlint</code> 配置文件中定义的规则来检查提交信息，确保它们符合预定的格式和风格。该工具还提供了一些提示，帮助开发人员更好地理解如何编写符合规则的提交信息。</td>
<td><em>67,802</em></td>
</tr>
<tr>
<td><a href="cz-cli">Commitizen ↗</a></td>
<td>一个命令行交互式工具，用于帮助开发人员规范化提交信息。它使用预定义的提交信息模板来引导开发人员编写符合规则的提交信息，并根据模板中的规则进行验证。与@commitlint&#x2F;prompt-cli不同的是，Commitizen不检查提交信息是否符合commitlint配置文件中定义的规则，而是依靠模板中的规则来确保提交信息的正确性。此外，Commitizen还提供了一些功能，例如自动填充提交信息，以帮助开发人员更快地编写提交信息。</td>
<td><em>917,033</em></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm</span></span><br><span class="line">npm add @commitlint/prompt-cli --save-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pnpm</span></span><br><span class="line">pnpm add @commitlint/prompt-cli --save-dev</span><br></pre></td></tr></table></figure>

<p><img src="test_prompt-cli.gif" alt="Test prompt-cli"></p>
<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><p>Node.js 遵循的版本号命名规范是 <strong>语义化版本号</strong>（SemVer）规范。很多 Node.js 模块和库的版本号也同样如此。</p>
<p>SemVer 规范定义了一个三位数字的版本号，格式为 <code>MAJOR.MINOR.PATCH</code>，其中：</p>
<ul>
<li><code>MAJOR</code>：主版本号，表示不兼容的 API 变化或重大功能变化。</li>
<li><code>MINOR</code>：次版本号，表示向后兼容的新功能添加。</li>
<li><code>PATCH</code>：补丁版本号，表示向后兼容的 bug 修复。</li>
</ul>
<p>除了这三位数字之外，SemVer 规范还可以包含一个预发布版本号和一个构建版本号。预发布版本号以连字符 <code>-</code> 开头，构建版本号以加号 <code>+</code> 开头，例如 <code>1.2.3-beta+build.123</code> 表示预发布版本号为 <code>beta</code>，构建版本号为 <code>build.123</code>。</p>
<p>预发布版本号可以使用以下标识符：</p>
<ul>
<li><p><code>alpha</code>：表示内部测试版本或仍在开发中的不稳定版本，可能会包含较多的 bug，不建议用于生产环境。</p>
</li>
<li><p><code>beta</code>：表示公开测试版本，已经完成了主要功能的开发，但仍需要进行测试和 bug 修复，建议用于测试环境和开发环境。</p>
</li>
<li><p><code>rc</code>：表示候选版本（Release Candidate），已经完成了所有的功能开发和测试，可以用于生产环境，但仍需要进行最后的测试和验证。</p>
</li>
</ul>
<p>需要注意的是，不同的项目可能会有自己的预发布版本号约定，以上标识符仅是语义化版本号规范中常见的预发布版本号标识符。在实际项目中，可以根据项目的特点和需求，自定义预发布版本号标识符。</p>
<p><img src="Snipaste_2023-07-25_18-24-32.png" alt="SemVer Manage"></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><em>以下是常用的几个命令：</em></p>
<ul>
<li>补丁（patch）预发布版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version prepatch --preid &lt;preid-1&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line">npm version prepatch --preid=&lt;preid-1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version --release-as patch --prerelease &lt;preid-1&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line">npx standard-version -r patch -p &lt;preid-1&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>次（minor）预发布版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version preminor --preid=&lt;preid-1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r minor -p &lt;preid-1&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>主（major）预发布版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version premajor --preid=&lt;preid-1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r major -p &lt;preid-1&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于当前预发布的 <code>preid</code> 自增预发布版号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version prerelease</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p</span><br></pre></td></tr></table></figure>

<ul>
<li>切换至下一个阶段的 <code>preid</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version prerelease --preid=&lt;preid-next&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p &lt;preid-next&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>正式发布</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果最初是以 npm version prepatch 开始</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version patch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r patch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果最初是以 npm version preminor 开始</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version minor</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r minor</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果最初是以 npm version premajor 开始</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">npm version major</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r major</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><em>下面以发布补丁的预发布版本为例，假定初始版本是 <code>0.0.1</code></em></p>
<p><strong>Step-1</strong>：更新补丁的 <code>alpha</code> 预发布版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm version prepatch --preid=alpha</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-alpha.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version --release-as patch --prerelease alpha</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line">npx standard-version -r patch -p alpha</span><br></pre></td></tr></table></figure>

<p><strong>Step-2</strong>：更新补丁的 <code>alpha</code> 预发布版本版号自增</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm version prerelease</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-alpha.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p</span><br></pre></td></tr></table></figure>

<p><strong>Step-3</strong>：更新补丁的下一个阶段的预发布版本，<code>beta</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换预发布版本至 beta</span></span><br><span class="line">npm version prerelease --preid=beta</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-beta.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p beta</span><br></pre></td></tr></table></figure>

<p><strong>Step-4</strong>：更新补丁的 <code>beta</code> 预发布版本版号自增</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在beta上，自增预发布版号</span></span><br><span class="line">npm version prerelease</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-beta.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p</span><br></pre></td></tr></table></figure>

<p><strong>Step-5</strong>：更新补丁的下一个阶段的预发布版本，<code>rc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换预发布版本至 rc</span></span><br><span class="line">npm version prerelease --preid=rc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-rc.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p rc</span><br></pre></td></tr></table></figure>

<p><strong>Step-6</strong>：更新补丁的 <code>rc</code> 预发布版本版号自增</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在rc上，自增预发布版号</span></span><br><span class="line">npm version prerelease</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2-rc.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -p</span><br></pre></td></tr></table></figure>

<p><strong>Step-7</strong>: 发布正式版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm version patch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output: 0.0.2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">npx standard-version -r patch</span><br></pre></td></tr></table></figure>
<p><img src="Snipaste_2023-07-25_18-23-41.png" alt="Example for version manage"></p>
<h2 id="Npm-Version生命周期"><a href="#Npm-Version生命周期" class="headerlink" title="Npm-Version生命周期"></a>Npm-Version生命周期</h2><p>在介绍 <code>conventional-changelog-cli</code> 使用的章节中，它配合了 <code>package.json</code> 的 <code>scripts</code> 脚本使用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># package.json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>npm version &lt;patch | minor | major ...&gt;</code> 命令生成 CHANGELOG。</p>
<p>❓ <em>为什么是 <code>version</code> 脚本？</em></p>
<p>❓ <em>为什么是 <code>npm version</code> 而不是 <code>npm run version</code>？</em></p>
<p>下面将带着这两个疑问拆解 <code>npm-version</code> 的生命周期。</p>
<hr>
<p><code>npm version &lt;cmd&gt;</code> 在执行后，按顺序先后执行以下流程：</p>
<ol>
<li><p>执行 <code>preversion</code> 脚本（如果有定义）；</p>
</li>
<li><p>更新 <code>package.json</code> 文件中的版本号；</p>
</li>
<li><p>执行 <code>version</code> 脚本（如果有定义）；</p>
</li>
<li><p>提交版本更新；</p>
</li>
<li><p>创建 Git 标签；</p>
</li>
<li><p>执行 <code>postversion</code> 脚本（如果有定义）；</p>
</li>
</ol>
<p><img src="Snipaste_2023-07-26_11-28-57.png" alt="LifeCycle of npm-version"></p>
<p><em>例如，执行 <code>npm version patch</code> 命令会触发以下操作：</em></p>
<p><strong>1. 执行 <code>preversion</code> 脚本（如果有定义）</strong>：在执行版本更新操作之前执行 <code>preversion</code> 脚本。例如，如果在 <code>package.json</code> 文件中定义了以下 <code>preversion</code> 脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;preversion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>则在执行 <code>npm version patch</code> 命令时，会先执行 <code>npm run lint</code> 命令，检查代码是否符合规范。</p>
<p><strong>2. 更新 <code>package.json</code> 文件中的版本号</strong>：<code>npm version patch</code> 命令会将 <code>package.json</code> 文件中的版本号自动加1，并将新版本号写回 <code>package.json</code> 文件中。</p>
<p><strong>3. 执行 <code>version</code> 脚本（如果有定义）</strong>：在更新版本号之后执行 <code>version</code> 脚本。例如，如果在 <code>package.json</code> 文件中定义了以下 <code>version</code> 脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run build&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>则在执行 <code>npm version patch</code> 命令时，会执行 <code>npm run build</code> 命令，自动生成构建文件。</p>
<p><strong>4. 提交版本更新</strong>：<code>npm version patch</code> 命令会自动执行 <code>git add</code> 和 <code>git commit</code> 命令，将更新后的 <code>package.json</code> 文件提交到 Git 仓库中。提交信息默认为 <code>&quot;v&lt;new-version&gt;&quot;</code>，例如，如果新版本号为 1.0.1，则提交信息为 “v1.0.1”。</p>
<p><strong>5. 创建 Git 标签</strong>：<code>npm version patch</code> 命令会自动执行 <code>git tag</code> 命令，为当前提交创建一个新的 Git 标签。标签名默认为 <code>&quot;v&lt;new-version&gt;&quot;</code>，例如，如果新版本号为 1.0.1，则标签名为 “v1.0.1”。</p>
<p><strong>6. 执行 <code>postversion</code> 脚本（如果有定义）</strong>：在提交版本更新之后执行 <code>postversion</code> 脚本。例如，如果在 <code>package.json</code> 文件中定义了以下 <code>postversion</code> 脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;postversion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm publish&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>则在执行 <code>npm version patch</code> 命令并成功提交版本更新后，会执行 <code>npm publish</code> 命令，将新版本发布到 npm 仓库中。</p>
<hr>
<p>上面提到了 <code>standard-version</code> 和 <code>conventional-changelog-cli</code>，它们都被用于生成 CHANGELOG。</p>
<p>在使用 <code>conventional-changelog-cli</code> 时，生成 CHANGELOG 的命令被设置到了 <code>package.json</code> 中的 <code>scripts.version</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># package.json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>❓ <em>为什么是 <code>npm version</code> 而不是 <code>npm run version</code>？</em></p>
<p>从上面可以知道，<code>version</code> 脚本的触发，是 <code>npm-version</code> 生命周期的一部分。所以可以通过 <code>npm-version</code> 命令更新版本的同时触发 <code>version</code> 脚本生成 CHANGELOG。</p>
<p>❓ <em>为什么是 <code>version</code> 脚本？</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s \</span><br><span class="line">  &amp;&amp; git add CHANGELOG.md</span><br></pre></td></tr></table></figure>

<p>这段命令包含了两部分：</p>
<ul>
<li><p>生成 CHANGELOG, <code>conventional-changelog -p angular -i CHANGELOG.md -s</code>;</p>
</li>
<li><p>将新版本对应的 CHANGELOG 变动添加到 Git 仓库的暂存区，<code>git add CHANGELOG.md</code>。</p>
</li>
</ul>
<p><code>version</code> 脚本的触发介乎于 “更新 package.json 文件中的版本号” 与 “提交版本更新” 之间。</p>
<p>生成 CHANGELOG 需要知道 新的版号。<code>version</code> 脚本的触发在 “提交版本更新” 之前，所以只要在 <code>version</code> 触发时将变动添加到Git仓库暂存区，“提交版本更新” 的 commit 就可以包含 CHANGELOG 的变动。</p>
<h2 id="Standard-Version的生命周期"><a href="#Standard-Version的生命周期" class="headerlink" title="Standard-Version的生命周期"></a>Standard-Version的生命周期</h2><p>在上一节 <a href>Npm-version生命周期</a> 中提到了 <code>conventional-changelog-cli</code>，但是没有提到 <code>standard-version</code>。因为 <code>standard-version</code> 有它自己的生命周期，而且在使用 <code>standard-version</code> 做版本号更新和 CHANGELOG 生成时，<strong>并不会触发 <code>npm-version</code> 的脚本（<code>preversion</code>、<code>version</code> 和 <code>postversion</code>）</strong>！</p>
<p><strong><code>standard-version</code> 的生命周期:</strong></p>
<ol>
<li><p>更新项目版本号；</p>
</li>
<li><p>生成 CHANGELOG；</p>
</li>
<li><p>提交版本 commit（包含 package.json的version 和 changelog的变动）；</p>
</li>
<li><p>创建版本的 <code>git-tag</code>；</p>
</li>
</ol>
<p><img src="Snipaste_2023-07-26_21-57-36.png" alt="lifecycle of standard-version"></p>
<p>📢 <strong>注意</strong>：<em>上图中的这句命令并没有执行，仅仅是提示！</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run `git push --follow-tags origin master &amp;&amp; npm publish --tag prerelease` to publish</span><br></pre></td></tr></table></figure>

<p><strong><code>standard-version</code> 的生命周期中触发的脚本</strong></p>
<ul>
<li><p><code>prerelease</code>: 在任何事情发生之前执行。 如果 <code>prerelease</code> 脚本返回非零退出代码（<code>process.exit()</code>），版本控制将中止，但对进程没有其他影响。</p>
</li>
<li><p><code>prebump/postbump</code>: 在版本更新之前和之后执行。 如果 <code>prebump</code> 脚本返回一个版本号，将使用它而不是 <code>standard-version</code> 计算的版本。</p>
</li>
<li><p><code>prechangelog/postchangelog</code>: 在生成 CHANGELOG 之前和之后执行。</p>
</li>
<li><p><code>precommit/postcommit</code>: 在提交版本 commit 之前和之后调用。</p>
</li>
<li><p><code>pretag/posttag</code>: 在添加 <code>git-tag</code> 步骤之前和之后调用。</p>
</li>
</ul>
<blockquote>
<p><strong>Lifecycle Scripts</strong><br>standard-version supports lifecycle scripts. These allow you to execute your own supplementary commands during the release. The following hooks are available and execute in the order documented:</p>
<ul>
<li><p><code>prerelease</code>: executed before anything happens. If the <code>prerelease</code> script returns a non-zero exit code, versioning will be aborted, but it has no other effect on the process.</p>
</li>
<li><p><code>prebump/postbump</code>: executed before and after the version is bumped. If the <code>prebump</code> script returns a version #, it will be used rather than the version calculated by <code>standard-version</code>.</p>
</li>
<li><p><code>prechangelog/postchangelog</code>: executes before and after the CHANGELOG is generated.</p>
</li>
<li><p><code>precommit/postcommit</code>: called before and after the commit step.</p>
</li>
<li><p><code>pretag/posttag</code>: called before and after the tagging step.</p>
</li>
</ul>
</blockquote>
<p><img src="Snipaste_2023-07-27_04-51-22.png"></p>
<p><strong>📢 注意</strong>：*<code>standard-version</code> 触发的脚本是 <code>strandard-version.scripts.*</code>，而不是 <code>scripts.*</code>。*</p>
<p><img src="Snipaste_2023-07-26_20-14-55.png"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><code>standard-version</code> 并非基于 <code>npm-version</code> 实现，它与 <code>npm-version</code> 相互独立。<code>standard-version</code> 有自己的生命周期，与 <code>npm-version</code> 不重合，在 <code>standard-version</code> 工作过程中不会触发 <code>npm-version</code> 生命周期脚本（<code>preversion</code>、<code>version</code> 和 <code>postversion</code>）。</p>
<p><code>standard-version</code> 的生命周期中，<em>包含 4 个工作点</em>：</p>
<ul>
<li><p>更新项目版本号；</p>
</li>
<li><p>生成 CHANGELOG；</p>
</li>
<li><p>提交版本 commit（包含 package.json的version 和 changelog的变动）；</p>
</li>
<li><p>创建版本的 <code>git-tag</code>；</p>
</li>
</ul>
<p><em>包含 9 个钩子脚本</em>：</p>
<ul>
<li><p><code>prerelease</code></p>
</li>
<li><p><code>prebump/postbump</code></p>
</li>
<li><p><code>prechangelog/postchangelog</code></p>
</li>
<li><p><code>precommit/postcommit</code></p>
</li>
<li><p><code>pretag/posttag</code></p>
</li>
</ul>
<p><code>standard-version</code> 与 <code>npm-version</code> 在 <code>package.json</code> 中定义脚本的格式不一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm-version</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;preversion&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">standard-version</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;standard-version&quot;: &#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">      &quot;prerelease&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="CHANGELOG自动化"><a href="#CHANGELOG自动化" class="headerlink" title="CHANGELOG自动化"></a>CHANGELOG自动化</h1><h2 id="conventional-changelog-cli"><a href="#conventional-changelog-cli" class="headerlink" title="conventional-changelog-cli"></a>conventional-changelog-cli</h2><p><code>conventional-changelog-cli</code> 是一个命令行工具，用于生成符合规范的 changelog。它可以根据项目的 commit message 格式，自动解析 commit 信息，并将其转换为人类可读的 changelog。</p>
<p>这个工具的基本原理是将符合规范的 commit message 按照类型（type）和 scope 等信息进行分类，然后根据分类的结果生成 changelog。</p>
<p><code>conventional-changelog-cli</code> 支持使用多种预设（preset）来生成 changelog，包括 <code>angular</code>、<code>atom</code>、<code>codemirror</code>、<code>conventionalcommits</code>、<code>ember</code>、<code>eslint</code>、<code>express</code>、<code>jquery</code> 和 <code>jshint</code> 等。你也可以使用自定义的配置文件来生成 changelog。</p>
<p>以下是 <code>conventional-changelog-cli</code> 的一些常用命令：</p>
<ul>
<li><p><code>conventional-changelog</code>: 生成 changelog，默认使用 Angular 规范。</p>
</li>
<li><p><code>conventional-changelog -p [preset]</code>: 生成指定预设的 changelog。</p>
</li>
<li><p><code>conventional-changelog -i [file]</code>: 将 changelog 写入到指定文件中。</p>
</li>
<li><p><code>conventional-changelog -s</code>: 将 changelog 添加到文件的开头而不是结尾。</p>
</li>
<li><p><code>conventional-changelog --release-count [number]</code>: 指定要包括的版本数量。</p>
</li>
<li><p><code>conventional-changelog --config [file]</code>: 使用自定义的配置文件生成 changelog。</p>
</li>
</ul>
<p>通过 <code>conventional-changelog-cli</code>，你可以方便地生成符合规范的 changelog，并且可以根据自己的需要进行自定义配置和预设，以满足项目的需求。</p>
<p>📢 <em>在默认情况下，<code>conventional-changelog-cli</code> 会匹配 <code>feat</code>、<code>fix</code> 类型的commits，并根据它们生成CHANGELOG</em></p>
<blockquote>
  <br>
  <pre><code class="language-shell">npm install -g conventional-changelog-cli
  cd my-project
  conventional-changelog -p angular -i CHANGELOG.md -s
  </code></pre>
  <p>This will not overwrite any previous changelogs. <mark>The above generates a changelog based on commits since the last semver tag that matches the pattern of &quot;Feature&quot;, &quot;Fix&quot;, &quot;Performance Improvement&quot; or &quot;Breaking Changes&quot;.</mark></p>
  <br>
</blockquote>


<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm</span></span><br><span class="line">npm install conventional-changelog-cli --save-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pnpm</span></span><br><span class="line">pnpm add conventional-changelog-cli --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx conventional-changelog -p conventionalcommits -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>-p conventionalcommit</code>：指定使用 conventionalcommit 规范生成 CHANGELOG 文件。<code>conventionalcommit</code> 是一种常见的规范，适用于大多数项目。</p>
</li>
<li><p><code>-i CHANGELOG.md</code>：指定将生成的 CHANGELOG 文件输出到名为 <code>CHANGELOG.md</code> 的文件中。如果该文件不存在，则会创建它；如果已存在，则会覆盖它。</p>
</li>
<li><p><code>-s</code>：指定生成的 CHANGELOG 文件中是否应包含当前版本之前的所有版本的变更记录。默认情况下，只会生成当前版本的变更记录。</p>
</li>
</ul>
<p><strong>结合 <code>npm version</code> 使用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cli</span></span><br><span class="line">npm version &lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>具体来说，当您执行 <code>npm version</code> 命令时，会按照以下顺序执行：</p>
<ul>
<li><p>执行 <code>scripts.version</code> 脚本，如果已经定义的话。<code>scripts.version</code> 脚本会返回一个字符串，表示新的版本号，如果没有定义 <code>scripts.version</code> 脚本，则使用默认的 SemVer 规范生成版本号。</p>
</li>
<li><p>将新的版本号更新到 package.json 文件中。</p>
</li>
<li><p>自动化执行 Git 操作，包括添加修改的 package.json 和生成的 changelog 文件、提交代码并打 Git tag。</p>
</li>
</ul>
<p>因此执行 <code>npm version &lt;version&gt;</code>的结果是：1）更新 <code>package.json</code> 的 <code>version</code> 字段；2）更新 CHANGELOG；3）生成包含 1、2 的 commit 和 git-tag。</p>
<p><strong>修改 version-commit</strong></p>
<p>默认的 <code>version-commit</code> 是下面这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 1d37dcf6dc685d0a49319d0c2e0a0a272af8fa7a (tag: v3.3.8)</span><br><span class="line">Author: isaaxite &lt;isaacgun@outlook.com&gt;</span><br><span class="line">Date:   Tue Jul 25 05:00:36 2023 +0800</span><br><span class="line"></span><br><span class="line">    3.3.8</span><br></pre></td></tr></table></figure>

<p>显然这样是不符合规范的。下面有 2 个方法可是使之合乎规范。</p>
<p><em>手动设置</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%s 是版本号的占位符</span></span><br><span class="line"></span><br><span class="line">npm version patch -m &quot;chore: bump version to %s&quot;</span><br></pre></td></tr></table></figure>

<p><em>配置文件设置</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.npmrc</span></span><br><span class="line"></span><br><span class="line">commit-hooks=true</span><br><span class="line">tag-version-prefix=v</span><br><span class="line">message=&quot;chore: bump version to %s&quot;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>从 <code>conventional-changelog-cli</code> 的 README 中没有太多关于配置的信息，仅仅是引导去查阅 <code>conventional-changelog</code> 和 <code>conventional-changelog-core</code>。</p>
<p>从其他的一些参考资料确实有介绍 <code>conventional-changelog-cli</code> 是基于 <code>conventional-changelog-core</code> 开发的。</p>
<blockquote>
<p>To fully customize the tool, please checkout <mark>conventional-changelog</mark> and <mark>conventional-changelog-core</mark> docs. You can find more details there. Note: config here can work with preset, which is different than options.config in conventional-changelog.</p>
</blockquote>
<p>但是，实际上 <code>conventional-changelog</code> 并没有太多关于配置的信息，仅仅是一个类似一个一级引导页的README!</p>
<p>而 <code>conventional-changelog-core</code> 相对有用一点，会介绍 API 的参数，但是并没有明确那些参数是可以复用到配置文件上的。</p>
<p>使用 <code>conventional-changelog --help</code> 有看到关于配置相关的描述：</p>
<blockquote>
<p><code>-n, --config</code>  A filepath of your config script Example of a config script: <a href="https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js">https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js</a></p>
</blockquote>
<p>打开的是一个过于简单的页面，并没有注释介绍参数作用，有用的参考信息约等于没有！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">writerOpts</span>: &#123;</span><br><span class="line">    <span class="attr">mainTemplate</span>: <span class="string">&#x27;&#123;&#123;commitGroups.[0].commits.[0].type&#125;&#125;&#123;&#123;testContext&#125;&#125;template&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>综合以上，基本可以认识到一个事实：</em></p>
<p><strong><code>conventional-changelog-cli</code> 具备配置的能力，但是缺少配置指引，以致配置体验不友好。基本可以认为这个工具的配置能力约等于“无”</strong></p>
<hr>
<p><em>本着研究的态度阅读 <code>conventional-changelog-cli</code> 的源码，探索它的配置详情！</em></p>
<p>通过阅读 <code>conventional-changelog-cli/cli.js</code> 代码，发现以下5个配置项可以从从配置文件中读取：</p>
<ul>
<li><p><code>options</code></p>
</li>
<li><p><code>templateContext</code></p>
</li>
<li><p><code>gitRawCommitsOpts</code></p>
</li>
<li><p><code>parserOpts</code></p>
</li>
<li><p><code>writerOpts</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (flags.<span class="property">context</span>) &#123;</span><br><span class="line">|   templateContext = <span class="built_in">require</span>(<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), flags.<span class="property">context</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags.<span class="property">config</span>) &#123;</span><br><span class="line">|   config = <span class="built_in">require</span>(<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), flags.<span class="property">config</span>))</span><br><span class="line">    options.<span class="property">config</span> = config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">options</span>) &#123;</span><br><span class="line">|     options = &#123;</span><br><span class="line">        ...options,</span><br><span class="line">        ...config.<span class="property">options</span>,</span><br><span class="line">        <span class="attr">pkg</span>: &#123;</span><br><span class="line">          ...options.<span class="property">pkg</span>,</span><br><span class="line">          ...config.<span class="property">options</span>.<span class="property">pkg</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    config = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to get file. &#x27;</span> + err)</span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gitRawCommitsOpts = &#123;</span><br><span class="line">| ...config.<span class="property">gitRawCommitsOpts</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changelogStream = <span class="title function_">conventionalChangelog</span>(</span><br><span class="line">  options, </span><br><span class="line">  templateContext, </span><br><span class="line">  gitRawCommitsOpts, </span><br><span class="line">| config.<span class="property">parserOpts</span>, </span><br><span class="line">| config.<span class="property">writerOpts</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在源码中可以知道, 以上 5 个配置项分别读取自不同的2个文件，它们分别是 <code>context</code> 配置文件 和 <code>config</code> 配置文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context</span></span><br><span class="line">templateContext = <span class="built_in">require</span>(<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), flags.<span class="property">context</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// config</span></span><br><span class="line">config = <span class="built_in">require</span>(<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), flags.<span class="property">config</span>))</span><br></pre></td></tr></table></figure>

<p><code>context</code> 配置文件：</p>
<ul>
<li><code>templateContext</code></li>
</ul>
<p><code>config</code> 配置文件：</p>
<ul>
<li><p><code>options</code></p>
</li>
<li><p><code>gitRawCommitsOpts</code></p>
</li>
<li><p><code>parserOpts</code></p>
</li>
<li><p><code>writerOpts</code></p>
</li>
</ul>
<p><code>npx conventional-changelog --help</code> 中关于 <code>context</code> 配置文件 和 <code>config</code> 配置文件的描述</p>
<blockquote>
<p><code>-c, --context</code> A filepath of a json that is used to define template variables</p>
<p><code>-n, --config</code>  A filepath of your config script. Example of a config script: <a href="https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js">https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js</a></p>
</blockquote>
<p>结合 <code>--help</code>的描述和配置文件的引入方式（<code>require</code>），可以推断 <code>context</code> 配置文件 和 <code>config</code> 配置文件的内容和语法。</p>
<p><em><code>context</code> 配置文件</em></p>
<p>支持的配置项及其详情参考：<a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-writer#context">conventional-changelog-writer &gt; context</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">conventional-changelog.context.js</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">支持的配置项参考：</span></span><br><span class="line"><span class="comment">https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-writer#context</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>context</code> 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx conventional-changelog --context conventional-changelog.context.js</span><br></pre></td></tr></table></figure>


<p><em><code>config</code> 配置文件</em></p>
<p>支持的4个配置项及其详情参考：</p>
<ul>
<li><p><code>gitRawCommitsOpts</code>: <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/git-raw-commits#gitopts">conventional-changelog&#x2F;packages&#x2F;git-raw-commits &gt; gitopts</a></p>
</li>
<li><p><code>parserOpts</code>: <a href="https://github.com/conventional-changelog-archived-repos/conventional-commits-parser#options">conventional-commits-parser &gt; options</a></p>
</li>
<li><p><code>writerOpts</code>: <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-writer#options">conventional-changelog-writer &gt; options</a></p>
</li>
<li><p><code>options</code>: <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-core#options">conventional-changelog-core &gt; options</a></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// conventional-changelog.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 参考：https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/git-raw-commits#gitopts</span></span><br><span class="line">  <span class="attr">gitRawCommitsOpts</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参考：https://github.com/conventional-changelog-archived-repos/conventional-commits-parser#conventionalcommitsparseroptions</span></span><br><span class="line">  <span class="attr">parserOpts</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参考：https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-writer#options</span></span><br><span class="line">  <span class="attr">writerOpts</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参考：https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-core#options</span></span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>config</code> 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx conventional-changelog --config conventional-changelog.config.js</span><br></pre></td></tr></table></figure>


<h3 id="preset"><a href="#preset" class="headerlink" title="preset"></a>preset</h3><p>Standard Version 是一个命令行工具，可用于自动生成符合语义化版本规范的版本标签和 CHANGELOG。它使用 Git 元数据（如提交消息）来确定下一个版本号，然后生成标签和更新日志。</p>
<p><code>standard-version</code> 和 <code>conventional-changelog-cli</code> 都是基于 <code>conventional-changelog</code> 实现的工具。</p>
<p>但是有别于 <code>conventional-changelog-cli</code>, <code>standard-version</code> 是明确支持配置文件，并且有较为详细的指引介绍如何配置(<a href="https://github.com/conventional-changelog/standard-version#configuration">Standard Version &gt; configuration</a>)。</p>
<blockquote>
<p><strong>Configuration</strong></p>
<p>You can configure <code>standard-version</code> either by:</p>
<p>Placing a <code>standard-version</code> stanza in your package.json (assuming your project is JavaScript).<br><mark>Creating a ‘.versionrc’, ‘.versionrc.json’ or ‘.versionrc.js’.</mark><br>If you are using a <code>.versionrc.js</code> your default export must be a configuration object, or a function returning a configuration object.<br>Any of the command line parameters accepted by <code>standard-version</code> can instead be provided via configuration. <mark>Please refer to the <a href="https://github.com/conventional-changelog/conventional-changelog-config-spec/">conventional-changelog-config-spec</a> for details on available configuration options.</mark></p>
</blockquote>
<p><code>standard-version</code> 配置文件的包含全部设置项的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .versionrc.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">header</span>: <span class="string">&#x27;# Changelog&#x27;</span>,</span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Features&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Bug Fixes&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;chore&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;style&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;perf&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">preMajor</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">commitUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/commit/&#123;&#123;hash&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">compareUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/compare/&#123;&#123;previousTag&#125;&#125;...&#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">issueUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/issues/&#123;&#123;id&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">userUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;user&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">releaseCommitMessageFormat</span>: <span class="string">&#x27;chore(release): &#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">issuePrefixes</span>: [ <span class="string">&#x27;#&#x27;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>两者都基于相同上游库开发，但是只有 <code>standard-version</code> 支持配置，而且是有别于上面 <code>conventional-changelog-cli</code> 介绍过的配置方式。这是为什么？</em></p>
<p><em>抱着这个疑问阅读 <code>standard-version</code> 相关的代码！</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// standard-version/lib/lifecycles/changelog.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changelogStream = <span class="title function_">conventionalChangelog</span>(&#123;</span><br><span class="line">  <span class="attr">debug</span>: args.<span class="property">verbose</span> &amp;&amp; <span class="variable language_">console</span>.<span class="property">info</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;conventional-changelog&#x27;</span>),</span><br><span class="line">  <span class="attr">preset</span>: <span class="title function_">presetLoader</span>(args),</span><br><span class="line">  <span class="attr">tagPrefix</span>: args.<span class="property">tagPrefix</span></span><br><span class="line">&#125;, context, &#123; <span class="attr">merges</span>: <span class="literal">null</span>, <span class="attr">path</span>: args.<span class="property">path</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>🔬 通过“打印”的方式确认了是 <code>presetLoader(args)</code> 引入了 <code>.versionrc.js</code> 的配置内容</strong></p>
<p><em>与上面例子有所区别是，在例子的基础上有增了 <code>name</code> 属性：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;/home/isaac/workspace/temp/node_modules/.pnpm/conventional-changelog-conventionalcommits@4.6.3/node_modules/conventional-changelog-conventionalcommits/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>npx conventional-changelog --help</code> 的描述上看，<code>--preset</code> 是指定 commit 规范。而 <code>--preset</code> 的设置值仅仅一个较短字符串，而不是上面探索到的对象形式的值。</p>
<blockquote>
<p><code>-p, --preset</code>  Name of the preset you want to use. Must be one of the following: angular, atom, codemirror, conventionalcommits, ember, eslint, express, jquery or jshint</p>
</blockquote>
<p>从上面 <code>standard-version</code> 的源码可知道， <code>preset</code> 是对应到前文 <code>conventional-changelog.config.js</code> 中的 <code>options.preset</code>，基于以上信息，进行下面的尝试。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// conventional-changelog.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">preset</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;/home/isaac/workspace/temp/node_modules/.pnpm/conventional-changelog-conventionalcommits@4.6.3/node_modules/conventional-changelog-conventionalcommits/index.js&#x27;</span>,</span><br><span class="line">      <span class="attr">header</span>: <span class="string">&#x27;# Changelog&#x27;</span>,</span><br><span class="line">      <span class="attr">types</span>: [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Features&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Bug Fixes&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;chore&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;style&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;perf&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">preMajor</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">commitUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/commit/&#123;&#123;hash&#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">compareUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/compare/&#123;&#123;previousTag&#125;&#125;...&#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">issueUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/issues/&#123;&#123;id&#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">userUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;user&#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">releaseCommitMessageFormat</span>: <span class="string">&#x27;chore(release): &#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">issuePrefixes</span>: [ <span class="string">&#x27;#&#x27;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细设置项参考：<a href="https://github.com/conventional-changelog/conventional-changelog-config-spec/">conventional-changelog-config-spec</a> </p>
<p><strong>结论是可以的！</strong></p>
<p>但是，并不是全部属性都有效果！下面是几个尝试后得到的结论：</p>
<ul>
<li><p><code>name</code>，必选设置，preset 的设置项生效的前提是们需要设置 <code>name</code> 属性。这是测试出来的结果，没有继续深挖！<code>name</code> 属性在两种设置方式下有效：1）如上面文件的；2）<code>name: &#39;conventional-changelog-conventionalcommits&#39;</code>;</p>
</li>
<li><p><code>header</code>，无效。查阅了 <code>standard-version</code> 的源码。关于 header 的实现，是独立与 <code>conventional-changelog</code> 的，所以不生效也正常。</p>
</li>
<li><p><code>types</code>，正常有效的。</p>
</li>
<li><p>其他，正常有效。</p>
<ul>
<li><code>preMajor</code></li>
<li><code>commitUrlFormat</code></li>
<li><code>compareUrlFormat</code></li>
<li><code>issueUrlFormat</code></li>
<li><code>userUrlFormat</code></li>
<li><code>releaseCommitMessageFormat</code></li>
<li><code>issuePrefixes</code></li>
</ul>
</li>
</ul>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>通过 preset 配置 <code>conventional-changelog-cli</code> 是从源码中得到的非正道的知识，在 conventional-changelog 的工具集中并没有相关的资料说明可以使用preset通过对象形式值去配置。所以这是一个不推荐在生产项目下使用的功能，是个不被保证的功能。</p>
<h2 id="Standard-Version"><a href="#Standard-Version" class="headerlink" title="Standard Version"></a>Standard Version</h2><p>Standard Version 和 conventional-changelog-cli 都是用于自动生成版本更新和 CHANGELOG 的命令行工具。它们都是基于 <code>conventional-changelog</code> 事先。</p>
<p>Standard Version 除了能够生成 CHANGELOG 之外，还能够自动创建 Git 标签、增加版本号，以及自动推送标签到 Git 仓库等。conventional-changelog-cli 则只是生成 CHANGELOG 文件。</p>
<p>Standard Version 的社区支持度相对来说更高，有较多的用户和贡献者，开发维护更新也更加频繁。而 conventional-changelog-cli 的社区支持度相对较低，开发维护更新也不如 Standard Version 频繁。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm</span></span><br><span class="line">npm install standard-version --save-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pnpm</span></span><br><span class="line">pnpm add standard-version --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;release&quot;</span>: <span class="string">&quot;standard-version&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Standard Version 是推荐使用它来代替 <code>npm version</code> 进行版本管理的。</p>
<p>Standard Version 将版本管理与 CHANGELOG 结合在一起，在使用 <code>standard-version</code> 更新版本号时，会自动触发 CHANGELOG 的更新。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">release</span></span><br><span class="line">npx standard-version -r 0.0.1</span><br><span class="line"></span><br><span class="line">npx standard-version -r 0.0.1-0</span><br><span class="line">npx standard-version -r 0.0.1-1</span><br><span class="line"></span><br><span class="line">npx standard-version -r 0.0.1-beta.0</span><br><span class="line">npx standard-version -r 0.0.1-beta.1</span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>默认的配置文件名是：<code>.versionrc</code>, <code>.versionrc.json</code> or <code>.versionrc.js</code></p>
<p>详细设置项参考：<a href="https://github.com/conventional-changelog/conventional-changelog-config-spec/">conventional-changelog-config-spec</a> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .versionrc.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">header</span>: <span class="string">&#x27;# Changelog&#x27;</span>,</span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Features&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">section</span>: <span class="string">&#x27;Bug Fixes&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;chore&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;style&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;perf&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">preMajor</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">commitUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/commit/&#123;&#123;hash&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">compareUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/compare/&#123;&#123;previousTag&#125;&#125;...&#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">issueUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;owner&#125;&#125;/&#123;&#123;repository&#125;&#125;/issues/&#123;&#123;id&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">userUrlFormat</span>: <span class="string">&#x27;&#123;&#123;host&#125;&#125;/&#123;&#123;user&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">releaseCommitMessageFormat</span>: <span class="string">&#x27;chore(release): &#123;&#123;currentTag&#125;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">issuePrefixes</span>: [ <span class="string">&#x27;#&#x27;</span> ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="工作流-1"><a href="#工作流-1" class="headerlink" title="工作流"></a>工作流</h1><p><img src="Snipaste_2023-07-26_11-57-45.png" alt="work flow"></p>
<p><strong>1. 创建开发分支</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin main</span><br><span class="line"></span><br><span class="line">git checkout -b feat/xxx origin/main</span><br></pre></td></tr></table></figure>

<p><strong>2. Commit 变动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全手动commit，让commitlint检测</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;feat(scope): add a new feat&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">半自动辅助编辑commit</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">npx commit</span><br></pre></td></tr></table></figure>

<p><strong>3. Push开发分支</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin feat/xxx</span><br></pre></td></tr></table></figure>

<p><strong>4. 合并开发分支</strong></p>
<p><strong>5. 版本管理</strong></p>
<p>切换到主分支，并更新到最新的commit点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git fetch origin main &amp;&amp; git pull origin main</span><br></pre></td></tr></table></figure>

<p>创建版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx standard-version -r patch -p alpha</span><br></pre></td></tr></table></figure>

<p><strong>6. 发布</strong></p>
<p>推送commit 与 git-tag 到远端git仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin main &amp;&amp; git push --tags</span><br></pre></td></tr></table></figure>

<p>发布到 npm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录</span></span><br><span class="line">npm login</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布</span></span><br><span class="line">npm publish --tag alpha</span><br></pre></td></tr></table></figure>


<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Husky支持的-Git-hook"><a href="#Husky支持的-Git-hook" class="headerlink" title="Husky支持的 Git hook"></a>Husky支持的 Git hook</h2><p>Husky 支持大部分 Git hook，以下是 Husky 支持的 Git hook 列表：</p>
<ul>
<li><code>applypatch-msg</code>：在 Git 执行 <code>git am</code> 命令时触发</li>
<li><code>pre-applypatch</code>：在 Git 执行 <code>git am</code> 命令前触发</li>
<li><code>post-applypatch</code>：在 Git 执行 <code>git am</code> 命令后触发</li>
<li><code>pre-commit</code>：在 Git 执行 <code>git commit</code> 命令前触发</li>
<li><code>prepare-commit-msg</code>：在 Git 执行 <code>git commit</code> 命令前触发，用于编辑提交信息</li>
<li><code>commit-msg</code>：在 Git 执行 <code>git commit</code> 命令后触发，用于验证提交信息</li>
<li><code>post-commit</code>：在 Git 执行 <code>git commit</code> 命令后触发</li>
<li><code>pre-rebase</code>：在 Git 执行 <code>git rebase</code> 命令前触发</li>
<li><code>post-checkout</code>：在 Git 执行 <code>git checkout</code> 命令后触发</li>
<li><code>post-merge</code>：在 Git 执行 <code>git merge</code> 命令后触发</li>
<li><code>pre-push</code>：在 Git 执行 <code>git push</code> 命令前触发</li>
<li><code>pre-receive</code>：在 Git 执行 <code>git push</code> 命令时，服务端接收到数据之前触发</li>
<li><code>update</code>：在 Git 执行 <code>git push</code> 命令时，服务端接收到数据之后触发</li>
<li><code>post-receive</code>：在 Git 执行 <code>git push</code> 命令后触发</li>
<li><code>post-update</code>：在 Git 执行 <code>git push</code> 命令后触发</li>
<li><code>pre-auto-gc</code>：在 Git 执行自动垃圾回收之前触发</li>
<li><code>post-rewrite</code>：在 Git 执行 <code>git filter-branch</code> 和 <code>git commit --amend</code> 命令后触发</li>
<li><code>sendemail-validate</code>：在 Git 执行 <code>git send-email</code> 命令前触发</li>
</ul>
<p>以上 Git hook 具体作用可以参考 Git 的官方文档。Husky 可以通过在 package.json 文件的 <code>husky.hooks</code> 中定义相应的命令，来自动触发这些 Git hook。例如，在 <code>husky.hooks</code> 中定义 <code>pre-commit</code> 命令，就可以在每次执行 <code>git commit</code> 命令时自动触发该命令。</p>
<h2 id="post-merge-钩子触发prompt失败"><a href="#post-merge-钩子触发prompt失败" class="headerlink" title="post-merge 钩子触发prompt失败"></a>post-merge 钩子触发prompt失败</h2><p>配置 post-merge 钩子，合并开发分支后触发版本更新逻辑。版本管理选择使用 <code>@isubo-org/version</code>，它是prompt工具，选择的方式设定新版号。</p>
<p><em>配置 post-merge 钩子</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky add .husky/post-merge  &#x27;npm run post-merge&#x27;</span><br></pre></td></tr></table></figure>

<p><em>配置post-merge脚本</em></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;post-merge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx isubo-version&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试结果是：行不通！</p>
<p>合并后确实可以触发脚本，但是完全跳过选择流程</p>
<p><img src="Snipaste_2023-08-07_00-58-17.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://git-scm.com/docs/githooks#_commit_msg">githooks - Hooks used by Git</a></li>
<li><a href="https://docs.npmjs.com/cli/v9/using-npm/scripts">How npm handles the “scripts” field</a></li>
<li><a href="https://commitlint.js.org/#/reference-configuration?id=configuration">Commitlint &gt; Configuration</a></li>
<li><a href="https://docs.npmjs.com/cli/v9/commands/npx">Npx | Run a command from a local or remote npm package</a></li>
<li><a href="https://typicode.github.io/husky/">Husky | Modern native git hooks made easy</a></li>
<li><a href="https://commitlint.js.org/#/">Commitlint | Helps your team adhere to a commit convention</a></li>
</ul>

]]></content>
      <categories>
        <category>CI/CD</category>
        <category>持续集成</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>CHANGELOG</tag>
        <tag>自动化</tag>
        <tag>Commit规范</tag>
        <tag>版本控制</tag>
        <tag>Git Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>一次性搞懂浏览器扩展程序开发</title>
    <url>/blog/resources/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文将介绍浏览器扩展是什么，怎么安装。详细分述关于浏览器扩展程序的开发，它项目结构，各个文件文件负者的职能，作为开发者我们可以怎么运用它们实现我们的功能。在开发到一定程度之后，该如何去调式，发现问题，解决问题。之后，如何发布开发好的浏览器开发程序。</p>
<p>全线保姆级别手把手教导</p>
<span id="more"></span>



<h1 id="浏览器扩展是什么？"><a href="#浏览器扩展是什么？" class="headerlink" title="浏览器扩展是什么？"></a>浏览器扩展是什么？</h1><p>浏览器扩展是一种软件模块，可为Web浏览器添加功能。它通常是用HTML、CSS和JavaScript编写的，可以在Web浏览器中安装和运行，以修改浏览器的行为或提供其他功能。</p>
<p>浏览器扩展可用于自定义网页外观、阻止广告、管理密码、下载文件、增强隐私和安全性等许多任务。它们适用于流行的Web浏览器，如Google Chrome、Mozilla Firefox、Safari和Microsoft Edge，并可以从浏览器的扩展商店或第三方网站下载和安装。</p>
<p>任何具有基本Web开发技能的人都可以开发浏览器扩展，而且有许多在线资源可供学习如何创建它们。但是，在从第三方来源安装扩展时，需要谨慎，因为它们可能包含恶意代码，会危及您的浏览器和计算机的安全。</p>
<p>以下是一些最受欢迎的Web浏览器的扩展商店：</p>
<p>🔗 Chrome Web商店：<a href="https://chrome.google.com/webstore">https://chrome.google.com/webstore</a></p>
<p>🔗 Mozilla Add-ons：<a href="https://addons.mozilla.org/">https://addons.mozilla.org/</a></p>
<p>🔗 Safari扩展程序库：<a href="https://extensions.apple.com/">https://extensions.apple.com/</a></p>
<p>🔗 Microsoft Edge Add-ons：<a href="https://microsoftedge.microsoft.com/addons">https://microsoftedge.microsoft.com/addons</a></p>
<h1 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h1><p>要使用官方方式安装浏览器扩展程序，请按照以下步骤操作：</p>
<p>1️⃣ 打开浏览器（Chrome、Firefox、Safari或Edge）；</p>
<p>2️⃣ 进入浏览器扩展商店（<a href="https://chrome.google.com/webstore">Chrome Web商店</a>、<a href="key_phrase?phrase=Firefox&prompt=Tell%20me%20more%20about%20Firefox">Firefox 商店</a>、<a href="https://addons.mozilla.org/">Mozilla Add-ons</a>、<a href="https://extensions.apple.com/">Safari扩展程序库</a>、<a href="https://microsoftedge.microsoft.com/addons">Microsoft Edge Add-ons</a>）；</p>
<p>3️⃣ 搜索你要安装的扩展程序；</p>
<p>4️⃣ 点击要安装的扩展程序；</p>
<p>5️⃣ 点击“添加至Chrome”（或“添加至Firefox”、“获取”（Safari）或“获取”（Edge））按钮；</p>
<p>6️⃣ 查看扩展程序请求的权限，并单击“添加扩展程序”（或“添加至Firefox”、“安装”或“获取”）；</p>
<p>7️⃣ 扩展程序现在已安装并添加到浏览器工具栏或菜单中。但可能需要重新启动浏览器以使扩展程序完全可用。</p>
<p><strong>如果您无法访问浏览器扩展商店，则有几种替代方法可以下载浏览器扩展程序：</strong></p>
<p>📌 <strong>从扩展程序开发人员的网站下载</strong>：许多扩展程序开发人员在自己的网站上托管扩展程序文件，你可以手动下载和安装；</p>
<p>📌 <strong>使用第三方扩展程序下载器</strong>：有几个第三方网站允许您从Chrome Web商店、Mozilla Add-ons和其他扩展程序商店下载浏览器扩展程序。比如 <a href="http://crxextractor.com/">CRX Extractor</a>，它可以从Chrome Web商店提取扩展程序文件，并允许你手动安装。</p>
<p>📌 <strong>使用预装有扩展程序的便携式浏览器</strong>：某些便携式Web浏览器版本预装了流行的扩展程序，你可以在不安装扩展程序的情况下使用它们。</p>
<h1 id="如何开发浏览器扩展？"><a href="#如何开发浏览器扩展？" class="headerlink" title="如何开发浏览器扩展？"></a>如何开发浏览器扩展？</h1><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>开发一个 chrome 扩展程序需要的技术栈：HTML、CSS、JavaScript</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── manifest.json</span><br><span class="line">├── background.js</span><br><span class="line">├── popup.html</span><br><span class="line">├── popup.js</span><br><span class="line">├── content_scripts/</span><br><span class="line">│   ├── content_script_1.js</span><br><span class="line">│   ├── content_script_2.js</span><br><span class="line">│   └── styles/</span><br><span class="line">│       ├── style_1.css</span><br><span class="line">│       └── style_2.css</span><br><span class="line">├── icons/</span><br><span class="line">│   ├── icon_16.png</span><br><span class="line">│   ├── icon_32.png</span><br><span class="line">│   ├── icon_48.png</span><br><span class="line">│   └── icon_128.png</span><br><span class="line">├── options.html</span><br><span class="line">├── options.js</span><br><span class="line">├── lib/</span><br><span class="line">│   ├── library_1.js</span><br><span class="line">│   ├── library_2.js</span><br><span class="line">│   └── utility/</span><br><span class="line">│       ├── utility_1.js</span><br><span class="line">│       └── utility_2.js</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://developer.chrome.com/docs/extensions/mv3/architecture-overview/">Architecture overview</a></p>
<table>
<thead>
<tr>
<th align="center"><img src="Snipaste_2023-06-08_19-25-08.png"></th>
</tr>
</thead>
</table>
<p>mainfest.json 是一个扩展程序最基本也是必须的，最少要有它。它是项目的配置文件，整个项目的结构是围绕它的配置项进行组织。</p>
<p>但是也不能只有它，毕竟没有业务逻辑的扩展程序是没有作用的！</p>
<p>一个有基本逻辑的扩展程序至少得有 content_scripts，而完整的完整的扩展程序包含 content_scripts、options、popup 和 background。</p>
<p><strong>content_script</strong>：js脚本，可以与扩展程序匹配到的页面交互和操作；</p>
<p><strong>options</strong>：扩展程序的设置页面，扩展程序暴露给用户的设置项一般放置在这个页面；</p>
<p><strong>popup</strong>：扩展程序的信息面板，在浏览器安装扩展程序后，由点击工具栏扩展程序的图标呼起的菜单；</p>
<p><strong>background</strong>：js脚本，但有别于 content_script，它可以使用 Chrome apis 以及 extension service worker。前三者都运行在自己的上下文，相互间是独立、隔离的，而 background 则可以通过 extension service worker 与它们三者通信，如上图，background 起到三个模块通信桥梁的重要作用！比包含但不限于以下作用：</p>
<p>1️⃣ 在options页面，开关扩展程序某功能，需要通知 content_script 开关对应功能；</p>
<p>2️⃣ content_script 执行或使用功能时需要将信息展示在 popup 面板；</p>
<p>3️⃣ 在 popup 面板临时禁用扩展程序，popup则需要通知 content_script。</p>
<h2 id="Mainfest"><a href="#Mainfest" class="headerlink" title="Mainfest"></a>Mainfest</h2><p><code>manifest.json</code> 是开发浏览器扩展时必备的清单文件，用于定义扩展程序的名称、版本、图标、权限、功能等信息。</p>
<p><em>它是必须的配置文件，需要将其存放在扩展程序的根目录下，即扩展程序的文件夹中！</em></p>
<p>以下是一个完整的manifest.json示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is a simple extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;default_title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon16.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;32&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon32.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;48&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon48.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;128&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon128.png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个示例中包含了一些简单的配置：</p>
<p>name, version, description 分别指定了扩展程序的名称、版本号、描述。<br>action 指定了浏览器操作按钮的默认图标、标题和弹出窗口。<br>需要注意的是，这个示例中没有包含后台脚本、内容脚本、权限等配置，这些配置根据具体需求和功能可以添加</p>
<p>完整的 mainfest 属性定义以及例子可以查阅 <a href="https://developer.chrome.com/docs/extensions/mv3/manifest/">Manifest file format</a></p>
<h2 id="Content-Scripts"><a href="#Content-Scripts" class="headerlink" title="Content Scripts"></a>Content Scripts</h2><p>扩展程序的 content script 作为浏览器扩展程序的一部分，主要用于与匹配到的页面交互和操作。它可以在匹配到的页面中注入 JavaScript 代码，并且可以访问页面的 DOM 和 JavaScript 对象。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><strong>修改页面的内容和样式</strong>：content script 可以直接操作页面的 DOM 和 CSS 样式，实现对页面内容和样式的修改。</p>
<p><strong>监听页面事件</strong>：content script 可以注册事件监听器，监听页面的事件，例如点击、滚动、输入等，从而实现与页面的交互。</p>
<p><strong>与扩展程序通信</strong>：content script 可以通过 chrome.runtime.sendMessage()、chrome.runtime.onMessage、chrome.runtime.connect()、chrome.runtime.onConnect 等 subset API 与扩展程序进行通信，从而实现与扩展程序的交互。</p>
<p><strong>执行页面脚本</strong>：content script 可以在匹配到的页面中执行 JavaScript 代码，从而实现更复杂的操作和交互。</p>
<p><strong>操作浏览器标签页</strong>：content script 可以通过 chrome.tabs API 操作浏览器标签页，例如切换标签页、打开新标签页、关闭标签页等。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>content_scripts 的相关逻辑文件需要在 manifest.json 中通过配置指定！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;manifest_version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">&quot;content_scripts&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;https://www.example.com/*&quot;</span>],</span><br><span class="line">      <span class="string">&quot;js&quot;</span>: [<span class="string">&quot;content/content_script.js&quot;</span>],</span><br><span class="line">      <span class="string">&quot;css&quot;</span>: [<span class="string">&quot;content/styles.css&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>js 属性：</strong> 用于指定要注入的 JavaScript 文件列表，即在匹配到的网页中，会将指定的 JavaScript 文件注入到网页中，从而实现对网页逻辑的修改和增强。它是一个数组，可以包含多个 JavaScript 文件路径。每个路径都是相对于扩展程序文件夹的路径，可以使用相对路径或绝对路径。</p>
<p><strong>css 属性：</strong> 用于指定要注入的 CSS 文件列表，即在匹配到的网页中，会将指定的 CSS 文件注入到网页中，从而实现对网页样式的修改和增强。它是一个数组，可以包含多个 CSS 文件路径。每个路径都是相对于扩展程序文件夹的路径，可以使用相对路径或绝对路径。</p>
<p><strong>📝 Hint：CSS 文件会自动注入到匹配的网页中，无需在 JavaScript 逻辑中声明。</strong></p>
<p><strong>matches 属性：</strong> 用于指定要注入脚本和样式的网页 URL 匹配模式，即只有匹配指定 URL 模式的网页才会注入相应的脚本和样式。需要注意的是，matches 属性是必需的，如果未指定该属性，则 content_scripts 不会生效。</p>
<p>每个 URL 模式都是一个字符串，可以使用通配符 <code>*</code> 匹配任意字符，例如：</p>
<p>📌 <code>https://www.example.com/*</code> 匹配 <code>https://www.example.com/</code> 及其子路径下的所有网页。</p>
<p>📌 <code>http://*.example.com</code> 匹配以 <code>http://</code> 开头、以 <code>.example.com</code> 结尾的所有网页。</p>
<p>📌 <code>https://www.example.com/page.html</code> 匹配指定的网页。</p>
<p><strong>📝 Hint:</strong> matches 的详细匹配规则可以参考 <a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/">Match Patterns - Google Chrome</a></p>
<p><strong>完整的 content_scripts 配置可参考 <a href="https://developer.chrome.com/docs/extensions/mv3/content_scripts/">Documentation &gt; Extensions &gt; In depth: core concepts | Content scripts</a></strong></p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在 content script 中，不能直接使用 Service Worker（SW）API，因为 Service Worker 是在后台服务工作线程中运行的。</p>
<p>content script 运行在 Web 页面的上下文中，它们不能直接访问浏览器的后台服务工作线程。相反，content script 只能访问一个受限的 subset API。</p>
<p>如果你需要使用 Service Worker API，你可以在后台服务工作线程中注册 Service Worker，并在 Service Worker 中处理相关的事件。然后使用 chrome.runtime.sendMessage() 方法向后台服务工作线程发送消息，以便 content script 与 Service Worker 进行通信。</p>
<h2 id="Background-Script"><a href="#Background-Script" class="headerlink" title="Background Script"></a>Background Script</h2><p>background 用于指定后台脚本或者后台服务工作线程。本节要</p>
<p>它在浏览器扩展中扮演着重要的角色，常用于处理扩展的核心功能、响应浏览器事件、与其他页面通信等；</p>
<p>📌 <strong>处理扩展的核心功能：</strong> 作为扩展的中央控制器，处理扩展的核心功能，例如数据存储、网络请求、数据同步等；</p>
<p>📌 <strong>响应浏览器事件：</strong> 响应浏览器事件，例如监听浏览器标签页的创建、更新、关闭等事件，以实现相关功能；</p>
<p>📌 <strong>与其他页面通信：</strong> 与扩展中的其他页面（例如 popup、options 页面）进行通信，以便实现页面之间的数据共享、状态同步等；</p>
<p>在扩展程序中，content_script、popup以及options三个部分都是可以执行脚本的。它们相互之间都是不能直接通信的。background 的Server Workers则可以起到事件中心的作用，给他们派发事件和消息！另外，它们三者都不能调用完整的 Chrome Apis，仅能使用一个子集 Api，但是 background 可以！那么它们三者则可以通过消息通信访问 background，从而调用完整的 Chrome Apis。</p>
<p>📌 <strong>处理后台任务：</strong> 在后台运行，处理后台任务，例如定期检查数据更新、发送推送消息等；</p>
<p>📌 <strong>扩展的初始化：</strong> 作为扩展的初始化入口，启动扩展时预加载一些资源、初始化一些状态等。</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>background 通过 manifest配置，涉及到 <code>service_worker</code> 和 <code>persistent</code> 两个属性，一个简单的例子如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;service_worker&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;persistent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>service_worker</code>属性：</strong> 配置执行的脚本文件位置； </p>
<p><strong><code>persistent</code>属性：</strong> 是一个可选的布尔类型的字段，用于指示后台脚本或者后台服务工作线程的持续性。</p>
<p>👉 <code>persistent: true</code>，表示后台脚本或者后台服务工作线程是持续性的，会一直运行，直到浏览器关闭或者扩展被卸载。在这种情况下，后台脚本或者后台服务工作线程可以随时响应事件、处理任务，而不需要重新启动。</p>
<p><strong>📝 Hint</strong>：在 persistent: true 模式下，后台服务工作线程独立于任何扩展操作窗口或标签页运行，并且会一直运行，直到用户关闭扩展或浏览器。即使用户关闭了扩展操作窗口或标签页，后台服务工作线程仍会继续运行。</p>
<p>👉 <code>persistent: false</code>，表示后台脚本或者后台服务工作线程只在需要时被加载和执行。在这种情况下，后台脚本或者后台服务工作线程只有在需要处理事件或者任务时才会被启动，并在完成任务后自动关闭。</p>
<p><strong>📝 Hint</strong>：当在 manifest.json 文件中设置 persistent: false 时，后台服务工作线程会在所有扩展操作窗口和标签页关闭后自动关闭。此时，后台服务工作线程的生命周期与扩展操作窗口和标签页的生命周期相同。</p>
<p>具体来说，后台服务工作线程会在所有扩展操作窗口和标签页关闭后的一段时间内保持活动状态，以便处理未完成的任务。在这段时间过后，后台服务工作线程会被终止。如果后台服务工作线程需要在关闭前执行一些清理操作，例如保存数据或关闭网络连接，可以在 chrome.runtime.onSuspend 事件中执行这些任务。</p>
<h3 id="区分扩展程序的-service-workers-和网页的-service-workers"><a href="#区分扩展程序的-service-workers-和网页的-service-workers" class="headerlink" title="区分扩展程序的 service workers 和网页的 service workers"></a>区分扩展程序的 service workers 和网页的 service workers</h3><p>首先要明确两者不是完全一致的，在概念上是一致的，但是他们的应用、api等都略有不同！</p>
<p>扩展程序 service workers 和 网页的 service workers 都是在后台运行并处理事件驱动任务的 JavaScript 文件。但是，它们之间存在一些不同之处：</p>
<p>📌 <strong>上下文</strong>：扩展程序 service workers 在浏览器扩展的上下文中运行，而网页的 service workers 在网页的上下文中运行。</p>
<p>📌 <strong>范围</strong>：扩展程序 service workers 的范围仅限于所属的扩展程序，而网页的 service workers 的范围仅限于注册它们的网站。</p>
<p>📌 <strong>权限</strong>：扩展程序 service workers 可以访问网页的 service workers 无法访问的其他权限，例如修改浏览器设置、访问用户数据和与其他扩展程序交互等。</p>
<p>📌 <strong>通信</strong>：扩展程序 service workers 可以与扩展程序的其他部分（例如内容脚本和后台页面）进行通信，而网页的 service workers 只能与注册它们的网页进行通信。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展程序 service workers 的消息通信</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tab.<span class="property">id</span>, &#123;<span class="attr">greeting</span>: <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sender.<span class="property">tab</span> ?</span><br><span class="line">                <span class="string">&quot;from a content script:&quot;</span> + sender.<span class="property">tab</span>.<span class="property">url</span> :</span><br><span class="line">                <span class="string">&quot;from the extension&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">greeting</span> === <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">      <span class="title function_">sendResponse</span>(&#123;<span class="attr">farewell</span>: <span class="string">&quot;goodbye&quot;</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页的 service workers消息通信</span></span><br><span class="line"></span><br><span class="line">client.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&quot;Hey I just got a fetch from you!&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: event.<span class="property">request</span>.<span class="property">url</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>.<span class="property">msg</span>, event.<span class="property">data</span>.<span class="property">url</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>📌 <strong>激活</strong>：安装扩展程序时扩展程序 service workers 会自动激活，而网页的 service workers 需要由网站开发人员手动注册。</p>
<p>总之，扩展程序服务工作者旨在为浏览器扩展提供额外的功能，而 Web 服务工作者旨在为网页提供离线支持和其他功能。</p>
<h2 id="Popup-Dasboard"><a href="#Popup-Dasboard" class="headerlink" title="Popup Dasboard"></a>Popup Dasboard</h2><p>popup 是指浏览器扩展中的一个特殊页面，用于在左键单击浏览器扩展图标时显示的弹出窗口中显示内容。popup 页面可以包含 HTML、CSS 和 JavaScript 等内容，可以实现各种功能，例如显示扩展程序的设置、调用浏览器扩展 API 进行操作、与用户进行交互等。</p>
<p>Popup 的尺寸时有限制的。不能小于 25x25，不能大于 800x600。</p>
<table>
<thead>
<tr>
<th align="center"><img src="Snipaste_2023-06-08_12-29-52.png"></th>
</tr>
</thead>
</table>
<p>popup 也是需要通过 manifest 配置指定！</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意！在 manifest中，popup 指定的是一个html文件！</p>
<p>popup也是可以引入 JS 和 CSS。但是和 content_script 不同的是，它不需要在 manifest 中指定。 需要在HTML文件中使用 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 标签引入 JavaScript 和 CSS 文件。可以认为popup是单独的小页面！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Extension Popup<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;popup.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;popup.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;my-button&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>popup 中引入的 JavaScript 文件运行在一个独立的沙盒环境中，它可以访问浏览器扩展 API，但需要注意它与浏览器扩展的其他部分（如 background 脚本）是隔离的。</p>
<p>另外，由于 popup 显示时间通常较短，因此在 JavaScript 文件中需要尽量避免使用长时间运行的操作，以免影响用户体验。例如，如果需要进行一些较为耗时的计算，可以考虑使用 Web Worker 来将计算过程转移到后台线程中，以免阻塞主线程。</p>
<p><strong>Hint</strong>：Popup的详细使用与配置可参考 <a href="https://developer.chrome.com/docs/extensions/reference/action/#popup">Documentation &gt; Extensions &gt; API reference | Popup</a></p>
<h2 id="Options-Page"><a href="#Options-Page" class="headerlink" title="Options Page"></a>Options Page</h2><table>
<thead>
<tr>
<th align="center"><img src="Snipaste_2023-06-08_15-51-31.png" alt="Options Page"></th>
</tr>
</thead>
</table>
<p>在浏览器扩展程序中，Options 页面提供了一个用户界面，允许用户配置扩展程序的设置和选项。通过 Options 页面，用户可以自定义扩展程序的行为和外观，以满足他们的需求和偏好。比如可以用于但不限于以下用途：</p>
<p>📌 <strong>配置选项</strong>：允许用户配置扩展程序的选项和设置，例如语言、主题、字体大小、颜色等，当然前提是扩展程序有暴露这些设置；</p>
<p>📌 <strong>显示帮助和文档</strong>：提供帮助和文档，帮助用户了解扩展程序的功能和用法；</p>
<p>📌 <strong>收集反馈和建议</strong>：提供反馈和建议的表单，允许用户向开发者反馈他们对扩展程序的看法和建议；</p>
<p>📌 <strong>显示关于信息</strong>：显示有关扩展程序的信息，例如版本号、作者、许可证等；</p>
<p>Options Page 是点击扩展程序图片右键 &gt; 点击 “Options” 跳转或弹出的页面，这个页面配置是可选的！</p>
<p>与 Popup Dashboard一样，它也可以包含 HTML、CSS 和 JavaScript 等内容。</p>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>Options Page有两种类型，整页和嵌入式，选项页面的类型取决于它在清单中的声明方式。</p>
<h4 id="整页"><a href="#整页" class="headerlink" title="整页"></a>整页</h4><p>整页的Options Page在用户点击“Options”按钮时会跳转页面，配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;options_page&quot;</span><span class="punctuation">:</span> <span class="string">&quot;options.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h4><p>与整页不同，它允许直接在“<a href="extensions">扩展程序管理页面</a>”（不是扩展程序匹配到的页面）弹出！</p>
<p><img src="Snipaste_2023-06-09_10-51-41.png"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;options_ui&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="string">&quot;options.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;open_in_tab&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>page</code></strong><br>Type：<code>String</code><br>Default: “”<br>配置 options 页面的文件路径。</p>
<p><strong><code>open_in_tab</code></strong><br>Type：<code>Boolean</code><br>Default: <code>false</code><br>若设置 <code>false</code>，则点 <code>Extension Options</code> 按钮将跳转<a href="extensions">扩展程序管理页面</a>并在本页弹出窗口展示 option 的内容；<br>若设置 <code>true</code>，则在点击按钮时则直接新标签跳转到 options 页面，效果与 <a href="#%E6%95%B4%E9%A1%B5">整页</a> 的效果一样。</p>
<h2 id="Extension-Icons"><a href="#Extension-Icons" class="headerlink" title="Extension Icons"></a>Extension Icons</h2><p>icons 是浏览器扩展所需要的图标文件，包括不同尺寸的图标，例如 icon16.png、icon32.png、icon48.png 和 icon128.png 等。</p>
<p>这些图标文件会在浏览器扩展被安装时显示在浏览器的地址栏、书签栏、工具栏等位置，以及在插件商店中展示。</p>
<p>不同浏览器的图标尺寸要求可能略有不同，因此需要按照相应的要求提供不同尺寸的图标文件，以保证扩展在各种情况下都能够正确显示。常见的尺寸包括16x16、32x32、48x48 和 128x128 等。</p>
<p>下面是icons配置的简单例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon16.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;32&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon32.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;48&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon48.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;128&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icons/icon128.png&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>📝 Hint:</strong> icons 允许以数组形式配置！</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>在调试你的扩展程序前，需要先确认项目是完整的，最少要包含一个 <code>manifest.json</code> 文件。</p>
<p>如果使用了content_scripts、popup或option，就要保证它们的路径被正确配置在 <code>manifest.json</code> 中。如果 content_scripts 没有生效，则需要留意 mathchs 属性是否正确配置；</p>
<h2 id="加载本地扩展程序"><a href="#加载本地扩展程序" class="headerlink" title="加载本地扩展程序"></a>加载本地扩展程序</h2><p>然后，你可以使用开发者模式加载你的本地项目进行调试！</p>
<p>1️⃣ 在浏览器地址栏输入 <code>chrome://extensions</code>，跳转到 扩展程序管理页面</p>
<p>2️⃣ 点击 <code>Developer mode</code> 旁边的切换开关启用开发人员模式；</p>
<p>3️⃣ 点击 <code>Load unpacked</code> 按钮，并选择你开发的扩展程序即可。</p>
<table>
<thead>
<tr>
<th align="center"><img src="BzVElZpUtNE4dueVPSp3.webp"></th>
</tr>
</thead>
</table>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p>代码中的console会在浏览器的 Console Tab 输出。</p>
<h3 id="Content-Scripts-1"><a href="#Content-Scripts-1" class="headerlink" title="Content Scripts"></a>Content Scripts</h3><p>content_scripts 输出的 console 在扩展程序执行时，将会在扩展程序匹配到的页面中输出，换言之可以在 <code>Console Tab</code> 看到 content_script 输出的 console。</p>
<table>
<thead>
<tr>
<th align="center"><img src="Snipaste_2023-06-09_11-12-25.png"></th>
</tr>
</thead>
</table>
<h3 id="Popup-Dashboard"><a href="#Popup-Dashboard" class="headerlink" title="Popup Dashboard"></a>Popup Dashboard</h3><p>popup 与 content_scripts不同，它输出的 console 不会在匹配到的页面中输出。若要查看 popup 输出的 console 则需要在 popup dashboard 区域，操作 <code>右键</code> &gt; <code>inspect</code>，则呼起调试页面！</p>
<table>
<thead>
<tr>
<th align="center"><img src="Snipaste_2023-06-09_11-23-46.png"></th>
</tr>
</thead>
</table>
<h3 id="Options-Page-1"><a href="#Options-Page-1" class="headerlink" title="Options Page"></a>Options Page</h3><p>与 Popup Dashboard 一样，options也需要通过 <code>inspect</code> 查看 console 的输出。</p>
<p><img src="Snipaste_2023-06-09_11-32-44.png"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>错误日志</strong>，扩展程序卡片上会有“Error”按钮，点击可以查看错误日志。</p>
<p><img src="a9lAHCJZZrebOSKrkPRD.webp"></p>
<p>既然已经可以进行 <code>inspect</code> 操作，那么常规的断点、性能检测、存储情况等等调试手段都可使用！</p>
<p>参考：</p>
<ul>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/getstarted/development-basics/">https://developer.chrome.com/docs/extensions/mv3/getstarted/development-basics/</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/tut_debugging/">Debugging extensions</a></li>
</ul>
<h1 id="发布扩展程序"><a href="#发布扩展程序" class="headerlink" title="发布扩展程序"></a>发布扩展程序</h1><p>发布前需要先对项目进行打包，打包完后的扩展程序已经可以使用。之后可以选择直接使用或者到浏览器扩展程序的商店。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>在发布前，需要先将扩展程序项目打包为 zip 包或者 crx 包。</p>
<p>打包方式就个人情况而定，可以直接使用 linux 的 <code>zip</code> 命令进行打包，比如下面将 browser-ext_gushiwen-delad 打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./dist/browser-ext_gushiwen-delads \</span><br><span class="line">&amp;&amp; zip -r ../browser-ext_gushiwen-delads.zip ./&quot;</span><br></pre></td></tr></table></figure>

<p>将 <code>./dist/browser-ext_gushiwen-delads</code> 压缩为 zip包，并在 <code>./dist/</code> 目录下输出 <code>browser-ext_gushiwen-delads.zip</code>。</p>
<p>或者在<a href="extensions">扩展程序管理页面</a>点击 <code>Pack extension</code> 按钮进入打包流程</p>
<p><img src="Snipaste_2023-06-09_12-17-53.png"></p>
<p>选择你的扩展程序目录</p>
<p><img src="Snipaste_2023-06-09_12-18-21.png"></p>
<p>点击 <code>Pack extension</code> 按钮进行打包。</p>
<p><img src="Snipaste_2023-06-09_12-18-38.png"></p>
<p><img src="Snipaste_2023-06-09_12-25-21.png"></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布到谷歌扩展程序商店：</p>
<p>1️⃣ 创建并设置一个开发者账号</p>
<p><img src="adH2VFqS92VdzPTjsHtB.webp"></p>
<p>📝 <strong>Hint</strong>：需要支付 5 刀的注册费！</p>
<p>2️⃣ 上传你的 zip 包，并提交</p>
<p><img src="g06GNVoineSSnxt4N6Fy.webp"><br><img src="BiZituXHHZ74SIkwc3q7.webp"></p>
<p>📝 <strong>Hint</strong>：发布扩展程序到谷歌扩展程序商店的详细流程可参考：<a href="https://developer.chrome.com/docs/webstore/publish/">Documentation &gt; Chrome Web Store &gt; Publish your extension</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>浏览器扩展程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器扩展程序</tag>
        <tag>浏览器扩展程序开发</tag>
        <tag>浏览器扩展程序安装</tag>
        <tag>浏览器扩展程序发布</tag>
        <tag>content script</tag>
        <tag>background script</tag>
        <tag>popup</tag>
        <tag>options</tag>
        <tag>chrome extension</tag>
      </tags>
  </entry>
  <entry>
    <title>LICENSE的选择与生成</title>
    <url>/blog/resources/license/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文旨在介绍何为license，如何选择license，以及开发常用的MIT license如何使用。</p>
<span id="more"></span>

<h1 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h1><p>LICENCE 是软件的授权许可，详细说明了获得代码后拥有的权利，哪些操作是允许的，哪些操作是禁止的。软件的版权许可证可有很多方式，本文仅限于讨论开源软件协议 Open Source License。</p>
<p>Open Source License 是指符合开源定义的许可证——简而言之，它们允许软件自由使用、修改和共享。要获得开源计划（也称为OSI）的批准，许可证必须经过开源计划的许可证审查过程。</p>
<p>对于大多数人来说，没必要花大把时间去写许可协议，选择一种比较流行的开源协议就足够了，省时省力，更便于自己作品的传播，于人于己都有利。</p>
<h1 id="常见的LICENSE"><a href="#常见的LICENSE" class="headerlink" title="常见的LICENSE"></a>常见的LICENSE</h1><p>世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。</p>
<p><img src="da68b98e404578126b87c5afd9ba9bc3.png" alt="常见的开源许可证"></p>
<h1 id="选择LICENSE"><a href="#选择LICENSE" class="headerlink" title="选择LICENSE"></a>选择LICENSE</h1><p>下面是来自 Paul Bagwell 整理的许可证选择流程：</p>
<p><img src="tumblr_lkhe2jxnXS1qguzn1o1_r7_1280.png" alt="来自Paul Bagwell整理"></p>
<p>下面是 阮一峰整理的选择流程，图已经略过时，但仍然有一定的参考价值，英文好的同学建议看 Paul Bagwell 整理的选择。</p>
<table>
<thead>
<tr>
<th align="center"><img src="9720a0afdb60d23b31b3a667ad6e70a2.png" alt="来自阮一峰整理"></th>
</tr>
</thead>
</table>
<h1 id="MIT-LICENSE"><a href="#MIT-LICENSE" class="headerlink" title="MIT LICENSE"></a>MIT LICENSE</h1><p>MIT许可协议之名源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称“X许可协议”（X License）或“X11许可协议”（X11 License）</p>
<p>MIT内容与三条款BSD许可协议（3-clause BSD license）内容颇为近似，但是赋予软件被许可人更大的权利与更少的限制。</p>
<p>有许多团体均采用MIT许可证。例如著名的SSH连线软件PuTTY与X窗口系统。Expat、Mono开发平台库、Ruby on Rails、Lua、微软的Visual Studio Code源代码等等也都采用MIT许可协议。</p>
<p>以下是 <a href="https://www.mit-license.org/">MIT LICENSE的原本</a> 的内容：</p>
<blockquote>
<p>Copyright &lt;YEAR&gt; &lt;COPYRIGHT HOLDER&gt;</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<p>对于个人开发者来说，可能没有太关注许可，最初注重的只是代码的合法与传播。所以如果不想管或不知道该选那个许可，可直接使用MIT许可。</p>
<p>以上引用的即是 MIT 的模板。需要修改的只有两个位置：</p>
<ol>
<li><strong>YEAR</strong>：是版权使用的年份。如果你在2015年申请版权（当你写作品时会自动发生），请在2015年提交。有些人喜欢设定一系列年份（即2015-2020年）——这没有必要。</li>
<li><strong>COPYRIGHT HOLDER</strong>：是拥有版权的实体的全名。如果拥有实体是私人则写上自己的名字即可。</li>
</ol>
<h2 id="生成-MIT"><a href="#生成-MIT" class="headerlink" title="生成 MIT"></a>生成 MIT</h2><p>比较流程化的操作是手动在项目目录下新建 LICENSE 文件，复制 MIT LICENSE 模板，修改 YEAR 和 COPYRIGHT HOLDER 即可。</p>
<p>另外，还可以在 Github 上直接创建 LICENSE 文件并选择MIT协议；</p>
<p>或者使用npm cli生成。</p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>Github是支持半自动化的方式创建LICENSE的。</p>
<h4 id="创建LICESE文件"><a href="#创建LICESE文件" class="headerlink" title="创建LICESE文件"></a>创建LICESE文件</h4><p>创建LICESE文件，会自动出现选择LICENSE协议的按钮（“Choose a license template”）</p>
<p><img src="Snipaste_2023-05-30_17-44-00.png" alt="创建LICESE文件"></p>
<h4 id="选择MIT协议"><a href="#选择MIT协议" class="headerlink" title="选择MIT协议"></a>选择MIT协议</h4><p><img src="Snipaste_2023-05-30_17-47-09.png" alt="选择MIT协议"></p>
<h3 id="Npm-Lib"><a href="#Npm-Lib" class="headerlink" title="Npm Lib"></a>Npm Lib</h3><p><a href="https://github.com/Ovyerus">Ovyerus</a> 提供了一个很方便生成LICESE的Npm Lib：<a href="https://www.npmjs.com/package/license">license</a>。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g license</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">license [license]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 YEAR 和 COPYRIGHT HOLDER</span></span><br><span class="line"></span><br><span class="line">license [license] -n &lt;COPYRIGHT HOLDER&gt; -y &lt;YEAR&gt;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/zh-cn/%E6%8E%88%E6%AC%8A_(%E6%B3%95%E5%BE%8B)">LICENSE WIKI</a></li>
<li><a href="https://opensource.org/licenses/">Open Source License</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%BA%90%E6%8E%88%E6%AC%8A">开源授权 WIKI</a></li>
<li><a href="https://web.archive.org/web/20110503183702/http://pbagwl.com/post/5078147450/description-of-popular-software-licenses">description-of-popular-software-licenses</a></li>
<li><a href="https://opensource.stackexchange.com/questions/1522/what-should-be-written-in-mit-license-year-full-name">What should be written in MIT license (year, full name)?</a></li>
</ul>
]]></content>
      <tags>
        <tag>开发标准</tag>
        <tag>LICENSE</tag>
      </tags>
  </entry>
  <entry>
    <title>初识WSL2</title>
    <url>/blog/resources/%E5%88%9D%E8%AF%86WSL2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文旨在记录WSL2的安装，让WSL基本可用。</p>
<p>接着是Linux发行版本的替换，以至于可以自由选择自己熟悉、喜欢的distribution。</p>
<p>最后，是有选择地介绍WSL的基础配置及其略详细的情况，目的是让WSL可以更加适合开发者使用。如果后面有需要会继续补充常用的配置使用。以及linux发行版本的替换。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本节将介绍安装WSL2的系统要求以及笔者的安装环境。笔者将在比较新的windows 10环境下，使用命令行安装，并且详细记录安装细节。</p>
<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>安装要求是指可以安装WSL2的windows 版本。它们分为最方便的安装要求和最低的要求，前者可以直接使用命令行安装，后者需要做一些windows功能的开启，官方的详细要求可参考 <a href="#Prerequisites">附录-Prerequisites</a>。</p>
<h3 id="最方便的要求"><a href="#最方便的要求" class="headerlink" title="最方便的要求"></a>最方便的要求</h3><p>与下面这个本版下相同或者更高：</p>
<p>window 10</p>
<ul>
<li>版本：2004</li>
<li>OS Build：19041</li>
</ul>
<h3 id="最低版本"><a href="#最低版本" class="headerlink" title="最低版本"></a>最低版本</h3><p>最低版本的要求根据x64版本和ARM64版本有所不同。具体如下</p>
<p>x64版本：</p>
<ul>
<li>window 10</li>
<li>版本：1903</li>
<li>OS Build：18362</li>
</ul>
<p>ARM64版本：</p>
<ul>
<li>window 10</li>
<li>版本：2004</li>
<li>OS Build：19041</li>
</ul>
<p><strong>在符合以上要求的情况下，还需要已经安装WSL1！</strong></p>
<p>安装WSL1，需要以下几个操作：</p>
<ol>
<li>启用wsl功能；</li>
<li>启用虚拟机平台；</li>
</ol>
<h4 id="启用wsl功能"><a href="#启用wsl功能" class="headerlink" title="启用wsl功能"></a>启用wsl功能</h4><p>还需要在控制面版 &gt; windows &gt; 功能开关，勾选打开 wsl 选项，见下图：</p>
<p><img src="enable-wsl1-windows-10.webp"></p>
<p>然后，重启电脑。</p>
<h4 id="启用虚拟机平台"><a href="#启用虚拟机平台" class="headerlink" title="启用虚拟机平台"></a>启用虚拟机平台</h4><p>以管理员权限打开powershell执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure>

<p>然后，重启电脑。</p>
<p>到此，旧版本的准备已经完成。</p>
<h2 id="实践环境"><a href="#实践环境" class="headerlink" title="实践环境"></a>实践环境</h2><p>笔者当前的环境是比较新的环境。适合使用命令行直接安装WSL2。环境细节见下图：</p>
<table>
<thead>
<tr>
<th><img src="Snipaste_2023-03-12_17-34-36.png"></th>
</tr>
</thead>
</table>
<h2 id="命令行安装"><a href="#命令行安装" class="headerlink" title="命令行安装"></a>命令行安装</h2><p>打开 powershell，使用以下命令安装，等待完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>

<p>安装结束后，可以使用 <code>wsl --help</code> 查看支持的命令，详细参考 <a href="#wsl-%E2%80%93help">附录-wsl –help</a>。</p>
<p>然后，使用 <code>wsl --status</code> 确认当前的 WSL 版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\isaac&gt; wsl --status</span><br><span class="line">Default Distribution: Debian</span><br><span class="line">Default Version: 2</span><br></pre></td></tr></table></figure>

<p>如果不是 <code>Default Version: 2</code> 的话，使用 <code>wsl --set-default-version 2</code> 修改。</p>
<blockquote>
–set-default-version <br>        Changes the default install version for new distributions.

<h2 id="旧版本windows安装WSL2"><a href="#旧版本windows安装WSL2" class="headerlink" title="旧版本windows安装WSL2"></a>旧版本windows安装WSL2</h2><p>旧版本的详情可以查看 <a href="#%E6%9C%80%E4%BD%8E%E7%89%88%E6%9C%AC">最低版本</a>。已经做好准备后，还需要做下面几步：</p>
<ul>
<li><p>下载并安装 <a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">WSL2 Linux kernel update package for x64 machines</a>；</p>
</li>
<li><p>设置WSL版本：<code>wsl --set-default-version 2</code></p>
</li>
</ul>
<h1 id="修改linux-distributions"><a href="#修改linux-distributions" class="headerlink" title="修改linux distributions"></a>修改linux distributions</h1><p>WSL默认安装的Linux发行版本是 Ubantu。当前WSL支持的Linux发行版本可查看 <a href="#WSL%E6%94%AF%E6%8C%81%E7%9A%84Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC">附录-WSL支持的Linux发行版本</a>。以下以切换 Debian 作为例子：</p>
<p>打开 powershell，使用 <code>wsl --list -o</code> 查看当前支持的发行版本：</p>
<p><img src="Snipaste_2023-03-12_22-58-58.png"></p>
<p>见上图提示，使用 <code>wsl --install -d &lt;Distro&gt;</code> 安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --install -d Debian</span><br></pre></td></tr></table></figure>

<p>安装完成后，设置WSL默认的发行版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl -s Debian</span><br></pre></td></tr></table></figure>

<p>设置完成后，可以使用 <code>wsl --status</code> 查看。</p>
<p><img src="Snipaste_2023-03-12_23-05-55.png"></p>
<h1 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h1><p>下面要介绍的是使用配置文件进行配置。</p>
<p>WSL的配置文件有2个，分别是 <code>wsl.conf</code> 和 <code>.wslconfig</code>。接下来要介绍的是：</p>
<ol>
<li>两种配置文件的异同；</li>
<li>配置文件的存放位置。</li>
</ol>
<p>在配置完成之后，需要重启WSL才会生效。注意不是单纯关闭 Terminal。</p>
<blockquote>
<p>You must wait until the subsystem running your Linux distribution completely stops running and restarts for configuration setting updates to appear. This typically takes about 8 seconds after closing ALL instances of the distribution shell.</p>
</blockquote>
<h2 id="配置文件的异同"><a href="#配置文件的异同" class="headerlink" title="配置文件的异同"></a>配置文件的异同</h2><p>两个文件都是WSL的配置文件，它们区别在于存储的位置、生效的范围、配置的选项。</p>
<p><code>wsl.conf</code> 是WSL1时已经有的配置文件。它可以在WSL1和WSL2版本下生效。但是它可以配置的属性有效，比如要配置WSL的内存占用则只能通过<code>.wslconfig</code>文件进行配置。</p>
<p><code>.wslconfig</code> 是WSL2的配置文件，它仅仅在WSL2版本环境下生效。</p>
<blockquote>
<p><img src="Snipaste_2023-04-11_18-49-48.png"></p>
</blockquote>
<h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><p>配置文件不是自动生成的，如果是第一次配置，需要手动创建对应的配置文件。如果没有配置文件存在即使用默认配置。</p>
<ul>
<li><p><code>wsl.conf</code>：<code>/etc/wsl.conf</code></p>
</li>
<li><p><code>.wslconfig</code>: <code>C:\Users\&lt;UserName&gt;\.wslconfig</code></p>
</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="systemd命令的支持"><a href="#systemd命令的支持" class="headerlink" title="systemd命令的支持"></a>systemd命令的支持</h2><p>默认不支持，需要在配置文件中开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ ERAZER <span class="keyword">in</span> ~/workspace/blog on git:develop x [11:15:48]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemd</span></span><br><span class="line">Trying to run as user instance, but the system has not been booted with systemd.</span><br></pre></td></tr></table></figure>

<p>配置文件中添加以下配置，重启后生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure>

<p>重启后可以使用 <code>systemctl list-unit-files --type=service</code> 检查。</p>
<h2 id="Automount-settings"><a href="#Automount-settings" class="headerlink" title="Automount settings"></a>Automount settings</h2><p>自动挂载设置，以及options的释义，参考：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#automount-settings">https://learn.microsoft.com/en-us/windows/wsl/wsl-config#automount-settings</a></p>
<p>其中涉及的概念：</p>
<ul>
<li><p>uid&#x3D;1000，参考<a href="#%E9%99%84%E5%BD%95">附录</a>中的 <a href="https://www.liquidweb.com/kb/what-is-umask-and-how-to-use-it-effectively/">What is Umask in Linux?</a></p>
</li>
<li><p>umask，参考<a href="#%E9%99%84%E5%BD%95">附录</a>中的 <a href="https://www.liquidweb.com/kb/what-is-umask-and-how-to-use-it-effectively/">What is Umask in Linux?</a></p>
<p>  栗子：umask&#x3D;022，则意味新建的目录与文件的权限将是<code>77 - 022 = 755</code></p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p><a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config">Advanced settings configuration in WSL</a> 中包含了 <a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#example-wslconf-file">wsl.conf</a> 和 <a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#example-wslconfig-file">.wslconfig</a>的示例文件；</p>
<h2 id="wsl-–help"><a href="#wsl-–help" class="headerlink" title="wsl –help"></a>wsl –help</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\isaac&gt; wsl --help</span><br><span class="line">Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">Usage: wsl.exe [Argument] [Options...] [CommandLine]</span><br><span class="line"></span><br><span class="line">Arguments for running Linux binaries:</span><br><span class="line"></span><br><span class="line">    If no command line is provided, wsl.exe launches the default shell.</span><br><span class="line"></span><br><span class="line">    --exec, -e &lt;CommandLine&gt;</span><br><span class="line">        Execute the specified command without using the default Linux shell.</span><br><span class="line"></span><br><span class="line">    --</span><br><span class="line">        Pass the remaining command line as is.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    --cd &lt;Directory&gt;</span><br><span class="line">        Sets the specified directory as the current working directory.</span><br><span class="line">        If ~ is used the Linux user&#x27;s home path will be used. If the path begins</span><br><span class="line">        with a / character, it will be interpreted as an absolute Linux path.</span><br><span class="line">        Otherwise, the value must be an absolute Windows path.</span><br><span class="line"></span><br><span class="line">    --distribution, -d &lt;Distro&gt;</span><br><span class="line">        Run the specified distribution.</span><br><span class="line"></span><br><span class="line">    --user, -u &lt;UserName&gt;</span><br><span class="line">        Run as the specified user.</span><br><span class="line"></span><br><span class="line">Arguments for managing Windows Subsystem for Linux:</span><br><span class="line"></span><br><span class="line">    --help</span><br><span class="line">        Display usage information.</span><br><span class="line"></span><br><span class="line">    --install [Options]</span><br><span class="line">        Install additional Windows Subsystem for Linux distributions.</span><br><span class="line">        For a list of valid distributions, use &#x27;wsl --list --online&#x27;.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --distribution, -d [Argument]</span><br><span class="line">                Downloads and installs a distribution by name.</span><br><span class="line"></span><br><span class="line">                Arguments:</span><br><span class="line">                    A valid distribution name (not case sensitive).</span><br><span class="line"></span><br><span class="line">                Examples:</span><br><span class="line">                    wsl --install -d Ubuntu</span><br><span class="line">                    wsl --install --distribution Debian</span><br><span class="line"></span><br><span class="line">    --set-default-version &lt;Version&gt;</span><br><span class="line">        Changes the default install version for new distributions.</span><br><span class="line"></span><br><span class="line">    --shutdown</span><br><span class="line">        Immediately terminates all running distributions and the WSL 2</span><br><span class="line">        lightweight utility virtual machine.</span><br><span class="line"></span><br><span class="line">    --status</span><br><span class="line">        Show the status of Windows Subsystem for Linux.</span><br><span class="line"></span><br><span class="line">    --update [Options]</span><br><span class="line">        If no options are specified, the WSL 2 kernel will be updated</span><br><span class="line">        to the latest version.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --rollback</span><br><span class="line">                Revert to the previous version of the WSL 2 kernel.</span><br><span class="line"></span><br><span class="line">            --inbox</span><br><span class="line">                Only update the inbox WSL 2 kernel. Do not install WSL from the Microsoft Store.</span><br><span class="line"></span><br><span class="line">            --web-download</span><br><span class="line">                Download the most recent version of WSL from the internet instead of the Microsoft Store.</span><br><span class="line"></span><br><span class="line">Arguments for managing distributions in Windows Subsystem for Linux:</span><br><span class="line"></span><br><span class="line">    --export &lt;Distro&gt; &lt;FileName&gt;</span><br><span class="line">        Exports the distribution to a tar file.</span><br><span class="line">        The filename can be - for standard output.</span><br><span class="line"></span><br><span class="line">    --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [Options]</span><br><span class="line">        Imports the specified tar file as a new distribution.</span><br><span class="line">        The filename can be - for standard input.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --version &lt;Version&gt;</span><br><span class="line">                Specifies the version to use for the new distribution.</span><br><span class="line"></span><br><span class="line">    --list, -l [Options]</span><br><span class="line">        Lists distributions.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --all</span><br><span class="line">                List all distributions, including distributions that are</span><br><span class="line">                currently being installed or uninstalled.</span><br><span class="line"></span><br><span class="line">            --running</span><br><span class="line">                List only distributions that are currently running.</span><br><span class="line"></span><br><span class="line">            --quiet, -q</span><br><span class="line">                Only show distribution names.</span><br><span class="line"></span><br><span class="line">            --verbose, -v</span><br><span class="line">                Show detailed information about all distributions.</span><br><span class="line"></span><br><span class="line">            --online, -o</span><br><span class="line">                Displays a list of available distributions for install with &#x27;wsl --install&#x27;.</span><br><span class="line"></span><br><span class="line">    --set-default, -s &lt;Distro&gt;</span><br><span class="line">        Sets the distribution as the default.</span><br><span class="line"></span><br><span class="line">    --set-version &lt;Distro&gt; &lt;Version&gt;</span><br><span class="line">        Changes the version of the specified distribution.</span><br><span class="line"></span><br><span class="line">    --terminate, -t &lt;Distro&gt;</span><br><span class="line">        Terminates the specified distribution.</span><br><span class="line"></span><br><span class="line">    --unregister &lt;Distro&gt;</span><br><span class="line">        Unregisters the distribution and deletes the root filesystem.</span><br></pre></td></tr></table></figure>

<h2 id="WSL支持的Linux发行版本"><a href="#WSL支持的Linux发行版本" class="headerlink" title="WSL支持的Linux发行版本"></a>WSL支持的Linux发行版本</h2><p>详细参考：<a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual#downloading-distributions">#downloading-distributions</a></p>
<p><em>PS:以下数据记录于 2023&#x2F;03&#x2F;12</em></p>
<blockquote>
<ul>
<li>Ubuntu</li>
<li>Ubuntu 22.04 LTS</li>
<li>Ubuntu 20.04</li>
<li>Ubuntu 20.04 ARM</li>
<li>Ubuntu 18.04</li>
<li>Ubuntu 18.04 ARM</li>
<li>Ubuntu 16.04</li>
<li>Debian GNU&#x2F;Linux</li>
<li>Kali Linux</li>
<li>SUSE Linux Enterprise Server 12</li>
<li>SUSE Linux Enterprise Server 15 SP2</li>
<li>SUSE Linux Enterprise Server 15 SP3</li>
<li>openSUSE Tumbleweed</li>
<li>openSUSE Leap 15.3</li>
<li>openSUSE Leap 15.2</li>
<li>Oracle Linux 8.5</li>
<li>Oracle Linux 7.9</li>
<li>Fedora Remix for WSL</li>
</ul>
</blockquote>
<p>另外，可以通过 powershell，使用 <code>wsl --list -o</code> 查阅当前WSL支持的Linux发行版本。</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>以下是官方的安装要求</p>
<h3 id="新版本："><a href="#新版本：" class="headerlink" title="新版本："></a>新版本：</h3><p>详细参考：<a href="https://learn.microsoft.com/en-us/windows/wsl/install#prerequisites">Install Linux on Windows with WSL - Prerequisites</a></p>
<blockquote>
<p>Prerequisites<br>You must be running Windows 10 version 2004 and higher (Build 19041 and higher) or Windows 11 to use the commands below. If you are on earlier versions please see the manual install page.</p>
</blockquote>
<h3 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h3><p>详细参考：<a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual#step-2---check-requirements-for-running-wsl-2">Check requirements for running WSL 2</a></p>
<blockquote>
<p>To update to WSL 2, you must be running Windows 10…</p>
<ul>
<li><p>For x64 systems: Version 1903 or later, with Build 18362 or later.</p>
</li>
<li><p>For ARM64 systems: Version 2004 or later, with Build 19041 or later.</p>
</li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p><a href="https://pureinfotech.com/install-windows-subsystem-linux-2-windows-10/">How to install WSL2 on Windows 10</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/en-us/windows/wsl/install">Install Linux on Windows with WSL</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual">Manual installation steps for older versions of WSL</a></p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config">Advanced settings configuration in WSL</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Systemd">Wiki about ‘Systemd’</a></p>
</li>
<li><p><a href="https://www.linuxquestions.org/questions/linux-general-1/what-is-the-user-1000-a-4175510196/">What is the user 1000?</a></p>
</li>
<li><p><a href="https://www.liquidweb.com/kb/what-is-umask-and-how-to-use-it-effectively/">What is Umask in Linux?</a></p>
</li>
<li><p><a href="https://learn.microsoft.com/en-us/windows/wsl/compare-versions?source=recommendations">Comparing WSL Versions</a></p>
</li>
</ul>


</blockquote>]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo deploy失败问题</title>
    <url>/blog/resources/hexo-deploy%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当前在WSL的Debian系统中使用hexo写作以及发布部署。</p>
<p>在Win和Mac系统环境下，在deploy的时候，会自动跳转浏览器做OAuth2授权，不影响使用。</p>
<p>但是在WSL环境或者说Linux环境（可能）下，会直接在终端 prompt。要求输入账号和密码，但是无论输入对或错都会失败。本文旨在解决此问题以及deploy的部分逻辑分析。</p>
<span id="more"></span>

<h1 id="为什么输入正确还是push失败？"><a href="#为什么输入正确还是push失败？" class="headerlink" title="为什么输入正确还是push失败？"></a>为什么输入正确还是push失败？</h1><p>使用 <a href="https://hexo.io/docs/one-command-deployment#Git">默认的deploy配置</a> 并进行部署，你会得到以下结果：</p>
<p><img src="Snipaste_2023-03-10_23-08-51.png"></p>
<p>在以上日志已经提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure>

<p>在 2021&#x2F;08&#x2F;31 开始，GitHub已经不支持通过账号和密码进行验证！</p>
<p>详细可以查阅：<a href="https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/">Github Blog: Git password authentication is shutting down</a></p>
<h1 id="更换验证方式"><a href="#更换验证方式" class="headerlink" title="更换验证方式"></a>更换验证方式</h1><p>既然密码验证方式已经不适用。那只能换个验证方式。</p>
<p>首先WSL环境下，是无法进行OAuth2授权的。</p>
<p>hexo部署使用 <a href="https://github.com/hexojs/hexo-deployer-git">Github Repository: hexo-deployer-git</a> 库，可以查阅该库支持的验证方式。</p>
<p><img src="Snipaste_2023-03-10_21-27-01.png"></p>
<p>README指明，可以使用 Github 的 Access Token 进行验证。</p>
<p>首先，需要在 Gtihub 申请个人Token，可以通过 <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Github Docs: Creating a personal access token</a> 指引进行申请。</p>
<p>注意，在分配权限时需要选择 repo 全部权限：</p>
<p><img src="Snipaste_2023-03-10_21-56-44.png"></p>
<p>接着，需要修改hexo配置，添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/&lt;repository&gt;.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">&lt;branch</span> <span class="string">name&gt;</span></span><br><span class="line">      <span class="attr">token:</span> <span class="string">&lt;GITHUB_TOKEN&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/isaaxite/blog.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 这里使用了环境变量 $GITHUB_TOKEN</span></span><br><span class="line">      <span class="attr">token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">      <span class="comment"># name: isaaxite</span></span><br><span class="line">      <span class="comment"># email: isaacgun@outlook.com</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意，虽然README有给出deploy的配置例子，但是不清晰！</p>
<p><img src="Snipaste_2023-03-10_21-46-08.png"></p>
<p>比较多人也对此吐槽了，并因此开了个issue！</p>
<p><a href="https://github.com/hexojs/hexo-deployer-git/issues/159">Issue: Token deploy prompts for username #159</a></p>
<p>另外，README推荐使用环境变量来配置 token。当然，如果项目是私有的或者对安全性无要求，可以直接将token直接配置在 <code>_config.yml</code> 中。</p>
<p>还有一个小点需要注意：不需要配置 <code>name</code> 和 <code>email</code>！</p>
<p>到此，配置即完成！</p>
<h1 id="hexo-deployer-git是怎么使用Token的"><a href="#hexo-deployer-git是怎么使用Token的" class="headerlink" title="hexo-deployer-git是怎么使用Token的"></a><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>是怎么使用Token的</h1><p>在阅读<a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>部分源码后，得知：</p>
<ol>
<li>使用git命令push commit;</li>
<li>使用 <code>spaw</code> 函数执行git命令；</li>
</ol>
<h2 id="使用git命令push"><a href="#使用git命令push" class="headerlink" title="使用git命令push"></a>使用git命令push</h2><p>经阅读源码 <a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js">lib&#x2F;deploy.js</a> 发现，最后是使用下面这句命令将本地commit推送到GitHub对应分支！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u &lt;repo.url&gt; HEAD:&lt;repo.branch&gt; --force</span><br></pre></td></tr></table></figure>

<p>详细代码可以参考 <a href="#git-push">附录-git push</a></p>
<p>但这么看，也没有发现是怎么使用token的。</p>
<p>上面有两个未确定的点是 <code>&lt;repo.url&gt;</code> 和 <code>&lt;repo.branch&gt;</code>。接下来查看 <code>repo</code> 是怎么来的！</p>
<p>从另外一个文件（<a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/parse_config.js">lib&#x2F;parse_config.js</a> ）中的部分源码中可以发现几句关键逻辑：</p>
<ol>
<li><code>repoUrl = new URL(url);</code>；</li>
<li><code>repoUrl.username = userToken;</code></li>
<li><code>url = repoUrl.href;</code></li>
</ol>
<p>而 <code>url</code> 就是上面使用的 <code>&lt;repo.url&gt;</code>！详细代码参考<a href="#parseObjRepo">附录-parseObjRepo</a>。</p>
<p>以下是一个直观的小实验，展示token是如何被使用的：</p>
<ol>
<li>创建URL实例 repoUrl；</li>
<li>设置 repoUrl.username；</li>
<li>观测 repoUrl.href。</li>
</ol>
<p><img src="Snipaste_2023-03-10_18-19-20.png"></p>
<h2 id="使用执行-spaw-执行-git-命令"><a href="#使用执行-spaw-执行-git-命令" class="headerlink" title="使用执行 spaw 执行 git 命令"></a>使用执行 spaw 执行 git 命令</h2><p>在 <a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js">lib&#x2F;deploy.js</a> 中知道，是使用 <a href="https://github.com/hexojs/hexo-util#spawncommand-args-options">Github Repository: hexojs&#x2F;hexo-util</a> 的 <code>spaw</code> 执行 git 命令。</p>
<p>这个 <code>spaw</code> 推测是使用 <a href="https://nodejs.org/docs/latest-v16.x/api/child_process.html">child_process</a>，类似常见的 npm lib 有：<a href="https://www.npmjs.com/package/shelljs">shelljs</a>、<a href="https://www.npmjs.com/package/simple-git">simple-git</a> 等等。</p>
<p><img src="Snipaste_2023-03-10_17-59-25.png"></p>
<p>详细就不展开，感兴趣可以参考：<br><a href="https://github.com/hexojs/hexo-util/blob/master/lib/spawn.ts">https://github.com/hexojs/hexo-util/blob/master/lib/spawn.ts</a></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>以下是核心逻辑，完整代码参考：<a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js">lib&#x2F;deploy.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">git</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="string">&#x27;git&#x27;</span>, args, &#123;</span><br><span class="line">    <span class="attr">cwd</span>: deployDir,</span><br><span class="line">    <span class="attr">verbose</span>: verbose,</span><br><span class="line">    <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">repo</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">git</span>(<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;-A&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">git</span>(<span class="string">&#x27;commit&#x27;</span>, <span class="string">&#x27;-m&#x27;</span>, message).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do nothing. It&#x27;s OK if nothing to commit.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">git</span>(<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;-u&#x27;</span>, repo.<span class="property">url</span>, <span class="string">&#x27;HEAD:&#x27;</span> + repo.<span class="property">branch</span>, <span class="string">&#x27;--force&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="parseObjRepo"><a href="#parseObjRepo" class="headerlink" title="parseObjRepo"></a>parseObjRepo</h2><p>以下是核心逻辑，完整代码参考：<a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/parse_config.js">lib&#x2F;parse_config.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseObjRepo</span>(<span class="params">repo</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = repo.<span class="property">url</span>;</span><br><span class="line">  <span class="keyword">let</span> branch = repo.<span class="property">branch</span>;</span><br><span class="line">  <span class="keyword">const</span> configToken = repo.<span class="property">token</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!branch) &#123;</span><br><span class="line">    branch = <span class="title function_">testBranch</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rRepoURL.<span class="title function_">test</span>(url)) &#123;</span><br><span class="line">    <span class="keyword">const</span> match = url.<span class="title function_">match</span>(rRepoURL);</span><br><span class="line">    <span class="keyword">const</span> scheme = match[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configToken &amp;&amp; (scheme === <span class="string">&#x27;http&#x27;</span> || scheme === <span class="string">&#x27;https&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> repoUrl, userToken;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        repoUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(url);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Fail to parse your repo url, check your config!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (configToken.<span class="title function_">startsWith</span>(<span class="string">&#x27;$&#x27;</span>)) &#123;</span><br><span class="line">        userToken = process.<span class="property">env</span>[configToken.<span class="title function_">substring</span>(<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (!userToken) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Fail to read environment varable: &#x27;</span> + configToken + <span class="string">&#x27;, check your config!&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        userToken = configToken;</span><br><span class="line">      &#125;</span><br><span class="line">      repoUrl.<span class="property">username</span> = userToken;</span><br><span class="line">      url = repoUrl.<span class="property">href</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">branch</span>: branch || <span class="string">&#x27;master&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://github.com/hexojs/hexo-deployer-git">Github Repository: hexo-deployer-git</a></p>
</li>
<li><p><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Github Docs: Creating a personal access token</a></p>
</li>
<li><p><a href="https://github.com/hexojs/hexo-util#spawncommand-args-options">Github Repository: hexojs&#x2F;hexo-util</a></p>
</li>
<li><p><a href="https://github.com/hexojs/hexo-deployer-git/issues/159">Issue: Token deploy prompts for username #159</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>hexo</tag>
        <tag>deploy</tag>
        <tag>wsl</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL的hosts文件被重置</title>
    <url>/blog/resources/WSL%E7%9A%84hosts%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用WSL安装软件时，需要从 <code>raw.githubusercontent.com</code> 拉取数据，抛异常 403。经查阅是DNS污染导致，推荐的解决方案是修改hosts文件，添加域名与ip的映射。</p>
<p>然而，再第二天打开电脑再次登入wsl发现，继续403异常！查看hosts文件：内容被重置！</p>
<span id="more"></span>


<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><img src="Snipaste_2023-03-08_16-08-58.png"></p>
<p>注释已经解释，host文件会被WSL自动生成，导致对hosts的历史修改被覆盖！</p>
<p>想要关闭自动生成功能，则需要在 <code>/etc/wsl.conf</code> 中设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">generateHosts = false</span><br></pre></td></tr></table></figure>

<p>抱着以防万一的心态，查阅 <code>wsl.conf</code> 详情：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#network-settings">https://learn.microsoft.com/en-us/windows/wsl/wsl-config#network-settings</a></p>
<p><img src="Snipaste_2023-03-08_16-15-42.png"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>关闭 generateHosts；</li>
<li>在win系统下的hosts做修改；</li>
</ul>
<h2 id="关闭-generateHosts"><a href="#关闭-generateHosts" class="headerlink" title="关闭 generateHosts"></a>关闭 generateHosts</h2><p>默认情况下，wsl是没有 <code>/etc/wsl.conf</code>，所以新建就好！</p>
<p>完整的 示例配置 可以从这个链接中获取：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#example-wslconf-file">https://learn.microsoft.com/en-us/windows/wsl/wsl-config#example-wslconf-file</a></p>
<p>setp1: 新建 <code>sudo vim /etc/wsl.conf</code>；</p>
<p>setp2：添加配置，<code>generateHosts = false</code></p>
<h2 id="在win系统下的hosts做修改"><a href="#在win系统下的hosts做修改" class="headerlink" title="在win系统下的hosts做修改"></a>在win系统下的hosts做修改</h2><p>在研究的过程中，发现wsl是基于win下的host文件生成的！</p>
<p>基于这些host映射在win和wsl都会用到，所以直接在win的host文件做修改！</p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器（Debian）内终端的中文展示与输入问题</title>
    <url>/blog/resources/Docker%E5%AE%B9%E5%99%A8%EF%BC%88Debian%EF%BC%89%E5%86%85%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%AD%E6%96%87%E5%B1%95%E7%A4%BA%E4%B8%8E%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用docker容器作为开发环境。以Debian11镜像启动容器，出现两个问题：</p>
<ol>
<li>无法展示中文，ls输出的都是八进制编码的字符串；</li>
<li>终端无法输入中文，粘贴可以但同学展示为八进制字符串；</li>
</ol>
<p><img src="Snipaste_2023-02-27_20-24-42.png"></p>
<span id="more"></span>

<h1 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h1><p>经查阅，确定问题是系统语言环境导致，默认使用的语言环境不支持中文编码！</p>
<p>使用 <code>locale</code> 查看当前使用的字符集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:~/workspace# locale</span><br><span class="line"></span><br><span class="line">LANG=</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=&quot;POSIX&quot;</span><br><span class="line">LC_NUMERIC=&quot;POSIX&quot;</span><br><span class="line">LC_TIME=&quot;POSIX&quot;</span><br><span class="line">LC_COLLATE=&quot;POSIX&quot;</span><br><span class="line">LC_MONETARY=&quot;POSIX&quot;</span><br><span class="line">LC_MESSAGES=&quot;POSIX&quot;</span><br><span class="line">LC_PAPER=&quot;POSIX&quot;</span><br><span class="line">LC_NAME=&quot;POSIX&quot;</span><br><span class="line">LC_ADDRESS=&quot;POSIX&quot;</span><br><span class="line">LC_TELEPHONE=&quot;POSIX&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;POSIX&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;POSIX&quot;</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>显然，当前我使用的Debian11镜像默认使用的是<code>POSIX</code>字符集！</p>
<p>可以使用 <code>locale -a</code> 查看当前系统支持的字符集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:~/workspace# locale -a</span><br><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">POSIX</span><br></pre></td></tr></table></figure>

<p>在 Debian 使用指南中关于 <code>locale</code> 中看到：</p>
<blockquote>
<p>You can set <code>LANG</code> or <code>LC_ALL</code> to your preferred locale.</p>
</blockquote>
<p>然后，将 <code>LANG</code> 环境变量设置成 <code>C.UTF-8</code>，这个系统支持的中文字符集！</p>
<p>设置方式有多种，在<code>~/.bashrc</code>文件、进入容器通过<code>env</code>变量设置或者通过<code>dockerfile</code>，详细不展开！</p>
<p>设置成功后可以通过 <code>locale</code> 命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@docker-desktop:/# locale</span><br><span class="line">LANG=C.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_NUMERIC=&quot;C.UTF-8&quot;</span><br><span class="line">LC_TIME=&quot;C.UTF-8&quot;</span><br><span class="line">LC_COLLATE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MONETARY=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MESSAGES=&quot;C.UTF-8&quot;</span><br><span class="line">LC_PAPER=&quot;C.UTF-8&quot;</span><br><span class="line">LC_NAME=&quot;C.UTF-8&quot;</span><br><span class="line">LC_ADDRESS=&quot;C.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE=&quot;C.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;C.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;C.UTF-8&quot;</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>Debian容器终端无法展示和输入中文，这个问题的原因之一是：系统默认使用不支持中文编码的字符集；</p>
</li>
<li><p>可以使用 <code>locale</code>查看当前系统使用的字符集，使用<code>locale -a</code>列出当前系统支持的字符集；</p>
</li>
<li><p>通过设置<code>LANG</code> 环境变量可以修改系统使用的字符集；</p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a href="https://wiki.debian.org/Locale">Debian使用指南locale篇章</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>debian</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装与基本使用</title>
    <url>/blog/resources/nvm%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="nvm-与-n-的区别"><a href="#nvm-与-n-的区别" class="headerlink" title="nvm 与 n 的区别"></a>nvm 与 n 的区别</h1><p>node 版本管理工具还有一个是 TJ大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node&#x2F;npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。</p>
<span id="more"></span>

<p>由于 npm 安装的模块路径均为 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node&#x2F;npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。</p>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure>

<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>在 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> 文件末尾添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>

<p> 保存！</p>
<p>重新加载配置：<code>source ~/.bashrc</code> 或 <code>source ~/.zshrc</code> </p>
<p>查看 nvm 版本，借此检查安装情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm -v</span></span><br><span class="line">0.39.1</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>安装node版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install &lt;node version&gt;</span><br></pre></td></tr></table></figure>

<p>查看版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure>
<p> <br>切换node版本（要先安装再切换）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm use &lt;node version&gt;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>github：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT添加文章置顶feat</title>
    <url>/blog/resources/NexT%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6feat/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hexo以及NexT主题默认没有置顶功能！本文旨在通过现有方案，花费最小力气补充此缺失的功能！</p>
<span id="more"></span>

<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>使用现有解决方案：<a href="https://github.com/netcan/hexo-generator-index-pin-top">https://github.com/netcan/hexo-generator-index-pin-top</a></p>
<blockquote>
<p>Feautres </p>
<p>This version supports pin-top feature, you can add the top: True field to post’s front-matter to pin it.</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>修改主题文件，添加“置顶”标志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">themes/next/layout/_partials/post/post-meta.njk</span></span><br><span class="line"></span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;font color=&quot;#1fa67a&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-thumb-tack&quot; style=&quot;position: relative;top: 1px;&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;span&gt; 置顶&lt;/span&gt;</span><br><span class="line">  &lt;/font&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h2><p>修改需要置顶的文章，Front-matter 添加 <code>top: true</code>，见下栗子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">vue中的diff算法实现</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-12-26 08:41:47</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">vue</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">vue源码分析</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">源码分析</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">vue</span>]</span><br><span class="line"><span class="string">+</span> <span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><blockquote>
<p><img src="Snipaste_2023-02-25_21-11-27.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust学习</title>
    <url>/blog/resources/Rust%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。</p>
<span id="more"></span>

<p>Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。</p>
<p>Rust 通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。</p>
<p>Rust是内存安全、没有GC(垃圾回收)的高效语言。</p>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b workspace]# curl --proto &#x27;=https&#x27; --tlsv1.3 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<p>安装成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info: default toolchain set to &#x27;stable-x86_64-unknown-linux-gnu&#x27;                 </span><br><span class="line">                                                                                 </span><br><span class="line">  stable-x86_64-unknown-linux-gnu installed - rustc 1.65.0 (897e37553 2022-11-02)</span><br><span class="line">                                                                                 </span><br><span class="line">                                                                                 </span><br><span class="line">Rust is installed now. Great!                                                    </span><br><span class="line">                                                                                 </span><br><span class="line">To get started you may need to restart your current shell.                       </span><br><span class="line">This would reload your PATH environment variable to include                      </span><br><span class="line">Cargo&#x27;s bin directory ($HOME/.cargo/bin).                                        </span><br><span class="line">                                                                                 </span><br><span class="line">To configure your current shell, run:                                            </span><br><span class="line">source &quot;$HOME/.cargo/env&quot;                                                        </span><br></pre></td></tr></table></figure>

<p>刷新当前shell配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b workspace]# source ~/.bashrc</span><br><span class="line"></span><br><span class="line">[root@f8ac270c7b6b workspace]# rustc --version</span><br><span class="line">rustc 1.65.0 (897e37553 2022-11-02)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><ul>
<li>Code</li>
<li>编译</li>
<li>执行</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>文件名：hello_world.rs</p>
<p>使用的是 <code>.rs</code> 后缀！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  println!(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装 vs code的 rust 扩展！</p>
<p>Extension ID：dustypomerleau.rust-syntax<br><img src="https://user-images.githubusercontent.com/25907273/204077420-7c3a88eb-57d2-4393-ae55-5ad625521997.png" alt="image"></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>rustc xxx.rs</code> 编译rust程序！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# rustc hello_world.rs</span><br><span class="line">[root@f8ac270c7b6b rust-learn]# ls</span><br><span class="line">hello_world  hello_world.rs</span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>直接执行编译后的文件！不需要启动程序！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# ./hello_world</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构建系统和包管理器，Cargo"><a href="#构建系统和包管理器，Cargo" class="headerlink" title="构建系统和包管理器，Cargo"></a>构建系统和包管理器，Cargo</h1><p>Cargo 是 Rust 的构建系统和包管理器。它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库</p>
<p>使用官方方式安装，会自带 Cargo！</p>
<p>Cargo的详细命令可以使用 <code>--help</code>，也可查看 <a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1327996209">附录</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# cargo --version</span><br><span class="line">cargo 1.65.0 (4bc8f24d3 2022-10-20)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建项目</li>
<li>编译项目<ul>
<li>开发时编译</li>
<li>生产时编译</li>
</ul>
</li>
<li>执行项目</li>
<li>快速检测</li>
<li>小结</li>
<li>参考</li>
</ul>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用 <code>cargo new &lt;new dir name&gt;</code></p>
<p>产物结构</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089591-b2abeda6-5cdc-4bda-8498-3a06cf746f4a.png" alt="image"></p>
<p>生成一个配置文件，是toml文件。</p>
<p>这个文件使用 <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) 格式，这是 Cargo 配置文件的格式。</p>
<p>还生成一个src以及src下的z&#x3D;主文件main。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089548-adadc8f1-ff1a-48e5-826b-68257e30cb6f.png" alt="image"></p>
<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><ul>
<li>开发时编译</li>
<li>生产时编译</li>
</ul>
<h3 id="开发时编译"><a href="#开发时编译" class="headerlink" title="开发时编译"></a>开发时编译</h3><p>切换到 项目目录下（此处是 hello_cargo），执行build命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>build 结果如下：</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204089646-b505984f-8cf6-4fae-b221-cbb47c59dcbb.png" alt="image"></p>
<p>增加了 <code>Cargo.lock</code> 和 <code>target/</code> 目录！</p>
<h3 id="生产时编译"><a href="#生产时编译" class="headerlink" title="生产时编译"></a>生产时编译</h3><p>在开发时编译的基础上增加 <code>--release</code>。</p>
<p>编译的产物会放在 <code>target/release</code> 中！详细参考 <a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1327996209">附录</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204099490-4309d4b8-7122-44d0-a7e7-2668d1940238.png" alt="image"></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>使用 <code>run</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204089972-fb695c14-1456-4863-8c09-fb8e5184a9bd.png" alt="image"></p>
<h2 id="快速检查"><a href="#快速检查" class="headerlink" title="快速检查"></a>快速检查</h2><p>在项目根目录下执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204100025-89f68fa1-26a0-4303-a32f-3a240ae04503.png" alt="image"></p>
<p>该命令快速检查代码确保其可以编译，但并不产生可执行文件！</p>
<p>通常 cargo check 要比 cargo build 快得多，因为它省略了生成可执行文件的步骤。如果你在编写代码时持续的进行检查，cargo check 可以让你快速了解现在的代码能不能正常通过编译！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>cargo new</code>，创建项目。</li>
<li><code>cargo build</code>，构建项目。</li>
<li><code>cargo run</code>，一步构建并运行项目。</li>
<li><code>cargo check</code>，在不生成二进制文件的情况下构建项目来检查错误。</li>
<li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target目录，默认在 <code>target/debug</code>，生产时在 <code>target/release</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html#hello-cargo">Rust 程序设计语言 简体中文版 —— Hello, Cargo!</a></li>
</ul>
<hr>
<h1 id="语法概念"><a href="#语法概念" class="headerlink" title="语法概念"></a>语法概念</h1><ul>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1328515749">函数定义</a></li>
<li><a href="https://github.com/isaaxite/blog/issues/296#issuecomment-1330017240">控制流</a></li>
</ul>
<h2 id="结束符号"><a href="#结束符号" class="headerlink" title="结束符号"></a>结束符号</h2><p>使用分号（<code>;</code>）作为结束符号</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一段注释</span></span><br></pre></td></tr></table></figure>

<h2 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量&#x2F;常量"></a>变量&#x2F;常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量默认是不可重复赋值！<br>如果要重复赋值可以使用<code>mut</code>配合声明。<br>变量是可以重复声明的！</p>
<p>使用 <code>let</code> 声明标量！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>需要重复赋值时声明</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以重复声明变量</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在此之前foo=1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">foo</span>: <span class="type">u8</span> = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 解析来foo = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用 <code>const</code>声明，与变量不同，它声明之后总是不可重复声明与赋值！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FOO = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的分为<em>标量（scalar）</em>和<em>复合（compound）</em>，以及其他</p>
<h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p><strong>标量（scalar）</strong> 类型代表一个单独的值。Rust 有四种基本的标量类型：</p>
<ul>
<li><a href="#%E6%95%B4%E5%9E%8B">整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E5%9E%8B">浮点型</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</a></li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>复合类型（Compound types）</strong> 可以将多个值组合成一个类型。Rust 有两个原生的复合类型：</p>
<ul>
<li><a href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B">元组（tuple）</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B">数组（array）</a></li>
</ul>
<p>其他类型包含：</p>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="#Slice%E7%B1%BB%E5%9E%8B">Slice类型</a></li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>其中，<code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<p><strong>数字类型默认是 i32。isize 或 usize 主要作为某些集合的索引。</strong></p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Rust 也有两个原生的 浮点数（floating-point numbers）类型:</p>
<ul>
<li><code>f32</code></li>
<li><code>f64</code></li>
</ul>
<p>f32、f64分别占 32 位和 64 位。默认类型是 f64。</p>
<p>所有的浮点型都是 <strong>有</strong> 符号的</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span>: <span class="type">f32</span> = <span class="number">2.12</span>;</span><br></pre></td></tr></table></figure>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>Rust 中的布尔类型使用 <code>bool</code> 表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let foo = false;</span><br><span class="line">let bar: bool;</span><br><span class="line">bar = true;</span><br></pre></td></tr></table></figure>

<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Rust中的字符类型包含char类型和字符串类型，而字符串类型由str和String组成。</p>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>使用 <code>char</code> 关键字声明，它只能存储<em>单个字符</em>！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">name</span>: <span class="type">char</span>;</span><br><span class="line">name = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, name)</span><br></pre></td></tr></table></figure>
<p>注意，我们用 <strong>单引号</strong> 声明 char 字面量，而与之相反的是，使用 <strong>双引号</strong> 声明字符串字面量。</p>
<p>Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>Rust有两种字符串类型：str和String。其中str是String的切片类型，也就是说，str类型的字符串值是String类型的字符串值的一部分或全部。</p>
<p>注意使用双引号！</p>
<h5 id="str"><a href="#str" class="headerlink" title="str"></a>str</h5><p>使用 <code>&amp;str</code>显式声明。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">name</span>: &amp;<span class="type">str</span> = <span class="string">&quot;isaac&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;i am &#123;&#125;&quot;</span>, name);</span><br></pre></td></tr></table></figure>

<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>使用 <code>String</code> 显式声明！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name: String = String::from(&quot;isaac&quot;);</span><br><span class="line">println!(&quot;i am &#123;&#125;&quot;, name);</span><br><span class="line"></span><br><span class="line">let name: String = &quot;isaac&quot;.to_string();</span><br><span class="line">println!(&quot;i am &#123;&#125;&quot;, name);</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用 点操作符（.）或者 解构取单个值。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点操作符</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n.<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">let</span> (x,_y,_z) = n;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;num &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>Rust 中的数组与一些其他语言中的数组不同，Rust中的数组长度是固定的。</p>
<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>显式声明，在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><strong>但是数组并不如 <a href="xxx">vector</a> 类型灵活。vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 <a href="xxx">vector</a> 的时候，那么很可能应该使用 <a href="xxx">vector</a>。</strong></p>

<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="概念与使用"><a href="#概念与使用" class="headerlink" title="概念与使用"></a>概念与使用</h4><p>引用类型是一种数据类型，它表示其所保存的值是一个引用。</p>
<p>引用，通常来说是指向其他数据的一个指针或一个胖指针(有额外元数据的指针)。例如&amp;33表示的是一个指向数据值33的一个指针。</p>
<p>因此，引用类型保存值的引用。</p>
<p>Rust中，使用&amp;T表示类型T的引用类型(reference type)。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span>: &amp;<span class="type">i32</span> = &amp;<span class="number">33_i32</span>;</span><br></pre></td></tr></table></figure>

<h4 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h4><p>直接使用&amp;创建出来的引用是只读的，这意味着可以通过该引用去读取其指向的数据，但是不能通过引用去修改指向的数据。</p>
<p>可以使用 <code>&amp;mut v</code> 来创建可修改源数据v的可变引用。</p>
<p><strong>注意，想要通过&amp;mut引用去修改源数据，要求原变量是可变的。</strong></p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x_ref</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">*x_ref = <span class="string">&quot;xxxx2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;x: &#123;&#125;\n&quot;</span>, x_ref);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;x_ref: &#123;&#125;&quot;</span>, x_ref);</span><br></pre></td></tr></table></figure>

<h4 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h4><p>解引用表示解除引用，即通过引用获取到该引用所指向的原始值。</p>
<p>解引用使用*T表示，其中T是一个引用</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line">*x_ref = <span class="string">&quot;xxxx2&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>引用类型，是一个数据类型，它存储的是一直数据的引用，地址！</li>
<li>可变引用即储存的可变变量</li>
<li>解引用，使用*号，读取引用变量指向地址所保存的指！</li>
</ul>
<h3 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h3><p>Slice操作，Rust中的切片操作只允许获取一段连续的局部数据，切片操作获取到的数据称为切片数据。</p>
<h1 id="所有权（ownership）"><a href="#所有权（ownership）" class="headerlink" title="所有权（ownership）"></a>所有权（ownership）</h1><p>栈（Stack）与堆（Heap）内存。</p>
<p>栈以放入值的顺序存储值。</p>
<p>堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。</p>
<p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<h2 id="所有权的规则"><a href="#所有权的规则" class="headerlink" title="所有权的规则"></a>所有权的规则</h2><ol>
<li>Rust 中的每一个值都有一个 所有者（owner）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><code>&#123;&#125;</code>，每个花括号包含的代码块都是一个作用域！</p>
<p>注意，这不包含 struct 的花括号！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">var_scope_main</span>() &#123;</span><br><span class="line">  &#123;                     <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">  &#125;                     <span class="comment">// Rust 在结尾的 &#125; 处自动调用 drop, 释放内存</span></span><br><span class="line">                        <span class="comment">// 此作用域已结束，s 不再有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>Rust 有第二个字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String。</p>
<p>String类型有别于字面量字符串，它是可修改的！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>

<p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器（memory allocator）请求内存。</li>
<li>需要一个当我们处理完 String 时将内存返回给分配器的方法。</li>
</ul>
<h3 id="变量与数据交互的方式"><a href="#变量与数据交互的方式" class="headerlink" title="变量与数据交互的方式"></a>变量与数据交互的方式</h3><p>使用堆内存的变量，他们之间的数据交互方式！</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204480696-4188bc14-809f-49dd-be12-3ef7868d3b0e.png" alt="图片"></p>
<ul>
<li>转移</li>
<li>拷贝</li>
</ul>
<h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>为了确保内存安全，在 let s2 &#x3D; s1 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。</p>
<p>相当于 s1 赋值给 s2，就将数据转移到s2。不是浅拷贝（将引用复制给s2），也不是深拷贝！</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">heap_var_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;s1 is &#123;&#125;&quot;</span>, s1);</span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204481489-09ebb4e5-5fb3-413c-83a6-36a528ed980a.png" alt="图片"></p>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>使用一个叫做 <a href="https://doc.rust-lang.org/std/clone/index.html">clone</a> 的通用函数。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">clone_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;\ns1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/25907273/204489601-c2e6f02b-4aa7-46bc-97d5-e707e7643458.png" alt="图片"></p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><p>引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。</p>
<p><code>&amp;</code> 符号就是 引用，它们允许你使用值但不获取其所有权。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/204947997-bd4878ea-b295-47fd-bd0d-895d2f703fc1.png" alt="图片"></p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ref_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  &#125;<span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;\ns1 len = &#123;&#125;&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值。</p>
<p>我们将创建一个引用的行为称为 借用（borrowing）。</p>
<h3 id="可变引用-1"><a href="#可变引用-1" class="headerlink" title="可变引用"></a>可变引用</h3><p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mut_ref_main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;\ns = &#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。</strong></p>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。</p>
<hr>
<h1 id="包、crate和模块"><a href="#包、crate和模块" class="headerlink" title="包、crate和模块"></a>包、crate和模块</h1><p>use 关键字: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用crate::garden::vegetables::Asparagus的作用域, 你可以通过 use crate::garden::vegetables::Asparagus;创建一个快捷方式，然后你就可以在作用域中只写Asparagus来使用该类型。</p>
<p>外部模块的寻址过程 </p>
<ol>
<li>内联；</li>
<li>在文件 <code>src/&lt;mod&gt;.rs</code>；</li>
<li>在文件 <code>src/&lt;mod&gt;/mod.rs</code>。</li>
</ol>
<p>内联模块：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>参考</li>
<li>cargo –help</li>
<li>cargo编译后的产物</li>
<li>Rust内存布局</li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://doc.rust-lang.org/book/#the-rust-programming-language">The Rust Programming Language</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html">Rust 程序设计语言 简体中文版</a></li>
<li><a href="https://rust-book.junmajinlong.com/">Rust入门秘籍</a></li>
<li><a href="https://www.rustwiki.org.cn/docs/">Rust 中文教程等相关资源列表</a></li>
</ul>
<h2 id="cargo-–help"><a href="#cargo-–help" class="headerlink" title="cargo –help"></a>cargo –help</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b rust-learn]# cargo --help                                                    </span><br><span class="line">Rust&#x27;s package manager                                                                          </span><br><span class="line">                                                                                                </span><br><span class="line">USAGE:                                                                                          </span><br><span class="line">    cargo [+toolchain] [OPTIONS] [SUBCOMMAND]                                                   </span><br><span class="line">                                                                                                </span><br><span class="line">OPTIONS:                                                                                        </span><br><span class="line">    -V, --version               Print version info and exit                                     </span><br><span class="line">        --list                  List installed commands                                         </span><br><span class="line">        --explain &lt;CODE&gt;        Run `rustc --explain CODE`                                      </span><br><span class="line">    -v, --verbose               Use verbose output (-vv very verbose/build.rs output)           </span><br><span class="line">    -q, --quiet                 Do not print cargo log messages                                 </span><br><span class="line">        --color &lt;WHEN&gt;          Coloring: auto, always, never                                   </span><br><span class="line">        --frozen                Require Cargo.lock and cache are up to date                     </span><br><span class="line">        --locked                Require Cargo.lock is up to date                                </span><br><span class="line">        --offline               Run without accessing the network                               </span><br><span class="line">        --config &lt;KEY=VALUE&gt;    Override a configuration value                                  </span><br><span class="line">    -Z &lt;FLAG&gt;                   Unstable (nightly-only) flags to Cargo, see &#x27;cargo -Z help&#x27; for </span><br><span class="line">                                details                                                         </span><br><span class="line">    -h, --help                  Print help information                                          </span><br><span class="line">                                                                                                </span><br><span class="line">Some common cargo commands are (see all commands with --list):                                  </span><br><span class="line">    build, b    Compile the current package                                                     </span><br><span class="line">    check, c    Analyze the current package and report errors, but don&#x27;t build object files     </span><br><span class="line">    clean       Remove the target directory                                                     </span><br><span class="line">    doc, d      Build this package&#x27;s and its dependencies&#x27; documentation                        </span><br><span class="line">    new         Create a new cargo package                                                      </span><br><span class="line">    init        Create a new cargo package in an existing directory                             </span><br><span class="line">    add         Add dependencies to a manifest file                                             </span><br><span class="line">    run, r      Run a binary or example of the local package                                    </span><br><span class="line">    test, t     Run the tests                                                                   </span><br><span class="line">    bench       Run the benchmarks                                                              </span><br><span class="line">    update      Update dependencies listed in Cargo.lock                                        </span><br><span class="line">    search      Search registry for crates                                                      </span><br><span class="line">    publish     Package and upload this package to the registry                                 </span><br><span class="line">    install     Install a Rust binary. Default location is $HOME/.cargo/bin                     </span><br><span class="line">    uninstall   Uninstall a Rust binary                                                         </span><br><span class="line">                                                                                                </span><br><span class="line">See &#x27;cargo help &lt;command&gt;&#x27; for more information on a specific command.                          </span><br><span class="line">                                                                                                </span><br></pre></td></tr></table></figure>

<h2 id="cargo编译后的产物"><a href="#cargo编译后的产物" class="headerlink" title="cargo编译后的产物"></a>cargo编译后的产物</h2><ul>
<li>开发时产物</li>
<li>生产时产物</li>
</ul>
<h3 id="开发时产物"><a href="#开发时产物" class="headerlink" title="开发时产物"></a>开发时产物</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b hello_cargo]# tree                      </span><br><span class="line">.                                                          </span><br><span class="line">|-- Cargo.lock                                             </span><br><span class="line">|-- Cargo.toml                                             </span><br><span class="line">|-- src                                                    </span><br><span class="line">|   `-- main.rs                                            </span><br><span class="line">`-- target                                                 </span><br><span class="line">    |-- CACHEDIR.TAG                                       </span><br><span class="line">    `-- debug                                              </span><br><span class="line">        |-- build                                          </span><br><span class="line">        |-- deps                                           </span><br><span class="line">        |   |-- hello_cargo-84cd33c7f338469a               </span><br><span class="line">        |   `-- hello_cargo-84cd33c7f338469a.d             </span><br><span class="line">        |-- examples                                       </span><br><span class="line">        |-- hello_cargo                                    </span><br><span class="line">        |-- hello_cargo.d                                  </span><br><span class="line">        `-- incremental                                    </span><br><span class="line">            `-- hello_cargo-aokenuaryvra                   </span><br><span class="line">                |-- s-gfry8e3ogd-1vtypym-2e5m3t5mj48xn     </span><br><span class="line">                |   |-- 1b24fot1ksjfohwq.o                 </span><br><span class="line">                |   |-- 2pcmwubz98u8588d.o                 </span><br><span class="line">                |   |-- 2skhc1xjwld6hx4y.o                 </span><br><span class="line">                |   |-- 387f08navk0xr9hq.o                 </span><br><span class="line">                |   |-- 41zl1lnzyfy87gmq.o                 </span><br><span class="line">                |   |-- 4gfj2nd48vmsnha0.o                 </span><br><span class="line">                |   |-- dep-graph.bin                      </span><br><span class="line">                |   |-- query-cache.bin                    </span><br><span class="line">                |   `-- work-products.bin                  </span><br><span class="line">                `-- s-gfry8e3ogd-1vtypym.lock              </span><br><span class="line">                                                           </span><br><span class="line">9 directories, 18 files                                    </span><br></pre></td></tr></table></figure>

<h3 id="生产时产物"><a href="#生产时产物" class="headerlink" title="生产时产物"></a>生产时产物</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@f8ac270c7b6b target]# tree                   </span><br><span class="line">.                                                  </span><br><span class="line">|-- CACHEDIR.TAG                                   </span><br><span class="line">|-- debug                                          </span><br><span class="line">|   |-- build                                      </span><br><span class="line">|   |-- deps                                       </span><br><span class="line">|   |   |-- hello_cargo-84cd33c7f338469a           </span><br><span class="line">|   |   `-- hello_cargo-84cd33c7f338469a.d         </span><br><span class="line">|   |-- examples                                   </span><br><span class="line">|   |-- hello_cargo                                </span><br><span class="line">|   |-- hello_cargo.d                              </span><br><span class="line">|   `-- incremental                                </span><br><span class="line">|       `-- hello_cargo-aokenuaryvra               </span><br><span class="line">|           |-- s-gfryfk4nh1-10dc9z2-2e5m3t5mj48xn </span><br><span class="line">|           |   |-- 1b24fot1ksjfohwq.o             </span><br><span class="line">|           |   |-- 2pcmwubz98u8588d.o             </span><br><span class="line">|           |   |-- 2skhc1xjwld6hx4y.o             </span><br><span class="line">|           |   |-- 387f08navk0xr9hq.o             </span><br><span class="line">|           |   |-- 41zl1lnzyfy87gmq.o             </span><br><span class="line">|           |   |-- 4gfj2nd48vmsnha0.o             </span><br><span class="line">|           |   |-- dep-graph.bin                  </span><br><span class="line">|           |   |-- query-cache.bin                </span><br><span class="line">|           |   `-- work-products.bin              </span><br><span class="line">|           `-- s-gfryfk4nh1-10dc9z2.lock          </span><br><span class="line">`-- release                                        </span><br><span class="line">    |-- build                                      </span><br><span class="line">    |-- deps                                       </span><br><span class="line">    |   |-- hello_cargo-42d24d7ef33ef483           </span><br><span class="line">    |   `-- hello_cargo-42d24d7ef33ef483.d         </span><br><span class="line">    |-- examples                                   </span><br><span class="line">    |-- hello_cargo                                </span><br><span class="line">    |-- hello_cargo.d                              </span><br><span class="line">    `-- incremental                                </span><br><span class="line">                                                   </span><br><span class="line">12 directories, 19 files</span><br></pre></td></tr></table></figure>

<h2 id="Rust-内存布局"><a href="#Rust-内存布局" class="headerlink" title="Rust 内存布局"></a>Rust 内存布局</h2><img width="100%" src="https://user-images.githubusercontent.com/25907273/204198140-44b47b88-e8ed-43b0-a554-181ebdd3ef0c.png">

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2日志优化</title>
    <url>/blog/resources/PM2%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="默认pm2日志存在的问题"><a href="#默认pm2日志存在的问题" class="headerlink" title="默认pm2日志存在的问题"></a>默认pm2日志存在的问题</h1><ol>
<li>缺少日志时间戳；</li>
<li>缺少日志分片；</li>
<li>没有日志rotate 功能，定期清除防止磁盘爆满</li>
</ol>
<span id="more"></span>


<h2 id="PM2自带的日志"><a href="#PM2自带的日志" class="headerlink" title="PM2自带的日志"></a>PM2自带的日志</h2><p><a href="https://pm2.keymetrics.io/docs/usage/log-management/">https://pm2.keymetrics.io/docs/usage/log-management/</a></p>
<h2 id="PM2的日志扩展插件"><a href="#PM2的日志扩展插件" class="headerlink" title="PM2的日志扩展插件"></a>PM2的日志扩展插件</h2><p><a href="https://github.com/keymetrics/pm2-logrotate">pm2-logrotate</a></p>
<h1 id="默认情况下，处理日志临近饱满磁盘的办法"><a href="#默认情况下，处理日志临近饱满磁盘的办法" class="headerlink" title="默认情况下，处理日志临近饱满磁盘的办法"></a>默认情况下，处理日志临近饱满磁盘的办法</h1><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>1 查看日志文件位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 show &lt;app name&gt;</span><br></pre></td></tr></table></figure>

<p>2 删除日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure>

<p>3 重启应用</p>
<p>重启应用会自动再生成日志文件！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 relaod &lt;app name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="pm2清洗日志命令"><a href="#pm2清洗日志命令" class="headerlink" title="pm2清洗日志命令"></a>pm2清洗日志命令</h2><p>这将清空当前pm2应用程序日志! </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 flush</span><br><span class="line"></span><br><span class="line">pm2 flush &lt;api&gt; # Clear the logs for the app with name/id matching &lt;api&gt;</span><br></pre></td></tr></table></figure>


<h1 id="pm2-logrotate基本使用"><a href="#pm2-logrotate基本使用" class="headerlink" title="pm2-logrotate基本使用"></a>pm2-logrotate基本使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 install pm2-logrotate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">output</span></span><br><span class="line"></span><br><span class="line">[PM2][Module] Installing NPM pm2-logrotate module</span><br><span class="line">[PM2][Module] Calling [NPM] to install pm2-logrotate ...</span><br><span class="line">+ pm2-logrotate@2.7.0</span><br><span class="line">added 213 packages from 236 contributors and audited 214 packages in 9.267s</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/25907273/199225377-6850e2b9-ffe8-4952-973c-571f591c711e.png" alt="image"></p>
<h2 id="查看rotate配置"><a href="#查看rotate配置" class="headerlink" title="查看rotate配置"></a>查看rotate配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 conf</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line"></span><br><span class="line">Module: pm2-logrotate</span><br><span class="line">$ pm2 set pm2-logrotate:max_size 10M</span><br><span class="line">$ pm2 set pm2-logrotate:retain 30</span><br><span class="line">$ pm2 set pm2-logrotate:compress false</span><br><span class="line">$ pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss</span><br><span class="line">$ pm2 set pm2-logrotate:workerInterval 30</span><br><span class="line">$ pm2 set pm2-logrotate:rotateInterval 0 0 * * *</span><br><span class="line">$ pm2 set pm2-logrotate:rotateModule true</span><br><span class="line">Module: module-db-v2</span><br><span class="line">$ pm2 set module-db-v2:pm2-logrotate [object Object]</span><br></pre></td></tr></table></figure>

<h2 id="查看日志分片"><a href="#查看日志分片" class="headerlink" title="查看日志分片"></a>查看日志分片</h2><p><img src="https://user-images.githubusercontent.com/25907273/199226021-2a431cae-143f-4350-baa9-65f0ea038ae4.png" alt="image"></p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 set pm2-logrotate:&lt;conf key&gt; &lt;conf val&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>PM2</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>编写油猴脚本扩展github评论编辑器，增加全屏模式</title>
    <url>/blog/resources/%E7%BC%96%E5%86%99%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E6%89%A9%E5%B1%95github%E8%AF%84%E8%AE%BA%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>安装 <a href="https://www.tampermonkey.net/index.php?version=4.18.0&ext=dhdg&show=dhdg#">tampermonkey</a></p>
<h1 id="注释说明"><a href="#注释说明" class="headerlink" title="注释说明"></a>注释说明</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Comment Zoomer</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      1.0.0</span></span><br><span class="line"><span class="comment">// @description  Add zoom button in github comment to provide full screen mode, allowing you to write comments more elegantly</span></span><br><span class="line"><span class="comment">// @author       IsaacKam</span></span><br><span class="line"><span class="comment">// @match        https://github.com/*</span></span><br><span class="line"><span class="comment">// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @license MIT</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">油猴脚本的名字</td>
</tr>
<tr>
<td align="left">namespace</td>
<td align="left">命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td>
</tr>
<tr>
<td align="left">version</td>
<td align="left">脚本版本，油猴脚本的更新会读取这个版本号</td>
</tr>
<tr>
<td align="left">description</td>
<td align="left">描述，用来告诉用户这个脚本是干什么用的</td>
</tr>
<tr>
<td align="left">author</td>
<td align="left">作者名字</td>
</tr>
<tr>
<td align="left">match</td>
<td align="left">只有匹配的网址才会执行对应的脚本，例如*、http:&#x2F;&#x2F;*、<a href="http://www.baidu.com/*%E7%AD%89%EF%BC%8C%E5%8F%82%E8%A7%81%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E6%96%87%E6%A1%A3">http://www.baidu.com/*等，参见谷歌开发者文档</a></td>
</tr>
<tr>
<td align="left">grant</td>
<td align="left">指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为none的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td>
</tr>
<tr>
<td align="left">require</td>
<td align="left">如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td>
</tr>
<tr>
<td align="left">connect</td>
<td align="left">当用户使用GM_xmlhttpRequest请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及*通配符</td>
</tr>
<tr>
<td align="left">updateURL</td>
<td align="left">脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td>
</tr>
<tr>
<td align="left">license</td>
<td align="left">声明开源协议，<em>在发布是必须的</em></td>
</tr>
</tbody></table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><code>@match</code>，<em>是必要的参数，用来匹配当前脚本要在那个页面生效！</em></li>
</ul>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>最简单的方式是编写完后，将代码复制到 tampermonkey 上。然后刷新脚本应用到的页面！</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><ol>
<li>进入 <a href="https://greasyfork.org/en">greasyfork</a>！</li>
<li>选择发布脚本；</li>
</ol>
<table>
<thead>
<tr>
<th><img width="383" alt="image" style="border: 1px solid black;" src="https://user-images.githubusercontent.com/25907273/198898570-20993ce2-6890-4583-9583-018500c99b1e.png"></th>
</tr>
</thead>
</table>
<ol start="3">
<li>输入代码，以及说明，即可发布！</li>
</ol>
<h1 id="栗子🌰"><a href="#栗子🌰" class="headerlink" title="栗子🌰"></a>栗子🌰</h1><p>欢迎 <a href="https://greasyfork.org/en/scripts/453950-comment-zoomer">使用</a> 和 <a href="https://github.com/isaaxite/comment_zoomer">star</a>!</p>
<table>
<thead>
<tr>
<th><img src="https://user-images.githubusercontent.com/25907273/198898702-ac29ff5d-7cbf-4086-a8d5-6ea28db837f4.png" alt="image"></th>
</tr>
</thead>
</table>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000021654926">油猴脚本编写教程</a></li>
<li><a href="https://www.tampermonkey.net/documentation.php">This section describes how the Tampermonkey API can be used and what is different to Geasemonkey</a></li>
<li><a href="https://www.tampermonkey.net/index.php?version=4.18.0&ext=dhdg&show=dhdg#">tampermonkey</a></li>
</ul>
]]></content>
      <categories>
        <category>油猴脚本</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>tampermonkey</tag>
        <tag>油猴脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>oauth2实践</title>
    <url>/blog/resources/oauth2%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><img src="2022-10-07-03-23-41.png"></p>
<span id="more"></span>

<h1 id="管理OAuth客户端注册"><a href="#管理OAuth客户端注册" class="headerlink" title="管理OAuth客户端注册"></a>管理OAuth客户端注册</h1><p>oauth服务器需要为每个客户端分配唯一的客户端标识！</p>
<h2 id="由谁来生成客户端-ID？"><a href="#由谁来生成客户端-ID？" class="headerlink" title="由谁来生成客户端 ID？"></a>由谁来生成客户端 ID？</h2><p>在常规 的 OAuth系统中，客户端 ID（client_id）和密钥（client_secret）由 <em>授权服务器</em> 颁发给客户端</p>
<p>通过客户端 ID查找信息，客户端 ID是从请求 </p>
<h2 id="对客户端授权"><a href="#对客户端授权" class="headerlink" title="对客户端授权"></a>对客户端授权</h2><p>OAuth协议要求授权服务器提供两个端点：</p>
<ul>
<li>授权端点，运行在前端信道上；</li>
<li>令牌端点，运行 在后端信道上</li>
</ul>
<h3 id="授权端点"><a href="#授权端点" class="headerlink" title="授权端点"></a>授权端点</h3><p>授权服务器提供了一个授权端点，供客户端请求访问令牌和刷新令牌。客户端直接向该端点 发出请求，携带一组表单格式的参数，授权服务器解析并处理这些参数。然后授权服务器返回一 个代表令牌的 JSON对象</p>
<h3 id="令牌端点"><a href="#令牌端点" class="headerlink" title="令牌端点"></a>令牌端点</h3><p>令牌端点不面向用户</p>
<p>客户端得到授权码，它可以将其发送给授权服务器的令牌端点，换取 OAuth访问令牌， 再进行解析和存储</p>
<p><img src="2022-10-07-12-10-49.png"></p>
<p>OAuth流程中的很多部分都使用标准的 HTTP请求和响应格式来相互通信。由于这些请求通 常都发生在资源拥有者和用户代理的可见范围之外，因此它们统称为后端信道通信</p>
<p><img src="2022-10-07-12-05-02.png"></p>
<h3 id="重定向到授权端点"><a href="#重定向到授权端点" class="headerlink" title="重定向到授权端点"></a>重定向到授权端点</h3><p>授权端点是一个前端信道端点，客户端会 将用户浏览器重定向至该端点，以发出授权请求。</p>
<p>资源拥有者从客户端重定向到授权端点，它会带上客户端id。授权端点根客户端 ID查找客户端的详细信息：</p>
<ol>
<li>需要检查客户端是否存在；</li>
<li>需要渲染出一个页面来（&#x2F;authorize），让用户交互并进行授权</li>
</ol>
<h3 id="资源拥有者对客户端授权"><a href="#资源拥有者对客户端授权" class="headerlink" title="资源拥有者对客户端授权"></a>资源拥有者对客户端授权</h3><ol>
<li>在授权页面交互，发请求（&#x2F;approve）给授权点，生成授权码。</li>
<li>生成授权码，将授权码存储。以便后续客户端用授权码换令牌</li>
</ol>
<p>通过浏览器传过来的唯一信息就是 client_id，由于该信息是用浏览器通过前端信道传输的， 因此被视为公开信息。如此一来，任何人都可以冒充该客户端，但是我们还是可以借助一些信息 来判断请求的合法性，其中重要的就是检查传入的 redirect_uri 是否与客户端注册信息中 的一致</p>
<h3 id="授权点需要保存客户端注册信息"><a href="#授权点需要保存客户端注册信息" class="headerlink" title="授权点需要保存客户端注册信息"></a>授权点需要保存客户端注册信息</h3><ol>
<li>client_id</li>
<li>redirect_uri，可以是array</li>
<li>client_secret</li>
</ol>
<h2 id="令牌颁发"><a href="#令牌颁发" class="headerlink" title="令牌颁发"></a>令牌颁发</h2><ol>
<li>对客户端进行身份认证</li>
<li>处理授权许可请求</li>
</ol>
<p>客户端带过来的授权码其实没有很大用处。至少在书中它没和令牌有直接的关系！</p>
<p>授权码是作为一个一次性凭证，请求的时候就必须消耗，二次请求就会失效！</p>
<p>授权码的作用：保持一次性！</p>
<p><img src="2022-10-07-08-14-35.png"></p>
<h3 id="对客户端进行身份认证"><a href="#对客户端进行身份认证" class="headerlink" title="对客户端进行身份认证"></a>对客户端进行身份认证</h3><p>客户端会带来 client_id 和 client_secret，用client_id去查client_id对应的的客户端已经注册的信息！比对 client_secret 是否正确有效！</p>
<h3 id="处理授权许可请求"><a href="#处理授权许可请求" class="headerlink" title="处理授权许可请求"></a>处理授权许可请求</h3><p>根据 grant_type 参数，选择令牌颁发方式！</p>
<p>OAuth 2.0完全没有规定访问令牌的内容应该是什么样的，它有一个很好的理由：支持多 样化的选择，每种选择都有各自的权衡，并适应于不同的场景。</p>
<p>看下面代码，我思考后发现：access_token，它颗粒度是去到单个用户，而不是单个client的维度！</p>
<p><img src="2022-10-07-11-32-59.png"></p>
<p>客户端获取权限之后，用access_token访问受保护资源时，使用access_token去数据库查找详细信息，得到scope！</p>
<h1 id="授权许可类型"><a href="#授权许可类型" class="headerlink" title="授权许可类型"></a>授权许可类型</h1><p><img src="2022-10-24-00-46-21.png"></p>
<ol>
<li><strong>隐式许可类型</strong>，直接从授权端点返回令牌，没有令牌端点；</li>
<li><strong>客户端凭据许可类型</strong>，没有明确的资源拥有者。只使用后端信道。</li>
<li><strong>资源拥有者凭据许可类型</strong>，资源拥有者通过客户端使用账号密码换令牌</li>
<li><strong>断言许可类型</strong>,</li>
</ol>
<p>隐式许可类型 的起点入口： </p>
<p>授权点接口（<code>/authorize</code>）的url search参数</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">response_type</td>
<td align="left">emAuthRespType</td>
<td align="left">响应类型</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">scope</td>
<td align="left">string</td>
<td align="left">需要申请的权限域</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">client_id</td>
<td align="left">string</td>
<td align="left">客户端的唯一标识</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">redirect_uri</td>
<td align="left">string</td>
<td align="left">客户端地址，需要授权完成后跳转的地址</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">string</td>
<td align="left">csrf-token</td>
<td align="left">optional</td>
</tr>
</tbody></table>
<p>回包结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式许可类型</span></span><br><span class="line">?access_token=987tghjkiu6trfghjuytrghj&amp;token_type=<span class="title class_">Bearer</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emAuthRespType &#123;</span><br><span class="line">  <span class="attr">CODE</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">TOKEN</span>: <span class="string">&#x27;token&#x27;</span>  <span class="comment">// 隐式许可类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端凭据许可类型 与 资源拥有者凭据许可类型 的起点接口</p>
<p><code>/token</code>，该接口是上面用code换access_token</p>
<table>
<thead>
<tr>
<th align="left">body参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">grant_type</td>
<td align="left">emGrantType</td>
<td align="left">获取token的方式</td>
<td align="left">required</td>
</tr>
<tr>
<td align="left">scope</td>
<td align="left">string</td>
<td align="left">csrf-token</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">username</td>
<td align="left">string</td>
<td align="left">账户，资源拥有者凭据许可类型使用，账户是受保护资源的账户</td>
<td align="left">optional</td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">string</td>
<td align="left">密码，资源拥有者凭据许可类型使用，账户是受保护资源的账户</td>
<td align="left">optional</td>
</tr>
</tbody></table>
<p>注意</p>
<ul>
<li>账号和密码是由用户交互输出的，交互的页面由客户端提供！</li>
</ul>
<table>
<thead>
<tr>
<th align="left">header参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>

<td align="left">Authorization</td>
‘Basic +‘
<td align="left"><em>客户端凭证许可类型</em>和*资源拥有者凭据许可类型 *的使用，传递账号密码</td>
<td align="left">optional</td>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emGrantType &#123;</span><br><span class="line">  <span class="attr">AUTHORIZATION_CODE</span>: <span class="string">&#x27;authorization_code&#x27;</span>,</span><br><span class="line">  <span class="attr">CLIENT_CREDENTIALS</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">  <span class="attr">PASSWORD</span>: <span class="string">&#x27;password&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回报接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>: <span class="string">&quot;987tghjkiu6trfghjuytrghj&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;foo bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="隐式许可类型"><a href="#隐式许可类型" class="headerlink" title="隐式许可类型"></a>隐式许可类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.<span class="property">response_type</span> == <span class="string">&#x27;token&#x27;</span>) &#123; </span><br></pre></td></tr></table></figure>

<p>完全运行在浏览器中的 JavaScript应用就属于这种情况。在这种情况下，通过浏览器向客户端传递仅用于换 取令牌的授权码就没有任何实际意义了，因为这个额外的保密层没有起到任何作.</p>
<p>这种许可流程只使用授权端点而不使 用令牌端点</p>
<p>隐式许可流程不可用于获取刷新令牌。因为浏览器内的应用具有短暂运行的特点，只会在被加载到浏览器的期间保持会话，所以刷新令牌在这里的作用非常有限。</p>
<p>response_type 参数的值为 token，而不是 code。这样会通知授权服务器直接生成令牌，而 不是生成一个用于换取令牌的授权码。 </p>
<h2 id="客户端凭据许可类型"><a href="#客户端凭据许可类型" class="headerlink" title="客户端凭据许可类型"></a>客户端凭据许可类型</h2><p>与前面不同，使用另外一个接口（<code>/token</code>）</p>
<p><code>/token</code>，该接口是上面用code换access_token</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">释义</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">grant_type</td>
<td align="left">emGrantType</td>
<td align="left">获取token的方式</td>
<td align="left">required</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum emGrantType &#123;</span><br><span class="line">  <span class="attr">AUTHORIZATION_CODE</span>: <span class="string">&#x27;authorization_code&#x27;</span>,</span><br><span class="line">  <span class="attr">CLIENT_CREDENTIALS</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">body</span>.<span class="property">grant_type</span> == emGrantType.<span class="property">CLIENT_CREDENTIALS</span>) &#123; </span><br></pre></td></tr></table></figure>

<p>比如后端系统之间需要直接通信<br>只使用后端信道，客户端代表自己（它自己就是资源拥有 者）从令牌端点获取令牌。 </p>
<p>客户端向授权服务器的令牌端点发出令牌请求，这与授权码流程是一样的，只不过这一次使 用 client_credentials 作为 grant_type 参数的值，而且没有授权码或者其他用于换取令牌 的临时凭据。相反，客户端直接向授权服务器进行身份认证，而授权服务器给客户端颁发访问令牌</p>
<p><img src="2022-10-07-14-51-53.png"></p>
<p>在客户端凭据许可流程中不会颁发刷新令牌，因为我们认为客户端能够随时获取新令牌，无 须单独的资源拥有者参与，因此在这种情况下没有必要使用刷新令牌。 </p>
<p>客户端凭据许可类型没有任何直接的用户交互!它确实是为可信的后端系统直接 访问服务而准备的。</p>
<p><img src="2022-10-07-14-34-57.png"></p>
<h2 id="资源拥有者凭据许可类型"><a href="#资源拥有者凭据许可类型" class="headerlink" title="资源拥有者凭据许可类型"></a>资源拥有者凭据许可类型</h2><p><img src="2022-10-07-16-00-30.png"></p>
<p>用户名和密码，那么客户端可以向用户索取用户 的凭据，然后用这个凭据换取令牌。支持客户端这样做的是资源拥有者凭据许可类型，也叫作密码流程。</p>
<p>这种许可类型的工作方式很简单。客户端收集用户的用户名和密码（使用什么样的交互接口 由客户端决定），然后将它们发送至授权服务器。 </p>
<p>授权服务器从收到的请求中取出用户名和密码，并与本地存储的用户信息对比。如果匹配， 则授权服务器向客户端颁发令牌。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grant_type == <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<p>完成所有的检查之后，就可以生成并返回令牌了。请注意，还可以生成刷新令牌（我们的练 习中这样做了）。为客户端提供刷新令牌之后，它就不需要再保存用户的密码了</p>
<p><img src="2022-10-08-05-42-33.png"></p>
<h1 id="客户端部署的应用类型"><a href="#客户端部署的应用类型" class="headerlink" title="客户端部署的应用类型"></a>客户端部署的应用类型</h1><ol>
<li>Web应用；</li>
<li>浏览器应用；</li>
<li>原生应用；</li>
</ol>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><p>Web应用运行在远程服务器上，需要通过Web浏览器访问。应用的配置和运行时状态由 Web 服务器维护，通常使用会话 cookie 与浏览器保持 连接。</p>
<p>Web 应用很容易有效地使用授权码、客 户端凭据或者断言许可流程。由于浏览器一般不会将请求 URI 中的片段部分发送给服务器，大 多数情况下隐式许可流程不适用于Web 应用。 </p>
<h2 id="浏览器应用"><a href="#浏览器应用" class="headerlink" title="浏览器应用"></a>浏览器应用</h2><p>浏览器应用完全运行在浏览器内，一般使用 JavaScript。虽然应用的代码确实需要由Web 服 务器提供，但代码本身并不在服务器上运行，Web 服务器也不会维护应用的任何运行时状态。应 用的所有执行动作都发生在最终用户计算机的浏览器内。 </p>
<p>因 为浏览器应用受限于同源策略以及其他安全限制条件，这些限制是为了防止跨站攻击。因此，最 适合这类应用的是隐式许可流程，该许可流程就是针对这种应用场景而做的优化。 </p>
<h2 id="原生应用"><a href="#原生应用" class="headerlink" title="原生应用"></a>原生应用</h2><p>原生应用是直接在最终用户的设备（计算机或者移动设备）上运行的应用。应用软件通常是在外部经过编译或者打包之后再安装到设备上的。</p>
<h1 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h1><p>客户端密钥属 于配置期间秘密，因为它代表客户端自身，是配置在客户端软件内部的。访问令牌、刷新令牌和 授权码都属于运行时秘密，因为它们都是在客户端软件被部署之后由客户端存储的。</p>
<p>运行时秘密仍然需要安全存储并保护，但是它们被设计得容易撤销或更改。相反，配置期间秘密一般不会经 常改变。 </p>
<p>不要求所有客户端都拥有客户端密钥，而是将客户 端分为两种类型：公开客户端和保密客户端，划分依据是能否持有配置期间秘密</p>
<p>Web 应用是最常见的保密客户端类 型，它是运行在 Web 服务器上的单个实例，单个 OAuth客户端可以对应多个资源拥有者</p>
<h1 id="OAuth令牌"><a href="#OAuth令牌" class="headerlink" title="OAuth令牌"></a>OAuth令牌</h1><p><strong>授权服务器生成令牌之后，会将令牌值存储在磁盘上的共享数据库中。当受保护资源从客户 端收到令牌之后，它会在同一个数据库中查找令牌值，以确定令牌有效</strong></p>
<p><em>授权服务器</em> 和 <em>受保护资源</em> 间共享数据库。存在两者不共享的场景！</p>
<p>在授权服务器和受保护资源间共享数据库并不总是实际可行，特别是在一个授权服务器需要 保护下游的多个资源服务器的情况下。该如何解决这个问题呢？本章将讨论另外两种常见的方 案：结构化令牌和令牌内省</p>
<p><img src="2022-10-08-13-31-55.png"></p>
<h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>JWT的核心是将一个 JSON对象封 装为一种用于网络传输的格式</p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9. </p>
</blockquote>
<p>句点符号将字符串分割成了两部分</p>
<p>以句点符号将令牌字符串分解，让我们可以对令牌的 不同部分分别进行处理</p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0</p>
<p>. </p>
<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</p>
<p>.</p>
</blockquote>
<p>对第一部分解码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>, </span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这是 JWT的头部，它是一个 JSON对象，用于描述与令牌剩余部分有关的信息。其中的 typ 头告诉处理程序令牌的第二部分（载荷）是何种类型。</p>
<p>第二部分是令牌的载荷，它的序列化方式与 JWT头部相同：对 JSON对象进行 Base64URL 编码。由于它是 JWT，因此其载荷可以是任意的 JSON对象</p>
<p><img src="2022-10-08-14-54-58.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = &#123; <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>, <span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;none&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> payload = &#123;</span><br><span class="line">  <span class="attr">iss</span>: <span class="string">&#x27;http://localhost:9001/&#x27;</span>,   </span><br><span class="line">  <span class="attr">sub</span>: code.<span class="property">user</span> ? code.<span class="property">user</span>.<span class="property">sub</span> : <span class="literal">undefined</span>,   </span><br><span class="line">  <span class="attr">aud</span>: <span class="string">&#x27;http://localhost:9002/&#x27;</span>,   </span><br><span class="line">  <span class="attr">iat</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>),   </span><br><span class="line">  <span class="attr">exp</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) + (<span class="number">5</span> * <span class="number">60</span>),   </span><br><span class="line">  <span class="attr">jti</span>: randomstring.<span class="title function_">generate</span>(<span class="number">8</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> access_token = base64url.<span class="title function_">encode</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(header))</span><br><span class="line">  + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">  + base64url.<span class="title function_">encode</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload))</span><br><span class="line">  + <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="令牌的加密保护：JOSE"><a href="#令牌的加密保护：JOSE" class="headerlink" title="令牌的加密保护：JOSE"></a>令牌的加密保护：JOSE</h2><p>JSON对象的签名和加密标准（JOSE①）。这套规范以 JSON为基础数据模型，提供了 签名（JSON Web签名，或称 JWS）、加密（JSON Web加密，或称 JWE）以及密钥存储格式（JSON Web 密钥，或称 JWK）的标准</p>
<h3 id="使用HS256的对称签名"><a href="#使用HS256的对称签名" class="headerlink" title="使用HS256的对称签名"></a>使用HS256的对称签名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = &#123; <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>, <span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;HS256&#x27;</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> access_token = jose.<span class="property">jws</span>.<span class="property">JWS</span>.<span class="title function_">sign</span>(</span><br><span class="line">  header.<span class="property">alg</span>,   </span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(header),   </span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload),   </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Buffer</span>(sharedTokenSecret).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// access_token</span></span><br><span class="line"><span class="comment">// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEv   </span></span><br><span class="line"><span class="comment">// Iiwic3ViIjoiOVhFMy1KSTM0LTAwMTMyQSIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMi8   </span></span><br><span class="line"><span class="comment">// iLCJpYXQiOjE0NjcyNTEwNzMsImV4cCI6MTQ2NzI1MTM3MywianRpIjoiaEZLUUpSNmUifQ.Wq  </span></span><br><span class="line"><span class="comment">// RsY03pYwuJTx-9pDQXftkcj7YbRn95o-16NHrVugg</span></span><br></pre></td></tr></table></figure>

<h3 id="使用RS256的非对称签名"><a href="#使用RS256的非对称签名" class="headerlink" title="使用RS256的非对称签名"></a>使用RS256的非对称签名</h3><p>使用共享密钥时，创建签名和验证签名的系统使用的是同一个密钥。这实际上意味着授权服务器和资源服务器都能够生成令牌，因为它们都拥有创建令牌所需的密钥。</p>
<p>使用公钥 加密的话，授权服务器拥有公钥和私钥，可用于生成令牌，而受保护资源则只能访问授权服务器 的公钥，用于验证令牌。与使用共享密钥不同的是，受保护资源虽然能够很容易地验证令牌，但它无法自己生成有效的令牌。、</p>
<p><em>使用非对称加密签名的目的就为了将创建令牌的权限收归到授权服务器。受保护资源服务器只能使用公钥进行验证而不能创建令牌！</em></p>
<p><img src="2022-10-09-06-17-02.png"></p>
<h1 id="内省协议"><a href="#内省协议" class="headerlink" title="内省协议"></a>内省协议</h1><p>OAuth令牌内省协议定义了一种机制，让受保护资源能够主动向授权服务器查询令牌状态。<br>该协议是对 OAuth 的一个简单增强。授权服务器向客户端颁发令牌，客户端向受保护资源 出示令牌，受保护资源则向授权服务器查询令牌状</p>
<p><img src="2022-10-09-07-08-23.png"></p>
<p>内省请求</p>
<p><img src="2022-10-09-07-15-45.png"></p>
<p>内省请求的响应是一个 JSON 对象，用于描述令牌信息。它的内容与 JWT 的载荷相似，任 何有效的 JWT声明都可以包含在响应中。 </p>
<p><img src="2022-10-09-07-16-11.png"></p>
<p>内省协议规范还在 JWT的基础上增加了几个声明定义，其中重要的是 active 声明。此 声明告诉受保护资源当前令牌在授权服务器上是否有效，且是唯一必须返回的声明。</p>
<h2 id="构建内省端点"><a href="#构建内省端点" class="headerlink" title="构建内省端点"></a>构建内省端点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> protectedResources = [&#123;</span><br><span class="line">  <span class="string">&quot;resource_id&quot;</span>: <span class="string">&quot;protected-resource-1&quot;</span>,        </span><br><span class="line">  <span class="string">&quot;resource_secret&quot;</span>: <span class="string">&quot;protected-resource-secret-1&quot;</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getProtectedResource = <span class="keyword">function</span>(<span class="params">resourceId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> __.<span class="title function_">find</span>(protectedResources, <span class="keyword">function</span>(<span class="params">protectedResource</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>   protectedResource.<span class="property">resource_id</span> == resourceId;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/introspect&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> auth = req.<span class="property">headers</span>[<span class="string">&#x27;authorization&#x27;</span>]; </span><br><span class="line">  <span class="keyword">var</span> resourceCredentials = <span class="title function_">decodeClientCredentials</span>(auth); </span><br><span class="line">  <span class="keyword">var</span> resourceId = resourceCredentials.<span class="property">id</span>; </span><br><span class="line">  <span class="keyword">var</span> resourceSecret = resourceCredentials.<span class="property">secret</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resource = <span class="title function_">getProtectedResource</span>(resourceId);</span><br><span class="line">  <span class="keyword">if</span> (!resource) &#123;   </span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">end</span>();   </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resource.<span class="property">resource_secret</span> != resourceSecret) &#123;   </span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">end</span>();   </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> inToken = req.<span class="property">body</span>.<span class="property">token</span>; </span><br><span class="line">  </span><br><span class="line">  nosql.<span class="title function_">one</span>(<span class="keyword">function</span>(<span class="params">token</span>) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (token.<span class="property">access_token</span> == inToken) &#123;        </span><br><span class="line">      <span class="keyword">return</span> token;   </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err, token</span>) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (token) &#123; </span><br><span class="line">      <span class="keyword">var</span> introspectionResponse = &#123;              </span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,              </span><br><span class="line">        <span class="attr">iss</span>: <span class="string">&#x27;http://localhost:9001/&#x27;</span>,              </span><br><span class="line">        <span class="attr">aud</span>: <span class="string">&#x27;http://localhost:9002/&#x27;</span>,              </span><br><span class="line">        <span class="attr">sub</span>: token.<span class="property">user</span> ? token.<span class="property">user</span>.<span class="property">sub</span> : <span class="literal">undefined</span>,              </span><br><span class="line">        <span class="attr">username</span>: token.<span class="property">user</span> ? token.<span class="property">user</span>.<span class="property">preferred_username</span> : <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">scope</span>: token.<span class="property">scope</span> ? token.<span class="property">scope</span>.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) : <span class="literal">undefined</span>,              </span><br><span class="line">        <span class="attr">client_id</span>: token.<span class="property">client_id</span>       </span><br><span class="line">      &#125;; </span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(introspectionResponse);       </span><br><span class="line">      <span class="keyword">return</span>;   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;       </span><br><span class="line">      <span class="keyword">var</span> introspectionResponse = &#123;              </span><br><span class="line">        <span class="attr">active</span>: <span class="literal">false</span>       </span><br><span class="line">      &#125;;       </span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(introspectionResponse);       </span><br><span class="line">      <span class="keyword">return</span>;   </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="发起令牌内省请求"><a href="#发起令牌内省请求" class="headerlink" title="发起令牌内省请求"></a>发起令牌内省请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> protectedResource = &#123;   </span><br><span class="line">  <span class="string">&quot;resource_id&quot;</span>: <span class="string">&quot;protected-resource-1&quot;</span>,   </span><br><span class="line">  <span class="string">&quot;resource_secret&quot;</span>: <span class="string">&quot;protected-resource-secret-1&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> form_data = qs.<span class="title function_">stringify</span>(&#123;   </span><br><span class="line">  <span class="attr">token</span>: inToken</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> headers = &#123;   </span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,   </span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Basic &#x27;</span> + <span class="title function_">encodeClientCredentials</span>(</span><br><span class="line">    protectedResource.<span class="property">resource_id</span>, protectedResource.<span class="property">resource_secret</span>)</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> tokRes = <span class="keyword">await</span> <span class="title function_">request</span>(<span class="string">&#x27;POST&#x27;</span>, authServer.<span class="property">introspectionEndpoint</span>, &#123;   </span><br><span class="line">  <span class="attr">body</span>: form_data,   </span><br><span class="line">  <span class="attr">headers</span>: headers </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tokRes.<span class="property">statusCode</span> &gt;= <span class="number">200</span> &amp;&amp; tokRes.<span class="property">statusCode</span> &lt; <span class="number">300</span>) &#123;   </span><br><span class="line">  <span class="keyword">var</span> body = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(tokRes.<span class="title function_">getBody</span>()); </span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got introspection response&#x27;</span>, body);   </span><br><span class="line">  <span class="keyword">var</span> active = body.<span class="property">active</span>;   </span><br><span class="line">  <span class="keyword">if</span> (active) &#123;        </span><br><span class="line">    req.<span class="property">access_token</span> = body;   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>呈现了两种用于授权服务器和受保护资源之间传递信息的方法：结构化令牌（具体来说 就是 JWT）和令牌内省。看起来这两种方法需要二选一，但实际上，将它们结合起来使用也可 以得到很好的效果</p>
<h1 id="动态客户端注册"><a href="#动态客户端注册" class="headerlink" title="动态客户端注册"></a>动态客户端注册</h1><p><img src="2022-10-09-12-16-09.png"></p>
<p>OAuth 动态客户端注册协议②提供了一种方法，让客户端可以自行加入授权服务器，并注册 自己的各类相关信息。</p>
<h1 id="生成授权码"><a href="#生成授权码" class="headerlink" title="生成授权码"></a>生成授权码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomString = <span class="built_in">require</span>(<span class="string">&#x27;random-string&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="title function_">randomString</span>();</span><br><span class="line"></span><br><span class="line">mysql.<span class="title function_">insert</span>(&#123;</span><br><span class="line">  <span class="attr">table</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">field</span>: &#123; code &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">KEYUTIL</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;jsrsasign&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rsaKeypair = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">generateKeypair</span>(<span class="string">&quot;RSA&quot;</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE</span> = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getPEM</span>(rsaKeypair.<span class="property">prvKeyObj</span>, <span class="string">&quot;PKCS8PRV&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC</span> = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getPEM</span>(rsaKeypair.<span class="property">pubKeyObj</span>);</span><br></pre></td></tr></table></figure>
<p><img src="2022-10-24-03-52-06.png"><br>参考：<a href="http://kjur.github.io/jsrsasign/api/symbols/KEYUTIL.html">http://kjur.github.io/jsrsasign/api/symbols/KEYUTIL.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://laibh.top/2020-07-17-oauth2%20nodejs%E5%AE%9E%E6%88%98.html">oauth2 nodejs实战</a></li>
<li><a href="https://www.jianshu.com/p/7febbe553c83">使用 Nodejs 搭建一个 OAuth2.0 服务</a></li>
<li><a href="http://www.rfcreader.com/#rfc6749">rfc6749</a></li>
</ul>
</table>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title>【win】安装ADB</title>
    <url>/blog/resources/%E3%80%90win%E3%80%91%E5%AE%89%E8%A3%85ADB/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://developer.android.com/studio/releases/platform-tools">下载adb for windows</a></p>
<p><img src="58064e0ddf514a219e22db69e7dbb67c.webp"></p>
<span id="more"></span>

<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p><img src="02512be76de14b79948bb73c4bd20785.webp"></p>
<p>在platform-tools目录下运行命令行工具（power shell或者cmd）</p>
<p><img src="363090a2e94b46f69101c41d06237dd8.webp"></p>
<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>我的电脑 &gt; 高级系统设置 &gt; 环境变量 &gt; 编辑 Path 环境变量</p>
<p>增加 platform-tools目录 路径</p>
<p><img src="2c4dd95b1ff24d0bbc38641b8399802e.webp"></p>
<p>结果</p>
<p><img src="00feed73893f4d84a8e2958e07d91771.webp"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.xda-developers.com/install-adb-windows-macos-linux/#adbsetupwindows">https://www.xda-developers.com/install-adb-windows-macos-linux/#adbsetupwindows</a></li>
</ul>
]]></content>
      <categories>
        <category>开发调试</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>adb</tag>
        <tag>安卓调试</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：从0开始与踩坑实录</title>
    <url>/blog/resources/hexo%EF%BC%9A%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%B8%8E%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<h1 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h1><h2 id="curl下载github-zip链接"><a href="#curl下载github-zip链接" class="headerlink" title="curl下载github zip链接"></a>curl下载github zip链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -LJO https://github.com/theme-next/theme-next-fancybox3 </span><br></pre></td></tr></table></figure>

<h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip theme-next-fancybox3-master.zip</span><br></pre></td></tr></table></figure>

<h1 id="page布局有什么用？"><a href="#page布局有什么用？" class="headerlink" title="page布局有什么用？"></a>page布局有什么用？</h1><p>官文档说的布局概念</p>
<blockquote>
<p><img src="Snipaste_2023-02-14_21-58-08.png"></p>
</blockquote>
<p><strong>布局概念含糊不清！</strong></p>
<h1 id="为什么主页将所有文章以详情的形式全列出来了？"><a href="#为什么主页将所有文章以详情的形式全列出来了？" class="headerlink" title="为什么主页将所有文章以详情的形式全列出来了？"></a>为什么主页将所有文章以详情的形式全列出来了？</h1><p>文章没有添加 <code>description</code> 属性。形如</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo：从0开始与踩坑实录</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-16 14:46:49</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">记录入坑hexo的过程中遇到的问题与最终解决</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>只有添加 <code>description</code>并且字段值不为空（可以使用空格占位），才会以概览模式在主页列出所有文章！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://ryderchan.github.io/2017/01/26/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7-%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E5%9B%BE%E7%89%87/">hexo小技巧-首页显示文章摘要及图片</a></li>
</ul>
<h1 id="文章中的图片的保存位置以及使用方式"><a href="#文章中的图片的保存位置以及使用方式" class="headerlink" title="文章中的图片的保存位置以及使用方式"></a>文章中的图片的保存位置以及使用方式</h1><h2 id="post-asset-folder"><a href="#post-asset-folder" class="headerlink" title="post_asset_folder"></a>post_asset_folder</h2><p>开启 <code>post_asset_folder</code>，将生成文章同名目录。可以使用路径访问此目录下的资源！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Markdown语法"><a href="#使用Markdown语法" class="headerlink" title="使用Markdown语法"></a>使用Markdown语法</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： image.jpg 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; </code>。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>hexo博客中如何插入图片: <a href="https://cloud.tencent.com/developer/article/1736563">https://cloud.tencent.com/developer/article/1736563</a></li>
<li>资源文件夹: <a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></li>
</ul>
<h1 id="Next如何添加分类页与标签页？"><a href="#Next如何添加分类页与标签页？" class="headerlink" title="Next如何添加分类页与标签页？"></a>Next如何添加分类页与标签页？</h1><h2 id="将Next配置文件中的Menu开启"><a href="#将Next配置文件中的Menu开启" class="headerlink" title="将Next配置文件中的Menu开启"></a>将Next配置文件中的Menu开启</h2><p>路径：themes&#x2F;next&#x2F;_config.yml</p>
<p>将配置开启后，就可以在页面上看到 分类页 和 标签页 的入口。但是仅仅只有入口没有内容！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h2 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h2><p>添加分类页面。执行下面命令将会生成 source&#x2F;categories&#x2F;index.md</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>categories&#x2F;index.md 的内容如下，还需做些必要修改：添加 <code>type: &quot;categories&quot;</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-02-14 16:56:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>标签页的添加与以上大部分相似！需要注意的是：</p>
<ul>
<li>标签页创建：<code>hexo new page tags</code>；</li>
<li>标签页属性修改：<code>type: &quot;tags&quot;</code></li>
</ul>
<h2 id="使用分类"><a href="#使用分类" class="headerlink" title="使用分类"></a>使用分类</h2><p>在 <code>source/_posts/</code> 目录的文章中的yml配置，添加 <code>categories</code> 属性。如下面例子。</p>
<p>文章添加标签后，再编译就会生成对应的标签文件！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">面试题62.</span> <span class="string">圆圈中最后剩下的数字</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-04-17 02:13:49</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">算法题</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">LCOF</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译后继承生成分类、标签目录，见下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">categories</span><br><span class="line">├── hexo</span><br><span class="line">|  └── index.html</span><br><span class="line">├── index.html</span><br><span class="line">└── 算法题</span><br><span class="line">   └── index.html</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="预览图片"><a href="#预览图片" class="headerlink" title="预览图片"></a>预览图片</h1><h2 id="打开-fancybox-开关"><a href="#打开-fancybox-开关" class="headerlink" title="打开 fancybox 开关"></a>打开 fancybox 开关</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NexT _config.yml</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="方式1：CDN"><a href="#方式1：CDN" class="headerlink" title="方式1：CDN"></a>方式1：CDN</h3><p>打开 NexT 配置文件FancyBox资源配置的注释即可！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NexT _config.yml</span></span><br><span class="line"><span class="comment"># FancyBox</span></span><br><span class="line"><span class="comment"># jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js</span></span><br><span class="line"><span class="comment"># fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line"><span class="comment"># fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br></pre></td></tr></table></figure>


<h3 id="方式2：下载-fancybox-插件资源"><a href="#方式2：下载-fancybox-插件资源" class="headerlink" title="方式2：下载 fancybox 插件资源"></a>方式2：下载 fancybox 插件资源</h3><p>将 fancybox 包下载到 cd next&#x2F;source&#x2F;lib，并将资源解压（假如需要）后命名为 fancybox 即可！</p>
<p>fancybox包：<a href="https://github.com/theme-next/theme-next-fancybox3">https://github.com/theme-next/theme-next-fancybox3</a></p>
<h1 id="评论插件-gittalk"><a href="#评论插件-gittalk" class="headerlink" title="评论插件(gittalk)"></a>评论插件(gittalk)</h1><p>仓库：<a href="https://github.com/gitalk/gitalk">https://github.com/gitalk/gitalk</a></p>
<p>NexT已经内置，只需要修改NexT配置文件！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span>  <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span>  <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span>  <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span>  <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span>  <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">false</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<p>上面配置 client_id 和 client_secret 需要在github注册 OAuth App: </p>
<p><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<p><img src="Snipaste_2023-02-16_13-28-44.png"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Application</span> <span class="string">name：</span> <span class="comment"># 应用名称，随意填写即可</span></span><br><span class="line"><span class="string">Homepage</span> <span class="string">URL：</span> <span class="comment"># 你的网站地址，如https://yourname.github.io</span></span><br><span class="line"><span class="string">Application</span> <span class="string">description</span> <span class="comment"># 描述，随意填写即可</span></span><br><span class="line"><span class="string">Authorization</span> <span class="string">callback</span> <span class="string">URL：#</span> <span class="string">你的网站地址，如https://yourname.github.io</span></span><br></pre></td></tr></table></figure>

<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://chenfeng2000.github.io/2020/01/30/NexT-7-7-0%E4%BB%A5%E5%90%8E%E7%89%88%E6%9C%AC-gitalk%E9%85%8D%E7%BD%AE/">hexo博客 NexT 7.7.0以后版本 gitalk配置</a></li>
<li><a href="https://blog.mmzi.online/2021/07/10/Hexo-%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0Valine%E5%92%8CGitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">Hexo 博客增加Valine&#x2F;Gitalk评论插件</a></li>
<li><a href="https://github.com/gitalk/gitalk">github:gitalk&#x2F;gitalk</a></li>
</ul>
<h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://theme-next.js.org/">NexT官方文档</a></li>
<li><a href="https://www.jianshu.com/p/5a1e6d8c83af">初步了解Hexo站点的布局</a></li>
<li><a href="https://ben286.github.io/2018/08/21/%E5%85%B6%E4%BB%96/hexo%E5%B8%83%E5%B1%80%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/">hexo布局架构及功能分析</a></li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Hook实现轻量级自动化部署</title>
    <url>/blog/resources/Git-Hook%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在整理项目，发现以前的一个项目中，发现使用git hook和pm2实现了一个简单的自动化部署，也没有写什么记录，故复记录之。</p>
<span id="more"></span>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://user-images.githubusercontent.com/25907273/81206194-59d7c700-8ffe-11ea-82b1-d8672393d6c7.png" alt="image"></p>
<h2 id="原理与流程"><a href="#原理与流程" class="headerlink" title="原理与流程"></a>原理与流程</h2><ol>
<li>git用户执行git push操作；</li>
<li>远程仓库发现有用户执行了push操作，就会执行一个脚本post-update（钩子）；</li>
<li>在post-update脚本中，将git仓库的代码拷贝到web站点目录下。</li>
</ol>
<h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>Git 钩子(hooks)是在 Git 仓库中特定事件(certain points)触发后被调用的脚本。通过钩子可以自定义 Git 内部的相关（如 git push）行为，在开发周期中的关键点触发自定义的行为。Git 含有两种类型的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<p>每个使用git进行版本版本管理的项目都存在hooks，这些hooks存在于项目目录下的<code>.git/hooks/</code>：</p>
<p><img src="https://user-images.githubusercontent.com/25907273/81207013-7fb19b80-8fff-11ea-9846-7565991e923a.png" alt="image"></p>
<p>以上这些就是git hook脚本。简单地说，hook是一种特殊的脚本（代码），仅在满足特定条件时执行。git hooks分别有对应各种操作的hook。每个hook都对应在不同的情况下触发，比如接下来要用到的post-update脚本，则是在检测到push的操作时触发。</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><ol>
<li>在服务端创建一个裸仓库；</li>
<li>编辑裸仓库中的post-update hook脚本；</li>
<li>本地仓库添加远程裸仓库作为remote。</li>
</ol>
<h3 id="1-在服务端创建一个裸仓库"><a href="#1-在服务端创建一个裸仓库" class="headerlink" title="1. 在服务端创建一个裸仓库"></a>1. 在服务端创建一个裸仓库</h3><p>什么是裸仓库？</p>
<p>裸仓库与 git init 初使化的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的.git文件夹，整个裸仓库中只有git索引（index），不包含工作目录。裸仓库只保存了一些配置信息等，肉眼找不到上传的代码。简单说就是一个简单版的git仓库，不能使用常见的git命令，比如<code>git status</code>等等。</p>
<p><img src="https://user-images.githubusercontent.com/25907273/81208387-8b05c680-9001-11ea-8cad-8fbcdf45bcff.png" alt="image"></p>
<p>创建裸仓库很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bare.git名字可以任意</span></span><br><span class="line">git init --bare bare.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">mkdir bare.git</span><br><span class="line">cd bare.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<p>为什么要创建裸仓库？</p>
<p>裸仓库存在于服务端，是我们要提交代码的目标。我们在本地仓库push代码，就是要push到这个裸仓库。当我们push到这个裸仓库时，就会触发裸仓库响应的git hook——post-update。</p>
<h3 id="2-编辑裸仓库中的post-update-hook脚本"><a href="#2-编辑裸仓库中的post-update-hook脚本" class="headerlink" title="2. 编辑裸仓库中的post-update hook脚本"></a>2. 编辑裸仓库中的post-update hook脚本</h3><p>在脚本中，你可以写Bash、Python、JavaScript等代码，Git通过Shebang来选择执行代码的解释器。如果要写Bash，Shebang可以是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>使用Windows的读者请注意，如果脚本文件含有BOM（字节序标识符），可能会导致一些问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去掉sample后缀才会触发</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> post-update.sample post-update</span></span><br></pre></td></tr></table></figure>

<p>下面是一个比较简单的hook脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bare-repos是实际要部署代码的目录，这个目录是需要现在服务端创建的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然也可以当前脚本中自动化创建</span></span><br><span class="line">DIR_ONE=/Users/baohua/workspace/bare-repos/</span><br><span class="line">cd $DIR_ONE</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git remote add origin /Users/baohua/workspace/bare.git</span><br><span class="line">git clean -df</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">npm run deploy</span><br></pre></td></tr></table></figure>
<p><strong>注意： 一定要unset GIT_DIR清除变量， 不然会引起remote: fatal: Not a git repository: ‘.’错误。</strong></p>
<p>上面脚本做的事情很简单：</p>
<ol>
<li>切换到部署目录；</li>
<li>初始化git，在部署目录中添加裸仓库作为remote；</li>
<li>拉取裸仓库中的代码；</li>
<li>执行打包脚本。</li>
</ol>
<p>接着还需要给 post-update 添加执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +x将所有用户的执行权限添加到现有权限</span></span><br><span class="line">chmod +x post-update</span><br></pre></td></tr></table></figure>

<h3 id="3-本地仓库添加远程裸仓库作为remote"><a href="#3-本地仓库添加远程裸仓库作为remote" class="headerlink" title="3. 本地仓库添加远程裸仓库作为remote"></a>3. 本地仓库添加远程裸仓库作为remote</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 如果测试，并且裸仓库建在本地</span><br><span class="line">git remote add deploy /Users/baohua/workspace/bare.git</span><br><span class="line"></span><br><span class="line">// 默认ssh端口号为22时</span><br><span class="line">git remote add deploy user@serverIp:/Users/baohua/workspace/bare.git</span><br><span class="line"></span><br><span class="line">// ssh端口号为不22时</span><br><span class="line">git  remote  add  deploy  ssh://user@serverIp:port/Users/baohua/workspace/bare.git</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>利用每次push到目标仓库都会触发对应git hook的机制，在git hook中进行需要部署的代码从目标仓库中克隆到实际的代码部署目录；</li>
<li>实现流程分为三步：<ol>
<li>在服务端创建一个裸仓库；</li>
<li>编辑裸仓库中的post-update hook脚本；</li>
<li>本地仓库添加远程裸仓库作为remote。</li>
</ol>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Customizing Git - Git Hooks</a></li>
<li><a href="https://juejin.im/post/5ce607946fb9a07ef5620e5b">前端自动化工作流中的hooks</a></li>
<li><a href="https://www.jianshu.com/p/c1478bfcb372">利用Git Hooks自动部署</a></li>
<li><a href="https://aotu.io/notes/2017/04/10/githooks/index.html">用 Git 钩子进行简单自动部署</a></li>
<li><a href="https://blog.csdn.net/u010837612/article/details/70825225?utm_source=itdadao&utm_medium=referral">git hook实现代码自动部署</a></li>
<li><a href="https://www.cnblogs.com/wowchky/p/9177036.html">使用 Git Hook 实现网站的自动部署</a></li>
<li><a href="https://segmentfault.com/q/1010000004683286">git init 和 git init –bare 的区别？</a></li>
<li><a href="https://segmentfault.com/a/1190000016513388">使用git hook 实现nodejs项目自动部署</a></li>
<li><a href="https://www.jianshu.com/p/ef373ea5c61b">不会写shell的程序员照样是好前端——用Node.JS实现git hooks</a></li>
<li><a href="https://ubuntuqa.com/article/2264.html">“chmod + x”和“chmod 755”有什么区别？</a></li>
</ul>
]]></content>
      <categories>
        <category>部署发布</category>
      </categories>
      <tags>
        <tag>旧文迁移</tag>
        <tag>部署发布</tag>
        <tag>git hook</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Generator</title>
    <url>/blog/resources/%E6%B5%85%E6%9E%90Generator/</url>
    <content><![CDATA[<p>Generator 函数就是遍历器生成函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>foo()</code>会生成迭代器对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>



<p>第一次执行<code>generator.next()</code>，指针指向的是<code>yield 1;</code>的执行结果。</p>
<p><strong>而<code>console.log(1)</code>则是会被放在<code>next</code>中执行，这是猜想！</strong></p>
<p>迭代器对象的原理可以参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>在调用<code>next</code>方法时会返回一个对象，但是在generator内部，<code>yield</code>表达式是不会有返回值（或者说是返回<code>undefind</code>）。</p>
<p>但是想起在koa的时候，下面的方法又是可以有返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/detail&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  * <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">headers</span>[setting.<span class="property">bizHeader</span>];</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">const</span> out = <span class="keyword">yield</span> model.<span class="property">Business</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">      <span class="attr">raw</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">attributes</span>: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>, <span class="string">&#x27;avatar&#x27;</span>],</span><br><span class="line">      <span class="attr">where</span>: &#123; <span class="attr">bizId</span>: id &amp; <span class="number">65535</span>, <span class="title class_">CompanyId</span>: id &gt;&gt; <span class="number">16</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out 会储存一个Business的对象</span></span><br></pre></td></tr></table></figure>

<p><strong><code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</strong></p>
<p>比如上面的handler generator函数，只要如是操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="title function_">handler</span>();</span><br><span class="line"><span class="comment">// 计算 const out = yield model.Business.findOne(&#123; /* ... */ &#125;)</span></span><br><span class="line"><span class="keyword">const</span> res = generator.<span class="title function_">next</span>();		<span class="comment">// &#123; value: /* Business对象 */, done: false &#125;</span></span><br><span class="line"><span class="comment">// res.value就会赋值给out</span></span><br><span class="line">generator.<span class="title function_">next</span>(res.<span class="property">value</span>);</span><br><span class="line"><span class="comment">// 最终就return out</span></span><br></pre></td></tr></table></figure>



<p>从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数</p>
<h2 id="generator的throw方法"><a href="#generator的throw方法" class="headerlink" title="generator的throw方法"></a>generator的throw方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="keyword">yield</span> <span class="string">&#x27;isaac&#x27;</span>; </span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`inner error:`</span>, e.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> 	<span class="keyword">const</span> generator = <span class="title function_">foo</span>();</span><br><span class="line">  <span class="comment">// 必须先启动，调用throw方法才有效</span></span><br><span class="line">  generator.<span class="title function_">next</span>();</span><br><span class="line">  generator.<span class="keyword">throw</span>(<span class="string">&#x27;i am a error&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;outer error:&#x27;</span>, e.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// inner error: i am a error</span></span><br></pre></td></tr></table></figure>

<p>正如上面例子，使用<code>generator.throw</code>方法抛出的错误会被<code>generator</code>函数内部的<code>try...catch</code>捕获到，当然如果<code>generator</code>函数内部没有使用<code>try...catch</code>则会冒泡想外层抛出。</p>
<h2 id="yield-的本质"><a href="#yield-的本质" class="headerlink" title="yield*的本质"></a>yield*的本质</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历迭代器的同时再生成迭代器</p>
<p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实</p>
<h2 id="generator对异步任务的封装"><a href="#generator对异步任务的封装" class="headerlink" title="generator对异步任务的封装"></a>generator对异步任务的封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">bio</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> result = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器实现路由的自动挂载</title>
    <url>/blog/resources/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="装饰器实现路由的自动挂载"><a href="#装饰器实现路由的自动挂载" class="headerlink" title="装饰器实现路由的自动挂载"></a>装饰器实现路由的自动挂载</h1><ul>
<li>类装饰器工作记录contriller路径；</li>
<li>方法装饰器记录方法路径；</li>
<li>参数装饰器记录参数类型；</li>
<li>组合路由</li>
</ul>
<span id="more"></span>

<h1 id="类装饰器工作记录controller路径"><a href="#类装饰器工作记录controller路径" class="headerlink" title="类装饰器工作记录controller路径"></a>类装饰器工作记录controller路径</h1><p>controller装饰器的实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Control</span> = (<span class="params"><span class="attr">prefix</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_CONTROLLER_METADATA</span>, prefix, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现一个装饰个装饰器工厂函数，传入要保存的controller路径，工厂函数内部返回一个闭包函数（即是装饰器），在类装饰器函数中会传入一下参数，第一个是当前类构造函数的引用。然后使用reflect-metadata这个库的defineMetadata方法保存controller路径。这个方法一共需要传入三个参数：分别是metadata的key，第二个是要保存的数据，第三个也是一个键值，在这里使用构造函数的引用作为键值，这里的存储路径是：“构造函数”下保存以“metadate key”作为键值的数据“controller路径”。</p>
<p>在取出时只需要使用方法<code>getMetadata(&lt;metadata key&gt;, &lt;ref&gt;)</code>按defineMetadata方法的顺序传参即可在任何地方取出刚刚保存的数据。</p>
<h1 id="方法装饰器记录方法路径"><a href="#方法装饰器记录方法路径" class="headerlink" title="方法装饰器记录方法路径"></a>方法装饰器记录方法路径</h1><p>方法装饰器根据http的动词方法进行封装。</p>
<p>跟controller装饰器实现类型，同样封装一样的装饰工厂来保存路径。与controller装饰器的实现不同的是，还需要额外保存另外两个数据：1.http动词；2.保存方法名。需要http方法动词是因为挂载路由时需要制定不同的http方法；保存方法名，则是为了在后续可以访问到与路径对应的方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createHttpMethodDecorator</span> = (<span class="params">methodtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">path</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handlers = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, target) || [];</span><br><span class="line">      handlers.<span class="title function_">push</span>(propertyKey);</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, handlers, target);</span><br><span class="line">      <span class="comment">// 设置方法</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_METHOD_METADATA</span>, methodtype, target, propertyKey);</span><br><span class="line">      <span class="comment">// 设置路由</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">ROUTE_URL_METADATA</span>, path, target, propertyKey);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Get</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">GET</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Post</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">POST</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Put</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">PUT</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Delete</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">DELETE</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Patch</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">PATCH</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">All</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">ALL</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Options</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">OPTIONS</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Head</span> = <span class="title function_">createHttpMethodDecorator</span>(<span class="title class_">HttpMethodEnum</span>.<span class="property">HEAD</span>);</span><br></pre></td></tr></table></figure>

<p>注意：方法装饰器传入的第一个参数和类装饰器不同，类装饰器传入的是构造函数的引用，而方法装饰器传入的构造函数原型对象的引用（Ctor.prototype）。</p>
<h1 id="参数装饰器记录参数类型"><a href="#参数装饰器记录参数类型" class="headerlink" title="参数装饰器记录参数类型"></a>参数装饰器记录参数类型</h1><p>参数装饰器的封装比以上两种会稍微复杂一点，主要需要保存的数据有：</p>
<ol>
<li>参数装饰的类型：包含Query对应get方法请求参数，Body对应post等方法参数，Param对应路径上的参数；</li>
<li>参数的索引：参数在方法参数列表上的索引；</li>
<li>参数名：参数的名字（字符串）。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">assignMetadata</span> = (<span class="params">args, paramtype, index, data, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;...args,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;paramtype&#125;</span>:<span class="subst">$&#123;index&#125;</span>`</span>]: &#123;</span><br><span class="line">      paramtype,</span><br><span class="line">      <span class="attr">paramIndex</span>: index,</span><br><span class="line">      <span class="attr">propName</span>: data,</span><br><span class="line">      pipes,</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouteParamDecorator</span> = (<span class="params">paramtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">data</span>?: <span class="built_in">any</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt;</span> <span class="function">(<span class="params">target, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_ARGS_METADATA</span>, target, key) || &#123;&#125;;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(</span><br><span class="line">      <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">      <span class="title function_">assignMetadata</span>(args, paramtype, index, data, ...pipes),</span><br><span class="line">      target,</span><br><span class="line">      key,</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Request</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">REQUEST</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Response</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">RESPONSE</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UploadFileStream</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">FILE_STREAM</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Headers</span> = <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">HEADERS</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Query</span> = (<span class="params"><span class="attr">property</span>?: <span class="built_in">string</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">QUERY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Body</span> = (<span class="params"><span class="attr">property</span>?: <span class="built_in">string</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">BODY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Param</span> = (<span class="params"><span class="attr">property</span>?: <span class="built_in">string</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">PARAM</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="组合路由"><a href="#组合路由" class="headerlink" title="组合路由"></a>组合路由</h1><p>首先需要动态引入Controller，因为装饰器保存的数据都是保存在键名是构造函数引用下或构造函数原型对象引用下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="built_in">require</span>(file).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> prototype = controller.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>取出Controller装饰器保存的路径：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制器前缀 类装饰器，传入的是构造函数</span></span><br><span class="line"><span class="keyword">const</span> ctrlPrefix = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_CONTROLLER_METADATA</span>, constructor) || <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>取出存储的方法名：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 方法、属性装饰器，传入原型</span></span><br><span class="line"><span class="keyword">const</span> methodNames = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_HANDLE_METADATA</span>, prototype) || [];</span><br></pre></td></tr></table></figure>

<p>取出该方法下的数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">methodNames.<span class="title function_">forEach</span>(<span class="function">(<span class="params">methodName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// http方法：get 、post、put等</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">httpMethod</span>: <span class="built_in">string</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_METHOD_METADATA</span>, prototype, methodName);</span><br><span class="line">  <span class="comment">// 方法装饰器声明的路由</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">urlPath</span>: <span class="built_in">string</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_URL_METADATA</span>, prototype, methodName) || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// 是否上传文件</span></span><br><span class="line">  <span class="keyword">const</span> uploadFile = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">UPLOAD_FILE_METADATA</span>, prototype, methodName) || <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// handler的参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">handlerArgs</span>: <span class="title class_">RouteParamMetadataInterface</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">    prototype,</span><br><span class="line">    methodName,</span><br><span class="line">  ) || &#123;&#125;;</span><br><span class="line">  <span class="comment">// handlerArgs的参数类型</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">handlerArgsTypes</span>: <span class="built_in">any</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="title class_">ReflectDefaultMetadata</span>.<span class="property">DESGIN_PARAMTYPES</span>,</span><br><span class="line">    prototype,</span><br><span class="line">    methodName,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(handlerArgs)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;paramIndex&#125; = handlerArgs[key];</span><br><span class="line">    <span class="comment">// 相应位置的参数类型。类型声明</span></span><br><span class="line">    handlerArgs[key].<span class="property">type</span> = handlerArgsTypes[paramIndex];</span><br><span class="line">  &#125;</span><br><span class="line">  handlers.<span class="title function_">push</span>(&#123;</span><br><span class="line">    urlPath,</span><br><span class="line">    httpMethod,</span><br><span class="line">    methodName,</span><br><span class="line">    handlerArgs,</span><br><span class="line">    uploadFile,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从上面我们就拿到了：</p>
<ul>
<li>Controller装饰器保存的路径；<code>ctrlPrefix</code></li>
<li>方法装饰器保存的路径：<code>urlPath</code>；</li>
<li>方法装饰器的类型：<code>httpMethod</code>、</li>
</ul>
<p>有以上数据就可以进行路由的挂载：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// url = [ctrlPrefix, urlPath].join(&#x27;/&#x27;);</span></span><br><span class="line">app.<span class="property">router</span>[httpMethod](url, ...middleware, <span class="title function_">async</span> (<span class="attr">ctx</span>: <span class="title class_">Context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">controller</span>(ctx);</span><br><span class="line">  <span class="keyword">if</span> (uploadFile) &#123;</span><br><span class="line">    ctx.<span class="property">request</span>.<span class="property">file</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getUploadFile</span>(ctx, uploadFile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">params</span>: <span class="built_in">any</span>[] = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getRouteParams</span>(ctx, handlerArgs);</span><br><span class="line">  <span class="comment">// instance[methodName]使用methodName保存的方法名调用与路由对应的方法</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> instance[methodName](...params);</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">body</span> === <span class="literal">undefined</span> &amp;&amp; result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>使用类装饰器和方法装饰器工厂函数保存路由的路径；</li>
<li>方法装饰器除了保存路径外，还需要保存以下数据：<ol>
<li>方法装饰器根据http方法进行封装，所以还需要保存不同方法的类型；</li>
<li>方法的名字，用于后续挂载路由时，调用与路由对应的方法</li>
</ol>
</li>
<li>使用<code>reflect-metadata</code>将路径保存在构造函数或构造函数原型对象的引用下，根据metadataKey来区分不同的数据；</li>
<li>在挂载路由时只需要引入对应的Controller就可取出所存储的数据，拼接处完成的路由路径，并实例化Controller并调用对应的方法。</li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器实现参数的校验</title>
    <url>/blog/resources/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>需要用到的工具：</p>
<ul>
<li>参数装饰器：记录参数的索引，方法名；</li>
<li>tslib_1.__metadata：这是ts的内置方法用于保存方法的参数类型、方法类型以及方法返回数据的类型；</li>
<li>reflect-metadata：保存参数的数据；</li>
<li>class-validator：对类成员进行校验；</li>
<li>class-transformer：使用class-transformer的plainToClass方法将对象转化成指定类的实例。</li>
</ul>
<span id="more"></span>

<h1 id="参数装饰器保存相关元数据"><a href="#参数装饰器保存相关元数据" class="headerlink" title="参数装饰器保存相关元数据"></a>参数装饰器保存相关元数据</h1><p>参数装饰器返回返回三个参数：1.构造函数的原型对象；2.参数所属方法名；3.参数的索引。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.target: 构造函数的原型对象；</span></span><br><span class="line"><span class="comment">// 2.key: 参数所属方法名；</span></span><br><span class="line"><span class="comment">// 3.index: 参数的索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouteParamDecorator</span> = (<span class="params">paramtype</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">data</span>?: <span class="built_in">any</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">ROUTE_ARGS_METADATA</span>, target, key) || &#123;&#125;;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(</span><br><span class="line">        <span class="variable constant_">ROUTE_ARGS_METADATA</span>,</span><br><span class="line">        <span class="title function_">assignMetadata</span>(args, paramtype, index, data, ...pipes),</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Query</span> = (<span class="params"><span class="attr">property</span>?: <span class="built_in">string</span>, ...<span class="attr">pipes</span>: <span class="title class_">PipeTransform</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRouteParamDecorator</span>(<span class="title class_">RouteParamtypesEnum</span>.<span class="property">QUERY</span>)(property, ...pipes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="保存参数类型元数据"><a href="#保存参数类型元数据" class="headerlink" title="保存参数类型元数据"></a>保存参数类型元数据</h1><p>在<a href="https://github.com/isaaxite/blog/issues/279#issuecomment-617980384">参数装饰器保存相关元数据</a>分别保存了三个数据，但是为什么呢？自然是用于取出保存的某数据，而这个某数据就是参数定义的类型，比如现在有一个类<code>Foo</code>，并定义了一个<code>setInfo</code>成员方法，这个方法的参数定义了一个类型<code>NameInfo</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameInfo</span> &#123;</span><br><span class="line">  <span class="attr">ch</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">en</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeInfo</span> &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">born</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">NameInfo</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">AgeInfo</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Control</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="title class_">NameInfo</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="title class_">AgeInfo</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Put</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">  <span class="title function_">setInfo</span>(</span><br><span class="line">    <span class="meta">@Query</span>() <span class="attr">_name</span>: <span class="title class_">NameInfo</span>,</span><br><span class="line">    <span class="meta">@Query</span>() <span class="attr">_age</span>: <span class="title class_">AgeInfo</span>,</span><br><span class="line">  ): <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = _name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = _age;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>, <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setInfo</code>编译后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tslib_1.<span class="title function_">__decorate</span>([</span><br><span class="line">    index_1.<span class="title class_">Put</span>(<span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">    tslib_1.<span class="title function_">__param</span>(<span class="number">0</span>, param_dec_1.<span class="title class_">Query</span>()),</span><br><span class="line">    tslib_1.<span class="title function_">__param</span>(<span class="number">1</span>, param_dec_1.<span class="title class_">Query</span>()),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:type&quot;</span>, <span class="title class_">Function</span>),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:paramtypes&quot;</span>, [<span class="title class_">NameInfo</span>, <span class="title class_">AgeInfo</span>]),</span><br><span class="line">    tslib_1.<span class="title function_">__metadata</span>(<span class="string">&quot;design:returntype&quot;</span>, <span class="title class_">PersonInfo</span>)</span><br><span class="line">], <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;setInfo&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>在定义的参数装饰器外，还另外多定义了三个<code>tslib_1.__metadata</code>装饰器。这个三个<code>tslib_1.__metadata</code>的定义分别是：</p>
<ul>
<li><p><code>tslib_1.__metadata(&quot;design:type&quot;, Function)</code>：存储成员方法的方法类型；</p>
</li>
<li><p><code>tslib_1.__metadata(&quot;design:paramtypes&quot;, [NameInfo, AgeInfo])</code>：方法的参数类型；</p>
</li>
<li><p><code>tslib_1.__metadata(&quot;design:returntype&quot;, PersonInfo)</code>：方法返回的类型。</p>
</li>
</ul>
<p>而这个<code>tslib_1.__metadata</code>方法相当于调用reflect-metadata库的<code>Reflect.defineMetadata</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, C.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>关于<code>tslib_1.__metadata</code>的具体实现可以参考附录中的<a href="https://github.com/isaaxite/blog/issues/279#issuecomment-617981211">tslib_1.__metadata</a>。</p>
<p>由上可知，在执行参数装饰器时，将方法的参数类型作为一个数组保存到构造函数的原型对象-&gt;参数所属方法名-&gt;metadataKey之中。</p>
<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><p>根据构造函数原型对象引用、参数所属方法名、metadata key即刚刚的<code>design:paramtypes</code>就可以拿到刚刚存储的参数类型数组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">handlerArgsTypes</span>: <span class="built_in">any</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">  <span class="title class_">ReflectDefaultMetadata</span>.<span class="property">DESGIN_PARAMTYPES</span>,</span><br><span class="line">  prototype,</span><br><span class="line">  methodName,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [NameInfo, AgeInfo]</span></span><br></pre></td></tr></table></figure>

<p>然后在根据存储的参数索引即可拿到参数对应的类型。</p>
<p>有了类型信息，再加上请求是传过来的对象，就可以使用class-transformer的<code>plainToClass</code>方法将请求的参数转化成参数类型的实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">clsObj = <span class="title function_">plainToClass</span>(<span class="keyword">type</span>, param)</span><br></pre></td></tr></table></figure>

<p>有了实例，就可以使用<code>class-validator</code>的<code>validate</code>方法对请求参数进行校验。<code>class-validator</code>这个库提供了许多装饰器可以对类实例的成员进行校验，比如<code>@isInt</code>可以校验可以校验整型数据，<code>@isString</code>可以校验字符类型的数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IsInt</span>, <span class="title class_">IsString</span>, validate&#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeInfo</span> &#123;</span><br><span class="line">  <span class="meta">@IsInt</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;$property必须是整型&#x27;</span> &#125;)</span><br><span class="line">  <span class="attr">num</span>: <span class="built_in">number</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IsString</span>()</span><br><span class="line">  <span class="attr">born</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errors = <span class="keyword">await</span> <span class="title function_">validate</span>(clsObj);</span><br></pre></td></tr></table></figure>


<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="tslib-1-metadata"><a href="#tslib-1-metadata" class="headerlink" title="tslib_1.__metadata"></a>tslib_1.__metadata</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tslib_1.__metadata(&quot;design:paramtypes&quot;, [NameInfo, AgeInfo])</span></span><br><span class="line">__metadata = <span class="keyword">function</span> (<span class="params">metadataKey, metadataValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&quot;object&quot;</span></span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Reflect</span>.<span class="property">metadata</span> === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.metadata的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">metadata</span>(<span class="params">metadataKey, metadataValue</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params">target, propertyKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">IsObject</span>(target))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">IsUndefined</span>(propertyKey) &amp;&amp; !<span class="title class_">IsPropertyKey</span>(propertyKey))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    <span class="title class_">OrdinaryDefineOwnMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> decorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.defineMetadata的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineMetadata</span>(<span class="params">metadataKey, metadataValue, target, propertyKey</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">IsObject</span>(target))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">IsUndefined</span>(propertyKey))</span><br><span class="line">    propertyKey = <span class="title class_">ToPropertyKey</span>(propertyKey);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">OrdinaryDefineOwnMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="decorate"><a href="#decorate" class="headerlink" title="__decorate"></a>__decorate</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__decorate = <span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="variable language_">arguments</span>.<span class="property">length</span>, </span><br><span class="line">      r = c &lt; <span class="number">3</span> </span><br><span class="line">        ? target </span><br><span class="line">        : desc === <span class="literal">null</span> </span><br><span class="line">          ? desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key)</span><br><span class="line">          : desc,</span><br><span class="line">      d;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&quot;object&quot;</span> </span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Reflect</span>.<span class="property">decorate</span> === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    r = <span class="title class_">Reflect</span>.<span class="title function_">decorate</span>(decorators, target, key, desc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d = decorators[i]) &#123;</span><br><span class="line">        r = (</span><br><span class="line">          c &lt; <span class="number">3</span></span><br><span class="line">            ? <span class="title function_">d</span>(r)</span><br><span class="line">            : c &gt; <span class="number">3</span> </span><br><span class="line">              ? <span class="title function_">d</span>(target, key, r) </span><br><span class="line">              : <span class="title function_">d</span>(target, key)</span><br><span class="line">        ) || r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, r), r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>ElementUI源码分析-Scrolllbar组件</title>
    <url>/blog/resources/ElementUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Scrolllbar%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>scrollbar组件可以通过设置native属性，是否使用自定义的scrollbar视图，默认为<code>undefined</code>即使用自定义的，下面也是主要分析自定义scrollbar的构成。</p>
<span id="more"></span>

<p>scrollbar视图的html代码由来年两层元素构成：</p>
<ol>
<li>第一层：<code>el-scrollbar</code>，样式设为<code>overflow: hidden</code>主要用于隐藏原生scrollbar；</li>
<li>第二层：<code>el-scrollbar__wrap</code>，用于存放内容的真实视图。<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nodes = ([</span><br><span class="line">  wrap,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  	<span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveX</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeWidth</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span>,</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">vertical</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveY</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeHeight</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="scrollbar的主要逻辑"><a href="#scrollbar的主要逻辑" class="headerlink" title="scrollbar的主要逻辑"></a>scrollbar的主要逻辑</h3><p><img src="image-20200420222553641.png"></p>
<h3 id="1-计算浏览器scrollbar默认宽度"><a href="#1-计算浏览器scrollbar默认宽度" class="headerlink" title="1,计算浏览器scrollbar默认宽度"></a>1,计算浏览器scrollbar默认宽度</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 通过离线创建一个容器，计算浏览器默认的scrollbar宽度</span><br><span class="line"><span class="comment">// 计算这个默认宽度是为了当出现默认scrollbar的时候隐藏掉</span></span><br><span class="line"><span class="keyword">let</span> gutter = <span class="title function_">scrollbarWidth</span>();</span><br></pre></td></tr></table></figure>

<p>计算方式是离线创建一个容器，并使之产生scrollbar，根据产生scrollbar前后容器的宽度计算宽度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scrollBarWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$isServer</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 使用缓存</span></span><br><span class="line">  <span class="keyword">if</span> (scrollBarWidth !== <span class="literal">undefined</span>) <span class="keyword">return</span> scrollBarWidth;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 外层</span></span><br><span class="line">  <span class="keyword">const</span> outer = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  outer.<span class="property">className</span> = <span class="string">&#x27;el-scrollbar__wrap&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;-9999px&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(outer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录产生scrollbar前的视图宽度</span></span><br><span class="line">  <span class="keyword">const</span> widthNoScroll = outer.<span class="property">offsetWidth</span>;</span><br><span class="line">  <span class="comment">// 强制显示scrollbar</span></span><br><span class="line">  outer.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;scroll&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inner = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  inner.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  outer.<span class="title function_">appendChild</span>(inner);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录产生scrollbar后的视图宽度</span></span><br><span class="line">  <span class="keyword">const</span> widthWithScroll = inner.<span class="property">offsetWidth</span>;</span><br><span class="line">  outer.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(outer);</span><br><span class="line">  scrollBarWidth = widthNoScroll - widthWithScroll;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scrollBarWidth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-撑大el-scrollbar-wrap容器隐藏原生scrollbar"><a href="#2-撑大el-scrollbar-wrap容器隐藏原生scrollbar" class="headerlink" title="2.撑大el-scrollbar__wrap容器隐藏原生scrollbar"></a>2.撑大<code>el-scrollbar__wrap</code>容器隐藏原生scrollbar</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (gutter) &#123;</span><br><span class="line">  <span class="keyword">const</span> gutterWith = <span class="string">`-<span class="subst">$&#123;gutter&#125;</span>px`</span>;</span><br><span class="line">  <span class="keyword">const</span> gutterStyle = <span class="string">`margin-bottom: <span class="subst">$&#123;gutterWith&#125;</span>; margin-right: <span class="subst">$&#123;gutterWith&#125;</span>;`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">wrapStyle</span>)) &#123;</span><br><span class="line">    style = <span class="title function_">toObject</span>(<span class="variable language_">this</span>.<span class="property">wrapStyle</span>);</span><br><span class="line">    style.<span class="property">marginRight</span> = style.<span class="property">marginBottom</span> = gutterWith;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">wrapStyle</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    style += gutterStyle;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    style = gutterStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-添加自定义滑块模拟原生scrollbar"><a href="#3-添加自定义滑块模拟原生scrollbar" class="headerlink" title="3.添加自定义滑块模拟原生scrollbar"></a>3.添加自定义滑块模拟原生scrollbar</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">nodes = ([</span><br><span class="line">  wrap,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveX</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeWidth</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span>,</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">vertical</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">move</span>=<span class="string">&#123;</span> <span class="attr">this.moveY</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">size</span>=<span class="string">&#123;</span> <span class="attr">this.sizeHeight</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="4-注册scrollbar事件"><a href="#4-注册scrollbar事件" class="headerlink" title="4.注册scrollbar事件"></a>4.注册scrollbar事件</h3><p>主要用于更新自定义bar的偏移位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrap = <span class="variable language_">this</span>.<span class="property">wrap</span>;</span><br><span class="line">  <span class="comment">// 纵向偏移比例 = 内容纵向偏移量 / 视图高度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">moveY</span> = ((wrap.<span class="property">scrollTop</span> * <span class="number">100</span>) / wrap.<span class="property">clientHeight</span>);</span><br><span class="line">  <span class="comment">// 横向偏移比例 = 内容横向偏移量 / 视图宽度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">moveX</span> = ((wrap.<span class="property">scrollLeft</span> * <span class="number">100</span>) / wrap.<span class="property">clientWidth</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-注册resize事件以及初始化滑块宽度"><a href="#5-注册resize事件以及初始化滑块宽度" class="headerlink" title="5.注册resize事件以及初始化滑块宽度"></a>5.注册resize事件以及初始化滑块宽度</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> heightPercentage, widthPercentage;</span><br><span class="line">    <span class="keyword">const</span> wrap = <span class="variable language_">this</span>.<span class="property">wrap</span>;</span><br><span class="line">    <span class="keyword">if</span> (!wrap) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纵轴滑块的高度 = 元素高度 / 元素内容视图高度</span></span><br><span class="line">    heightPercentage = (wrap.<span class="property">clientHeight</span> * <span class="number">100</span> / wrap.<span class="property">scrollHeight</span>);</span><br><span class="line">    <span class="comment">// 纵轴滑块的高度 = 元素宽度 / 元素内容视图宽度</span></span><br><span class="line">    widthPercentage = (wrap.<span class="property">clientWidth</span> * <span class="number">100</span> / wrap.<span class="property">scrollWidth</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sizeHeight</span> = (heightPercentage &lt; <span class="number">100</span>) ? (heightPercentage + <span class="string">&#x27;%&#x27;</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sizeWidth</span> = (widthPercentage &lt; <span class="number">100</span>) ? (widthPercentage + <span class="string">&#x27;%&#x27;</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">native</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 初始化scrollbar的宽度</span></span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="variable language_">this</span>.<span class="property">update</span>);</span><br><span class="line">  <span class="comment">// 注册resize事件，用于之后更新scrollbar的宽度</span></span><br><span class="line">  !<span class="variable language_">this</span>.<span class="property">noresize</span> &amp;&amp; <span class="title function_">addResizeListener</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">resize</span>, <span class="variable language_">this</span>.<span class="property">update</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h2 id="bar组件"><a href="#bar组件" class="headerlink" title="bar组件"></a>bar组件</h2><p>bar组件是对原生滑块的模拟，滑块由滑块容器以及滑块本身组成！</p>
<p>bar组件负责的主要功能是：计算滑块的偏移距离与滑块容器高度的比例，以次比例计算Scrill-view的偏移值。</p>
<p>实现的交互功能分别有两个：</p>
<ol>
<li>点击滑块容器，移动scroll-view内容，通过给滑块容器绑定<code>mousedown</code>事件触发；</li>
<li>拖动滑块使移动scroll-view内容，通过绑定三个事件实现：<code>mousedown</code>、<code>mousemove``mouseup</code>。</li>
</ol>
<p>注意：</p>
<ol>
<li>bar组建的滑块自身的偏移不是由bar组建自身直接改变，而是根据根据传入的两个props属性绑定到滑块的style上实现的；<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">	<span class="attr">vertical</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">	<span class="attr">size</span>: <span class="title class_">String</span>,	<span class="comment">// 滑块的长度</span></span><br><span class="line">	<span class="attr">move</span>: <span class="title class_">Number</span>	<span class="comment">// 话快的偏移值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>滑块的偏移有css3的<code>tansfrom: translate()</code>实现<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderThumbStyle</span>(<span class="params">&#123; move, size, bar &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> translate = <span class="string">`translate<span class="subst">$&#123;bar.axis&#125;</span>(<span class="subst">$&#123; move &#125;</span>%)`</span>;</span><br><span class="line"></span><br><span class="line">  style[bar.<span class="property">size</span>] = size;</span><br><span class="line">  style.<span class="property">transform</span> = translate;</span><br><span class="line">  style.<span class="property">msTransform</span> = translate;</span><br><span class="line">  style.<span class="property">webkitTransform</span> = translate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">&#123;</span> [&#x27;<span class="attr">el-scrollbar__bar</span>&#x27;, &#x27;<span class="attr">is-</span>&#x27; + <span class="attr">bar.key</span>] &#125;</span></span><br><span class="line"><span class="tag">     <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickTrackHandler</span> &#125; &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">       <span class="attr">ref</span>=<span class="string">&quot;thumb&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">&quot;el-scrollbar__thumb&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickThumbHandler</span> &#125;</span></span><br><span class="line"><span class="tag">       <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">renderThumbStyle</span>(&#123; <span class="attr">size</span>, <span class="attr">move</span>, <span class="attr">bar</span> &#125;) &#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由滑块容器<code>el-scrollbar__bar</code>和滑块<code>el-scrollbar__thumb</code>组成。</p>
<h3 id="点击容器移动滑块"><a href="#点击容器移动滑块" class="headerlink" title="点击容器移动滑块"></a>点击容器移动滑块</h3><p>容器元素监听<code>onMousedown</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击滑块容器，移动父元素的内容移动`$parent.wrap`的scrollTop/scrollLeft</span></span><br><span class="line"><span class="title function_">clickTrackHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.target.getBoundingClientRect()：获取元素大小与位置信息，返回一个DOMRect对象</span></span><br><span class="line">  <span class="comment">// x: 390 // 左边距离视窗左边距离</span></span><br><span class="line">  <span class="comment">// y: 91  // 上边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// width: 240 // 元素宽度</span></span><br><span class="line">  <span class="comment">// height: 26 // 元素高度</span></span><br><span class="line">  <span class="comment">// top: 91  // 上边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// right: 630 // 右边距离视窗左边距离</span></span><br><span class="line">  <span class="comment">// bottom: 117  // 低边距离视窗上边距离</span></span><br><span class="line">  <span class="comment">// left: 390  // 左边距离视窗左边距离</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以纵向滚轴为例子</span></span><br><span class="line">  <span class="comment">// offset：计算点击位置在元素矩形内纵向的偏移数值</span></span><br><span class="line">  <span class="keyword">const</span> offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(e.<span class="property">target</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]);   <span class="comment">// e[this.bar.client]点击的横纵/坐标值</span></span><br><span class="line">  <span class="comment">// thumbHalf：滑块高度的一半</span></span><br><span class="line">  <span class="keyword">const</span> thumbHalf = (<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> thumbPositionPercentage = ((offset - thumbHalf) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this.wrap: this.$parent.wrap</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拖动滑块移动父容器内容"><a href="#拖动滑块移动父容器内容" class="headerlink" title="拖动滑块移动父容器内容"></a>拖动滑块移动父容器内容</h3><p>涉及到三个事件的监听：</p>
<ol>
<li><code>onMousedown</code>事件：负责触发事件；</li>
<li><code>mousemove</code>事件：负责计算滑块移动距离与容器高度的比例，以此更新父容器的scrollTop</li>
<li><code>mouseup</code>事件：负责移除<code>mousemove</code>事件的监听和整个功能结束的收尾。</li>
</ol>
<h4 id="点击触发，动态绑定mousemove和mouseup事件"><a href="#点击触发，动态绑定mousemove和mouseup事件" class="headerlink" title="点击触发，动态绑定mousemove和mouseup事件"></a>点击触发，动态绑定mousemove和mouseup事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clickThumbHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// e.ctrlKey </span></span><br><span class="line">  <span class="comment">// 鼠标事件ctrlKey是只读属性，可返回一个布尔值，当ctrl键被按下，返回true，否则返回false</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// e.button:</span></span><br><span class="line">  <span class="comment">// 0：主按键被按下，通常指鼠标左键 or the un-initialized state</span></span><br><span class="line">  <span class="comment">// 1：辅助按键被按下，通常指鼠标滚轮 or the middle button (if present)</span></span><br><span class="line">  <span class="comment">// 2：次按键被按下，通常指鼠标右键</span></span><br><span class="line">  <span class="comment">// 3：第四个按钮被按下，通常指浏览器后退按钮</span></span><br><span class="line">  <span class="comment">// 4：第五个按钮被按下，通常指浏览器的前进按钮</span></span><br><span class="line">  <span class="comment">// prevent click event of right button</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">ctrlKey</span> || e.<span class="property">button</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">startDrag</span>(e);</span><br><span class="line">  <span class="comment">// 点击位置距离滑块下边的距离</span></span><br><span class="line">  <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = (e.<span class="property">currentTarget</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - (</span><br><span class="line">    <span class="comment">// 1.点击位置的纵坐标：e[this.bar.client]</span></span><br><span class="line">    <span class="comment">// 2.滑块元素上边的纵坐标：e.currentTarget.getBoundingClientRect()[this.bar.direction])</span></span><br><span class="line">    <span class="comment">// 点击位置到滑块上边的高度 = 1 - 2</span></span><br><span class="line">    e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>] - e.<span class="property">currentTarget</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>])</span><br><span class="line">                        );</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">startDrag</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// addEventListener监听mousemove事件</span></span><br><span class="line">  <span class="comment">// addEventListener监听mouseup事件</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">  <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="动态计算父容器内容的偏移"><a href="#动态计算父容器内容的偏移" class="headerlink" title="动态计算父容器内容的偏移"></a>动态计算父容器内容的偏移</h4><p>此时鼠标右键已经被按下且未放开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动鼠标，同步移动父元素容器的内容</span></span><br><span class="line"><span class="title function_">mouseMoveDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cursorDown</span> === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> prevPage = <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevPage) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// offset：点击位置到滑块容器顶部的距离</span></span><br><span class="line">  <span class="keyword">const</span> offset = ((</span><br><span class="line">    <span class="comment">// 1.滑块容器上边距离视窗上边距离：this.$el.getBoundingClientRect()[this.bar.direction]</span></span><br><span class="line">    <span class="comment">// 2.当前点击的纵轴坐标</span></span><br><span class="line">    <span class="comment">// 点击位置距离容器上边的长度 = 1 - 2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]</span><br><span class="line">  ) * -<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 点击位置距离滑块上边的距离</span></span><br><span class="line">  <span class="keyword">const</span> thumbClickPosition = (</span><br><span class="line">    <span class="comment">// 1.this.$refs.thumb[this.bar.offset]：滑块高度</span></span><br><span class="line">    <span class="comment">// 2.prevPage：点击位置距离下边的距离</span></span><br><span class="line">    <span class="comment">// 点击位置距离滑块上边的距离 = 1 - 2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - prevPage</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 计算“滑块上边到容器上边距离”占容器高度的百分比</span></span><br><span class="line">  <span class="keyword">const</span> thumbPositionPercentage = ((</span><br><span class="line">    <span class="comment">// 计算滑块上边到容器上边的距离</span></span><br><span class="line">    offset - thumbClickPosition</span><br><span class="line">  ) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;计算滑块上边到容器上边的距离&#x27;</span>: offset - thumbClickPosition,</span><br><span class="line">  <span class="string">&#x27;容器的高度&#x27;</span>: <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过thumbPositionPercentage计算夫容器移动的距离</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="结束滑块移动"><a href="#结束滑块移动" class="headerlink" title="结束滑块移动"></a>结束滑块移动</h4><p>鼠标右键放开，结束事件重置基本变量，解绑mousemove事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mouseUpDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件生命周期结束解绑mouseup事件"><a href="#组件生命周期结束解绑mouseup事件" class="headerlink" title="组件生命周期结束解绑mouseup事件"></a>组件生命周期结束解绑mouseup事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="bar源码注释"><a href="#bar源码注释" class="headerlink" title="bar源码注释"></a>bar源码注释</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; on, off &#125; <span class="keyword">from</span> <span class="string">&#x27;zhuiyi-ui/src/utils/dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderThumbStyle, <span class="variable constant_">BAR_MAP</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">vertical</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="comment">// 滑块的长度</span></span><br><span class="line">    <span class="attr">size</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="comment">// 滑块的偏移量</span></span><br><span class="line">    <span class="attr">move</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">BAR_MAP</span>[<span class="variable language_">this</span>.<span class="property">vertical</span> ? <span class="string">&#x27;vertical&#x27;</span> : <span class="string">&#x27;horizontal&#x27;</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">wrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">wrap</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size, move, bar &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">class</span>=<span class="string">&#123;</span> [&#x27;<span class="attr">el-scrollbar__bar</span>&#x27;, &#x27;<span class="attr">is-</span>&#x27; + <span class="attr">bar.key</span>] &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickTrackHandler</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&quot;thumb&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">class</span>=<span class="string">&quot;el-scrollbar__thumb&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onMousedown</span>=<span class="string">&#123;</span> <span class="attr">this.clickThumbHandler</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">renderThumbStyle</span>(&#123; <span class="attr">size</span>, <span class="attr">move</span>, <span class="attr">bar</span> &#125;) &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">clickThumbHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// e.ctrlKey </span></span><br><span class="line">      <span class="comment">// 鼠标事件ctrlKey是只读属性，可返回一个布尔值，当ctrl键被按下，返回true，否则返回false</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="comment">// e.button:</span></span><br><span class="line">      <span class="comment">// 0：主按键被按下，通常指鼠标左键 or the un-initialized state</span></span><br><span class="line">      <span class="comment">// 1：辅助按键被按下，通常指鼠标滚轮 or the middle button (if present)</span></span><br><span class="line">      <span class="comment">// 2：次按键被按下，通常指鼠标右键</span></span><br><span class="line">      <span class="comment">// 3：第四个按钮被按下，通常指浏览器后退按钮</span></span><br><span class="line">      <span class="comment">// 4：第五个按钮被按下，通常指浏览器的前进按钮</span></span><br><span class="line">      <span class="comment">// prevent click event of right button</span></span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">ctrlKey</span> || e.<span class="property">button</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">startDrag</span>(e);</span><br><span class="line">      <span class="comment">// 点击位置距离滑块下边的距离</span></span><br><span class="line">      <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = (e.<span class="property">currentTarget</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - (</span><br><span class="line">        <span class="comment">// 1.点击位置的纵坐标：e[this.bar.client]</span></span><br><span class="line">        <span class="comment">// 2.滑块元素上边的纵坐标：e.currentTarget.getBoundingClientRect()[this.bar.direction])</span></span><br><span class="line">        <span class="comment">// 点击位置到滑块上边的高度 = 1 - 2</span></span><br><span class="line">        e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>] - e.<span class="property">currentTarget</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>])</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击滑块容器，移动父元素容器的内容（scrollTop/scrollLeft）</span></span><br><span class="line">    <span class="title function_">clickTrackHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// e.target.getBoundingClientRect()：获取元素大小与位置信息，返回一个DOMRect对象</span></span><br><span class="line">      <span class="comment">// x: 390 // 左边距离视窗左边距离</span></span><br><span class="line">      <span class="comment">// y: 91  // 上边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// width: 240 // 元素宽度</span></span><br><span class="line">      <span class="comment">// height: 26 // 元素高度</span></span><br><span class="line">      <span class="comment">// top: 91  // 上边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// right: 630 // 右边距离视窗左边距离</span></span><br><span class="line">      <span class="comment">// bottom: 117  // 低边距离视窗上边距离</span></span><br><span class="line">      <span class="comment">// left: 390  // 左边距离视窗左边距离</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以纵向滚轴为例子</span></span><br><span class="line">      <span class="comment">// offset：计算点击位置在元素矩形内纵向的偏移数值</span></span><br><span class="line">      <span class="keyword">const</span> offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(e.<span class="property">target</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]);   <span class="comment">// e[this.bar.client]点击的横纵/坐标值</span></span><br><span class="line">      <span class="comment">// thumbHalf：滑块高度的一半</span></span><br><span class="line">      <span class="keyword">const</span> thumbHalf = (<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> thumbPositionPercentage = ((offset - thumbHalf) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">startDrag</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// addEventListener监听mousemove事件</span></span><br><span class="line">      <span class="comment">// addEventListener监听mouseup事件dsfsdf sdfsdfsdfsdfsdfdsfds</span></span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动鼠标，同步移动父元素容器的内容</span></span><br><span class="line">    <span class="title function_">mouseMoveDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cursorDown</span> === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> prevPage = <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!prevPage) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// offset：点击位置到滑块容器顶部的距离</span></span><br><span class="line">      <span class="keyword">const</span> offset = ((</span><br><span class="line">        <span class="comment">// 1.滑块容器上边距离视窗上边距离：this.$el.getBoundingClientRect()[this.bar.direction]</span></span><br><span class="line">        <span class="comment">// 2.当前点击的纵轴坐标</span></span><br><span class="line">        <span class="comment">// 点击位置距离容器上边的长度 = 1 - 2</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">getBoundingClientRect</span>()[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">direction</span>] - e[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">client</span>]</span><br><span class="line">      ) * -<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 点击位置距离滑块上边的距离</span></span><br><span class="line">      <span class="keyword">const</span> thumbClickPosition = (</span><br><span class="line">        <span class="comment">// 1.this.$refs.thumb[this.bar.offset]：滑块高度</span></span><br><span class="line">        <span class="comment">// 2.prevPage：点击位置距离下边的距离</span></span><br><span class="line">        <span class="comment">// 点击位置距离滑块上边的距离 = 1 - 2</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">thumb</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>] - prevPage</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 计算“滑块上边到容器上边距离”占容器高度的百分比</span></span><br><span class="line">      <span class="keyword">const</span> thumbPositionPercentage = (</span><br><span class="line">        (</span><br><span class="line">          <span class="comment">// 计算滑块上边到容器上边的距离</span></span><br><span class="line">          offset - thumbClickPosition</span><br><span class="line">        ) * <span class="number">100</span> / <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">      );</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;计算滑块上边到容器上边的距离&#x27;</span>: offset - thumbClickPosition,</span><br><span class="line">        <span class="string">&#x27;容器的高度&#x27;</span>: <span class="variable language_">this</span>.<span class="property">$el</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">offset</span>]</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过thumbPositionPercentage计算夫容器移动的距离</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scroll</span>] = (thumbPositionPercentage * <span class="variable language_">this</span>.<span class="property">wrap</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">scrollSize</span>] / <span class="number">100</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mouseUpDocumentHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cursorDown</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">bar</span>.<span class="property">axis</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseMoveDocumentHandler</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onselectstart</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="variable language_">this</span>.<span class="property">mouseUpDocumentHandler</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Element-UI</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题目分析与解答</title>
    <url>/blog/resources/leetcode-algorithm-test/</url>
    <content><![CDATA[<p>在计算机科学和编程领域，算法是一项至关重要的核心技能。解决各种问题的高效算法可以极大地提升程序的性能和效率。而算法题目则是考察和锻炼这种技能的常见方式之一。</p>
<p>当我们面对算法题目时，可能会感到挑战和困惑。这些题目往往涉及复杂的逻辑、数据结构和数学原理，需要我们运用创造力和分析能力来找到最佳的解决方案。然而，正是这种挑战性使得算法题目如此令人着迷。</p>
<span id="more"></span>


<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> <code>nums = [2,7,11,15], target = 9</code><br><strong>输出：</strong> <code>[0,1]</code><br><strong>解释：</strong> 因为 <code>nums[0] + nums[1] == 9</code> ，返回 <code>[0, 1] </code>。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> <code>nums = [3,2,4], target = 6</code><br><strong>输出：</strong> <code>[1,2]</code></p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> <code>nums = [3,3], target = 6</code><br><strong>输出：</strong> <code>[0,1]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>核心思路是挑一个，找一个。</p>
<p>使用双重遍历。第一重遍历用于挑选元素，可以按索引逐步升序的方式遍历，每访问一个元素，即根据它算出与 target 的差，即为要在 nums 中寻找的元素，此时进行第二重遍历找前面提到的差。由于使用了双重遍历，可以预见时间复杂度为 O(n^2)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> v1 = nums[i];</span><br><span class="line">		<span class="keyword">const</span> v2 = target - v1;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.<span class="property">length</span> - <span class="number">1</span>; j += <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v2 === nums[j] &amp;&amp; i !== j) &#123;</span><br><span class="line">				<span class="keyword">return</span> [i, j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的暴力方法中可以再优化一下运算时间（虽然时间的复杂度不变）。<code>j</code> 其实可以不从 0 开始找，而是从 <code>i+1</code> 开始！因为在第一层遍历的前 <code>0</code>～<code>i-1</code> 轮中，索引为<code>i</code>的元素值已经与索引为<code>0</code>～<code>i-1</code>的元素值进行过比较。并且因为题目要求不可使用同一个元素，因此排除从 <code>j=i</code> 开始。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>双重遍历的时间复杂度是O(n^2)，要将时间复杂度降为 O(n)，可以简单理解为去掉一层循环。</p>
<p>使用哈希表，将 nums，以元素值为键名，索引为对应健名的元素值。这样即可去掉第二重遍历，在“挑”完一个元素后，即可在哈希表中确认是否存在目标值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> hashTable = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">ret, val, idx</span>) =&gt;</span> &#123;</span><br><span class="line">		ret[val] = idx;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> v1 = nums[i];</span><br><span class="line">		<span class="keyword">const</span> v2 = target - v1;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> hashTable[v2] !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; i !== j) &#123;</span><br><span class="line">			<span class="keyword">return</span> [i, j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶||"></a>变态跳台阶||</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpFloorII</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title function_">jumpFloorII</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看程序就知道，这个解法不是单纯依赖平常思维写的，<code>2 * jumpFloorII(n - 1)</code>这句代码明显就是个规律，所以就是找规律！</p>
<p>设有<code>f(n)，n=台阶数</code>为算出“跳上一个n级的台阶总共有多少种跳法”的函数。</p>
<p>只关心第一次跳多少个台阶，剩下的就交给这个<code>f(n)</code>来解决！<br>那么有n个台阶，第一次可以选择跳的台阶数就可以是1级，或2级，或3级，……，或n级。<br>当第一次跳1级时，那么剩下就有n-1级，那么剩下n-1级台阶就有f(n-1)种跳法；<br>当第一次跳2级时，那么剩下就有n-2级，那么剩下n-2级台阶就有f(n-2)种跳法；<br>当第一次跳3级时，那么剩下就有n-3级，那么剩下n-3级台阶就有f(n-3)种跳法；<br>……<br>当第一次跳n-1级时，那么剩下就有n-(n-1)级，那么剩下n-(n-1)级台阶就有f(n-(n-1))种跳法；<br>当第一次跳n级时，那么剩下就有n-n级，那么剩下n-n级台阶就有f(n-n)种跳法。</p>
<p>上面已经将“跳上一个n级的台阶总共有多少种跳法”这个问题做了拆分，拆分为：以第一次跳的级数作为分类，由上面的排比就知道分成了n类方式（是不是很熟悉，排列组合中<a href="https://baike.baidu.com/item/%E5%88%86%E7%B1%BB%E5%8A%A0%E6%B3%95%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/467166">分类加法计数原理</a>）。</p>
<p>显然将这n类方式的跳法加起来就是题目的问题，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span><br></pre></td></tr></table></figure>
<p>整理一下这个代数式就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1) + f(0)</span><br></pre></td></tr></table></figure>
<p>根据这个代数式，你可以推导出f(n-1)的代数式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n-1) = f(n-2) + f(n-3) + ... + f(1) + f(0)</span><br></pre></td></tr></table></figure>
<p>结合一下，就有最终的式子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-1) = 2 * f(n-1)</span><br></pre></td></tr></table></figure>
<p>到现在，只是知道代数关系，还是不知道f(n)这个函数的具体逻辑！但是有这个关系，就可以将问题向下转化！比如我们不知道f(2)等于多少，但是知道<code>f(2) = 2 * f(1)</code>，而f(1)是很轻松就可以知道的！<br>f(1)就是第一次跳了n-1级的台阶，剩下的台阶数就只有1级，显然就只有1种跳法，即<em>f(1) &#x3D; 1</em>!<br>然后就知道f(2) &#x3D; 2；这样就可以将所有未知转化为已知！</p>
<p>然后就有了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpFloorII</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title function_">jumpFloorII</span>(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:</p>
<p>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。<br>示例 4:</p>
<p>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:</p>
<p>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p>
<h2 id="1-暴力递归进行穷举"><a href="#1-暴力递归进行穷举" class="headerlink" title="1.暴力递归进行穷举"></a>1.暴力递归进行穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isMatchIt</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> s === <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> subMatch = s &amp;&amp; [s[<span class="number">0</span>], <span class="string">&#x27;.&#x27;</span>].<span class="title function_">includes</span>(p[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// *是需要和前面一个字符结合使用，即至少p的长度是2</span></span><br><span class="line">  <span class="keyword">if</span> (p.<span class="property">length</span> &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 匹配0次: isMatch(s, p.slice(2))，可以忽略s[0] !== p[0]，既然匹配0次，即可以跳过“p[0]*”的匹配</span></span><br><span class="line">    <span class="comment">// 2. 匹配多次，匹配多次的前提是[p[0], &#x27;.&#x27;].includes(s[0])</span></span><br><span class="line">    <span class="comment">// 2.1 通过后移s，而不动p，然后下一个s可以持续匹配&quot;p[0]*&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isMatch</span>(s, p.<span class="title function_">slice</span>(<span class="number">2</span>)) || subMatch &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subMatch &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p.<span class="title function_">slice</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-备忘录优化暴力法"><a href="#2-备忘录优化暴力法" class="headerlink" title="2.备忘录优化暴力法"></a>2.备忘录优化暴力法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isMatchByMemo</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sLen = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> pLen = p.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> meno = &#123;&#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dp</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">    <span class="comment">// [i, sLen)</span></span><br><span class="line">    <span class="comment">// [j, pLen)</span></span><br><span class="line">    <span class="keyword">const</span> key = [i, j].<span class="title function_">join</span>();</span><br><span class="line">    <span class="keyword">const</span> sRestLen = sLen - i;</span><br><span class="line">    <span class="keyword">const</span> pRestLen = pLen - j;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> meno[key] !== <span class="string">&#x27;undefined&#x27;</span>) <span class="keyword">return</span> meno[key];</span><br><span class="line">    <span class="keyword">if</span> (pRestLen &lt; <span class="number">1</span>) <span class="keyword">return</span> sRestLen &lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> isMatch = sRestLen &gt; <span class="number">0</span> &amp;&amp; (s[i] === p[j] || p[j] === <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pRestLen &gt; <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// j: p[j], j + 1: *</span></span><br><span class="line">      isMatch = <span class="title function_">dp</span>(i, j + <span class="number">2</span>) || isMatch &amp;&amp; <span class="title function_">dp</span>(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isMatch = isMatch &amp;&amp; <span class="title function_">dp</span>(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    meno[key] = isMatch;</span><br><span class="line">    <span class="keyword">return</span> isMatch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dp</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>


<p>例如:<br>给定的树 A:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   4 </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<p>输入：A &#x3D; [1,2,3], B &#x3D; [3,1]<br>输出：false<br>示例 2：</p>
<p>输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]<br>输出：true<br>限制：</p>
<p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a></p>
<h2 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题思路：</span></span><br><span class="line"><span class="comment"> * 1.先序遍历找到与B根节点匹配的A子节点或A的根节点subA，找到后暂停</span></span><br><span class="line"><span class="comment"> * 2.比较从B和subA的根节点开始比较，B是不是subA的子树</span></span><br><span class="line"><span class="comment"> * 3.如果2判断不是，则重复1、2直到遍历完A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubStructure = <span class="keyword">function</span>(<span class="params">A, B</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isSub = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">preOrder</span>(A);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">val</span> === B.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isSubOf</span>(node, B)) &#123;</span><br><span class="line">        isSub = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isSubOf</span>(<span class="params">sup, sub</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sub) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sup || sup.<span class="property">val</span> !== sub.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isSubOf</span>(sup.<span class="property">left</span>, sub.<span class="property">left</span>) &amp;&amp; <span class="title function_">isSubOf</span>(sup.<span class="property">right</span>, sub.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; matrix.length &lt;&#x3D; 100<br>0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100<br>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
<h2 id="1-缩小边界直到越界"><a href="#1-缩小边界直到越界" class="headerlink" title="1.缩小边界直到越界"></a>1.缩小边界直到越界</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *  [1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"> *  [5, 6, 7, 8],</span></span><br><span class="line"><span class="comment"> *  [9,10,11,12]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *  [(0,0), (0,1), (0,2), (0,3)],</span></span><br><span class="line"><span class="comment"> *  [(1,0), (1,1), (1,2), (1,3)],</span></span><br><span class="line"><span class="comment"> *  [(2,0), (2,1), (2,2), (2,3)],</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * 0.定义边界top, right, bottom, left. [top, bottom], [left, right]</span></span><br><span class="line"><span class="comment"> * 1.顺时针打印边界元素，每打印完一条边，将这条边的位置向中心步进1</span></span><br><span class="line"><span class="comment"> * 2.直到越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!matrix.<span class="property">length</span>) <span class="keyword">return</span> []; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历上边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[top][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[i][right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; --right) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历下边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; --bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历左边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(matrix[i][left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MinStack</span> minStack = <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">minStack.<span class="title function_">push</span>(-<span class="number">2</span>);</span><br><span class="line">minStack.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">minStack.<span class="title function_">push</span>(-<span class="number">3</span>);</span><br><span class="line">minStack.<span class="title function_">min</span>();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.<span class="title function_">pop</span>();</span><br><span class="line">minStack.<span class="title function_">top</span>();   --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.<span class="title function_">min</span>();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次
 </p>
<p>注意：本题与主站 155 题相同：<a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a></p>
<h2 id="双栈实现最小栈"><a href="#双栈实现最小栈" class="headerlink" title="双栈实现最小栈"></a>双栈实现最小栈</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双栈实现最小栈</span></span><br><span class="line"><span class="comment"> * 1._data保存数据 _data: 9, 10, 7, 11, 5</span></span><br><span class="line"><span class="comment"> * 2._min保存最小值 _min: 9, 7, 5</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.每次push的时候，在push到_data同时，如果新值比_min的最小值（栈顶元素）小就入栈_min，否则不入_min</span></span><br><span class="line"><span class="comment"> * 4.在pop的时候_data出栈，如果出栈的元素和_min栈顶元素相等，那么_min也出栈，因为这个最小值已经失效</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_min</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> || x &lt;= <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_min</span>.<span class="title function_">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tail = <span class="variable language_">this</span>.<span class="property">_data</span>[<span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (tail === <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_min</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>[len - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_min</span>[<span class="variable language_">this</span>.<span class="property">_min</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>示例 1：</p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。<br>注意：本题与主站 946 题相同：<a href="https://leetcode-cn.com/problems/validate-stack-sequences/">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
<h2 id="使用真实stack模拟"><a href="#使用真实stack模拟" class="headerlink" title="使用真实stack模拟"></a>使用真实stack模拟</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用真实stack模拟</span></span><br><span class="line"><span class="comment"> * 0.定义辅助栈stack</span></span><br><span class="line"><span class="comment"> * 1.持续按照pushed的顺序入栈stack，直到stack的栈顶元素与poped的栈底元素相同，</span></span><br><span class="line"><span class="comment"> * 2.则按照poped顺序出栈stack直到stack的栈顶元素不再与poped的栈低元素相同，然后重复1-&gt;2之道pushed的元素使用完</span></span><br><span class="line"><span class="comment"> * 3.如果poped不为空，则stack按照poped继续出栈，直到poped使用完返回true，否则返回false；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">pushed</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">popped</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = validateStackSequences2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateStackSequences1</span>(<span class="params">pushed, popped</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (pushed.<span class="property">length</span> || popped.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === popped[<span class="number">0</span>]) &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      popped.<span class="title function_">shift</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pushed.<span class="property">length</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(pushed.<span class="title function_">shift</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pushed.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== popped[<span class="number">0</span>]) &#123;</span><br><span class="line">      isValid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateStackSequences2</span>(<span class="params">pushed, popped</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;  <span class="comment">// pushed idx</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;  <span class="comment">// poped idx</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; pushed.<span class="property">length</span> || j &lt; popped.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] === popped[j]) &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pushed.<span class="property">length</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(pushed[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= pushed.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== popped[j]) &#123;</span><br><span class="line">      isValid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>示例: </p>
<p>你可以将以下二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>

<p>序列化为 “[1,2,3,null,null,4,5]”<br>注意：本题与主站 297 题相同：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p>
<h2 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h2><p>关键：</p>
<ol>
<li>将遍历的序列转化为字符串；</li>
<li>保留空子节点（可以保存为‘null’），作为标识符来反序列化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">preOrder</span>(root);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> res.<span class="title function_">push</span>(<span class="string">&#x27;null&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">join</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = data.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = arr.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="string">&#x27;null&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    node.<span class="property">left</span> = <span class="title function_">buildTree</span>(arr);</span><br><span class="line">    node.<span class="property">right</span> = <span class="title function_">buildTree</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">buildTree</span>(arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your functions will be called as such:</span></span><br><span class="line"><span class="comment"> * deserialize(serialize(root));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<p>输入：s &#x3D; “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
<h2 id="1-暴力穷举"><a href="#1-暴力穷举" class="headerlink" title="1.暴力穷举"></a>1.暴力穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(s, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">restStr, recordStr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!restStr.<span class="property">length</span> &amp;&amp; !res.<span class="title function_">includes</span>(recordStr)) res.<span class="title function_">push</span>(recordStr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; restStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> newRest = restStr.<span class="title function_">slice</span>(<span class="number">0</span>, i) + restStr.<span class="title function_">slice</span>(i + <span class="number">1</span>);</span><br><span class="line">      <span class="title function_">dfs</span>(newRest, recordStr + restStr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
 </p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p>
<p> </p>
<p>注意：本题与主站 169 题相同：<a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a></p>
<h2 id="1-Hash去重与计数"><a href="#1-Hash去重与计数" class="headerlink" title="1.Hash去重与计数"></a>1.Hash去重与计数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash去重与计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> halfLen = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[num]) &#123;</span><br><span class="line">      obj[num]++;</span><br><span class="line">      <span class="keyword">if</span> (obj[num] &gt; halfLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[num] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[num] &gt; halfLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p>
<p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：</p>
<p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]
 </p>
<p>限制：</p>
<p>最多会对 addNum、findMedia进行 50000 次调用。<br>注意：本题与主站 295 题相同：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p>
<h2 id="1-二分查找找插入位置"><a href="#1-二分查找找插入位置" class="headerlink" title="1.二分查找找插入位置"></a>1.二分查找找插入位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MedianFinder</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_stack</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addNum</span> = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="title function_">push</span>(num);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// [left, right)</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> midIdx = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="variable language_">this</span>.<span class="property">_stack</span>[midIdx]) &#123;</span><br><span class="line">      right = midIdx;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="variable language_">this</span>.<span class="property">_stack</span>[midIdx]) &#123;</span><br><span class="line">      right = midIdx;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = midIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="title function_">splice</span>(right, <span class="number">0</span>, num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">findMedian</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">_stack</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &amp; <span class="number">1</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_stack</span>[(len - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> right = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">_stack</span>[right-<span class="number">1</span>] + <span class="variable language_">this</span>.<span class="property">_stack</span>[right]) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MedianFinder()</span></span><br><span class="line"><span class="comment"> * obj.addNum(num)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.findMedian()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
<p>提示：</p>
<p>0 &lt;&#x3D; num &lt; 231</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
<h2 id="1-深度优遍历"><a href="#1-深度优遍历" class="headerlink" title="1.深度优遍历"></a>1.深度优遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum1 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">dfs</span>(num + <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">str, start</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= str.<span class="property">length</span>) <span class="keyword">return</span> ++count;</span><br><span class="line">    <span class="keyword">const</span> num1 = +(str[start]);</span><br><span class="line">    <span class="keyword">const</span> num2 = +(str[start] + str[start+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">dfs</span>(str, start + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; num2 &amp;&amp; num2 &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>(str, start + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i]：长度为i字符串的翻译方法数</span></span><br><span class="line"><span class="comment"> * 最优子结构：dp[i-1]:最后单字符翻译，dp[i-2]：最后双字符翻译</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i] = isValid(s[i-1]+s[i-2]) ? dp[i-1] + dp[i-2] : dp[i-1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum2 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">&#x27;_&#x27;</span> + num;</span><br><span class="line">  <span class="comment">// [0, pos)</span></span><br><span class="line">  <span class="keyword">let</span> dp1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = dp2;</span><br><span class="line">    <span class="keyword">const</span> num = str[i-<span class="number">2</span>] + str[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; +num &amp;&amp; +num &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      dp2 = dp2 + dp1;</span><br><span class="line">    &#125;</span><br><span class="line">    dp1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-动态规划（优化）"><a href="#3-动态规划（优化）" class="headerlink" title="3.动态规划（优化）"></a>3.动态规划（优化）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum3 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">&#x27;_&#x27;</span> + num;</span><br><span class="line">  <span class="comment">// [0, pos)</span></span><br><span class="line">  <span class="keyword">let</span> dp1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = dp2;</span><br><span class="line">    <span class="keyword">const</span> num = str[i-<span class="number">1</span>] + str[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> &lt; +num &amp;&amp; +num &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      dp2 = dp2 + dp1;</span><br><span class="line">    &#125;</span><br><span class="line">    dp1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:</p>
<p>输入: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 </p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt; grid.length &lt;= 200</span><br><span class="line">0 &lt; grid[0].length &lt;= 200</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<h2 id="1-深度优先遍历（超时）"><a href="#1-深度优先遍历（超时）" class="headerlink" title="1.深度优先遍历（超时）"></a>1.深度优先遍历（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxValue1 = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> n = grid[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j, count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; m || j &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    count += grid[i][j];</span><br><span class="line">    <span class="keyword">if</span> (i === m &amp;&amp; j === n) &#123;</span><br><span class="line">      res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, count);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// to right</span></span><br><span class="line">    <span class="title function_">dfs</span>(grid, i, j + <span class="number">1</span>, count);</span><br><span class="line">    <span class="comment">// to bottom</span></span><br><span class="line">    <span class="title function_">dfs</span>(grid, i + <span class="number">1</span>, j, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划-1"><a href="#2-动态规划-1" class="headerlink" title="2.动态规划"></a>2.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i][j]：到达(i,j)位置的最大价值</span></span><br><span class="line"><span class="comment"> * 最优子结构：</span></span><br><span class="line"><span class="comment"> * 1.从上方移动一步到达，dp[i][j-1] + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 2.从左边移动一步到达，dp[i-1][j] + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]) + grid[i][j]</span></span><br><span class="line"><span class="comment"> * 边界：dp[0][0] = grid[0][0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxValue2 = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> n = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>();</span><br><span class="line">  dp = dp.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub1 = i &lt; <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">const</span> sub2 = j &lt; <span class="number">1</span> ? <span class="number">0</span> :dp[i][j-<span class="number">1</span>];</span><br><span class="line">      dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(sub1, sub2) + grid[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。
 </p>
<p>提示：</p>
<p>s.length &lt;&#x3D; 40000<br>注意：本题与主站 3 题相同：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1.滑动窗口"></a>1.滑动窗口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable language_">window</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = s[idx];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="title function_">includes</span>(char) &amp;&amp; idx &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span> += char;</span><br><span class="line">      idx++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, <span class="variable language_">window</span>.<span class="property">length</span>);</span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= s.<span class="property">length</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="variable language_">window</span> = <span class="variable language_">window</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<p>输入: n &#x3D; 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p>
<p>1 是丑数。<br>n 不超过1690。<br>注意：本题与主站 264 题相同：<a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p>
<p>通过次数7,052提交次数11,250</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * dp[i]: 第i个丑数</span></span><br><span class="line"><span class="comment"> * 最优子结构: 左前最靠近i的因子为2的丑数dp[a], 左前最靠近i的因子为3的丑数dp[b]，左前最靠近i的因子为5的丑数dp[c]</span></span><br><span class="line"><span class="comment"> * dp[i]是丑数，所以肯定是dp[c] * 2或dp[b] * 2或dp[c] * 5得到，当前是要找下一个丑数，所以肯定是取前三者最小之一</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[i] = Math.min(dp[i-1] * 2, dp[i-1] * 3. dp[i-1] * 5)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ugly1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> ugly2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> ugly3 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (count &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp1 = dp[ugly1] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp2 = dp[ugly2] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp3 = dp[ugly3] * <span class="number">5</span>;</span><br><span class="line">    dp[count] = <span class="title class_">Math</span>.<span class="title function_">min</span>(tmp1, tmp2, tmp3);</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp1) ugly1++;</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp2) ugly2++;</span><br><span class="line">    <span class="keyword">if</span> (dp[count] === tmp3) ugly3++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<p>示例:</p>
<p>s &#x3D; “abaccdeff”<br>返回 “b”</p>
<p>s &#x3D; “”<br>返回 “ “
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a></p>
<h2 id="Hash表记录"><a href="#Hash表记录" class="headerlink" title="Hash表记录"></a>Hash表记录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">character</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> charMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    charMap[s[i]] = charMap[s[i]] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> charMap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charMap[key] === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例 1:</p>
<p>输入: [7,5,6,4]<br>输出: 5
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a></p>
<h2 id="1-暴力双迭代（超时）"><a href="#1-暴力双迭代（超时）" class="headerlink" title="1.暴力双迭代（超时）"></a>1.暴力双迭代（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力双迭代，时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePairs1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在使用归并排序时，拆分的过程是不会打乱数组，</span></span><br><span class="line"><span class="comment"> * 使用归并排序成左小右大的时，会先将拆分出的两个数组中小的一个进入临时数组</span></span><br><span class="line"><span class="comment"> * 在添加左数组进入临时数组时，假如在此前右数组已经添加了一部分元素进临时数组，说明这些元素是</span></span><br><span class="line"><span class="comment"> * 比当前要添加临时数组的左数组元素要小，又因为这些元素在右数组中，说明这些元素在原数组中是在当前左元素后面的，</span></span><br><span class="line"><span class="comment"> * 换言之，这些元素可以与当前左数组元素可以构成逆序对，那么会构成多少个呢？</span></span><br><span class="line"><span class="comment"> * 只需要统计一下目前右数组已经添加了多少个元素到临时数组就好！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePairs2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">numArr, left, right</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right - left === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [numArr[left]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> leftArr = <span class="title function_">mergeSort</span>(numArr, left, mid);</span><br><span class="line">    <span class="keyword">const</span> rightArr = <span class="title function_">mergeSort</span>(numArr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(leftArr, rightArr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArr, rightArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    <span class="keyword">let</span> lIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lIdx &lt; leftArr.<span class="property">length</span> &amp;&amp; rIdx &lt; rightArr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意这里要加上等号</span></span><br><span class="line">      <span class="comment">// 因为相同的值不算逆序对，没有等号时，就是将right中的元素添加到tmp中，rIdx就会步进，</span></span><br><span class="line">      <span class="comment">// 相当于相同值也算进了逆序对</span></span><br><span class="line">      <span class="keyword">if</span> (leftArr[lIdx] &lt;= rightArr[rIdx]) &#123;</span><br><span class="line">        tmp.<span class="title function_">push</span>(leftArr[lIdx]);</span><br><span class="line">        lIdx++;</span><br><span class="line">        count += rIdx</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp.<span class="title function_">push</span>(rightArr[rIdx]);</span><br><span class="line">        rIdx++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lIdx &lt; leftArr.<span class="property">length</span>) &#123;</span><br><span class="line">      tmp.<span class="title function_">push</span>(leftArr[lIdx]);</span><br><span class="line">      lIdx++;</span><br><span class="line">      count += rIdx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rIdx &lt; rightArr.<span class="property">length</span>) &#123;</span><br><span class="line">      tmp.<span class="title function_">push</span>(rightArr[rIdx]);</span><br><span class="line">      rIdx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src="160_statement.png"></p>
<p>在节点 c1 开始相交。</p>


<p>示例 1：</p>
<p><img src="160_example_1.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：</p>
<p><img src="160_example_2.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：</p>
<p><img src="160_example_3.png" alt="img"></p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<h2 id="计算长短链表差值"><a href="#计算长短链表差值" class="headerlink" title="计算长短链表差值"></a>计算长短链表差值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.遍历headA, headB，分别计算长度countA, countB</span></span><br><span class="line"><span class="comment"> * 2.根据countA, countB判断长链表long和短链表short，相差长度k</span></span><br><span class="line"><span class="comment"> * 3.让long先步进k步，然后long和short一起步进，直到long.next和short.next相等就break, long或short就是公共节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (headA === headB) <span class="keyword">return</span> headA;</span><br><span class="line">  <span class="keyword">let</span> curA = headA;</span><br><span class="line">  <span class="keyword">let</span> curB = headB;</span><br><span class="line">  <span class="keyword">let</span> countA = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> countB = <span class="number">0</span>;  </span><br><span class="line">  <span class="comment">// 计算A链表和B链表的长度</span></span><br><span class="line">  <span class="keyword">while</span> (curA.<span class="property">next</span> || curB.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curA.<span class="property">next</span>) &#123;</span><br><span class="line">      countA++;</span><br><span class="line">      curA = curA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curB.<span class="property">next</span>) &#123;</span><br><span class="line">      countB++;</span><br><span class="line">      curB = curB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (curA !== curB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> long;</span><br><span class="line">  <span class="keyword">let</span> short;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">if</span> (countB &gt; countA) &#123;</span><br><span class="line">    long = headB;</span><br><span class="line">    short = headA;</span><br><span class="line">    k = countB - countA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    long = headA;</span><br><span class="line">    short = headB;</span><br><span class="line">    k = countA - countB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (long) &#123;</span><br><span class="line">    long = long.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (k) &#123;</span><br><span class="line">      k--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      short = short.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (long === short) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> long;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="II-0～n-1中缺失的数字"><a href="#II-0～n-1中缺失的数字" class="headerlink" title="II. 0～n-1中缺失的数字"></a>II. 0～n-1中缺失的数字</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 注意点：每个数字都在范围0～n-1之内，最大值不超过n，所以若给的nums是一个递增无缺少的序列，则是缺少n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nums[mid] !== mid</span><br><span class="line">      &amp;&amp; (nums[mid - <span class="number">1</span>] === mid - <span class="number">1</span> || nums[mid - <span class="number">1</span>] === <span class="literal">undefined</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === mid) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="II-平衡二叉树"><a href="#II-平衡二叉树" class="headerlink" title="II. 平衡二叉树"></a>II. 平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 false 。</p>
<p> </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000<br>注意：本题与主站 110 题相同：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof</a></p>
<h2 id="1-深度优先遍历（后序）"><a href="#1-深度优先遍历（后序）" class="headerlink" title="1.深度优先遍历（后序）"></a>1.深度优先遍历（后序）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先（后序递归遍历）计算左右子树的深度</span></span><br><span class="line"><span class="comment"> * 判断左右子树深度差是否超过1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced1 = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">dfs</span>(root);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> lDeep = <span class="title function_">dfs</span>(node.<span class="property">left</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> rDeep = <span class="title function_">dfs</span>(node.<span class="property">right</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(lDeep - rDeep) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      res = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(lDeep, rDeep);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isBalanced = isBalanced1;</span><br></pre></td></tr></table></figure>

<h1 id="II-数组中数字出现的次数-II"><a href="#II-数组中数字出现的次数-II" class="headerlink" title="II. 数组中数字出现的次数 II"></a>II. 数组中数字出现的次数 II</h1><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,4,3,3]<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [9,1,7,9,7,9,7]<br>输出：1
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10000<br>1 &lt;&#x3D; nums[i] &lt; 2^31</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</a></p>
<h2 id="1-Hash表去重"><a href="#1-Hash表去重" class="headerlink" title="1.Hash表去重"></a>1.Hash表去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumberHash = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> record = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!record[num]) &#123;</span><br><span class="line">      record[num] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      record[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> record) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record[key] === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算计算目标数"><a href="#2-位运算计算目标数" class="headerlink" title="2.位运算计算目标数"></a>2.位运算计算目标数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算目标数的二进制上的每一位（0/1），注意是计算出，不是过滤出的</span></span><br><span class="line"><span class="comment"> * 1.使用2的冥值去探测各个二进制位上的情况，设要找的书是tar，设nums中，二进制第i位上的值是1的数有k个，k肯定是满足：</span></span><br><span class="line"><span class="comment"> * 1.1 当tar的二进制的第i位是1,则k=3n+1, (n = 0, 1, ..., nums,length)</span></span><br><span class="line"><span class="comment"> * 1.2 当tar的二进制的第i位是0,则k=3n, (n = 0, 1, ..., nums,length)</span></span><br><span class="line"><span class="comment"> * 2.根据1.1和1.2就可以去探测tar每一位具体是0还是1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumberBit1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tar = [];</span><br><span class="line">  <span class="comment">// 题目指出：1 &lt;= nums[i] &lt; 2^31</span></span><br><span class="line">  <span class="comment">// bit是由1左移得到，所以最多可以移30位，因为第一次是移动0位，所以可以遍历31次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// bit:</span></span><br><span class="line">    <span class="comment">// i= 0: 1</span></span><br><span class="line">    <span class="comment">// i= 1: 10</span></span><br><span class="line">    <span class="comment">// i= 2: 100</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((num &amp; bit) !== <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count % 3 !== 0, 说明tar左起第i位是</span></span><br><span class="line">    tar.<span class="title function_">unshift</span>(count % <span class="number">3</span> !== <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="built_in">parseInt</span>(tar.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>), <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-完全位运算"><a href="#3-完全位运算" class="headerlink" title="3.完全位运算"></a>3.完全位运算</h2><p>与“2.位运算计算目标数”不同，不是使用记录目标书二进制情况，而是使用按位或直接计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count % <span class="number">3</span> !== <span class="number">0</span>) tar = tar | bit;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumberBit2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tar = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 题目指出：1 &lt;= nums[i] &lt; 2^31</span></span><br><span class="line">  <span class="comment">// bit是由1左移得到，所以最多可以移30位，因为第一次是移动0位，所以可以遍历31次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((num &amp; bit) !== <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |:按位或，只要同一位不为0都得1</span></span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">3</span> !== <span class="number">0</span>) tar = tar | bit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="II-和为s的连续正数序列"><a href="#II-和为s的连续正数序列" class="headerlink" title="II. 和为s的连续正数序列"></a>II. 和为s的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
 </p>
<p>示例 1：</p>
<p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p>
<p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; target &lt;&#x3D; 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a></p>
<h2 id="使用滑动窗口（双指针变种）"><a href="#使用滑动窗口（双指针变种）" class="headerlink" title="使用滑动窗口（双指针变种）"></a>使用滑动窗口（双指针变种）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用滑动窗口（双指针变种）</span></span><br><span class="line"><span class="comment"> * idx向右移动，同时累加当前总数sum，win入栈idx，直到sum大于或等于target</span></span><br><span class="line"><span class="comment"> * 1.当sum等于target，则保存win副本，然后继续右移idx</span></span><br><span class="line"><span class="comment"> * 2.当sum大于target，则出队win头元素tmp，并sum -= tmp（相当于右移win的边界）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> win = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(target / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (idx &lt;= max) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">      sum += idx;</span><br><span class="line">      win.<span class="title function_">push</span>(idx);</span><br><span class="line">      idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">      sum -= win.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(win.<span class="title function_">slice</span>(<span class="number">0</span>));</span><br><span class="line">      sum -= win.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="I-翻转单词顺序"><a href="#I-翻转单词顺序" class="headerlink" title="I. 翻转单词顺序"></a>I. 翻转单词顺序</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 </p>
<p>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>注意：本题与主站 151 题相同：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p>
<p>注意：此题对比原题有改动</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a></p>
<h2 id="1-滑动窗口-双指针"><a href="#1-滑动窗口-双指针" class="headerlink" title="1.滑动窗口+双指针"></a>1.滑动窗口+双指针</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口+双指针</span></span><br><span class="line"><span class="comment"> * 1.使用滑动窗口取出每个单词</span></span><br><span class="line"><span class="comment"> * 2.双指针，left=0, right=len-1，同时向中间偏移同时交换元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isSpace</span> = (<span class="params">val</span>) =&gt; [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>].<span class="title function_">includes</span>(val); </span><br><span class="line">  <span class="keyword">const</span> wordArr = [];</span><br><span class="line">  <span class="comment">// [left. right)</span></span><br><span class="line">  <span class="keyword">while</span> (right &lt;= s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="title function_">isSpace</span>(s[left])</span><br><span class="line">      &amp;&amp; !<span class="title function_">isSpace</span>(s[right - <span class="number">1</span>])</span><br><span class="line">      &amp;&amp; <span class="title function_">isSpace</span>(s[right] || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      wordArr.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(left, right));</span><br><span class="line">      left = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSpace</span>(s[left])) left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  left = <span class="number">0</span>;</span><br><span class="line">  right = wordArr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = wordArr[left];</span><br><span class="line">    wordArr[left] = wordArr[right];</span><br><span class="line">    wordArr[right] = tmp;</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wordArr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="II-左旋转字符串"><a href="#II-左旋转字符串" class="headerlink" title="II. 左旋转字符串"></a>II. 左旋转字符串</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a></p>
<h2 id="1-简单切片"><a href="#1-简单切片" class="headerlink" title="1.简单切片"></a>1.简单切片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = reverseLeftWords2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseLeftWords1</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">slice</span>(n) + s.<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符拼接"><a href="#2-字符拼接" class="headerlink" title="2.字符拼接"></a>2.字符拼接</h2><p>拼接比起数组保存后拼接要快……</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseLeftWords2</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    res += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="I-滑动窗口的最大值"><a href="#I-滑动窗口的最大值" class="headerlink" title="I. 滑动窗口的最大值"></a>I. 滑动窗口的最大值</h1><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  滑动窗口的位置                 最大值</span><br><span class="line">---------------               -------</span><br><span class="line">[</span><br><span class="line">  1  3  -1] -3  5  3  6  7       3</span><br><span class="line">  1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line">  1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line">  1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line">  1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line">  1  3  -1  -3  5 [3  6  7       7</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a></p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = k - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (right &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// [left, right]</span></span><br><span class="line">    <span class="keyword">let</span> max = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(max);</span><br><span class="line">    left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res= [];</span><br><span class="line">  <span class="keyword">let</span> curMaxNumIdx;</span><br><span class="line">  <span class="keyword">const</span> deQueue = <span class="keyword">new</span> <span class="title class_">DeQueue</span>(nums, k);</span><br><span class="line"></span><br><span class="line">  curMaxNumIdx = deQueue.<span class="title function_">getLeftHead</span>();</span><br><span class="line">  res.<span class="title function_">push</span>(nums[curMaxNumIdx]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    deQueue.<span class="title function_">push</span>(i);</span><br><span class="line">    curMaxNumIdx = deQueue.<span class="title function_">getLeftHead</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(nums[curMaxNumIdx]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护一个队列，成员是nums中元素的idx，并且这些idx都是当前</span></span><br><span class="line"><span class="comment"> * 并且这些idx都是在滑动中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DeQueue</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_queue</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_nums</span> = nums;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_k</span> = k;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">idx</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_clean</span>(idx);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">push</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getLeftHead</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">_k</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DeQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_clean</span> = <span class="keyword">function</span>(<span class="params">idx</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queueLen = <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> leftHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> minValidIdx = idx + <span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">_k</span>;</span><br><span class="line">  <span class="comment">// 队列为空，不需要清理无用元素</span></span><br><span class="line">  <span class="keyword">if</span> (!queueLen) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ps: 每次调用_clean只会调用一次</span></span><br><span class="line">  <span class="comment">// 当前滑动窗口中index的取值范围是：[minValidIdx, idx]</span></span><br><span class="line">  <span class="comment">// 如果deQueue的中的元素已经不再取值范围内就已经无用，出队清理掉</span></span><br><span class="line">  <span class="keyword">if</span> (leftHead &lt; minValidIdx) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PS: 调用多次更新序列</span></span><br><span class="line">  <span class="comment">// 背景：nums[idx]将会进入deQueue，现在这里的逻辑是在入队新元素前的整理工作</span></span><br><span class="line">  <span class="comment">// deQueue中的元素要求是：一个由大到小的有序列</span></span><br><span class="line">  <span class="comment">// 如果队尾（队列中最小）元素指向的nums的真实值比nums[idx]还小，那就没用，要清理掉</span></span><br><span class="line">  <span class="keyword">let</span> rightHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_nums</span>[idx] &gt;= <span class="variable language_">this</span>.<span class="property">_nums</span>[rightHead]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">    rightHead = <span class="variable language_">this</span>.<span class="property">_queue</span>[<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="II-队列的最大值"><a href="#II-队列的最大值" class="headerlink" title="II. 队列的最大值"></a>II. 队列的最大值</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000<br>1 &lt;&#x3D; value &lt;&#x3D; 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p>
<h2 id="辅助双端队列"><a href="#辅助双端队列" class="headerlink" title="辅助双端队列"></a>辅助双端队列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助双端队列</span></span><br><span class="line"><span class="comment"> * 1._data队列正常对数据进行入队出队</span></span><br><span class="line"><span class="comment"> * 2._max是一个双端队列。每次_data入队元素，_max如下操作：</span></span><br><span class="line"><span class="comment"> * 2.1 当_max空，如对元素</span></span><br><span class="line"><span class="comment"> * 2.2 当_max非空，新数据value从右侧入队，入队前需要将右侧所有比value小的从右侧出队再入队。</span></span><br><span class="line"><span class="comment"> * 为什么？为了位置一个左到右递减的数列，这样才能维持_max每次从左侧出队的都是最大元素</span></span><br><span class="line"><span class="comment"> * 3.当出队_data元素value时，若_max的队头元素与value相等，则也出队_max的队头。为什么？因为value已经出队无效了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MaxQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_max</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max_value</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push_back</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span> &amp;&amp; value &gt; <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="variable language_">this</span>.<span class="property">_max</span>.<span class="property">length</span>-<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">push</span>(value);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MaxQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop_front</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="variable language_">this</span>.<span class="property">_max</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_max</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MaxQueue()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"> * obj.push_back(value)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.pop_front()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h1><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:</p>
<p>输入: 1<br>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<br>示例 2:</p>
<p>输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 11</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof</a></p>
<h2 id="1-动态规划穷举"><a href="#1-动态规划穷举" class="headerlink" title="1.动态规划穷举"></a>1.动态规划穷举</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态：dp[n][i]:掷出第n个骰子，总点数是i的所有次数</span></span><br><span class="line"><span class="comment"> * 最优子结构：每枚骰子6个点数，dp[n][i]的次数可以由 dp[n-1][i-1] + 1或dp[n-1][i-2] + 2或...或dp[n-1][i-6] + 6构成</span></span><br><span class="line"><span class="comment"> * 状态转移方程：dp[n][i] = sum(dp[n-1][i-j]), 1 &lt;= j &lt;= 6</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = twoSumDp2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSumDp1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>();</span><br><span class="line">  dp = dp.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">7</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;=  <span class="number">6</span>; i++) &#123;</span><br><span class="line">    dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dpCount</span>(n);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> all = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt;= n * <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dp[n][i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">const</span> tmp = dp[n][i] / all;</span><br><span class="line">    res.<span class="title function_">push</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dpCount</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= i * <span class="number">6</span>; j++) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j - num &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">const</span> sub = dp[i - <span class="number">1</span>][j - num] || <span class="number">0</span>;</span><br><span class="line">          dp[i][j] += sub;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-优化动态规划"><a href="#2-优化动态规划" class="headerlink" title="2.优化动态规划"></a>2.优化动态规划</h2><p>使用一个长度是2的二维数值存储dp元素，因为计算<code>dp[i][j]</code>只是依赖<code>dp[i - 1][j - num]</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twoSumDp2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], []];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dpCount</span>(n);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> all = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt;= n * <span class="number">6</span>; i++) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(dp[<span class="number">0</span>][i] / all);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dpCount</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= i * <span class="number">6</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j - num &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          dp[<span class="number">1</span>][j] += dp[<span class="number">0</span>][j - num] || <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>] = [];</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h1><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5]<br>输出: True
 </p>
<p>示例 2:</p>
<p>输入: [0,0,1,2,5]<br>输出: True
 </p>
<p>限制：</p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p>
<h2 id="1-找最大最小值"><a href="#1-找最大最小值" class="headerlink" title="1.找最大最小值"></a>1.找最大最小值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.连续序列的特点：max - min + 1 = 序列长度，由于0可以变化，所以max - min + 1 &lt;- 序列长度</span></span><br><span class="line"><span class="comment"> * 2.如果存在重复，则不是顺子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isStraight = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">14</span></span><br><span class="line">  <span class="keyword">let</span> max = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> repeated = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums[i]) <span class="keyword">continue</span>; </span><br><span class="line">    min = <span class="title class_">Math</span>.<span class="title function_">min</span>(min, nums[i]);</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (!repeated.<span class="title function_">includes</span>(nums[i])) &#123;</span><br><span class="line">      repeated.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max - min + <span class="number">1</span> &gt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h1><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：</p>
<p>输入: n &#x3D; 5, m &#x3D; 3<br>输出: 3<br>示例 2：</p>
<p>输入: n &#x3D; 10, m &#x3D; 17<br>输出: 2</p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 10^5<br>1 &lt;&#x3D; m &lt;&#x3D; 10^6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a></p>
<h2 id="1-暴力模拟（超时）"><a href="#1-暴力模拟（超时）" class="headerlink" title="1.暴力模拟（超时）"></a>1.暴力模拟（超时）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastRemaining = lastRemaining2;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining1</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">getIdx</span> = (<span class="params">idx</span>) =&gt; idx % n;</span><br><span class="line">  <span class="keyword">const</span> record = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!record[num]) idx++;</span><br><span class="line">    <span class="comment">// console.log(num, idx, record)</span></span><br><span class="line">    <span class="keyword">if</span> (!record[num] &amp;&amp; idx &gt; <span class="number">0</span> &amp;&amp; idx % m === <span class="number">0</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">// console.log(&#123;count, n&#125;)</span></span><br><span class="line">      record[num] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span> num;</span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="title function_">getIdx</span>(num + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-约瑟夫自杀环"><a href="#2-约瑟夫自杀环" class="headerlink" title="2.约瑟夫自杀环"></a>2.约瑟夫自杀环</h2><p><img src="2020-04-16_17-00.png" alt="2020-04-16_17-00"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * f(x)：最后输出的序号</span></span><br><span class="line"><span class="comment"> * f(n, m) = (f(n - 1, m) + m)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining2</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">josephus</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="title function_">josephus</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">josephus</span>(n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-迭代优化约瑟夫问题"><a href="#3-迭代优化约瑟夫问题" class="headerlink" title="3.迭代优化约瑟夫问题"></a>3.迭代优化约瑟夫问题</h2><p>避免使用递归栈空间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining3</span>(<span class="params">n, m</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = (res + m) % i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。
 </p>
<p>注意：本题与主站 8 题相同：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p>
<h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strToInt1 = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> matched = str.<span class="title function_">match</span>(<span class="regexp">/^\s*([-|+]?\d+).*$/</span>);</span><br><span class="line">  <span class="keyword">if</span> (!matched) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">let</span> num = +matched[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">if</span> (num &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; min) <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-线性遍历"><a href="#2-线性遍历" class="headerlink" title="2.线性遍历"></a>2.线性遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strToInt2 = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sign;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        res += str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[i] === <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        res += str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>].<span class="title function_">includes</span>(str[i])) &#123;</span><br><span class="line">        sign = str[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = sign === <span class="string">&#x27;-&#x27;</span> ? -res : res;</span><br><span class="line">  <span class="keyword">if</span> (res &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">  <span class="keyword">if</span> (res &lt; min) <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></p>
<h2 id="1-深度优先（比较隐含的回溯）"><a href="#1-深度优先（比较隐含的回溯）" class="headerlink" title="1.深度优先（比较隐含的回溯）"></a>1.深度优先（比较隐含的回溯）</h2><p>由于传入下一层调用栈的参数都是新值，不会影响当前栈所以不用显式地回溯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute1 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(nums, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">nums, visited</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      visited.<span class="title function_">push</span>(nums[<span class="number">0</span>]);</span><br><span class="line">      res.<span class="title function_">push</span>(visited);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>([...nums.<span class="title function_">slice</span>(<span class="number">0</span>, i), ...nums.<span class="title function_">slice</span>(i + <span class="number">1</span>)], [nums[i], ...visited]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-显式的回溯"><a href="#2-显式的回溯" class="headerlink" title="2.显式的回溯"></a>2.显式的回溯</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute2 = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// [left, right]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">dfs</span>(nums, [], &#123;&#125;, res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">nums, path, visited, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(path.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">        <span class="title function_">dfs</span>(nums, path, visited, res);</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">        path.<span class="title function_">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法题</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript创建对象的多种模式</title>
    <url>/blog/resources/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>工厂模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> o.<span class="property">name</span> = name;</span><br><span class="line"> o.<span class="property">age</span> = age</span><br><span class="line"> o.<span class="property">job</span> = job;</span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>工作模式是通过一个函数返回一个对象，但是有个问题是：新建对象实例和普通的调用函数没有辨识度。</p>
</blockquote>
<ul>
<li>构造函数模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>和工厂模式相比，构造函数模式，没有显示地创建对象，并返回，而是直接将属性和“静态“方法赋值给this对象。使用new操作符新建实例，this对象引用的是以Person对象为模板的新对象。</li>
</ul>
</blockquote>
<ul>
<li>使用new操作符这种方式调用构造函数，实际上是经历了下面四个步骤：</li>
</ul>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋值给新对象（因此this对象引用的是新对象，而不是原型对象）；</li>
<li>执行构造函数的代码；</li>
<li>返回这个新对象。</li>
</ol>
<blockquote>
<p><em>上面的工厂模式也是经历的这几个步骤，不过工厂模式是在构造函数中使用new操作符新建对象实例。</em></p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>使用构造函数模式，解决了“标识函数和类型”的问题，但是如果在构造函数内部新建函数就会有个问题：<br><strong>在实例person1和person2中都sayName函数，虽然功能相同，<br>但是他们却是开辟了两个空间，新建了两个函数，因为他们各自在不同的作用域中。</strong><br>避免重复新建同样功能函数，避免冗余可以这样做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做也带来一个新的问题：<br><em><em>为了避免同功能函数的冗余，然后我们把这些”静态函数”都放在了全局作用域中，而在新对象中进行引用。但是一旦函数多起来，封装性就会失去，一堆函数在全局作用域，这样也污染全局作用域。我自己的一个折中的做法是：用“+function(){ &#x2F;*代码</em>&#x2F; }()”包裹。js提供另外一种方法：<em>原型模式</em></em>*</p>
<ul>
<li>原型模式</li>
</ul>
<blockquote>
<p>构造函数会有一个prototype属性，他存放的是一个指针，指向原型对象，实例也是有个功能相同的内部属性[[prototype]] &#x2F; __proto__(__proto__属性只在FireFox、chrome、Safari得到支持)指向原型对象，而原型对象中则有一个属性，constructor，他指向构造函数，而prototype是原型模式的核心：</p>
</blockquote>
<ul>
<li>prototype &#x2F; [[prototype]]，该属性存放的是一个指针，指向原型对象；</li>
<li>原型对象的属性：constructor，该属性存放的是一个指针，指向构造函数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;issac&#x27;</span>;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><strong>更简单的原型语法</strong></p>
<blockquote>
<p>将对象赋值给prototype属性，即使用字面量的方法简写为：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样虽然可以很好的简写，但要注意的一点是，这样做相当于重写了原型对象，constructor不再指向Person，而是指向Object构造函数。如果要使用到这个属性，就要手动将constructor指向Person</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样做，也并非和默认获得的constructor属性相同，因为该属性是手动添加的，那么内部属性[[Enumerable]]是默认为true的，而默认获得的constructor的枚举是false的。可以使用defineProperty方法设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property">proptotype</span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: fase,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>只用原型模式的问题</li>
</ul>
<p><strong>原型模式最大的问题是由他的共享性引起，在属性还是基本类型的时候还没有什么问题，但如果是引用类型，问题就很明显了。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;issac&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arr</span> = [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;iron&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;man&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">arr</span>);  <span class="comment">//[&#x27;issac&#x27;, &#x27;is&#x27;, &#x27;iron&#x27;, &#x27;man&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">arr</span>);  <span class="comment">//[&#x27;issac&#x27;, &#x27;is&#x27;, &#x27;iron&#x27;, &#x27;man&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果一开始就是打算共享这个数组还好说，但是更多时候这种情况是希望每个对象实例拥有独立的数组。这也是，比较少单独使用原型模式的原因。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<ul>
<li>小插曲：实例对象中建立和原型对象属性同名的属性，会屏蔽原型对象的属性，就算将实例对象中的同名属性赋值为null也不能取消屏蔽，但是可以使用 delete 操作符 删除实例对象中的同名属性，可以重新访问到原型对象中的同名属性。<br>&nbsp;</li>
<li>hasOwnProperty可以用来判断属性是不是属于实例对象</li>
</ul>
</blockquote>
<ul>
<li>组合原型模式和构造函数模式</li>
</ul>
<blockquote>
<p>从上面的构造函数模式和原型模式，可以知道，构造函数模式，定义的属性和方法是非共享的，在新建对象实例时复制了一份属性副本(没有必要在这里定义方法，因为方法功能一样，不必给每个实例分配一个副本，这是冗余，浪费内存)，都是独立的；而用原型模式构造的属性和方法是共享的，每个属性调用的原型属性和方法都是共享的，相当于静态的属性&#x2F;方法。<br>结合这两个特点，可以以构造函数模式定义实例属性&#x2F;方法（非共享），以原型模式定义静态方法&#x2F;属性（共享）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造实例属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">not_share</span> = [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;frank&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态的共享属性/方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">share</span>: [<span class="string">&#x27;issac&#x27;</span>, <span class="string">&#x27;person&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">p1.<span class="property">share</span>.<span class="title function_">push</span>(<span class="string">&#x27;dube&#x27;</span>);</span><br><span class="line">p1.<span class="property">not_share</span>.<span class="title function_">push</span>(<span class="string">&#x27;dube&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">not_share</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">not_share</span>);</span><br></pre></td></tr></table></figure>

<img src="2838289-cbf09eba34a5fef8.png" alt="JavaScript创建对象的多种模式">

<ul>
<li>寄生构造函数模式</li>
</ul>
<p><strong>个人是认为这种模式适合用在原生对象上进行扩展，这样也很适合“寄生”这一词。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给Array添加一个特殊的方法，但是有不污染Array对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>);</span><br><span class="line">  values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">toPipedString</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个小插曲，也是写到这里才知道，函数可以不写形参，而直接从arguments对象（数组）中获取实参。</p>
</blockquote>
<img src="2838289-f07fc44919e0c0f6.png" alt="JavaScript创建对象的多种模式">


<ul>
<li>小结：主要介绍了以下五种创建对象的模式。</li>
</ul>
<ol>
<li>工厂模式;</li>
<li>构造函数模式；</li>
<li>原型模式；</li>
<li>组合原型模式和构造函数模式；</li>
<li>寄生构造函数模式；</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript函数提升和变量的声明提前</title>
    <url>/blog/resources/javascript%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>把他们两个概念放在一起说，并不是因为他们有多大关联，只是因为他们都会被“提前”。</p>
<span id="more"></span>

<h1 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h1><p>函数提升，比较好理解，基本就是js的运行规则了，记住就好。就是无论函数被定义在上下问那个位置，都会在代码执行前优先定义。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="2838289-b42e2aadee7b912f.png" alt="javascript函数提升和变量的声明提前">

<p>上面的例子是可以执行的，不会报错，会正常输出“issac”。虽然上面说到上下文的任何位置，但是这个任何位置是指同一个执行环境，怎么才叫同一个执行环境？比如说下面的例子就会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fnCreat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fnCreate</span>();</span><br></pre></td></tr></table></figure>

<p>为什么会报错？fn函数执行的执行环境，和fn定义的执行环境已经不同，每个函数都创建一个执行环境，自身的执行环境，外部环境对其是不可见的，全局执行环境对于任何一个函数的函数体内的代码来说都是外部执行环境。</p>
<img src="2838289-081624fdf69205c5.png" alt="javascript函数提升和变量的声明提前">

<p>所以上面你在全局执行环境调用，就要在全局执行环境定义。</p>
<p>PS：谈到函数定义想必会想到下面这样的方式定义函数，这样的定义函数个人觉得是很好看的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issax&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种函数的定义方式叫“函数表达式”，这样定义函数是不会被函数提升，因此上面的代码执行会抛出异常：</p>
<img src="2838289-069a3b74b6763e02.png" alt="javascript函数提升和变量的声明提前">

<h1 id="变量的声明提前"><a href="#变量的声明提前" class="headerlink" title="变量的声明提前"></a>变量的声明提前</h1><p>变量和函数有一点相同：他们都会被提前到当前作用域的顶部；但是变量的提前和函数的提前也是有一点不同：函数是会被提升，并且会定义，而变量的提前是不会被提前定义的，即不会当前作用域提前定义；如果你不清楚作用域的话，对于函数来说，你可以笼统地认为是函数体内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<img src="2838289-634314a72255a147.png" alt="javascript函数提升和变量的声明提前">

<p>如上面的例子所见，a变量没有被提前定义。<br>如果不会被提前定义，那么怎么体现变量的声明提前？<br>你知道作用域链（感兴趣可以自行Google）吗？不知道？也不要紧，写过js代码的coder，都应该会有这样的经验：函数内部可以访问到外层作用域（比如说最外层的全局作用域）定义的变量和函数，而函数内部的定义的和外层作用域同名的变量会遮盖外层的，就是说如果函数内部有和外层同名的函数会变量，内部的优先级更高，了解到这一点就算不了解作用域链也可以理解变量提升。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<img src="2838289-358c20b812529f39.png" alt="javascript函数提升和变量的声明提前">

<p>变量的声明提前就体现在下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);   </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<p>你认为会输出什么？会输出  <code>1</code>  <code>2</code> ？然而并不是！</p>
<img src="2838289-17c44cf694435498.png" alt="javascript函数提升和变量的声明提前">

<p>为什么会这样，就是因为变量的声明提前，相信到这里你已经大概知道什么是变量提前，通俗地讲：在当前作用域内，变量会提前声明，遮盖外层作用域的同名变量，因为没有解析作用域链，所以就笼统地说一下，毕竟在深入学习前就得不求甚解嘛。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析JavaScript作用域链</title>
    <url>/blog/resources/%E6%B5%85%E6%9E%90JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为可以大概了解作用域链是个什么东西，本文着重说明作用域链，尽量不引入其他的概念。</p>
<span id="more"></span>

<h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>在说作用域链前，先简单地说明变量对象，毕竟是作用域链的核心组成。每个函数内部都会定义变量，会定义函数，在全局环境下也会定义函数、变量。对应的区域都会有一个特殊对象，这个对象就会存放对应区域的变量、函数，这个特殊的对象就是变量对象。所以说全局环境有和全局环境对应的变量对象，每个函数内部也有一个与之对应的变量对象，不如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">isShow</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> gihubLink = <span class="string">&#x27;https://github.com/issaxite&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(isShow) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(githubLink);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;issax&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码中,</p>
<ul>
<li>全局环境的变量对象存储的是：a, b, fn</li>
<li>fn函数的变量对象存储的是：isShow，gihubLink；<strong>你可以看见，fn函数的变量对象没有包含全局环境定义的变量和函数</strong></li>
</ul>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>为什么要说变量对象呢？因为作用域链就是由变量对象组成，作用域链是一个由变量对象组成的列表，一个有序，只能由头开始逐个往尾访问的列表（说是列表其实更应该说是链表，先不要在意这个概念）。<br>并且作用域链和变量对象有一个共同的特点：每个区域都会有一个与之对象对的。比如说上面的代码中，全局环境有一个与之对应的变量对象，也有一个和全局环境对应的作用域链；fn函数也是如此。</p>
<h2 id="那么作用域链是有哪些变量对象组成呢？"><a href="#那么作用域链是有哪些变量对象组成呢？" class="headerlink" title="那么作用域链是有哪些变量对象组成呢？"></a>那么作用域链是有哪些变量对象组成呢？</h2><p>我们先看下图：</p>
<img src="2838289-ea22086b2a47a918.png" alt="浅析JavaScript作用域链">

<p>由上图应该可以看出，作用域链由当前区域的变量对象作为开头，然后是逐层往外直至全局环境的变量对象组成如上图一样的列表，这就是作用域链，并且如上文所说，每个区域都有这样一个与之对应的作用域链。比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">isShow</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> gihubLink = <span class="string">&#x27;https://github.com/issaxite&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">param1, param2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> mailLink = <span class="string">&#x27;issaxite@gmail.com&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fn1函数的作用域链：</p>
<img src="2838289-b0a1699c6beb4b74.png" alt="浅析JavaScript作用域链">
</li>
<li><p>fn的作用域链：</p>
<img src="2838289-9fdc6ccc56ef3e26.png" alt="浅析JavaScript作用域链">
</li>
<li><p>全局环境的作用域链</p>
<img src="2838289-828698a0bf9bc1b4.png" alt="浅析JavaScript作用域链"></li>
</ul>
<p>那么作用域链的作用是什么？<br>jser都应该有这样的体验，在函数内部可以访问到外部区域的变量和函数，而在外部区域访问不了函数内定义的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<img src="2838289-2a0bdcdf12428f9a.png" alt="浅析JavaScript作用域链">

<p>如上所示，fn函数内部可以访问到外层区域（全局环境）的变量，为什么可以，就是因为fn函数的作用域链，在变量调用的时候（在fn就是访问c变量的时候），会在当前作用域链的头部开始往尾部，依次在变量对象中查询对应的变量，找到即返回，不再继续查询，这个也是内层同名变量比外层同名变量优先级更高的原因，这个查询的过程叫做<strong>变量解析</strong>，也叫<strong>标识符解析</strong>，<code>console.log(c);</code>会抛出异常就是因为全局环境的作用域链中的变量对象没有该变量。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>正如本文开头所说，本文仅是浅析作用域链，一些相关概念都被隐掉了，比如说上文说的“区域“，应该说是作用域或执行环境，这两个概念其实说的不是很明确，比如说执行环境，在《javascript高级程序设计》的4.2中有说到，简直堪称极具迷惑性，标题更加是醉”执行环境和作用域“，然而基本没有谈到作用域。作用域在《javascript权威指南》的3.10中倒是说的挺多，还分变量作用域和函数作用域。不过啊，要是拘泥于这些细节更加难搞明白作用域链了。上文也说道作用域链更像链表，个人也是这样认为，但两书中都没有明确地说是，权威指南倒是提了一下，而且作用域链也是很符合链表的特点，如果不了解链表，但由不了解其他语言，推荐这本书<strong>《数据结构与算法JavaScript描述》</strong>，吐槽完毕，作用域链的解析当然没有那么浅显，想了解更多细节还是自己去看看书。</p>
<p>有说得不对的，欢迎指出</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>我不知道的hash表</title>
    <url>/blog/resources/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84hash%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%AD%A3%E6%96%87">正文</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%A3%E5%88%97%E8%A1%A8">什么是散列表</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%A3%E5%88%97%E8%A1%A8">为什么需要散列表</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%95%A3%E5%88%97%E8%A1%A8">如何构建散列表</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%A2%B0%E6%92%9E">哈希冲突（碰撞）</a><ul>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95">开放定址法</a></li>
<li><a href="#%E5%8D%95%E7%8B%AC%E9%93%BE%E8%A1%A8%E6%B3%95">单独链表法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6">平均查找长度</a></li>
<li><a href="#%E8%BD%BD%E8%8D%B7%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90">载荷（装填）因子</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%90%8E%E5%86%99%E4%B8%A4%E5%8F%A5">最后写两句</a></li>
</ul>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>为什么要写散列表（Hash Table）？！因为忘记，就算以前在大学的时候学得多好，分数考多高。成了前端狗之后一方面是自己对自己不够严格，另一方面工作方面也是用得少这方面的知识，平时大多都是一群朋友吹牛皮的时候，亮出来吓吓人（也只能说自己记得的部分）。当夜深人静时都会想想自己吹过的牛皮~感叹这些知识自己真的忘得差不多了，三分钟热度来写个文章温故知新！</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>散列表（Hash Table），用一个映射函数将数据的特征值与数据保存表的存储位置建立联系，以便在寻找数据的时候可以快速定位，这样的表成为散列表（Hash Table），上述映射函数成为hash函数。</p>
<blockquote>
<p>根据设定的哈希函数和冲突处理方法将一组关键字映射到一个有限连续的地址集上，并以关键字映射得到的值作为关键字对应数据在表中的存储位置，这种称为哈希表。</p>
</blockquote>
<blockquote>
<p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。（摘自<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表维基百科</a>）</p>
</blockquote>
<h3 id="为什么需要散列表"><a href="#为什么需要散列表" class="headerlink" title="为什么需要散列表"></a>为什么需要散列表</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>一般来说hash表的数据会用一个一维数组存储。而在低级语言中使用数组是需要预先申请数组的长度，即是内存大小。而在实际应用中，很难确定最后应该申请多大的内存，过大浪费资源，过小则会造成内存溢出。在溢出前你就需要扩容，扩容的时候又涉及到内存拷贝的问题，因为数组是一组连续的地址集，你难保在这段地址集后面的地址没有保存另外的数据。另外，单纯用数组存储数据，存储的时候很爽，但是在寻找的时候就一身骚了~毕竟在数组一定规模的时候你遍历一次或许就要做成千上万次的对比数据，这还是单纯的一维数组而已，如果是个矩阵呢？复杂度是不是就蹭蹭往上涨！</p>
<h3 id="如何构建散列表"><a href="#如何构建散列表" class="headerlink" title="如何构建散列表"></a>如何构建散列表</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>如上文所述，哈希函数就是用来确定数据特征值与数据在哈希表存储位置的映射关系。</p>
<blockquote>
<p>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)&#x3D;f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。</p>
</blockquote>
<p>常用的几个用于构建哈希函数的方法如下：</p>
<ul>
<li>直接定址法：使用一个线性函数作为映射函数；</li>
<li>除留余数法：通过模 一个小于或等于散列表长度的值，取其余数作为散列表的存储位置；</li>
<li>数字分析法：肉眼观测，剔除显而易见的噪点；</li>
<li>平方中值法：将数据特征（一般是自然数）平方后取中间几位数，取几位取决于表的大小；</li>
<li>折叠法：将数据特征值分隔成为数相同的几部分，然后取叠加和（舍去高位）；</li>
<li>伪随机数法；</li>
</ul>
<p>以上每个方法不一一阐述，我只挑出“除留余数法”浅析。一是它常用；二是我只想说它。</p>
<p>除留余数法的数学表达式：</p>
<div style="font-weight: bold;">
    <dl style="text-align: center;">hash( key ) = key mod p ( p ≤ m )</dl>
    <dl style="text-align: right;">
        <sub>key: 数据特征值；</sub>
        <sub>m: 散列表的长度；</sub>
    </dl>
</div>



<p>下面用一例子对上述数学表达式进行实践（注意，一下例子只是对除留余数法的实践，并未完全达到理想的映射关系，仅仅是基本的关系）：</p>
<p>假设现有一组数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Issac&#x27;</span>, <span class="string">&#x27;Fanck&#x27;</span>, <span class="string">&#x27;Sonia&#x27;</span>, <span class="string">&#x27;Gary&#x27;</span>, <span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;Ryron&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>取以上人名的首字母的 <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII码</a> 作为数据的特征值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nameKeys = names.map((name) =&gt; &#123;</span><br><span class="line">	const initial = name.slice(0, 1);</span><br><span class="line">	const key = initial.charCodeAt();</span><br><span class="line">	return key;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// print: [73, 70, 83, 71, 82, 82, 69]</span><br></pre></td></tr></table></figure>

<p>然后，取 <code>p = 7</code>。<strong>对p的选择很重要，一般取素数（质数）或m，若p选择不好，容易产生冲突（哈希冲突）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> indexs = nameKeys.<span class="title function_">map</span>(<span class="function">(<span class="params">nameKey</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = nameKey % p;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print: [3, 0, 6, 1, 5, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>根据 <code>names</code> 和 <code>indexs</code> 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<p>可以得到一个基本的关系表：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">-</td>
<td align="center">Issac</td>
<td align="center">-</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Ryron</td>
<td align="center">Emma</td>
</tr>
</tbody></table>
<p>由表中的数据你可以看见3、5、6这三个位置都有一个以上的name映射到了同一个存储位置上，显然一个位置是不能存放多个数据，除非使用别的储存方式。该当如何下节分解！</p>
<h4 id="哈希冲突（碰撞）"><a href="#哈希冲突（碰撞）" class="headerlink" title="哈希冲突（碰撞）"></a>哈希冲突（碰撞）</h4><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>前一小节中出现“多个name映射到了同一个存储位置”的情况就是典型的哈希冲突。<br>出现哈希冲突，一是更换其他的哈希函数，二是对哈希函数的结果进行处理。要知道在数据足够大后无论怎么更换哈希函数都无法避免哈希冲突，只能尽量减小出现哈希冲突的几率。</p>
<p>常用方法有以下几种：</p>
<ul>
<li>开放定址法；</li>
<li>单独链表法；</li>
<li>再散列；</li>
<li>双散列；</li>
</ul>
<p>以下浅析前两种方法，原因同上。 </p>
<h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>开放定址法的数学表达式：</p>
<div style="text-align: center;font-weight: bold;">
    <dl>Hash = (hash(key) + d<sub>i</sub>) mod m, i=1,2,3...k (k <= m-1)</dl>
    <dl style="text-align: right;">
        <sub>m为散列表长，d<sub>i</sub>为增量序列（函数），i为已发生冲突的次数</sub>
    </dl>
</div>



<p>增量序列的构建方法有以下几种：</p>
<ul>
<li>线性探测：d(i) &#x3D; i;</li>
<li>平方探测：d(i) &#x3D; i^2;</li>
<li>伪随机探测；</li>
</ul>
<p>下面用“线性探测”编写例子。</p>
<p>回顾哈希函数得到的映射结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<p>取哈希表的长度<code>m = p = 7</code>。</p>
<p>映射 <code>Ryron</code> 时出现冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># i = 1, d(1) = 1，hash(key) = 5</span><br><span class="line">(5 + 1) mod 7 = 6   # 冲突</span><br><span class="line"></span><br><span class="line"># i = 2, d(2) = 2，hash(key) = 5</span><br><span class="line">(5 + 2) mod 7 = 0   # 冲突</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line"># i = 4, d(4) = 4，hash(key) = 5</span><br><span class="line">(5 + 4) mod 7 = 2   # 命中</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">Ryron</td>
<td align="center">Issac</td>
<td align="center">-</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
</tbody></table>
<p>映射 <code>Emma</code> 时继续出现冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># i = 1, d(1) = 1，hash(key) = 6</span><br><span class="line">(6 + 1) mod 7 = 0   # 冲突</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># i = 5, d(5) = 5，hash(key) = 6</span><br><span class="line">(6 + 5) mod 7 = 4   # 命中</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Fanck</td>
<td align="center">Gary</td>
<td align="center">Ryron</td>
<td align="center">Issac</td>
<td align="center">Emma</td>
<td align="center">Rick</td>
<td align="center">Sonia</td>
</tr>
</tbody></table>
<p>到此，冲突处理完毕，散列表构建完成！我们可以试着在散列表中查找数据。</p>
<p>假设现在要查找 <code>Issac</code> 和 <code>Ryron</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Issac</span><br><span class="line"># key(&#x27;I&#x27;) = 73, Hash(key) = 3</span><br><span class="line">hashTable(3)  # output &#x27;Issac&#x27; =&gt; Hit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Ryron</span><br><span class="line"># key(&#x27;R&#x27;) = 82, Hash(key) = 5</span><br><span class="line">hashTable(3)  # output &#x27;Rick&#x27; =&gt; Miss</span><br><span class="line"></span><br><span class="line"># d(1) = 1, Hash(key) = 6</span><br><span class="line">hashTable(6)  # output &#x27;Sonia&#x27; =&gt; Miss</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># d(4) = 4, Hash(key) = 2</span><br><span class="line">hashTable(2)  # output &#x27;Ryron&#x27; =&gt; Hit</span><br></pre></td></tr></table></figure>





<h5 id="单独链表法"><a href="#单独链表法" class="headerlink" title="单独链表法"></a>单独链表法</h5><p>使用单链表作为存储数据的方式，言外之意，hash(key)得到的在哈希表的存储位置不再是数据的存储位置，而是用于存储数据所用链表的地址。</p>
<p><img src="169da0ac46bad36d.png"></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">单链表</a>（LinkList）形如：</p>
<p><img src="169da0ebd588f9f9.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LinkList() &#123;</span><br><span class="line">    constructor(_data, _next) &#123;</span><br><span class="line">        this.head = new Entry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert(_data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    find(_data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的每个节点形如：</p>
<p><img src="169da10a5c98fb7c.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_data, _next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = _data;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾哈希函数得到的映射结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Issac&#x27;, &#x27;Fanck&#x27;, &#x27;Sonia&#x27;, &#x27;Gary&#x27;, &#x27;Rick&#x27;, &#x27;Ryron&#x27;, &#x27;Emma&#x27;]</span><br><span class="line">[      3,       0,       6,      1,      5,       5,      6]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">const</span> hashTable = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Issac&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Issac&#x27;</span>);    <span class="comment">// 73</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 3, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Issac&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Fanck&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Fanck&#x27;</span>);    <span class="comment">// 70</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 0, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Fanck&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Sonia&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Sonia&#x27;</span>);    <span class="comment">// 83</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 6, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Sonia&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Gary&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Gary&#x27;</span>);    <span class="comment">// 71</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 1, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Gary&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Rick&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Rick&#x27;</span>);    <span class="comment">// 82</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 5, 命中</span></span><br><span class="line"><span class="title function_">hashTable</span>(index) = <span class="keyword">new</span> <span class="title class_">LinkList</span>();</span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Rick&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Ryron&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Ryron&#x27;</span>);    <span class="comment">// 82</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 5, 冲突</span></span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Ryron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert &#x27;Emma&#x27;</span></span><br><span class="line">key = <span class="title function_">getKey</span>(<span class="string">&#x27;Emma&#x27;</span>);    <span class="comment">// 69</span></span><br><span class="line">index = <span class="title function_">hash</span>(key);    <span class="comment">// 6, 冲突</span></span><br><span class="line"><span class="title function_">hashTable</span>(index).<span class="title function_">insert</span>(<span class="string">&#x27;Emma&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="169da36dcac47d29.png"></p>
<h3 id="平均查找长度"><a href="#平均查找长度" class="headerlink" title="平均查找长度"></a>平均查找长度</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>为什么要求取“平均查找长度”？从上文中你可以发现，由于哈希冲突的出现，用数据特征并不能直接获取数据的储存位置，是需要进行一次以上的对比才能找到目标数据，也可能数据并不存在于哈希表中，即查找不成功。因此，就需要一个量度去衡量查找效率，即平均查找长度。</p>
<p>平均查找长度分为下面两类：</p>
<ul>
<li>成功的平均查找长度：</li>
</ul>
<div style="font-weight: bold;">
    <dl style="text-align: center;">ASL = (d<sub>0</sub> + d<sub>1</sub> + d<sub>2</sub> + ... + d<sub>i</sub>) / n, (i = 0, 1, 2 ... n)</dl>
    <dl style="text-align: right;">
        <sub>ASL: 平均查找长度</sub>,<sub>n: 哈希表的元素个数</sub><br>
        <sub>di: 第 i 个元素查找成功所需要的查找（比对）次数</sub>
    </dl>
</div>


<ul>
<li>不成功的平均查找长度：</li>
</ul>
<div style="font-weight: bold;">
    <dl style="text-align: center;">ASL = (d<sub>0</sub> + d<sub>1</sub> + d<sub>2</sub> + ... + d<sub>i</sub>) / n, (i = 0, 1, 2 ... l)</dl>
    <dl style="text-align: right;">
        <sub>l: 哈希表的长度</sub>,
        <sub>n: 哈希表的元素个数</sub>,
        <sub>ASL: 平均查找长度</sub><br>
        <sub>di: 在第 i 个存储位置开始查找直到确定不存在所需要的查找（比对）次数</sub>
    </dl>
</div>

<p>下面分别计算前一小节中哈希表的成功和不成功的平均查找长度。</p>
<p><img src="169da36dcac47d29.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 成功的平均查找长度</span><br><span class="line">Frank：1</span><br><span class="line">Gary: 1</span><br><span class="line">Issac: 1</span><br><span class="line">Rick: 1</span><br><span class="line">Ryron: 2</span><br><span class="line">Sonia: 1</span><br><span class="line">Emma: 2</span><br><span class="line"></span><br><span class="line">ASL = (1 + 1 + 1 + 1 + 2 + 1 + 2) / 7 ≈ 1.2857</span><br></pre></td></tr></table></figure>

<hr>
<p>对于不成功的平均查找长度数学代数式中d<sub>i</sub>有必要再细说一下。<br>比如现在要再上表中查找<code>Fiona</code>，这是不存在中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash(&#x27;F&#x27;)  # output 0</span><br></pre></td></tr></table></figure>

<p>然后，就是在 <code>hashTable(0)</code> 存储的单链表中查找<code>Fiona</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次查找， 第一个节点的data存的是Frank，不匹配！</span><br><span class="line"># 并且第一个的指针域为空指针（没有指向下一个节点），这样就成功确定Fiona不在表中，即查找失败！</span><br><span class="line">结果是hash(key)等于0的查找失败长度为1</span><br></pre></td></tr></table></figure>

<p>由上面的例子就可以知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不成功的平均查找长度</span><br><span class="line">hash(key) =&gt; 0: 1</span><br><span class="line">hash(key) =&gt; 1: 1</span><br><span class="line">hash(key) =&gt; 2: 0</span><br><span class="line">hash(key) =&gt; 3: 1</span><br><span class="line">hash(key) =&gt; 4: 0</span><br><span class="line">hash(key) =&gt; 5: 2</span><br><span class="line">hash(key) =&gt; 6: 2</span><br><span class="line"></span><br><span class="line">ASL = (1 + 1 + 0 + 1 + 0 + 2 + 2) / 7 = 1</span><br></pre></td></tr></table></figure>



<h3 id="载荷（装填）因子"><a href="#载荷（装填）因子" class="headerlink" title="载荷（装填）因子"></a>载荷（装填）因子</h3><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>载荷因子指的是哈希表的装满程度，具体计算式是：</p>
<div style="font-weight: bold;">
    <dl style="text-align: center;">α = 表中元素个数 / 哈希表长度</dl>
</div>



<p>从公式中你可以直观地感受到，α 越大下次存入新元素的时候发生冲突的几率越大，因为表中空缺的位置已经很小了！<br>发生冲突的次数越多，也就是意味着查找长度就可能越大！想想哈希表的存在意义：为了方便定位目标查找元素！查找长度足够大时哈希表就不在方便了，也就失去存在意义。而α就可以直观地指明当前哈希表已经不够方便了，那么这个时候就需要对哈希表进行扩容！没错，它就是标示何时应该扩容，比如java中的hashMap则是<code>α &gt; 0.75</code> 时后对当前哈希表进行扩容！</p>
<h2 id="最后写两句"><a href="#最后写两句" class="headerlink" title="最后写两句"></a>最后写两句</h2><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>上文其实已经很早就写好，剩下自己定的两个问题本来想浅析一下，但是由于自身原因一拖再拖，也只能先在此留个坑，希望自己有生之年可以回来填坑（滑稽）</p>
<ul>
<li>如何判断一个哈希表的好坏？</li>
<li>为什么除留余数发中p一般取质数？</li>
</ul>
<p>希望自己一如既往可以对未知的知识保有好奇心~</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的JavaScript实现</title>
    <url>/blog/resources/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>1 在数据集之中，选择一个元素作为”基准”（pivot）。<br>2 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>3 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>
</blockquote>
<span id="more"></span>

<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">80</span>, <span class="number">34</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<p><img src="36534815-97fd73f2-1802-11e8-9039-36b714dfd2ee.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(list.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> list; &#125;</span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = list[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="36535646-54302edc-1805-11e8-8fa4-0d0eef8591c6.png"></p>
</blockquote>
<h3 id="quickSort函数解构"><a href="#quickSort函数解构" class="headerlink" title="quickSort函数解构"></a><code>quickSort</code>函数解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> left = [], right = [];</span><br><span class="line"><span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = list[index];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">    left.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分逻辑正是对<strong>基本思想</strong>中的1、2点的实践。</p>
<ul>
<li><h4 id="1-找出基准数"><a href="#1-找出基准数" class="headerlink" title="1 找出基准数"></a>1 找出基准数</h4></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(list.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> pivot = list.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="2-以“基准”二分数组"><a href="#2-以“基准”二分数组" class="headerlink" title="2 以“基准”二分数组"></a>2 以“基准”二分数组</h4></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, len = list.<span class="property">length</span>; index &lt; len; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = list[index];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(val &lt;= pivot) &#123;</span><br><span class="line">    left.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right.<span class="title function_">push</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="3-重复1、2点"><a href="#3-重复1、2点" class="headerlink" title="3 重复1、2点"></a>3 重复1、2点</h4></li>
</ul>
<p>在栗子中的数组执行一次1、2点实现后，你会发现此时执行后出现三个结果<br>1）letf &#x3D; [2];<br>2）pivot &#x3D; 3;<br>3）right &#x3D; [9, 6, 80, 34, 7, 8];</p>
<p>然后依次组合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...left, pivot, ...right]</span><br><span class="line"><span class="comment">// [2, 3, 9, 6, 80, 34, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>你会发现<code>left</code>只有一个元素，那就没有必要继续对<code>left</code>排序，所以没有必要再排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(list.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> list; &#125;</span><br></pre></td></tr></table></figure>
<p>然后再看<code>right</code>，并不是有序数组。那要怎么办？继续对<code>right</code>排序，调用<code>quickSort</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">quickSort</span>(right)</span><br><span class="line"><span class="comment">// [...quickSort(left), pivot, ...quickSort(right)];</span></span><br></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)];</span><br></pre></td></tr></table></figure>
<p>正是对第3点的实践。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历的javascript实现</title>
    <url>/blog/resources/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>紧接着上篇  <a href="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0.md">二叉树的javascript实现</a> ，来说一下二叉树的遍历。</p>
<span id="more"></span>

<p>本次一本正经的胡说八道，以以下这个二叉树为例子进行遍历：</p>
<p><img src="2838289-3daeb5c545e5c721.png"></p>
<p>接着是要引入二叉树实现的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">show</span> = show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树遍历的分类"><a href="#二叉树遍历的分类" class="headerlink" title="二叉树遍历的分类"></a>二叉树遍历的分类</h1><p>二叉树的遍历分为先序、中序、后序遍历。这里说到的先序、中序、后序是相对于父节点来说。父节点的值先输出就是先序，三者间它在中间输出就是中序，最后输出就是后序。至于那个是父节点是相对而言的，因为除了叶子节点（最底下一层节点），其他每个节点都可以是父节点。</p>
<p><img src="2838289-ba95130e0738830d.png"></p>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>先序遍历就是，先打印父节点，然后是左子节点（左子树），然后再打印右子节点（子树）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">preOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="title function_">preOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加先序遍历的成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preOrder函数是递归实现的，应该说二叉树的遍历都是递归实现的。可能有些人会因为先序遍历的特征：“先打印父节点，然后是左子节点（左子树），然后再打印右子节点（子树）” 而陷入一个错误的想法，这想法是什么请看下图：</p>
<p><img src="2838289-ce81e216fca99c93.png"></p>
<p>注意红框部分，父节点是10，左子节点是3，右子节点是18，因为上面的结论，可能会错误地认为打印的顺序是<code>10 → 3 → 18 </code>，然而事实并非如此[捂脸]，真是的顺序是：先打印10，然后是打印左子树，打印完左子树的全部节点后，才开始打印以10位父节点的右子树：</p>
<p><img src="2838289-123d7b9722e9a43e.png"></p>
<p>这个时候，你的脑海就该这样想：</p>
<p><img src="2838289-07040be1a2a54793.png"></p>
<p>然后是这样想：</p>
<p><img src="2838289-a48c2ac242f3e007.png"></p>
<p>如此类推打印完以10为父节点的左子树，然后也是以这样的方式打印以10为父节点的右子树，按着这种  <strong>拆分代替的思想</strong>  来理解会更好明白二叉树的遍历。</p>
<p>然后最终，先序遍历改二叉树的顺序是：</p>
<p><img src="2838289-4745ead9a13aaa9d.png"></p>
<p>按图的输出顺序是：<code>10 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 9 -&gt; 8 -&gt; 9 -&gt; 18 -&gt; 13 -&gt; 21</code><br>最后来实践一下，先序遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bst = <span class="keyword">new</span> <span class="title function_">BST</span>();</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    bst.<span class="title function_">insert</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">bst.<span class="title function_">preOrder</span>(bst.<span class="property">root</span>);</span><br></pre></td></tr></table></figure>

<p><img src="2838289-f5173b222f16cec8.png"></p>
<p>这里强调一下，输出顺序和插入顺序有关的，因为你插入顺序不同生成的二叉树也是不同的。有疑问的可以去 <a href="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0.md">二叉树的javascript实现</a> 细看一下，有比较明白的说明了二叉树，也可以实验一下：</p>
<p><img src="2838289-da13ca026775f5e5.png"></p>
<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>看完先序遍历，已经可以类推到很多和中序、后序遍历相关的知识点。中序遍历的特征是：先打印左子树（左子节点），接着打印父节点，最后打印右子树（右子节点）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="title function_">inOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">inOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加该成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">inOrder</span> = inOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历的打印顺序：</p>
<p><img src="2838289-c4b8e6b205daf67e.png"></p>
<p>按上图的输出顺序是：<code>2 -&gt; 3 -&gt; 4 -&gt; 8 -&gt; 9 -&gt; 9 -&gt; 10 -&gt; 13 -&gt; 18 -&gt; 21</code><br>接着是，实践一下中序遍历：</p>
<p><img src="2838289-f7147d8e222cc77c.png"></p>
<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="title function_">postOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="title function_">postOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">show</span>() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BST类添加该成员方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">preOrder</span> = preOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">inOrder</span> = inOrder;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">postOrder</span> = postOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历的打印顺序</p>
<p><img src="2838289-40ce1a6b62a8dfc2.png"></p>
<p>按上图的输出顺序是：<code>2 -&gt; 8 -&gt; 9 -&gt; 9 -&gt; 4 -&gt; 3 -&gt; 13 -&gt; 21 -&gt; 18  -&gt; 10</code></p>
<p><img src="2838289-b98b04bb61c0aa6c.png"></p>
<p>各位观众老爷，文章到此为止，有写的不对的，请斧正！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的javascript实现</title>
    <url>/blog/resources/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="2838289-a4d05edb6062df13.png"></p>
<span id="more"></span>

<p><strong>二叉树的特点(例图只是二叉树的一种情况，不要尝试用例图推理以下结论)</strong></p>
<ul>
<li>除了最下面一层，每个节点都是父节点，每个节点都有且最多有两个子节点；</li>
<li>除了嘴上面一层，每个节点是子节点，每个节点都会有一个父节点；</li>
<li>最上面一层的节点（即例图中的节点50）为根节点；</li>
</ul>
<img src="2838289-e0e3b9a05871efaa.png" alt="二叉树的javascript实现">

<ul>
<li>最下面一层的节点称为叶子节点，他们没有子节点；</li>
</ul>
<img src="2838289-da27d2f6031b1d36.png" alt="二叉树的javascript实现">

<ul>
<li>左子节点的值 &lt; 父节点的值 &lt;&#x3D; 右节点的值</li>
</ul>
<p>1 节点的javascript实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">data</span> = data;  <span class="comment">// 节点值</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">left</span> = left;  <span class="comment">// 当前节点的左子节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">right</span> = right;  <span class="comment">// 当前节点的右子节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">show</span> = show;  <span class="comment">// 辅助function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感受下上面实现节点的代码，感觉和链表有点相似不是吗，存着当前值，又存着下个节点（左、右子节点）的引用，下面是一张伪代码的草图：</p>
<img src="2838289-d7aede07576cc831.png" alt="二叉树的javascript实现">

<p>2 二叉树的实现<br>实现二叉树，当然就是要插入节点构成二叉树，先看看实现二叉树的js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是看一下伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;  <span class="comment">// 根节点</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">insert</span> = insert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="comment">// 初始化一个节点，为什么要将左右子节点的引用初始化为空呢，因为可能是叶子节点，加入他有子节点，会在下面的代码添加</span></span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (该二叉树是否为空，是空则根节点为空，因此可以用根节点判断二叉树是否为空) &#123;</span><br><span class="line">      <span class="comment">// 将当前节点存为根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里就表示，该二叉树不为空，这里关键的是两句代码：</span></span><br><span class="line">      <span class="comment">// 0.while (true);</span></span><br><span class="line">      <span class="comment">// 1.parent = current；</span></span><br><span class="line">      <span class="comment">// 2.current = current.left;/current = current.right;</span></span><br><span class="line">      <span class="comment">// 3.break;</span></span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         parent = current;  <span class="comment">// 获得父节点，第一次循环，那么父节点就是根节点</span></span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;  <span class="comment">// 当前节点值小于父节点的值就是存左边，记得二叉树的特点吧，如果真是小于父节点，那么就说明该节点属于，该父节点的左子树。</span></span><br><span class="line">            current = current.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其实上面这样写不好理解，可以等价于下面的代码：</span></span><br><span class="line">            <span class="comment">// start</span></span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">left</span> == <span class="literal">null</span>)&#123;  <span class="comment">// 若果左节点空，那么这个空的节点就是我们要插入的位置</span></span><br><span class="line">                current.<span class="property">left</span> = n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 不空则继续往下一层找空节点（插入的位置）</span></span><br><span class="line">                current = current.<span class="property">left</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// end</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右节点的逻辑代码个左节点的一样的</span></span><br><span class="line">            current = current.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               parent.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个更好理解的插入函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="comment">// start change</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">left</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">               current.<span class="property">left</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               current = current.<span class="property">left</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">right</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">               current.<span class="property">right</span> = n;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               current = current.<span class="property">right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>二叉树的实现的三个部件</p>
<ul>
<li>Node对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params">data, left, right</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>BST对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BST</span>(<span class="params"></span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>插入节点函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">data</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图的javascript实现</title>
    <url>/blog/resources/%E5%9B%BE%E7%9A%84javascript%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>图：关于图的概念就大概说一下基本的，图分成有向和无向。图由若干顶点构成，顶点相连成边，边由顶点对组成，(假设有v1，v2两顶点，(v1,v2)即为一条边)每个顶点有权重，对于图的概念可以自行Google，本文着重对图的实现，上两张“图”的例子：</p>
<span id="more"></span>

<p>有向图：</p>
<p><img src="2838289-34f3c4e8246fdbfd.png"></p>
<p>无向图：</p>
<p><img src="2838289-1effeaaa6413bc13.png"></p>
<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><ul>
<li><p>使用邻接表：<br>以顶点值为下标，构建数组，元素为与该顶点相连的顶点值，下面例子就是用邻接表存储。假设有顶点v1、v2、v3，且有边(v1, v2)、(v1, v3)、(v2, v3)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> edges = [];</span><br><span class="line">edges[v1] = [v2, v3];</span><br><span class="line">edges[v2] = [v1, v3];</span><br><span class="line">edges[v3] = [v1, v2];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用邻接矩阵：<br>临界矩阵，简单说是个二维数组，假设有顶点v1、v2，并且v1、v2有边相连，则用邻接矩阵表示为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> edges = [];</span><br><span class="line">edges[v1][v2] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 若无边相连则为</span></span><br><span class="line">edges[v1][v2] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="图的javascript实现"><a href="#图的javascript实现" class="headerlink" title="图的javascript实现"></a>图的javascript实现</h1><p><strong>下面以上文中的无向图为例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Graph</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">edges</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顶点</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">initVertices</span> = <span class="keyword">function</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(toString.<span class="title function_">call</span>(list) !== <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;please init adj with Array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertices</span>[list[item]] = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点的连结（边）</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEdge</span> = <span class="keyword">function</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">vertices</span>[v1] || !<span class="variable language_">this</span>.<span class="property">vertices</span>[v2]) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;vertex that does not exist！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span>[v1].<span class="title function_">push</span>(v2);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span>[v2].<span class="title function_">push</span>(v1);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">edges</span>++; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出存储图的邻接表</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showGraph</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(item <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">vertices</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item+<span class="string">&#x27;: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">vertices</span>[item].<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">graph.<span class="title function_">initVertices</span>(list);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">showGraph</span>();</span><br></pre></td></tr></table></figure>

<p><img src="2838289-1e184a4fff1588ef.png"></p>
<p>PS：图当然是没有那么简单的啦，想了解图自己去看书吧</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与防抖</title>
    <url>/blog/resources/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81">函数节流</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96">函数防抖</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数节流<br>给定时间间隔内只执行一次</p>
<p>函数防抖<br>在连续尝试触发的情况，只有触发的时间间隔大于给定时间才会真正触发。</p>
<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>正如其名，就是为了节流。<br>在实现同样的功能下，尽量使用最少的资源，达到节约的效果！<br>比如，在绑定一个滚动事件，滚轴的位置有一点变化都会触发。然而，人眼可以识别的只有60帧每秒，甚至30帧就够了！<br>所以，让触发频率实在是浪费资源！</p>
<p>先来实现一个节流函数的构造器！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttleCreator</span>(<span class="params">_cb, _time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cacheTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - cacheTime  &gt; _time) &#123;</span><br><span class="line">      cacheTime = now;</span><br><span class="line">      <span class="title function_">_cb</span>(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyEle = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">bodyEle.<span class="property">onscroll</span> = <span class="title function_">throttleCreator</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p>意义在于防止多次触发无意义操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounceCreator</span>(<span class="params">_cb, _time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(_cb.<span class="property">id</span>);</span><br><span class="line">    _cb.<span class="property">id</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      _cb.<span class="title function_">call</span>(ctx, ...rest);</span><br><span class="line">    &#125;, _time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>关于继承多种实现的笔记</title>
    <url>/blog/resources/%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">原型链继承</a></li>
<li><a href="#%E5%80%9F%E8%B0%83%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">借调构造函数继承</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">组合继承</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">原型式继承</a></li>
<li><a href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生式继承</a></li>
<li><a href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生组合式继承</a></li>
</ul>
<span id="more"></span>

<h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>先说原型链继承的问题：包含引用类型属性的原型（不想被共享的引用属性）会变成共享。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;color&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">type</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins2.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line">ins2.<span class="title function_">sayType</span>();</span><br><span class="line">ins2.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<img src="http://upload-images.jianshu.io/upload_images/2838289-0ef782193b536392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%" alt="关于继承多种实现的笔记">

<p><strong>根据超类，colors应该为每个实例独有、不共享的，但由上面的代码可见，由于原型链继承后，colors变成了共享的属性</strong></p>
<blockquote>
<p>造成此结果的原因是：以SuperType的实例作为了prototype，而每个对象实例都只是指向这个prototype，因此每个实例拥有的colors实际都是同一个colors，换言之ins1.colors和ins2.colors存放都是同一个指针。</p>
</blockquote>
<p>  <strong>原型链继承的问题：无法保证“私有”引用类型继续“私有”</strong></p>
<h1 id="借调构造函数继承"><a href="#借调构造函数继承" class="headerlink" title="借调构造函数继承"></a>借调构造函数继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>为解决原型链本应为实例独有的引用属性变成共享属性的问题，提出借调构造函数继承</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">sub.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<img src="http://upload-images.jianshu.io/upload_images/2838289-1925f395a7a67071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%" alt="关于继承多种实现的笔记">

<blockquote>
<p>借调构造函数解决上面提出了的问题，而且接受参数更加的方便</p>
</blockquote>
<p>  <strong>构造函数自身的老问题：</strong></p>
<blockquote>
<p>由于构造函数会将它的把内容创建在一个新的作用域内赋给实例，因此，同样功能的方法就会为每个实例新建一份。这样本应共有的方法一旦多起来，创建的对象实例一旦多起来，就会造成很大冗余，这就是方法无法复用的问题。而且你也看到了，假如父类是使用组合式创建对象（组合原型式和构造函数式），子类是无法继承父类的原型的，因此上面 <code>sub.sayName();</code> 才会抛出异常，因为subType中确实没有这个方法。</p>
</blockquote>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>由上面两种继承的方式可以看出： <strong>原型链继承</strong> 不能保证“私有”引用属性继续“私有”，但是 <strong>借调构造函数</strong> 可以；<strong>借调构造函数继承</strong> 不可以复用方法，但 <strong>原型链继承</strong> 可以。那么可以组合两种方式的长处，使用 <strong>原型链继承</strong> 继承共享属性和方法，使用 <strong>借调构造函数</strong> 继承“私有”属性。</p>
</blockquote>
<p> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">//公用方法和属性要定义后将父对象的实例赋值给SubType对象之后，不然会因为重写prototype而被“抹去”</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SuperType</span>;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;red&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ins2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins2.<span class="property">colors</span>);  <span class="comment">//&#x27;yellow&#x27;, &#x27;white&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>要理解组合继承是怎么工作的，要先知道一件事：js会先执行prototype的代码，再执行构造函数的代码。</strong><br>首先是执行 <strong>SubType.prototype &#x3D; new SuperType();</strong> 这句相当于给SubType的原型对象创建了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是涉及的主要部分</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">colors</span>: [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>],</span><br><span class="line">    [[prototype]]: <span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">//包含了SuperType的公有方法和属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在新建SubType对象实例 **var ins1 &#x3D; new SubType(‘a’, 18);**的时候调用构造函数，相当于给ins1对象创建“私有”属性： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我不太会表达下面属性是ins1独有的属性，姑且如下面这样写，但愿不会误导人</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>这些属性会屏蔽原型对象的同名属性，从而达到“私有”。</p>
<p> </p>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>通过封装一个函数来作为继承的媒介</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title function_">object</span>(person);</span><br><span class="line">anthorPerson.<span class="property">name</span> = <span class="string">&#x27;Annd&#x27;</span>;</span><br><span class="line">anthorPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Dda&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在ES5中添加Object.create()方法规范了这种继承，这个方法接受两个参数，一个是原型对象，第二个是需要新增的属性会方法[可选]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anthorPerson.<span class="property">name</span> = <span class="string">&#x27;Annd&#x27;</span>;</span><br><span class="line">anthorPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Dda&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> yetPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;issac&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Object.create()仅在IE9+支持，特别指出IE其他的浏览器就不说了</strong></p>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>寄生式继承是和原型式继承紧密相关的思路。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnthor</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title function_">object</span>(o);</span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi Issac&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;issac&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;Aye&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anthorPerson = <span class="title function_">createAnthor</span>(person);</span><br><span class="line">anthorPerson.<span class="title function_">sayHi</span>();  <span class="comment">//Hi Issac</span></span><br></pre></td></tr></table></figure>
<p><strong>寄生的精髓即在原有对象上进行扩展</strong></p>
<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<blockquote>
<p>在说组合继承的时候，已经说过超类是会被调用两次，“私有”属性的继承即通过对象实例的属性对原型对象的屏蔽，显然，原型对象中的“私有”属性是多余了。为解决中多余，提出了 <strong>寄生组合式继承</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    prototype.<span class="property">constructor</span> = superType;</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>));  <span class="comment">//打印一个0~10的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ins1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;issac1&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">ins1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins1.<span class="property">colors</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2838289-4d9d8877c8ca347b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以上代码的执行结果"></p>
</blockquote>
<p><strong>显然，使用寄生组合式继承仅仅调用了一次超类。<br>使用组合继承，会调用2次超类：<br>第一次，以超类的实例作为子类的原型对象（原型链式继承）；<br>第二次，创建子类的对象实例时调用子类构造函数，子类构造函数，通过借调构造函数继承调用超类的构造函数；<br> <br>寄生组合式继承是抹去上面说的第一次调用超类。它是通过直接将超类的原型对象赋值给子类的原型对象，然后子类在此基础上进行个扩充，这样就会不会触发到超类的构造函数。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>New操作符的机制与实现相同功能的方法</title>
    <url>/blog/resources/New%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%90%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">new操作符做了什么？</a><ul>
<li><a href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B">小结一下</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">实现一个new创建实例</a><ul>
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>先来看一个例子，分别用新旧方式创建类，并实例化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">fn</span> = <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="title class_">Bar</span>.<span class="property">fn</span> = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别创建两个类的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;isaac&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&#x27;isaac&#x27;</span>);</span><br></pre></td></tr></table></figure>
<img src="62819728-ddf24080-bb8b-11e9-8ebb-97522b8ce822.png" alt="New操作符的机制与实现相同功能的方法">

<p>首先，可以看输出结果。很明显两个实例的结构上是基本一致的，类比一下，你可以猜到新语法“class”的实现本质，当然class也确实是传统实现的语法糖。</p>
<p>所以，接下来直接使用Foo的定义方式作为例子讲。</p>
<p>再来看看定义一个类的时候我们做了什么：</p>
<ul>
<li>定义了一个构造函数，将需要属性赋值给了上下文（context，即上文的this）</li>
<li>定义了构造函数的属性prototype，将方法、属性挂载在这个prototype上。</li>
</ul>
<p>最后再对比下实例的结构：</p>
<p>你可以发现，传入Foo的实参被初始化到了对象的第一层属性上：</p>
<img src="62832611-9b039c00-bc63-11e9-9812-f76237cce809.png" alt="New操作符的机制与实现相同功能的方法">

<p><strong>说不准这就是构造函数做的事情：通过构造函数将传参，经过逻辑处理，然后初始化到实例上。</strong></p>
<p>在看输出结果，在<code>name</code>属性的下面还有一个<code>__proto__</code>属性，他是一个类对象的结构，你可以发现有两个成员是我们自己定义的：</p>
<blockquote>
<ol>
<li>fn</li>
<li>sayName</li>
</ol>
</blockquote>
<p>这两个属性都是我们在定义类的时候挂载到prototype上的。</p>
<p><strong>说不准这就是我们定义在Foo.prototype属性</strong></p>
<p>最后，我们根据上面两个猜想，再进行推断new做了什么事情：</p>
<ul>
<li>new通过构造函数创建了一个对象foo，并且通过构造函数的逻辑初始化了这个对象的基本成员；</li>
<li>new将foo的原型引用指向了Foo.prototype，从而连接好从<code>foo -&gt; Foo.prototype -&gt; Object.prototype</code>这条原型链。</li>
</ul>
<p>上面即是猜想也是实质，我不去证明，这不是我的主要想写的，我是想根据这个猜测去实现一个方法达到“new”的功能。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>javascript的类的实现分成两部分：</p>
<ul>
<li>Constructor（构造函数）</li>
<li>Proptotype（原型）</li>
</ul>
<p>实例化一个类的实例的本质是：</p>
<ul>
<li>创建一个对象，且在访问该对象成员时，可以向它类指向原型回溯；</li>
<li>对象的成员属性（包含方法）通过Constructor进行初始化；</li>
</ul>
<h1 id="实现一个new创建实例"><a href="#实现一个new创建实例" class="headerlink" title="实现一个new创建实例"></a>实现一个new创建实例</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据上面对new操作符的分析，我们可以这么做：</p>
<ol>
<li>创建一个对象；</li>
<li>将这个对象的原型引用（不是这个对象的原型，是一个内部属性<code>__proto__</code>指向）；</li>
<li>调用构造函数，将上下文（this）绑定到对象。</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li>使用<code>setPrototypeOf</code>实现原型指向</li>
</ul>
<p><code>setPrototypeOf</code>是ES6的新方法，具体实现其实就是对对象<code>__proto__</code>的修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">_ctx, _proto</span>) &#123;</span><br><span class="line">  _ctx.<span class="property">__proto__</span> = _proto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type"> Constructor </span>&#125; ctor 构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newIns</span>(<span class="params">ctor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ins = &#123;&#125;;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(ins, ctor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  ctor.<span class="title function_">apply</span>(ins, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = <span class="title function_">newInsOf</span>(<span class="title class_">Foo</span>, <span class="string">&#x27;isaac&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ins);</span><br></pre></td></tr></table></figure>

<img src="62832251-0cd8e700-bc5e-11e9-80c6-578eb9c982e7.png" alt="New操作符的机制与实现相同功能的方法">

<ul>
<li>通过<code>Object.create</code>“继承”类</li>
</ul>
<p><code>Object.create</code>是官方对原型式继承的内部实现，具体逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCreate</span>(<span class="params">prototype</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于原型式继承可参考: <a href="https://github.com/isaaxite/blog/issues/253#issuecomment-520214476">原型式继承</a></p>
<p><code>Object.create</code>不但创建了一个对象，并且设置了这个对象的<code>__proto__</code>指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newInsOf</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">const</span> ins = <span class="built_in">Object</span>.create(ctor.prototype);</span></span><br><span class="line"><span class="params">  ctor.apply(ins, <span class="built_in">Array</span>.prototype.slice.call(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ins;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>

<img src="62832679-d357aa00-bc64-11e9-9963-dd2741ad89f9.png" alt="New操作符的机制与实现相同功能的方法">

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>filter的实现原理</title>
    <url>/blog/resources/filter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#filter%E4%B8%80%E8%88%AC%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%89%E7%A7%8D">filter一般调用方式有三种</a></li>
<li><a href="#_f%E6%98%AF%E4%BB%80%E4%B9%88">_f是什么？</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用如下例子，说明<code>filter</code>作为html属性一部分或元素文本一部分的解析，以及vue对<code>filter</code>解析过程的详细实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:data-filter</span>=<span class="string">&quot;price|decimal(3)|format-unit|test&quot;</span>&gt;</span>&#123;&#123;price|decimal(3)|format-unit|test&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">methodA</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">curcoder</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;isaac&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">position</span>: <span class="string">&#x27;fe&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">email</span>: <span class="string">&#x27;isaacgun@outlook.com&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">price</span>: <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">filters</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">decimal</span>(<span class="params">val, count = <span class="number">2</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(val)) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> val;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(count) || count &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> val.<span class="title function_">toFixed</span>(count);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">formatUnit</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> [<span class="string">&#x27;￥&#x27;</span>, val].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Test</span>(val) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">334</span>, <span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> val;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">methodA</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> &#123; decimal &#125; = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">filters</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> num = <span class="title function_">decimal</span>(<span class="number">120</span>, <span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vm:&#x27;</span>, vm);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="filter一般调用方式有三种"><a href="#filter一般调用方式有三种" class="headerlink" title="filter一般调用方式有三种"></a>filter一般调用方式有三种</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ol>
<li>在双花括号中使用：<code>&lt;span&gt;&#123;&#123;price|unit&#125;&#125;&lt;/span&gt;</code>，在解析模板阶段，使用<code>parseText</code>进行解析；</li>
<li>在 <code>v-bind</code> 中使用：<code>&lt;span :data-format-price=&quot;price|unit&quot;&gt;&lt;/span&gt;</code>，在解析模板阶段，使用<code>processAttrs</code>进行解析；</li>
<li>在钩子或回调函数中使用：<code>this.$options.filters.unit(this.price)</code>。</li>
</ol>
<p>在<code>parseText</code>中解析</p>
<p>path: <code>vue/src/compiler/parser/text-parser.js:20</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `&lt;span&gt;&#123;&#123;price|unit&#125;&#125;&lt;/span&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseText</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">text</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">delimiters</span>?: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">TextParseResult</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tagRE = delimiters ? <span class="title function_">buildRegex</span>(delimiters) : defaultTagRE</span><br><span class="line">  <span class="keyword">if</span> (!tagRE.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((match = tagRE.<span class="title function_">exec</span>(text))) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">log</span>(match[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> exp = <span class="title function_">parseFilters</span>(match[<span class="number">1</span>].<span class="title function_">trim</span>())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: &quot;price|unit&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<code>processAttrs</code>中解析</p>
<p>path: <code>vue/src/compiler/parser/index.js:765</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `&lt;span :data-format-price=&quot;price|unit&quot;&gt;&lt;/span&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processAttrs</span> (<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, l = list.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    name = rawName = list[i].<span class="property">name</span></span><br><span class="line">    value = list[i].<span class="property">value</span></span><br><span class="line">    <span class="keyword">if</span> (dirRE.<span class="title function_">test</span>(name)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (bindRE.<span class="title function_">test</span>(name)) &#123; <span class="comment">// v-bind</span></span><br><span class="line">        name = name.<span class="title function_">replace</span>(bindRE, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, value)</span><br><span class="line">        value = <span class="title function_">parseFilters</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: &quot;price|unit&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，以上两种方式去解析filter文本，最后都是调用<code>parseFilters</code>对filter文本进行解析。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse `price|decimal(3)|format-unit|test`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseFilters</span> (<span class="params"><span class="attr">exp</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (filters) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filters.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      expression = <span class="title function_">wrapFilter</span>(expression, filters[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">log</span>(expression);</span><br><span class="line">  <span class="keyword">return</span> expression</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapFilter</span> (<span class="params"><span class="attr">exp</span>: <span class="built_in">string</span>, <span class="attr">filter</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> i = filter.<span class="title function_">indexOf</span>(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// _f: resolveFilter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;filter&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span>)`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = filter.<span class="title function_">slice</span>(<span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">const</span> args = filter.<span class="title function_">slice</span>(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;name&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span><span class="subst">$&#123;args !== <span class="string">&#x27;)&#x27;</span> ? <span class="string">&#x27;,&#x27;</span> + args : args&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: `_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))`</span></span><br></pre></td></tr></table></figure>
<p>filter文本最后解析完还是文本！是一串有函数和参数组成的字符串，其中比较突出的就是<code>_f</code>！<br>从<code>_f(&quot;decimal&quot;)(price,3)</code>就可以大致推断<code>_f</code>是一个工厂函数，用来生产filter函数，<code>_f(&quot;decimal&quot;)</code>应该就是获取<code>decimal</code>过滤器，<br>那么大概<code>_f(&quot;decimal&quot;)(price,3)</code>就是，调用<code>decimal</code>过滤器，传入参数<code>this.price,3</code>！</p>
<p>为什么最后解析出的只是一段函数调用的文本？</p>
<p>因为vue的视图渲染分成两步：a. 解析视图模板，生成用于渲染整个视图的函数文本；b. 将函数文本作为视图订阅器（render-watcher）的getter（用于获取watcher的值，watcher.value）。</p>
<p>可以直接打印一下例子中render-watcher的文本：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">template</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="title function_">log</span>(code.<span class="property">render</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># output:</span><br><span class="line"></span><br><span class="line">with(this)&#123;return _c(&#x27;main&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#x27;span&#x27;,&#123;attrs:&#123;&quot;data-filter&quot;:_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))&#125;&#125;,[_v(_s(_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))))])])&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见<code>_f(&quot;test&quot;)(_f(&quot;format-unit&quot;)(_f(&quot;decimal&quot;)(price,3)))</code>就被包含在其中！</p>
<h1 id="f是什么？"><a href="#f是什么？" class="headerlink" title="_f是什么？"></a>_f是什么？</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>上面推测<code>_f</code>是生产过滤器的工厂，具体看下这个<code>_f</code>是怎么来的！</p>
<p>全局搜索<code>._f</code>，可以在<code>vue/src/core/instance/render-helpers/index.js</code>找到下面的代码！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resolveFilter &#125; <span class="keyword">from</span> <span class="string">&#x27;./resolve-filter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">installRenderHelpers</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.<span class="property">_f</span> = resolveFilter</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向上回溯去找<code>installRenderHelpers</code>在哪里被调用！可以找到<code>renderMixin</code>！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderMixin</span> (<span class="params"><span class="title class_">Vue</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt;</span>) &#123;</span><br><span class="line">  <span class="comment">// install runtime convenience helpers</span></span><br><span class="line">  <span class="title function_">installRenderHelpers</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vue/src/core/instance/render-helpers/index.js</code>中向下寻找<code>resolveFilter</code>的本质逻辑！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identity, resolveAsset &#125; <span class="keyword">from</span> <span class="string">&#x27;core/util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for resolving filters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; id filter的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveFilter</span> (<span class="params"><span class="attr">id</span>: <span class="built_in">string</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>, <span class="string">&#x27;filters&#x27;</span>, id, <span class="literal">true</span>) || identity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve an asset.</span></span><br><span class="line"><span class="comment"> * This function is used because child instances need access</span></span><br><span class="line"><span class="comment"> * to assets defined in its ancestor chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveAsset</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">Object</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">type</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">id</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">warnMissing</span>?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> assets = options[<span class="keyword">type</span>]</span><br><span class="line">  <span class="comment">// check local registration variations first</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, id)) <span class="keyword">return</span> assets[id]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中划线转驼峰</span></span><br><span class="line">  <span class="keyword">const</span> camelizedId = <span class="title function_">camelize</span>(id)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开头大写化</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">PascalCaseId</span> = <span class="title function_">capitalize</span>(camelizedId)</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, <span class="title class_">PascalCaseId</span>)) <span class="keyword">return</span> assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fallback to prototype chain</span></span><br><span class="line">  <span class="comment">// 自然回溯原型链</span></span><br><span class="line">  <span class="keyword">const</span> res = assets[id] || assets[camelizedId] || assets[<span class="title class_">PascalCaseId</span>]</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warnMissing &amp;&amp; !res) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;Failed to resolve &#x27;</span> + <span class="keyword">type</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>) + <span class="string">&#x27;: &#x27;</span> + id,</span><br><span class="line">      options</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看<code>_f(&quot;decimal&quot;)</code>，即是<code>resolveFilter (&quot;decimal&quot;)</code>,</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolveAsset(this.$options, &#x27;filters&#x27;, id, true)</span></span><br><span class="line"><span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>, <span class="string">&#x27;filters&#x27;</span>, <span class="string">&#x27;decimal&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>那么对于filter来说，xx的几个参数的意思：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveAsset</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">Object</span>,  <span class="comment">// this.$options</span></span></span><br><span class="line"><span class="params">  <span class="attr">type</span>: <span class="built_in">string</span>, <span class="comment">// &#x27;filters&#x27;</span></span></span><br><span class="line"><span class="params">  <span class="attr">id</span>: <span class="built_in">string</span>, <span class="comment">// &#x27;decimal&#x27;(过滤器名)</span></span></span><br><span class="line"><span class="params">  <span class="attr">warnMissing</span>?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>)</span><br></pre></td></tr></table></figure>
<p>那么<code>const assets = options[type]</code>中的assets就是filters，<code>return assets[id]</code>就是返回我们自己定义的filter-callback！</p>
<p><code>_f(&quot;decimal&quot;)</code>就返回decimal过滤器回调函数！</p>
<p>从上面<code>resolveAsset</code>的实现，可以看出，filter的使用方式可以兼容以下几种情况：</p>
<ol>
<li>正常调用，<code>&#123;&#123;price|formatUnit&#125;&#125;</code>；</li>
<li>中划线调用，单用驼峰法定义filter，<code>&#123;&#123;price|format-unit&#125;&#125;</code>；</li>
<li>小写开头调用，但定义时用开头大写，<code>&#123;&#123;price|test&#125;&#125;</code>，test对使用Test定义的filter有效；</li>
<li>自然回溯原型链，但对于filter作用不大，除非是与原型链上属性或函数同名！</li>
</ol>
<p>整个流程下来，可以发现：a. filter-callback没有使用bind绑定上下文；b. 没有直接挂在在vue实例上。</p>
<p>这也是有别于<code>methods</code>的不同，看<code>methods</code>的初始化就知道：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initMethods</span> (<span class="params"><span class="attr">vm</span>: <span class="title class_">Component</span>, <span class="attr">methods</span>: <span class="title class_">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span> ? noop : <span class="title function_">bind</span>(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter的特点</p>
<ol>
<li>filter不会被代理到vm实例上；      </li>
<li>filter不会绑定vm作为上下文。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ul>
<li>filter兼容的调用方式</li>
</ul>
<ol>
<li>正常调用，<code>&#123;&#123;price|formatUnit&#125;&#125;</code>；</li>
<li>中划线调用，单用驼峰法定义filter，<code>&#123;&#123;price|format-unit&#125;&#125;</code>；</li>
<li>小写开头调用，但定义时用开头大写，<code>&#123;&#123;price|test&#125;&#125;</code>，test对使用Test定义的filter有效；</li>
<li>自然回溯原型链，但对于filter作用不大，除非是与原型链上属性或函数同名！</li>
</ol>
<ul>
<li>filter的特点</li>
</ul>
<ol>
<li>filter不会被代理到vm实例上；     </li>
<li>filter不会绑定vm作为上下文。</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>vnode的内部实现</title>
    <url>/blog/resources/vnode%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>path: vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;vnode.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?<span class="built_in">string</span>; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">tag</span>?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">data</span>?: <span class="title class_">VNodeData</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">children</span>?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span></span><br><span class="line"><span class="params">    <span class="attr">text</span>?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">elm</span>?: <span class="title class_">Node</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">context</span>?: <span class="title class_">Component</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">componentOptions</span>?: <span class="title class_">VNodeComponentOptions</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">asyncFactory</span>?: <span class="title class_">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 标签名，小写</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标签上的属性数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 儿子虚拟节点（vnode）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真是元素的引用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点所在vue实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// v-for元素的key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncFactory</span> = asyncFactory</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncMeta</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAsyncPlaceholder</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get <span class="title function_">child</span> (): <span class="title class_">Component</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createEmptyVNode</span> = (<span class="params"><span class="attr">text</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">VNode</span>()</span><br><span class="line">  node.<span class="property">text</span> = text</span><br><span class="line">  node.<span class="property">isComment</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span> (<span class="params"><span class="attr">val</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optimized shallow clone</span></span><br><span class="line"><span class="comment">// used for static nodes and slot nodes because they may be reused across</span></span><br><span class="line"><span class="comment">// multiple renders, cloning them avoids errors when DOM manipulations rely</span></span><br><span class="line"><span class="comment">// on their elm reference.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cloneVNode</span> (<span class="params"><span class="attr">vnode</span>: <span class="title class_">VNode</span></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    vnode.<span class="property">tag</span>,</span><br><span class="line">    vnode.<span class="property">data</span>,</span><br><span class="line">    <span class="comment">// #7975</span></span><br><span class="line">    <span class="comment">// clone children array to avoid mutating original in case of cloning</span></span><br><span class="line">    <span class="comment">// a child.</span></span><br><span class="line">    vnode.<span class="property">children</span> &amp;&amp; vnode.<span class="property">children</span>.<span class="title function_">slice</span>(),</span><br><span class="line">    vnode.<span class="property">text</span>,</span><br><span class="line">    vnode.<span class="property">elm</span>,</span><br><span class="line">    vnode.<span class="property">context</span>,</span><br><span class="line">    vnode.<span class="property">componentOptions</span>,</span><br><span class="line">    vnode.<span class="property">asyncFactory</span></span><br><span class="line">  )</span><br><span class="line">  cloned.<span class="property">ns</span> = vnode.<span class="property">ns</span></span><br><span class="line">  cloned.<span class="property">isStatic</span> = vnode.<span class="property">isStatic</span></span><br><span class="line">  cloned.<span class="property">key</span> = vnode.<span class="property">key</span></span><br><span class="line">  cloned.<span class="property">isComment</span> = vnode.<span class="property">isComment</span></span><br><span class="line">  cloned.<span class="property">fnContext</span> = vnode.<span class="property">fnContext</span></span><br><span class="line">  cloned.<span class="property">fnOptions</span> = vnode.<span class="property">fnOptions</span></span><br><span class="line">  cloned.<span class="property">fnScopeId</span> = vnode.<span class="property">fnScopeId</span></span><br><span class="line">  cloned.<span class="property">asyncMeta</span> = vnode.<span class="property">asyncMeta</span></span><br><span class="line">  cloned.<span class="property">isCloned</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> cloned</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>nextTick实现原理</title>
    <url>/blog/resources/nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#nexttick%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">nextTick的实现逻辑</a></li>
<li><a href="#timerfunc%E6%98%AF%E4%BB%80%E4%B9%88">timerFunc是什么？</a></li>
<li><a href="#timerfunc%E7%9A%84%E5%AE%9E%E7%8E%B0">timerFunc的实现</a><ul>
<li><a href="#promise%E5%AE%9E%E7%8E%B0timerfunc">Promise实现timerFunc</a></li>
<li><a href="#mutationobserver%E5%AE%9E%E7%8E%B0timerfunc">MutationObserver实现timerFunc</a></li>
<li><a href="#setimmediate%E5%AE%9E%E7%8E%B0timerfunc">setImmediate实现timerFunc</a></li>
<li><a href="#settimeout%E5%AE%9E%E7%8E%B0timerfunc">setTimeout实现timerFunc</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>vue版本：<code>2.6.9</code>；</li>
<li>path：<code>vue/src/core/util/next-tick.js</code>；</li>
</ul>
<p>&nbsp;</p>
<h1 id="nextTick的实现逻辑"><a href="#nextTick的实现逻辑" class="headerlink" title="nextTick的实现逻辑"></a>nextTick的实现逻辑</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (<span class="params"><span class="attr">cb</span>?: <span class="title class_">Function</span>, <span class="attr">ctx</span>?: <span class="title class_">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入nextTick，首先会点cb进行封装，涉及三个控制流！</p>
<ol>
<li>如果存在cb，则调用cb函数：<code>cb.call(ctx)</code>；</li>
<li>如果<code>_resolve</code>存在，则调用 <code>_resolve(ctx)</code>，<code>_resolve</code>是<code>Promise.resolve</code>的引用！这是在当前环境支持<code>Promise</code>；</li>
<li>不做任何处理。</li>
</ol>
<p>在将<code>cb</code>推入<code>callbacks</code>后，判断当前是不是正在执行上次<code>callbacks</code>的回调函数，根据pending（待定）来判断，当前是否要执行新的<code>callbacks</code>的cb！</p>
<p>先假设当前<code>pending = fakse</code>，那么进入<code>if (!pending)</code>，执行<code>timerFunc()</code>！</p>
<p>&nbsp;</p>
<h1 id="timerFunc是什么？"><a href="#timerFunc是什么？" class="headerlink" title="timerFunc是什么？"></a>timerFunc是什么？</h1><p><code>timerFunc</code>，是一个可将当前<code>callbacks</code>作为一个回调函数（这个包裹的函数就是下面的<code>flushCallbacks</code>），入队微&#x2F;宏任务队列中，等待主线程代码执行完毕之后执行！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 立刻执行 “pending = false” 意味着，在主线程代码执行完，</span></span><br><span class="line">  <span class="comment">// 轮到当前这个 “flushCallbacks()” 被放入主线程执行开始</span></span><br><span class="line">  <span class="comment">// 就可以进入 &quot;if (!pending)&quot; 控制流再次执行触发 “timerFunc()”，</span></span><br><span class="line">  <span class="comment">// 将新的“flushCallbacks” 放进微/宏任务队列</span></span><br><span class="line">  <span class="comment">// 而不是等到 上一次 “callbacks” 的所有cb执行完之后</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>timerFunc</code>根据当前环境的支持情况可能用<code>Promise</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code>实现！优先级：<code>Promise</code> &gt; <code>MutationObserver</code> &gt; <code>setImmediate</code> &gt; <code>setTimeout</code>。</p>
<ul>
<li>微任务（micro task）：Promise、MutationObserver；</li>
<li>宏任务（macro task）：setImmediate、setTimeout。</li>
</ul>
<p>任务调用优先级：微任务 &gt; 宏任务。</p>
<p>关于为什么这样的优先级，vue做了说明：</p>
<blockquote>
<p>Here we have async deferring wrappers using microtasks. In 2.5 we used (macro) tasks (in combination with microtasks).However, it has subtle problems when state is changed right before repaint(e.g. #6813, out-in transitions).Also, using (macro) tasks in event handler would cause some weird behaviors that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109). So we now use microtasks everywhere, again.A major drawback of this tradeoff is that there are some scenarios where microtasks have too high a priority and fire in between supposedly sequential events (e.g. #4521, #6690, which have workarounds) or even between bubbling of the same event (#6566).</p>
<p>这里我们使用微任务异步延迟包装器。在2.5中，我们使用了（宏）任务（与微任务结合使用），但是当重新绘制之前状态发生改变时它存在一些细微的问题（例如＃6813，输出转换）。在事件处理程序中使用（宏）任务会导致一些无法避免的怪异行为（例如＃7109，＃7153，＃7546，＃7834，＃8109）。因此，我们现在再次在各处使用微任务。 是在某些情况下，微任务的优先级过高，并且在假定的顺序事件之间（例如＃4521，＃6690，它们具有变通方法）甚至在同一事件冒泡之间也会触发（＃6566）。</p>
</blockquote>
<p>&nbsp;</p>
<h1 id="timerFunc的实现"><a href="#timerFunc的实现" class="headerlink" title="timerFunc的实现"></a>timerFunc的实现</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br></pre></td></tr></table></figure>



<h3 id="Promise实现timerFunc"><a href="#Promise实现timerFunc" class="headerlink" title="Promise实现timerFunc"></a>Promise实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="comment">// 在有问题的UIWebViews中，Promise.then并不会完全中断，但是它可能会陷入一种怪异的状态，</span></span><br><span class="line">    <span class="comment">// 在这种状态中，回调被推送到微任务队列中，但是队列没有被刷新，直到浏览器需要执行其他一些工作，</span></span><br><span class="line">    <span class="comment">// 例如 处理一个计时器。 因此，我们可以通过添加空计时器来“强制”刷新微任务队列。</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MutationObserver实现timerFunc"><a href="#MutationObserver实现timerFunc" class="headerlink" title="MutationObserver实现timerFunc"></a>MutationObserver实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="comment">// 在本地Promise不可用的地方使用MutationObserver，</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// （＃6466 MutationObserver在IE11中不可靠）</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setImmediate实现timerFunc"><a href="#setImmediate实现timerFunc" class="headerlink" title="setImmediate实现timerFunc"></a>setImmediate实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  <span class="comment">// 退回到setImmediate。</span></span><br><span class="line">  <span class="comment">// 从技术上讲，它利用（宏）任务队列，</span></span><br><span class="line">  <span class="comment">// 但它仍然是比setTimeout更好的选择。</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setTimeout实现timerFunc"><a href="#setTimeout实现timerFunc" class="headerlink" title="setTimeout实现timerFunc"></a>setTimeout实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>v-for的原理分析</title>
    <url>/blog/resources/v-for%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#v-for%E7%9A%84%E5%87%BD%E6%95%B0%E6%96%87%E6%9C%AC">v-for的函数文本</a><ul>
<li><a href="#%E8%A7%A3%E6%9E%90%E5%87%BAast">解析出<code>ast</code></a></li>
<li><a href="#%E6%A0%B9%E6%8D%AEast%E8%A7%A3%E6%9E%90%E5%87%BA%E5%87%BD%E6%95%B0%E6%96%87%E6%9C%AC">根据ast解析出函数文本</a></li>
</ul>
</li>
<li><a href="#renderlist%E7%9A%84%E5%AE%9E%E7%8E%B0">renderList的实现</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>使用<code>parse</code>解析模板生成<code>ast</code>，<code>v-for</code>相关的属性；</li>
<li>使用<code>generate</code>，结合<code>ast</code>生成函数文本（<code>code</code>），包含<code>v-for</code>的函数文本是<code>_l(/* ... */)</code>;</li>
<li>结合<code>code</code>构造<code>render_watcher.update()</code>，从而渲染<code>v-for</code>元素。</li>
</ul>
<p>接下来使用一下例子结合源码进行学习：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">v-for</span>=<span class="string">&quot;(name, idx) in names&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;idx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">names</span>: [<span class="string">&#x27;isaac&#x27;</span>, <span class="string">&#x27;frank&#x27;</span>, <span class="string">&#x27;rick&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="v-for的函数文本"><a href="#v-for的函数文本" class="headerlink" title="v-for的函数文本"></a>v-for的函数文本</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p><strong>解析模板的入口</strong>：<code>vue/src/compiler/index.js</code></p>
<p><code>ast</code>由<code>parse</code>返回，所以先深入去parse是怎么生成<code>v-for</code>的<code>ast</code>!</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">template</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="comment">// parse 生产 ast</span></span><br><span class="line">  <span class="title function_">log</span>(<span class="string">&#x27;ast:&#x27;</span>, ast);</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// generate 生产 渲染用的函数文本</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="解析出ast"><a href="#解析出ast" class="headerlink" title="解析出ast"></a>解析出<code>ast</code></h2><p>解析视图模板主要由<code>parseHTML</code>函数实现，而这个函数是比较长，<code>parseHTML</code>对<code>v-for</code>相关信息的解析，先说明用到的函数，以及对应的作用：</p>
<ol>
<li><code>const startTagMatch = parseStartTag()</code>，parseStartTag是解析开始标签，主要是解析：a. 开始标签这段文本在整个html文本的开始和结束位置，b. 标签内的属性文本的位置，比如<code>v-for=&quot;(name, idx) in names&quot;</code>的开始和结束位置。</li>
<li><code>handleStartTag(startTagMatch)</code>，根据位置信息进一步接续出属性值，比如<code>&#123; name: &#39;v-for&#39;, value: &#39;(name, idx) in names&#39; &#125;</code>。<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert HTML string to AST.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">template</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ASTElement</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">start</span> (tag, attrs, unary, start, end) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">element</span>: <span class="title class_">ASTElement</span> = <span class="title function_">createASTElement</span>(tag, attrs, currentParent)</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;element:&#x27;</span>, element);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseHTML</span> (<span class="params">html, options</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (html) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Start tag: 记录属性文本在争端元素字符串开始和结束的位置</span></span><br><span class="line">    <span class="keyword">const</span> startTagMatch = <span class="title function_">parseStartTag</span>()</span><br><span class="line">    <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">      <span class="comment">// 根据 parseStartTag 解析出来的位置信息，进一步将文本解析成对象解构的属性</span></span><br><span class="line">      <span class="title function_">handleStartTag</span>(startTagMatch)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// advance(推进)，更新html文本</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">advance</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    index += n</span><br><span class="line">    html = html.<span class="title function_">substring</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 找出开始标签的start-index和end-index，</span></span><br><span class="line">  <span class="comment">// 比如&lt;span name=&quot;isaac&quot;&gt;&lt;/span&gt;中的开始标签就是&lt;span name=&quot;isaac&quot;&gt;</span></span><br><span class="line">  <span class="comment">// 2. 找出每个属性文本的始和终index</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">parseStartTag</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = html.<span class="title function_">match</span>(startTagOpen)</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;html.match(startTagOpen):&#x27;</span>, html);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      <span class="keyword">const</span> match = &#123;</span><br><span class="line">        <span class="attr">tagName</span>: start[<span class="number">1</span>],</span><br><span class="line">        <span class="attr">attrs</span>: [],</span><br><span class="line">        <span class="attr">start</span>: index</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">advance</span>(start[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">let</span> end, attr</span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        !(end = html.<span class="title function_">match</span>(startTagClose))</span><br><span class="line">        &amp;&amp; (</span><br><span class="line">          attr = html.<span class="title function_">match</span>(dynamicArgAttribute)</span><br><span class="line">          || html.<span class="title function_">match</span>(attribute)</span><br><span class="line">        )</span><br><span class="line">      ) &#123;</span><br><span class="line">        attr.<span class="property">start</span> = index</span><br><span class="line">        <span class="title function_">advance</span>(attr[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        attr.<span class="property">end</span> = index</span><br><span class="line">        match.<span class="property">attrs</span>.<span class="title function_">push</span>(attr)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (end) &#123;</span><br><span class="line">        match.<span class="property">unarySlash</span> = end[<span class="number">1</span>]</span><br><span class="line">        <span class="title function_">advance</span>(end[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        match.<span class="property">end</span> = index</span><br><span class="line">        <span class="keyword">return</span> match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 parseStartTag, 得到的文职信息，以及属性的匹配信息</span></span><br><span class="line">  <span class="comment">// 将属性信息从文本解析成对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStartTag</span> (<span class="params">match</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = match.<span class="property">attrs</span>[i]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">const</span> attrItem = &#123;</span><br><span class="line">        <span class="attr">name</span>: args[<span class="number">1</span>],</span><br><span class="line">        <span class="attr">value</span>: <span class="title function_">decodeAttr</span>(value, shouldDecodeNewlines)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;attrItem:&#x27;</span>, attrItem)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * it-1: &quot;attrItem:&quot; &#123;name: &quot;v-for&quot;, value: &quot;(name, idx) in names&quot;&#125;</span></span><br><span class="line"><span class="comment">       * it-2: &quot;attrItem:&quot; &#123;name: &quot;:key&quot;, value: &quot;idx&quot;&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      attrs[i] = attrItem;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log(&#x27;stack:&#x27;, JSON.parse(JSON.stringify(stack)));</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">start</span>) &#123;</span><br><span class="line">      <span class="title function_">log</span>(<span class="string">&#x27;attrs:&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(attrs)));</span><br><span class="line">      options.<span class="title function_">start</span>(tagName, attrs, unary, match.<span class="property">start</span>, match.<span class="property">end</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedAttr = <span class="regexp">/&amp;(?:lt|gt|quot|amp|#39);/g</span></span><br><span class="line"><span class="keyword">const</span> encodedAttrWithNewLines = <span class="regexp">/&amp;(?:lt|gt|quot|amp|#39|#10|#9);/g</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeAttr</span> (<span class="params">value, shouldDecodeNewlines</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">replace</span>(re, <span class="function"><span class="params">match</span> =&gt;</span> decodingMap[match])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p><code>log(&#39;attrs:&#39;, JSON.parse(JSON.stringify(attrs)));</code><br><img src="attrs.png"></p>
</li>
<li><p><code>log(&#39;element:&#39;, element)</code><br><img src="element.jpg"></p>
</li>
<li><p><code>log(&#39;ast:&#39;, ast)</code><br><img src="ast.jpg"></p>
</li>
</ul>
<h2 id="根据ast解析出函数文本"><a href="#根据ast解析出函数文本" class="headerlink" title="根据ast解析出函数文本"></a>根据ast解析出函数文本</h2><p>path: vue&#x2F;src&#x2F;compiler&#x2F;codegen&#x2F;index.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">generate</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">ast</span>: <span class="title class_">ASTElement</span> | <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">CodegenResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> <span class="title class_">CodegenState</span>(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? <span class="title function_">genElement</span>(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: state.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="params"><span class="attr">el</span>: <span class="title class_">ASTElement</span>, <span class="attr">state</span>: <span class="title class_">CodegenState</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> forCode = <span class="title function_">genFor</span>(el, state);</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;forCode&#x27;</span>, forCode);</span><br><span class="line">    <span class="comment">// output: &quot;forCode&quot; &quot;_l((names),function(name,idx)&#123;return _c(&#x27;dl&#x27;,&#123;key:idx&#125;,[_c(&#x27;dt&#x27;,[_v(&quot;name:&quot;)]),_v(&quot; &quot;),_c(&#x27;dd&#x27;,[_v(_s(name))])])&#125;)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> forCode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>path: vue&#x2F;src&#x2F;compiler&#x2F;codegen&#x2F;index.js</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genFor</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">el</span>: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">state</span>: <span class="title class_">CodegenState</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">altGen</span>?: <span class="title class_">Function</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">altHelper</span>?: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">...rest</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>(), <span class="string">`genFor-<span class="subst">$&#123;rest.shift()&#125;</span>`</span>, ...rest);</span><br><span class="line">  <span class="comment">// exp这名变量名也提醒我们：被遍历的目标，可以直接是变量名，也可以是一段可执行的语句</span></span><br><span class="line">  <span class="keyword">const</span> exp = el.<span class="property">for</span></span><br><span class="line">  <span class="comment">// 成员临时别名</span></span><br><span class="line">  <span class="keyword">const</span> alias = el.<span class="property">alias</span></span><br><span class="line">  <span class="comment">// &lt;div v-for=&quot;(value, name, index) in object&quot;&gt;，中的 name</span></span><br><span class="line">  <span class="keyword">const</span> iterator1 = el.<span class="property">iterator1</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator1&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// &lt;div v-for=&quot;(value, name, index) in object&quot;&gt;，中的 index</span></span><br><span class="line">  <span class="keyword">const</span> iterator2 = el.<span class="property">iterator2</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator2&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">  el.<span class="property">forProcessed</span> = <span class="literal">true</span> <span class="comment">// avoid recursion</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="string">`<span class="subst">$&#123;altHelper || <span class="string">&#x27;_l&#x27;</span>&#125;</span>((<span class="subst">$&#123;exp&#125;</span>),`</span> +</span><br><span class="line">    <span class="string">`function(<span class="subst">$&#123;alias&#125;</span><span class="subst">$&#123;iterator1&#125;</span><span class="subst">$&#123;iterator2&#125;</span>)&#123;`</span> +</span><br><span class="line">      <span class="comment">// genElement递归生成</span></span><br><span class="line">      <span class="string">`return <span class="subst">$&#123;(altGen || genElement)(el, state)&#125;</span>`</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">renderList</span>((names), <span class="keyword">function</span>(<span class="params">name,idx</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;dl&#x27;</span>, &#123;<span class="attr">key</span>:idx&#125;, [</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dt&#x27;</span>, [<span class="title function_">createTextVNode</span>(<span class="string">&quot;name:&quot;</span>)]),</span><br><span class="line">    <span class="title function_">createTextVNode</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dd&#x27;</span>, [<span class="title function_">createTextVNode</span>(<span class="title function_">toString</span>(name))])</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="renderList的实现"><a href="#renderList的实现" class="headerlink" title="renderList的实现"></a>renderList的实现</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<p>由上面知道最后<code>v-for</code>html段落最后被解析出来的函数文本：<br>解析v-for模板的函数文本</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">_l</span>((names), <span class="keyword">function</span>(<span class="params">name,idx</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;dl&#x27;</span>, &#123;<span class="attr">key</span>:idx&#125;, [</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dt&#x27;</span>, [<span class="title function_">_v</span>(<span class="string">&quot;name:&quot;</span>)]),</span><br><span class="line">    <span class="title function_">_v</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    <span class="title function_">_c</span>(<span class="string">&#x27;dd&#x27;</span>, [<span class="title function_">_v</span>(<span class="title function_">_s</span>(name))])</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>全局搜索一下<code>_l</code>就可以找到：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">installRenderHelpers</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.<span class="property">_l</span> = renderList</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderList函数是<code>vm._l</code>的实现，它的功能是遍历<code>v-for=&quot;item in list&quot;</code>中的list，list可以有多种不同的类型！注意遍历是这个函数功能，元素的渲染则是依赖renderList函数的第二个参数：<code>ender: (val: any, keyOrIndex: string | number, index?: number) =&gt; VNode</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, isDef, hasSymbol &#125; <span class="keyword">from</span> <span class="string">&#x27;core/util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for rendering v-for lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderList</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 遍历的目标</span></span></span><br><span class="line"><span class="params">  <span class="attr">val</span>: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="params">  <span class="attr">render</span>: (val: <span class="built_in">any</span>, keyOrIndex: <span class="built_in">string</span> | <span class="built_in">number</span>, index?: <span class="built_in">number</span>) =&gt; <span class="title class_">VNode</span></span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">ret</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;, i, l, keys, key</span><br><span class="line">  <span class="comment">// 1. 遍历一个数组</span></span><br><span class="line">  <span class="comment">// 2. 遍历一个字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) || <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="title class_">Array</span>(val.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      ret[i] = <span class="title function_">render</span>(val[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 3. 循环 val 次</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="title class_">Array</span>(val)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">      ret[i] = <span class="title function_">render</span>(i + <span class="number">1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 遍历一个对象</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isObject</span>(val)) &#123;</span><br><span class="line">    <span class="comment">// 4.1 遍历迭代器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下内置类型拥有默认的@<span class="doctag">@iterator</span>方法：</span></span><br><span class="line"><span class="comment">     *  Array.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  TypedArray.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  String.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  Map.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     *  Set.prototype[@<span class="doctag">@iterator</span>]()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (hasSymbol &amp;&amp; val[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]) &#123;</span><br><span class="line">      ret = []</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">iterator</span>: <span class="title class_">Iterator</span>&lt;<span class="built_in">any</span>&gt; = val[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">      <span class="keyword">let</span> result = iterator.<span class="title function_">next</span>()</span><br><span class="line">      <span class="keyword">while</span> (!result.<span class="property">done</span>) &#123;</span><br><span class="line">        ret.<span class="title function_">push</span>(<span class="title function_">render</span>(result.<span class="property">value</span>, ret.<span class="property">length</span>))</span><br><span class="line">        result = iterator.<span class="title function_">next</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.2 遍历常规对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="title class_">Array</span>(keys.<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = <span class="title function_">render</span>(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isDef</span>(ret)) &#123;</span><br><span class="line">    ret = []</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="attr">ret</span>: <span class="built_in">any</span>).<span class="property">_isVList</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以知道，<code>v-for</code>可以遍历以下几种类型</p>
<ol>
<li>遍历数组</li>
<li>遍历类数组的字符串</li>
<li>循环指定次数</li>
<li>遍历迭代器</li>
<li>遍历常规对象</li>
</ol>
<p>遍历迭代器可能用得比较少，下面有个不算很好的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>myIterable: <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in myIterable&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;: &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">myIterable</span>: (<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myIterable = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">yield</span> <span class="number">3</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> myIterable;</span></span><br><span class="line"><span class="language-javascript">      &#125;)()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>迭代器的详细分析参考：<a href="#">什么是迭代器？</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">start</span> (tag, attrs, unary, start, end) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">element</span>: <span class="title class_">ASTElement</span> = <span class="title function_">createASTElement</span>(tag, attrs, currentParent)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!element.<span class="property">processed</span>) &#123;</span><br><span class="line">      <span class="comment">// structural directives</span></span><br><span class="line">      <span class="title function_">processFor</span>(element)</span><br><span class="line">      <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<ul>
<li>v-for视图解析到渲染成html文段的过程</li>
</ul>
<ol>
<li>使用<code>parse</code>方法解析视图模板，生成ast，其中主要的三个函数是: a. parseStartTag解析属性等主要信息的位置，b. handleStartTag解析属性，c. createASTElement根据解析出的属性等生成元素的ast；</li>
<li>使用<code>generate</code>将ast转化成函数文本，<code>_l</code>（<code>renderlist</code>）即是<code>v-for</code>视图的文本函数，其中主要函数是<code>genElement</code>，可递归生成后代元素的函数文本；</li>
<li>函数文本作为render-watcher.update方法主逻辑</li>
</ol>
<ul>
<li>从<code>renderlist</code>中可以看出v-for可以遍历以下几种类型</li>
</ul>
<ol>
<li>遍历数组</li>
<li>遍历类数组的字符串</li>
<li>循环指定次数</li>
<li>遍历迭代器</li>
<li>遍历常规对象</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>多角度剖析计算属性的运行机制</title>
    <url>/blog/resources/%E5%A4%9A%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a><ul>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6">计算属性的更新机制</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%9A%E7%9F%A5%E5%8F%98%E5%8A%A8">如何通知变动</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E8%A2%AB%E6%9B%B4%E6%96%B0">计算属性如何被更新</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-1">小结</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96">计算属性如何收集依赖</a><ul>
<li><a href="#%E5%B0%8F%E7%BB%93-2">小结</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<span id="more"></span>

<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性的初始化过程"><a href="#计算属性的初始化过程" class="headerlink" title="计算属性的初始化过程"></a>计算属性的初始化过程</h1><p>在创建Vue实例时调用<code>this._init</code>初始化。</p>
<p>其中就有调用<code>initState</code>初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initState会初始化计算属性：调用<code>initComputed</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历computed</p>
<p>先创建计算属性的watcher实例，留意<code>computedWatcherOptions</code>这个option决定了计算属性的watcher和普通watcher的不同</p>
<p>然后定义计算属性的属性的getter和setter</p>
<ul>
<li>再来看看watcher的创建</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">expOrFn</span>: <span class="built_in">string</span> | <span class="title class_">Function</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">options</span>?: ?<span class="title class_">Object</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">isRenderWatcher</span>?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>watcher.lazy = true</code>;</li>
<li><code>watcher.dirty = true</code>;</li>
<li><code>watcher.getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get</code></li>
<li>不会在构造函数内调用watcher.get()&#96;(非计算属性的watcher&#x2F;lazy watcher会在创建watcher实例时调用)</li>
</ol>
<ul>
<li>再来看计算属性defineProperty的定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComputed</span> (<span class="params"></span></span><br><span class="line"><span class="params">  target: any,</span></span><br><span class="line"><span class="params">  key: string,</span></span><br><span class="line"><span class="params">  userDef: <span class="built_in">Object</span> | <span class="built_in">Function</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !<span class="title function_">isServerRendering</span>()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = shouldCache</span><br><span class="line">      ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">      : <span class="title function_">createGetterInvoker</span>(userDef)</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = userDef.<span class="property">get</span></span><br><span class="line">      ? shouldCache &amp;&amp; userDef.<span class="property">cache</span> !== <span class="literal">false</span></span><br><span class="line">        ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">        : <span class="title function_">createGetterInvoker</span>(userDef.<span class="property">get</span>)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = userDef.<span class="property">set</span> || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shouldCache</code>，浏览器渲染都是 <code>shouldCache = true</code></p>
<p>那么gtter就是由<code>createComputedGetter</code>方法创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">        watcher.<span class="title function_">evaluate</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        watcher.<span class="title function_">depend</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是计算属性的的初始化过程。</p>
<p>&nbsp;&nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性被访问时的运行机制"><a href="#计算属性被访问时的运行机制" class="headerlink" title="计算属性被访问时的运行机制"></a>计算属性被访问时的运行机制</h1><p>如上，假设计算属性当前被调用</p>
<p>就是触发计算属性的getter，再次强调：计算属性的getter不是用户定义的回调，而是由<code>createComputedGetter </code>返回的函数（详细参考<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a>的最后一段代码）。<br>用户定义的回调则是在计算属性getter的逻辑中进行调用。</p>
<p>计算属性getter中主要由两个if控制流，<br>这个两个if组合起来就可能由四种可能，<br>对于第二个控制流的逻辑<code>watcher.depend</code>，如果有看到Vue的Dep的功能的话，可以推测这段代码是用于收集依赖，<br>结合以上可以如下推测：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th><code>if (watcher.dirty)</code></th>
<th><code>if (Dep.target)</code></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>N</td>
<td>N</td>
<td>返回旧值</td>
</tr>
<tr>
<td>2</td>
<td>N</td>
<td>Y</td>
<td>收集依赖</td>
</tr>
<tr>
<td>3</td>
<td>Y</td>
<td>N</td>
<td>更新计算属性值（watcher.value）</td>
</tr>
<tr>
<td>4</td>
<td>Y</td>
<td>Y</td>
<td>收集依赖，并更新计算属性值（watcher.value）</td>
</tr>
</tbody></table>
<p>目前掌握的信息有：</p>
<ol>
<li>计算属性的getter是核心功能就是获取计算属性的值，而getter返回的是<code>watcher.value</code>，说明计算属性的值保存在<code>watcher.value</code>；</li>
<li>evaluate可能是用于更新watcher.value;</li>
<li>watcher.depend可能是用于收集依赖，不清楚收集什么；</li>
</ol>
<p>我们先来看第一个控制流：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watcher.dirty = true</span></span><br><span class="line"><span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">evaluate</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">计算属性的初始化过程</a>中创建计算属性watcher实例时就可以看出，第一次调用watcher.dirty肯定是<code>true</code>。</p>
<p>但不论watcher.dirty是不是“真”，我们都要去看看“evaluate ”时何方神圣，而且肯定会有访问它的时候。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">evaluate</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，evaluate确实是用于更新计算属性值（watcher.value）的。</p>
<p>另外，你可以发现在<code>this.value = this.get()</code>执行完后，还执行了一句代码：<code>this.dirty = false</code>。</p>
<p>然后你会发现一个逻辑：</p>
<ol>
<li>初始化计算属性时，watcher.dirty &#x3D; true；</li>
<li>执行evaluate更新后，watcher.dirty &#x3D; false；</li>
<li>watcher.dirty &#x3D; false 时不会去更新计算属性的值。</li>
</ol>
<p>一切说明计算属性是懒加载的，在访问时根据状态值来判断使用缓存数据还是重新计算。</p>
<p>再者，我们还可以再总结一下dirty和lazy的信息：</p>
<p>对比普通的watcher实例创建：</p>
<p>构造函数中的逻辑</p>
<table>
<thead>
<tr>
<th>normal</th>
<th>computed</th>
</tr>
</thead>
<tbody><tr>
<td><code>this.value = this.get()</code></td>
<td><code>this.value = undefined</code></td>
</tr>
<tr>
<td><code>this.lazy = false</code></td>
<td><code>this.lazy = true</code></td>
</tr>
<tr>
<td><code>this.dirty = false</code></td>
<td><code>this.dirty = true</code></td>
</tr>
</tbody></table>
<p> 综上，可以看出<br>lazy的意思</p>
<ul>
<li><p>实例化Watcher时调用get就是非lazy</p>
</li>
<li><p>非实例化Watcher时调用get就是lazy</p>
</li>
</ul>
<p>dirty（脏值）的意思</p>
<ul>
<li><code>watcher.value</code>还是<code>undefined（或者还不是最新值时）</code>就是dirty</li>
<li><code>watcher.value</code>已经存有当前计算的实际值就不是dirty</li>
</ul>
<p>lazy属性只是一个说明性的标志位，主要用来表明当前watcher是惰性模式的。<br>而dirty则是对lazy的实现，作为状态为表示当前是不是脏值状态。</p>
<p>再来看看<code>watcher.get()</code>的调用，其内部的动作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Dep</span>, &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">&#x27;./dep&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">get</span> () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在get()函数开头的地方调用<code>pushTarget</code>函数，为了接下来的内容，有必要先说明下<code>pushTarget</code>和结尾处的<code>popTarget</code>，根据字面意思就知道是对什么进行入栈出栈。</p>
<p>你可以看到是该方法来自于dep，具体函数实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="params">target: ?Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> (<span class="params"></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，pushTarget和popTarget操作的对象是Watcher，存放在全局变量<code>targetStack</code>中。每次出栈入栈都会更新Dep.target的值，而它值由上可知是targetStack的栈顶元素。</p>
<p>现在就知道<code>pushTarget(this)</code>的意思是：将当前的watcher入栈，并设置Dep.Target为当前watcher。</p>
<p>然后就是执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br></pre></td></tr></table></figure>

<p>计算属性watcher的getter是什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watcher.<span class="property">getter</span> = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="property">get</span></span><br></pre></td></tr></table></figure>

<p>是用户定义的回调函数，计算属性的回调函数。<br>回顾这一节开头的结论：</p>
<blockquote>
<p>用户定义的回调则是在计算属性getter的逻辑中进行调用。</p>
</blockquote>
<p>到此，我们就可以清晰知道：用户定义的getter是在computedWatcher.get()中调用！<br>用一段伪代码表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">computedGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  computedWatcher.<span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    computedWatcher.<span class="property">value</span> = computedWatcher.<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> 用户定义的<span class="title function_">getter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用完getter算是完事没有呢？没有，这里还有一层隐藏的逻辑！</p>
<p>我们知道一般计算属性都依赖于<code>$data</code>的属性，而调用计算属性的回调函数就会访问这些属性，就会触发这些属性的getter。</p>
<p>这些基础属性的getter就是隐藏的逻辑，如果你有看过基础属性的数据劫持就知道他们的getter都是有收集依赖的逻辑。</p>
<p>这些基本属性的getter都是在数据劫持的时候定义的，我们去看看会发生什么！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得刚刚调用了<code>pushTarget</code>吧，现在<code>Dep.target</code>已经不为空，并且<code>Dep.target</code>就是当前计算属性的watcher。</p>
<p>则会执行<code>dep.depend()</code>，dep是每个<code>$data</code>属性关联的（通过闭包关联）。</p>
<p>dep是依赖收集器，收集watcher，用一个数组（dep.subs）存放watcher，</p>
<p>而执行<code>dep.depend()</code>，除了执行其他逻辑，里面还有一个关键逻辑就是将<code>Dep.target</code>push到当前属性关联的dep.subs，言外之意就是，计算属性的访问在条件适合的情况下是会让计算属性所依赖的属性收集它的wathcer，而这个收集操作的作用且听下回分解。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>计算watcher.value：computed-watcher.evaluate()，访问计算属性时，若当前计算属性是脏值状态则调用evaluate计算计算属性的真实值；</li>
<li>在计算计算属性真实值时，合乎条件下会触发它依赖的基础属性收集它的watcher。</li>
</ol>
<p>&nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性的更新机制"><a href="#计算属性的更新机制" class="headerlink" title="计算属性的更新机制"></a>计算属性的更新机制</h1><h3 id="如何通知变动"><a href="#如何通知变动" class="headerlink" title="如何通知变动"></a>如何通知变动</h3><p>计算属性所依赖属性的dep收集computed-watcher的意义何在呢？</p>
<p>假如现在更新计算属性依赖的任一个属性，会发生什么？</p>
<p>更新依赖的属性，当然是触发对应属性的setter，首先来看看基础属性setter的定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dep.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先是在setter里面调用<code>dep.notify()</code>，通知变动。dep当然就是与属性关联的依赖收集器，notfiy必然是去通知订阅者它们订阅的数据之一已经发生变动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在notify方法里面可以看出，遍历了当前收集里面所有（订阅者）watcher，并且调用了他们的update方法。</p>
<p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>已经知道，计算属性的watcher是会被它所依赖属性的dep收集的。因此，<code>notify</code>中的<code>subs</code>肯定也包含了计算属性的watcher。</p>
<p>所以，计算属性所依赖属性变动是通过调用计算属性watcher的update方法通知计算属性的。</p>
<p>接下来，在深入去看看watcher.update是怎么更新计算属性的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">update</span> () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中就知道，计算属性watcher是lazy的，所以，comuptedWatcher.update的对应逻辑就是下面这一句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>再回想一下<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中计算属性getter调用evalute()的控制流逻辑（<code>if(watcher.dirty)</code>），这下计算属性的访问和他的被动更新就形成闭环！</p>
<p><strong>每次变化通知都是只更新脏值状态，真是计算还是访问的时候再计算</strong></p>
<h3 id="计算属性如何被更新"><a href="#计算属性如何被更新" class="headerlink" title="计算属性如何被更新"></a>计算属性如何被更新</h3><p>从上面我们就知道通知计算属性“变化”是不会直接引发计算属性的更新！</p>
<p>那么问题就来了，现实我们看到的是：绑定的视图上的计算属性的值，只要它所依赖的属性值更新，会直接响应到视图上。</p>
<p>那就说明在通知完之后，立即访问了计算属性，引起了计算属性值的更新，并且更新了视图。</p>
<p>对于，不是绑定在视图上的计算属性很好理解，毕竟我们也是在有需要的时候才会去访问他，相当于即时计算了（假如是脏值），因此不论是不是即时更新都无所谓，只要在访问时可以拿到最新的实际值就好。</p>
<p>但是对于视图却不一样，要即时反映出来，所以肯定是还有更新视图这一步的，我们现在需要做的测试找出vue是怎么做的。</p>
<p>其实假如你有去看过vue数据劫持的逻辑就知道：<strong>在访问属性时，只要当前的Dep.target（订阅者的引用）不为空，与这个属性关联的dep就会收集这个订阅者</strong></p>
<p>这个订阅者之一是“render-watcher”，它是视图对应的watcher，只要在视图上绑定了的属性都会收集这个render-watcher，所以每个属性的<code>dep.subs</code>都有一个render-watcher。</p>
<p>没错，就是这个render-watcher完成了对计算属性的访问与视图的更新。</p>
<p>到这里我们就可以小结一下计算属性对所依赖属性的响应机制：<br>所依赖属性更新，会通知该属性收集的所有watcher，调用update方法，其中就包含计算属性的watcher（computed-watcher），如果计算属性绑定在视图上，则还包含render-watcher，computed-watcher负责更新计算属性的脏值状态，render-watcher负责更新访问计算属性和更新视图。</p>
<p><strong>但是这里又引出了一个问题！</strong></p>
<p><em>假设现在计算属性就绑定在视图上，那么现在计算属性响应更新就需要两个watcher，分别是computed-watcher和render-watcher。</em></p>
<p><em>你细心点就会发现，要达到预期的效果，对这两个watcher.update()的调用顺序是有要求的！</em></p>
<p>必须要先调用computed-watcher.update()更新脏值状态，然后再调用render-watcher.update()去访问计算属性，才会去重新算计算属性的值，否者只会直接缓存的值watcher.value。</p>
<p>比如说有模板是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123; attr &#125;&#125;&lt;span&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123; computed &#125;&#125;&lt;span&gt;</span><br></pre></td></tr></table></figure>

<p>attr的dep.subs中的watcher顺序就是</p>
<p>情况1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[render-watcher, computed-watcher]</span><br></pre></td></tr></table></figure>

<p>反之就是</p>
<p>情况2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[computed-watcher, render-watcher]</span><br></pre></td></tr></table></figure>

<p>我们知道deo.notify的逻辑遍历调用subs里面的每个watcher.update</p>
<p>假如这个遍历的顺序是按照subs数组的顺序来更新的话，情况1就会有问题</p>
<p>情况1</p>
<p>是先触发视图watcher的更新，他会更新视图上所有绑定的属性，不论属性有没有更新过</p>
<p>然而此时<code>computed-watcher</code>的属性<code>dirty</code> 还是 <code>false</code>，这意味这着这个计算属性不会重新计算，而是使用已有的挂在<code>watcher.value</code>的旧值。</p>
<p>如果真是如此，之后在调用computred-watcher的update也没有意义了，除非重新调用render-watcher的update方法。</p>
<p>很明显，vue不可能那么蠢，肯定会做控制更新顺序的逻辑</p>
<p>我们看看notify方法的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">notify</span> (key) &#123;</span><br><span class="line">  <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">    <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到控制流里面确实做了顺序控制</p>
<p>但是<code>process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async</code> 的输出是false呢</p>
<p>很直观，在生成环境就进不了这个环境！</p>
<p>然而，现实表现出来的结果是，就算没有进入这个控制流里面，视图还是正确更新了</p>
<p>更令人惊异的是：更新的遍历顺序确实是按着<code>[render-watcher, computed-watcher]</code>进行的</p>
<p><img src="https://user-images.githubusercontent.com/25907273/62833220-cbe8ce80-bc6d-11e9-9d4b-47d855bead48.png" alt="image"></p>
<p>你可以看到是先遍历了<code>render-watcher</code>(render-watcher的id肯定是最大的，越往后创建的watcher的id越大，计算属性是在渲染前创建，而render-watcher则是在渲染时)</p>
<p>但是如果你细心的话你可以发现，render-watcher更新回调是在遍历完所有的watcher之后才执行的（白色框）</p>
<p><img src="https://user-images.githubusercontent.com/25907273/62833231-ee7ae780-bc6d-11e9-9904-5e14647aa79a.png" alt="image"></p>
<p>我们再来看看<code>watcher.update</code>的内部逻辑</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">update</span> () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;watcher.id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with lazy`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with sync`</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`update with queueWatcher`</span>)</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;update finish&#x27;</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="string">`this.dirty = <span class="subst">$&#123;<span class="variable language_">this</span>.dirty&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据打印的信息，可以看到render-watcher进入了else的逻辑，调用<code>queueWatcher(this)</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueWatcher</span> (<span class="params"><span class="attr">watcher</span>: <span class="title class_">Watcher</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;queueWatcher:&#x27;</span>, queue)</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">        <span class="title function_">flushSchedulerQueue</span>()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数名，可以知道是个watcher的队列</p>
<p>has是一个用于判断待处理watcher是否存在于队列中，并且在队中的每个watcher处理完都会将当前has[watcher.id] &#x3D; null</p>
<p>flushing这个变量是一个标记：是否正在处理队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">  queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">    i--</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是不同的将待处理watcher推入队列的方式。</p>
<p>然后接下来的逻辑，才是处理watcher队列</p>
<p><code>waitting</code>和<code>flushing</code>这两个标志标量大致相同，他们都会在watcher队列处理完之后重置为false</p>
<p>而不同的是waitting在最开始就会置为true，而flushing则是在调用<code>flushSchedulerQueue</code>函数的时候才会置为<code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br></pre></td></tr></table></figure>

<p>这一句是关键，nextTick，可以理解为一个微任务，即会在主线程任务调用完毕之后才会执行回调，</p>
<p>此时回调即是<code>flushSchedulerQueue</code>。</p>
<p>关于nextTick可以参考<a href="#">Vue：深入nextTick的实现</a></p>
<p>这样就可以解析：</p>
<blockquote>
<p>更令人惊异的是：更新的遍历顺序确实是按着<code>[render-watcher, computed-watcher]</code>进行的</p>
<p>但是如果你细心的话你可以发现，render-watcher更新回调是在遍历完所有的watcher之后才执行的（白色框）</p>
</blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>通过遍历调用dep.subs里的watcher.update方法（其中就包含computed-watcher）来通知计算属性基础属性已经更新，在下次访问计算属性时就是做脏值检测，然后重新计算计算属性。绑定在视图上的计算属性的即时更新是通过调用render-watcher的update方法达到，它会访问计算属性，并更新整个视图。</li>
<li>绑定在视图上的计算属性，它所依赖属性的dep.subs中，computed-watcher和render-watcher的顺序不会影响计算属性在视图上的正常更新，因为render-watcher的update方法的主体逻辑是放在微任务中执行，因此render-watcher.update()总是会在computed-watcher.update()之后执行。</li>
</ul>
<p>&nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="计算属性如何收集依赖"><a href="#计算属性如何收集依赖" class="headerlink" title="计算属性如何收集依赖"></a>计算属性如何收集依赖</h1><p>在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6">计算属性的更新机制</a>中我们知道了计算属性所依赖属性的dep是会收集computed-watcher的，目的是为了通知计算属性当前依赖的属性已经发生变化。</p>
<p><em>那么计算属性为什么要收集依赖？是如何收集依赖的？</em></p>
<p>“计算属性所依赖属性的dep具体怎么收集computed-watcher”并没有展开详细说。现在我们来详细看看这部分逻辑。那就必然要从第一次访问计算属性开始， 第一次访问必然会调用<code>watcher.evaluate</code>去算计算属性的值，那就是必然会调用<code>computed-watcher.get()</code>，然后在get方法里面去调用用户定义的回调函数，算计算属性的值，调用用户定义的回调函数就必然会访问计算属性所依赖属性，那就必然触发他们的getter，没错我们就是要从这里开始看详细的逻辑，也是从这里开始收集依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算属性依赖的属性通过<code>dep.depend()</code>收集<code>computed-watcher</code>，展开<code>dep.depend()</code>看看详细逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # dep.js</span></span><br><span class="line"><span class="title function_">depend</span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然现在的全局watcher就是computed-watcher，而<code>this</code>则是当前计算属性所依赖属性的dep（下面简称：<code>prop-dep</code>），继续展开<code>computed-watcher.addDep(prop-dep)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # watcher.js</span></span><br><span class="line"><span class="title function_">addDep</span> (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在dep收集watcher的之前（dep.addSub(this)），watcher也在收集dep。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`this.newDeps.push(dep)`</span></span><br></pre></td></tr></table></figure>

<p>watcher收集dep就是接下来我们要说的点之一！</p>
<p>另外，上面的代码中还包含了之前没见过的三个变量<code>this.newDepIds</code>，<code>this.newDeps</code>，<code>this.depIds</code></p>
<p>先看看他们的声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>depIds</code>和<code>newDepIds</code>都是Set的数据结构，结合<code>if (!this.newDepIds.has(id))</code>和<code>!this.depIds.has(id)</code>就可以推断他们的功能是防止重复操作的。</p>
<p>到此，我们知道了<em>计算属性是如何收集依赖的</em>！并且，从上面知道了所收集的依赖是不重复的。</p>
<p>但是，到这里还没有结束！</p>
<p>这个<code>newDeps</code>并不是最终存放存放点，真实的dep存放点是deps，在上面声明你就可以看见它。</p>
<p>在调用<code>computed-watcher.get()</code>的过程中还有一个比较关键的方法没有给出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span> () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 在最后调用</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形如其名，就是用来清除dep的，清除newDeps，并且转移newDeps到Deps上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">cleanupDeps</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 遍历deps，对比newDeps，看看哪些dep已经没有被当前的watcher收集</span></span><br><span class="line">  <span class="comment">// 如果没有，同样也解除dep对当前watcher的收集</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转存newDepIds到depIds</span></span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转存newDeps到Deps</span></span><br><span class="line">  tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行完<code>computed-watcher.get()</code>后的打印信息：<br><img src="https://user-images.githubusercontent.com/25907273/62833255-53ced880-bc6e-11e9-8c07-722e85c93e62.png"></p>
<p>从上面的分析我们可以知道：<em>计算属性的watcher会在计算值（watcher.evalute()）时，收集每个它依赖属性的dep，并最后存放在<code>watcher.deps</code>中</em></p>
<p>接下来再来探究<em>计算属性为什么要收集依赖</em>。</p>
<p>还记得计算属性的getter中的另一个控制流，一直没有展开细说。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">depend</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码可以知道，只有全局watcher（Dep.target）不为空，才会执行<code>watcher.depend()</code>，这就是要想的第一个问题：什么情况下全局watcher是不为空？</p>
<p>首先来确认下全局watcher的update机制：</p>
<ul>
<li>pushTarget和popTarget是成对出现的；</li>
<li>只有在watcher.get方法中才会入栈非空的watcher；</li>
<li>在执行watcher.get的开头pushTarget(this)，在结尾popTarget()，意味着在get方法调用完成后，全局watcher就变回调用get方法前的全局watcher。</li>
</ul>
<p>还记得computed的getter的逻辑吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">evaluate</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">  watcher.<span class="title function_">depend</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在脏值状态下会执行<code>watcher.evaluate()</code>，执行完已经完成watcher.get()的调用，所以watcher.evaluate不会影响到下面的<code>if (Dep.target)</code>判断。</p>
<p> pushTarget和popTarget是成对出现的，显然只有在调用完<code>pushTarget</code>后，且未调用popTarget这个时间段内调用计算属性才会执行<code>watcher.depend()</code>。另外，只有watcher.get()才会入栈非空的watcher，所以我们就可以再次缩小范围到：<em>在调用watcher.get()的过程中访问了计算属性</em>！</p>
<p>记得在<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%A2%AB%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">计算属性被访问时的运行机制</a>中有用表格对比过新建普通watcher和计算属性watcher实例的异同，其中普通watcher的创建就会在实例化的时候调用<code>this.get()</code>。</p>
<p>此刻让我想到了<code>render-watcher</code>，它就是一个普通的watcher，而且render-watcher是会访问绑定在视图上的所用属性，而且它访问视图上属性的过程就是在get方法里面的getter的调用中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span> () &#123;</span><br><span class="line">  <span class="comment">// 那么全局watcer就是render-watcher了</span></span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 视图上的所有属性都在getter方法被访问，包括计算属性</span></span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下展开watcher.depend看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">depend</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已经很明了，上面已经说过this.deps是计算属性收集的dep（它所依赖的dep），然后现在遍历deps，调用<code>dep.depend()</code>，上面也同样已经说过<code>dep.depend()</code>的功能是收集全局watcher。</p>
<p>所以，<code>watcher.depend()</code>的功能就是让计算属性收集的deps去收集当前的全局watcher。<br>而现在的全局watcher就是render-watcher！</p>
<p>现在我们知道<code>watcher.depend</code>的功能是让prop-dep去收集全局watcher，但是为什么要这么做？<br>不放将问题细化到render-watcher的场景上。为什么prop-watcher要去收集render-watcher？</p>
<p>首先，我要再次强调：<em>一个绑定在视图上的计算属性要即时响应所依赖属性的更新，那么这些依赖属性的dep.subs就必须包含<code>computed-watcher</code>和<code>render-watcher</code>，前者是用来更新计算属性的脏值状态，后者用来访问计算属性，让计算属性重新计算。并更新视图。</em></p>
<p>*计算属性所依赖属性的dep.subs中肯定会包含<code>computed-watcher</code>*，这一点不需要质疑，上面已经证明分析过！</p>
<p>但是，是否会包含<code>render-watcher</code>就不一定了！首先上面也有间接地提过，<em>绑定在视图上的属性，它的dep会收集到render-watcher</em>。那么，计算属性所依赖的属性，有可能存在一些是没有绑定在视图上，而是直接定义在<code>data</code>上而已，对于这些属性，它的dep.subs是肯定没有<code>render-watcher</code>的了。没有<code>render-watcher</code>意味着没有更新视图的能力。那么怎么办？那当然就是去保证它！</p>
<p>而<code>watcher.depend()</code>就起到了这个作用！它让计算属性所依赖的属性</p>
<p>对于这个推测</p>
<blockquote>
<p>绑定在视图上的属性，它的dep会收集到render-watcher</p>
</blockquote>
<p>我们可以探讨一下。</p>
<p>要一个vue.$data属性的dep去收集dep.subs没有的watcher需要具备两个条件：</p>
<ul>
<li>访问这个属性；</li>
<li>全局watcher（Dep.target）不为空;</li>
</ul>
<p>而没有绑定在视图上的属性，在render-watcher.get()调用的过程中就没有访问，没有访问就不会调用<code>dep.depend()</code>去收集<code>render-watcher</code>!</p>
<p>可能有人会问，在访问计算属性的时候不是有调用用户定义的回调吗？不就访问了这些依赖的属性？</p>
<p>是！确实是访问了，那个时候的Dep.target是computed-watcher。</p>
<p>ok，render-watcher这个场景也差不多了。我们该抽离表象看本质！</p>
<p>首先想想属性dep为什么要收集依赖（订阅者），因为有函数依赖了这个属性，希望这个属性在更新的时候通知订阅者。可以以此类比一下计算属性，计算属性的deps为什么需要收集依赖（订阅者），是不是也是因为有函数依赖了计算属性，希望计算属性在更新时通知订阅者，在想深一层：怎么样才算是计算属性更新？不就是它所依赖的属性发生变动吗？计算属性所依赖属性更新 &#x3D; 计算属性更新，计算属性更新就要通知依赖他的订阅者！再想想，计算属性所依赖属性更新就可以直接通知依赖计算属性的订阅者了，那么计算属性所依赖属性的dep直接收集依赖计算属性的订阅者就好了！这不就是<code>watcher.depend()</code>在做的事情吗？！</p>
<p>本质我们知道了，但是怎么才可以实现依赖计算属性！</p>
<p>首先全局watcher不为空！<br>怎么才会让Dep.target不为空！只有一个方法：调用<code>watcher.get()</code>，在vue里面只有这个方法会入栈非空的watcher，另外我们知道pushTarget和popTarget是成对出现的，即要在未调用popTarget前访问计算属性，怎么访问呢？pushTarget和popTarget分别在get方法的一头一尾，中间可以用户定义的只有一个地方！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span> () &#123;</span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">popTarget</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是getter，getter是可以由用户定义的~</p>
<p>再来getter具体存储的是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = noop</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由上可以知道，一个有效的getter是有expOrFn决定，expOrFn如果是<code>Function</code>则getter就是用户传入的函数！如果是<code>String</code>则由parsePath进行构造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个访问vm属性（包含计算属性）的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parsePath</span> (<span class="params">path: string</span>): any &#123;</span><br><span class="line">  <span class="comment">// 判断是否是一个有效的访问vm属性的路径</span></span><br><span class="line">  <span class="keyword">if</span> (bailRE.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，我们有两种手段可以让getter访问计算属性：<br>并且在此我不做说明，直接说结论，watch一个属性（包含计算属性），包括使用<code>$watch</code>都是会创建一个watcher实例的，而且是普通的watcher，即会在构造函数直接调用<code>watcher.get()</code>。</p>
<ul>
<li><p>直接watch计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;isaac&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">msg</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">msg</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this is computed property <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这种方法就是在创建实例时传进了一个路径，这个路径就是<code>msg</code>，即expOrFn是<code>String</code>，然后由<code>parsePath</code>构造getter，从而访问到计算属性。</p>
</li>
<li><p>使用<code>$watch</code>监听一个函数，函数中包含计算属性<br>$watch的用法可以参考<a href="https://cn.vuejs.org/v2/api/#vm-watch">vm.$watch</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">msg</span>;</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this is computed property <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法直接就传入一个函数，即expOrFn是<code>Function</code>，就是<code>$watch</code>的第一个参数！同样在getter中访问了计算属性。</p>
</li>
</ul>
<p>上面两种都是在getter中访问了计算属性，从而让deps收集订阅者，计算属性的变动（当然并非真的更新了值，只是进入脏值状态）就会通知依赖他的订阅者，调用<code>watcher.update()</code>，如果没有传入什么特殊的参数，就会调用watch的回调函数，如果在回调函数中有访问计算属性就会重新计算计算属性，更新状态为非脏值！</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>计算属性所依赖的属性的dep会收集computed-watcher，存放在<code>prop-dep.subs</code>中；</li>
<li>computed-watcher也会收集它所依赖的dep，存放在<code>computed-watcher.deps</code>中，为了确保计算属性获得通知依赖他的订阅者可以监听到他的变化，通过<code>watcher.depend()</code>来收集依赖它的订阅者。</li>
</ul>
<p>&nbsp;</p>
<p><a href="#%E5%A4%A7%E7%BA%B2">回到顶部</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>计算属性在initState阶段初始化；</li>
<li>计算属性也是会使用defineProperty进行计算属性劫持；</li>
<li>每个计算属性都会关联一个特殊的watcher（lazy）。存放在一个对象中，以计算属性的名字作为键值，挂载在vm._computedWatchers_；</li>
<li>通过让计算属性所依赖属性的dep收集计算属性watcher的行为实现“依赖属性的变动通知计算属性”；</li>
<li>计算属性的watcher是lazy的，不会在创建实例时计算自身的值（即不会调用watcher.get()）；</li>
<li>计算属性是lazy的，调用计算属性的watcher.update不会直接计算值，只是更新标志位（this.dirty &#x3D; true），直到计算属性被访问才会计算值；</li>
<li>dep（依赖收集器）会收集watcher（订阅者），watcher也会收集dep；</li>
<li>计算属性通过watcher.value对其值进行缓存，不会每次访问都从新计算；</li>
<li>计算属性通过<code>watcher.depend()</code>来收集依赖它的订阅者</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数组变异方法的实现原理</title>
    <url>/blog/resources/%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>path: vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;array.js</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// 原型式继承数组原型对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object.create(arrayProto)的操作等同于下面的操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * arrayMethods = &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * Object.setPrototypeOf(arrayMethods, arrayProto);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给 arrayMethods 变异方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// def，使用defineProperty是定对象属性的value</span></span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 指定上下文调用原始的数组方法</span></span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line"></span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">      <span class="comment">// 若有新增元素，则需要对新增元素进行观察，劫持</span></span><br><span class="line">      ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 既然对象成员个数新增，就需要通知订阅者，当前它依赖的数据已经发生变动</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">def</span> (<span class="params">obj: <span class="built_in">Object</span>, key: string, val: any, enumerable?: boolean</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整段代码执行下来，创建了一个对象arrayMethods，它的原型只想数组原型，并且它有这么成员方法：’push’,<br> ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’！</p>
<p>很明显，这样还不够！这样还能直接通过vue数组实例的点操作符调用变异方法！还需要将这些挂在vue实例数组的原型链上！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"><span class="attr">value</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="comment">// 通过__proto__将数组的原型指向arrayMethods</span></span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有__proto__，说明不能通过__proto__设置原型指向！</span></span><br><span class="line">        <span class="comment">// 则直接将变异的数组方法作为OwnProperty直接挂载在数组上</span></span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在坚持数组时，会将arrayMethods，根据实际情况挂在到当前这个数组的原型链上！在可以设置原型执行时，直接改变当前数组原型指向，改为arrayMethods；否则，直接将arrayMethods的方法，复制到当前数组上，作为当前数组的成员方法！</p>
<p>回看上面的代码（这一处：<code>def(arrayMethods, method, function mutator (...args)</code>），在这一块代码可以发现<code>this.__ob__</code>！经过以上分析，我们知道arrayMethods最后会挂在到vue数组上，那么这个this指向的就是这个数组，那么<code>__ob__</code>应该就是在vue数组原型链上或数组ownProperties上的！</p>
<p>似曾相似，在哪里遇过~</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"><span class="attr">value</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Observer实例时，会将当前实例挂在到当前观察数据的<code>__ob__</code>上，对vue数组而言，这个被观察的数据就是它了！</p>
<p>既然<code>__ob__</code>是Observer实例，当然调用劫持数组的方法<code>ob.observeArray(inserted)</code>！这里插一句题外话，虽然新增元素是属于当前数组的，但还是在被劫持这个行为上，他们是相互独立的，所以这里就是不使用ob.ob.observeArray去劫持，而使用<code>inserted.forEach((item) =&gt; observe(it))</code>劫持也是可以的~</p>
<p>这里需要当前数组的<code>__ob__</code>，主要是为了通知到这个数组的订阅者！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>变异方法通过对数组原型方法的拦截对原有方法进行处理，拦截的方式分两种：1. 可以设置原型的情况下，通过改变vue数组的原型指向进行拦截；2. 1不可行的情况下，则在vue数组的ownProperties上创建同名成员方法拦截！</li>
<li>编译数组方法可以通知watche，是因为最后调用<code>ob.dep.notify()</code>，通知了订阅者，这就是本质区别；</li>
<li><code>ob.observeArray(inserted)</code>再次坚持新元素是为了让别的watcher可以订阅新属性。</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS(跨域资源共享)实现与session丢失解决方案详解</title>
    <url>/blog/resources/CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-%E5%AE%9E%E7%8E%B0%E4%B8%8Esession%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>跨域是什么？只要请求地址与当前地址的<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>其中一个不同都会引起跨域，这是由于浏览器的同源策略导致。</p>
<span id="more"></span>

<p><a href="https://www.zhihu.com/question/31459669">同源策略的存在意义</a></p>
<p>但有时候跨域又是难以避难，目前有很多跨域的方法：</p>
<ol>
<li>JSON-P(安全性不好)；</li>
<li>window.name + iframe(实现的方式恶心)；</li>
<li>window.postMessage(HTML5)；</li>
<li>proxy(麻烦的部署及维护)；</li>
<li>使用同域后端语言作为中转；</li>
<li>跨域资源共享;</li>
<li>…</li>
</ol>
<p>其中我实践过得有1、4、5、6，常用的是4，最近XXX的时候被问到CORS，引申出很多知识，比如其中问到了<strong>复杂请求和简单请求</strong>，我对CORS并没有太多深入，接下来你懂的……</p>
<p>CORS需要服务器端及客户端双方面的更改支持。本编主要基于js和php代码以及session机制介绍如何实现CORS跨域以及解决CORS后的session丢失问题。</p>
<p>以下是本次实现的前后端域名。观两端域名可知会引起跨域问题。</p>
<p>前端域名为：<code>http://dev.github.io</code>；</p>
<p>后端域名：<code>http://php.cn</code> 请求地址为：<code>http://php.cn/cors.php</code>。</p>
<h1 id="CORS的兼容性"><a href="#CORS的兼容性" class="headerlink" title="CORS的兼容性"></a>CORS的兼容性</h1><ul>
<li>Chrome 3+</li>
<li>Firefox 3.5+</li>
<li>Opera 12+</li>
<li>Safari 4+</li>
<li>Internet Explorer 8+</li>
</ul>
<p>#CORS实现跨域</p>
<ul>
<li><p>客服端（Client）</p>
<p>封装一个ajax函数：</p>
<p>path：<code>http://dev.github.io/index.html</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">sender</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">&quot;http://php.cn/cors.php?fn=&quot;</span> + sender.<span class="property">url</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;withCredentials&quot;</span> <span class="keyword">in</span> xhr) &#123;</span><br><span class="line">        <span class="comment">// &quot;withCredentials&quot;属性只存在于XMLHttpRequest2对象中</span></span><br><span class="line">        <span class="comment">// Chrome, Firefox, Opera and Safari</span></span><br><span class="line">        xhr.<span class="title function_">open</span>(sender.<span class="property">method</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">XDomainRequest</span> != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// XDomainRequest对象，兼容IE</span></span><br><span class="line">        xhr = <span class="keyword">new</span> <span class="title class_">XDomainRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(sender.<span class="property">method</span>, url);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sender.<span class="property">header</span>) &#123;</span><br><span class="line">        xhr[key] = sender.<span class="property">header</span>[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> responseText = xhr.<span class="property">responseText</span>;</span><br><span class="line">        sender.<span class="property">callback</span> &amp;&amp; sender.<span class="title function_">callback</span>(responseText);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起一个get请求：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/getData&#x27;</span>,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="keyword">function</span>(<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
<li><p>服务端（Server）</p>
<p>path：<code>http://php.cn/cors.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: *&#x27;);</span></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: http://dev.github.io&#x27;);</span></span><br><span class="line"><span class="variable">$fn</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] ? <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] : <span class="string">&#x27;getData&#x27;</span>;</span><br><span class="line"><span class="variable">$fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnAjax</span>(<span class="params"><span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&quot;getData&quot;</span></span><br><span class="line">	));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备代码写完，先发起一个请求测试：</p>
<p>抛出以下异常</p>
<blockquote>
<p><code>Failed to load http://php.cn/cors.php?fn=getData: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://dev.github.io&#39; is therefore not allowed access.</code></p>
</blockquote>
<p>大致意思就是响应报文中没有指定当前域为可跨域域名。</p>
<p>CORS怎么解决，也是很简单：</p>
<p>回看刚刚的php代码，你发现两行注释代码，取消任意一行都可以解决以上异常</p>
<ul>
<li>使用通配符，表示允许任何来源域名进行跨域；</li>
<li>也可以指定来源域名，比如第二行。</li>
</ul>
<p><strong>ok，取消第一行注释，来实践一下：</strong><br><img src="01.png"><br><img src="02.png"></p>
<p><strong>这就这么简单，关键是服务端向响应报文的消息头中指定可进行跨域的源域名</strong></p>
</li>
</ul>
<h1 id="CORS后出现session丢失问题"><a href="#CORS后出现session丢失问题" class="headerlink" title="CORS后出现session丢失问题"></a>CORS后出现session丢失问题</h1><p>先简单介绍一下session机制：</p>
<p>服务端建立session，比如php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>建立session后，session保存的到服务端，生成一个sessionId以cookie形式保存到客户端。</p>
<p>当下一次访问的时候，保存在浏览器cookie的sessionId会被带在请求头中，服务端就会根据请求头中的sessionId去服务端获取对应的sessionId</p>
<p>然后，再来说一下CORS后出现session丢失问题，为什么会出现呢？</p>
<p>这就需要说一下<code>Access-Control-Allow-Credentials</code></p>
<blockquote>
<p><strong>Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
</blockquote>
<p>CORS后默认是不会发送cookie的，在看上面说到的session机制，最后一步是需要发送sessionId的cookie到服务端的，服务端才能获取到对应的session，这就是session丢失的原因。</p>
<p>既然知道原因，那么就好办了！</p>
<p>如上引用中写到，需要服务端向响应头中设置Access-Control-Allow-Credentials为true才能允许浏览器向服务器发送cookie。</p>
<p>另外，在浏览器端也是需要在AJAX请求中打开<code>withCredentials</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>注意：必须浏览器端将<code>withCredentials</code>设为<code>true</code>和服务端将<code>Access-Control-Allow-Credentials</code>设为<code>true</code>才能达到预期效果</p>
<p>ok，现在再来实践一下，首先先做一下代码准备：</p>
<p>html:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/getData&#x27;</span>,</span><br><span class="line">        <span class="attr">header</span>: &#123;</span><br><span class="line">            <span class="attr">withCredentials</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setSession</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/setSession&#x27;</span>,</span><br><span class="line">        <span class="attr">callback</span>: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先发送请求建立一个session，然后在发送一个请求获取刚刚建立的session，若果不为空即session没有丢失</span></span><br><span class="line"><span class="title function_">setSession</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">getData</span>(<span class="keyword">function</span>(<span class="params">resp</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>php：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// header(&#x27;Access-Control-Allow-Origin: *&#x27;);</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin: http://dev.github.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fn</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] ? <span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>] : <span class="string">&#x27;getData&#x27;</span>;</span><br><span class="line"><span class="variable">$fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnAjax</span>(<span class="params"><span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Credentials: true&quot;</span>); </span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&quot;getData&quot;</span>,</span><br><span class="line">		<span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">	));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSession</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">returnAjax</span>(<span class="keyword">array</span>(</span><br><span class="line">		<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;setSession&#x27;</span></span><br><span class="line">	));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，现在来执行一下</p>
<p><img src="03.png"></p>
<p><img src="04.png"></p>
<p>如上，发送第一个请求php代码建立的一个session</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;isaac&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>发送第二个请求，获取该session，并且如上图，确实返回了该session保存的值。</p>
<p>对比第一次实现CORS，你会发现第二次实现CORS的时候，在服务端，没有再用通配符<code>*</code>来配置<code>Access-Control-Allow-Origin</code>而是直接指定为：<code>http://dev.github.io</code>，这也是一个注意点，要发送cookie就必须明确指明可跨域域名，不可以使用通配符，不然则会抛出如下异常：</p>
<blockquote>
<p><code>Failed to load http://php.cn/cors.php?fn=getData: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. Origin &#39;http://dev.github.io&#39; is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</code></p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看得多了，不如试试？！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CORS</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>$set和$del和方法的实现原理</title>
    <url>/blog/resources/$set%E5%92%8C$del%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li><a href="#%E5%A4%A7%E7%BA%B2">大纲</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#nexttick%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91">nextTick的实现逻辑</a></li>
<li><a href="#timerfunc%E6%98%AF%E4%BB%80%E4%B9%88">timerFunc是什么？</a></li>
<li><a href="#timerfunc%E7%9A%84%E5%AE%9E%E7%8E%B0">timerFunc的实现</a><ul>
<li><a href="#promise%E5%AE%9E%E7%8E%B0timerfunc">Promise实现timerFunc</a></li>
<li><a href="#mutationobserver%E5%AE%9E%E7%8E%B0timerfunc">MutationObserver实现timerFunc</a></li>
<li><a href="#setimmediate%E5%AE%9E%E7%8E%B0timerfunc">setImmediate实现timerFunc</a></li>
<li><a href="#settimeout%E5%AE%9E%E7%8E%B0timerfunc">setTimeout实现timerFunc</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>vue版本：<code>2.6.9</code>；</li>
<li>path：<code>vue/src/core/util/next-tick.js</code>；</li>
</ul>
<p>&nbsp;</p>
<h1 id="nextTick的实现逻辑"><a href="#nextTick的实现逻辑" class="headerlink" title="nextTick的实现逻辑"></a>nextTick的实现逻辑</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (<span class="params"><span class="attr">cb</span>?: <span class="title class_">Function</span>, <span class="attr">ctx</span>?: <span class="title class_">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入nextTick，首先会点cb进行封装，涉及三个控制流！</p>
<ol>
<li>如果存在cb，则调用cb函数：<code>cb.call(ctx)</code>；</li>
<li>如果<code>_resolve</code>存在，则调用 <code>_resolve(ctx)</code>，<code>_resolve</code>是<code>Promise.resolve</code>的引用！这是在当前环境支持<code>Promise</code>；</li>
<li>不做任何处理。</li>
</ol>
<p>在将<code>cb</code>推入<code>callbacks</code>后，判断当前是不是正在执行上次<code>callbacks</code>的回调函数，根据pending（待定）来判断，当前是否要执行新的<code>callbacks</code>的cb！</p>
<p>先假设当前<code>pending = fakse</code>，那么进入<code>if (!pending)</code>，执行<code>timerFunc()</code>！</p>
<p>&nbsp;</p>
<h1 id="timerFunc是什么？"><a href="#timerFunc是什么？" class="headerlink" title="timerFunc是什么？"></a>timerFunc是什么？</h1><p><code>timerFunc</code>，是一个可将当前<code>callbacks</code>作为一个回调函数（这个包裹的函数就是下面的<code>flushCallbacks</code>），入队微&#x2F;宏任务队列中，等待主线程代码执行完毕之后执行！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 立刻执行 “pending = false” 意味着，在主线程代码执行完，</span></span><br><span class="line">  <span class="comment">// 轮到当前这个 “flushCallbacks()” 被放入主线程执行开始</span></span><br><span class="line">  <span class="comment">// 就可以进入 &quot;if (!pending)&quot; 控制流再次执行触发 “timerFunc()”，</span></span><br><span class="line">  <span class="comment">// 将新的“flushCallbacks” 放进微/宏任务队列</span></span><br><span class="line">  <span class="comment">// 而不是等到 上一次 “callbacks” 的所有cb执行完之后</span></span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>timerFunc</code>根据当前环境的支持情况可能用<code>Promise</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code>实现！优先级：<code>Promise</code> &gt; <code>MutationObserver</code> &gt; <code>setImmediate</code> &gt; <code>setTimeout</code>。</p>
<ul>
<li>微任务（micro task）：Promise、MutationObserver；</li>
<li>宏任务（macro task）：setImmediate、setTimeout。</li>
</ul>
<p>任务调用优先级：微任务 &gt; 宏任务。</p>
<p>关于为什么这样的优先级，vue做了说明：</p>
<blockquote>
<p>Here we have async deferring wrappers using microtasks. In 2.5 we used (macro) tasks (in combination with microtasks).However, it has subtle problems when state is changed right before repaint(e.g. #6813, out-in transitions).Also, using (macro) tasks in event handler would cause some weird behaviors that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109). So we now use microtasks everywhere, again.A major drawback of this tradeoff is that there are some scenarios where microtasks have too high a priority and fire in between supposedly sequential events (e.g. #4521, #6690, which have workarounds) or even between bubbling of the same event (#6566).</p>
<p>这里我们使用微任务异步延迟包装器。在2.5中，我们使用了（宏）任务（与微任务结合使用），但是当重新绘制之前状态发生改变时它存在一些细微的问题（例如＃6813，输出转换）。在事件处理程序中使用（宏）任务会导致一些无法避免的怪异行为（例如＃7109，＃7153，＃7546，＃7834，＃8109）。因此，我们现在再次在各处使用微任务。 是在某些情况下，微任务的优先级过高，并且在假定的顺序事件之间（例如＃4521，＃6690，它们具有变通方法）甚至在同一事件冒泡之间也会触发（＃6566）。</p>
</blockquote>
<p>&nbsp;</p>
<h1 id="timerFunc的实现"><a href="#timerFunc的实现" class="headerlink" title="timerFunc的实现"></a>timerFunc的实现</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br></pre></td></tr></table></figure>



<h3 id="Promise实现timerFunc"><a href="#Promise实现timerFunc" class="headerlink" title="Promise实现timerFunc"></a>Promise实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="comment">// 在有问题的UIWebViews中，Promise.then并不会完全中断，但是它可能会陷入一种怪异的状态，</span></span><br><span class="line">    <span class="comment">// 在这种状态中，回调被推送到微任务队列中，但是队列没有被刷新，直到浏览器需要执行其他一些工作，</span></span><br><span class="line">    <span class="comment">// 例如 处理一个计时器。 因此，我们可以通过添加空计时器来“强制”刷新微任务队列。</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MutationObserver实现timerFunc"><a href="#MutationObserver实现timerFunc" class="headerlink" title="MutationObserver实现timerFunc"></a>MutationObserver实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="comment">// 在本地Promise不可用的地方使用MutationObserver，</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// （＃6466 MutationObserver在IE11中不可靠）</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setImmediate实现timerFunc"><a href="#setImmediate实现timerFunc" class="headerlink" title="setImmediate实现timerFunc"></a>setImmediate实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  <span class="comment">// 退回到setImmediate。</span></span><br><span class="line">  <span class="comment">// 从技术上讲，它利用（宏）任务队列，</span></span><br><span class="line">  <span class="comment">// 但它仍然是比setTimeout更好的选择。</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setTimeout实现timerFunc"><a href="#setTimeout实现timerFunc" class="headerlink" title="setTimeout实现timerFunc"></a>setTimeout实现timerFunc</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Nest如何实现装饰器的路由注册</title>
    <url>/blog/resources/%E6%B5%85%E6%9E%90Nest%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>在<code>nest</code>中你可以看到使用装饰器实现路由路径。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span>, <span class="title class_">Get</span>, <span class="title class_">Query</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ListAllEntities</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="title function_">findAll</span>(<span class="params"><span class="meta">@Query</span>() <span class="attr">query</span>: <span class="title class_">ListAllEntities</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns all cats (limit: <span class="subst">$&#123;query.limit&#125;</span> items)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>主要就是由<code>Controller</code>和其他<code>http-method</code>装饰器。而实际的路由路径是：</p>
<p>全局前缀（可选） + Controller装饰器的文本参数（可选） + http-method装饰器文本参数（可选）</p>
<h1 id="存储路径数据"><a href="#存储路径数据" class="headerlink" title="存储路径数据"></a>存储路径数据</h1><h2 id="Controller前缀的保存"><a href="#Controller前缀的保存" class="headerlink" title="Controller前缀的保存"></a>Controller前缀的保存</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Controller</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">prefixOrOptions</span>?: <span class="built_in">string</span> | <span class="title class_">ControllerOptions</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ClassDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultPath = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> [path, scopeOptions] = <span class="title function_">isUndefined</span>(prefixOrOptions)</span><br><span class="line">    ? [defaultPath, <span class="literal">undefined</span>]</span><br><span class="line">    : <span class="title function_">isString</span>(prefixOrOptions)</span><br><span class="line">    ? [prefixOrOptions, <span class="literal">undefined</span>]</span><br><span class="line">    : [prefixOrOptions.<span class="property">path</span> || defaultPath, &#123; <span class="attr">scope</span>: prefixOrOptions.<span class="property">scope</span> &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">target</span>: <span class="built_in">object</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, target);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">SCOPE_OPTIONS_METADATA</span>, scopeOptions, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Controller</code>装饰器工厂中，首先是获取了path, scopeOptions，然后返回了一个装饰器函数。这个函数主要是保存工厂函数的参数。<br>这里用到了<a href="https://github.com/rbuckton/reflect-metadata"><code>Reflect</code></a>，是一个用来存取元数据的库，数据结构主要是Map和WeakMap。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, target);</span><br></pre></td></tr></table></figure>
<p>将path这个数据<code>WeakMap/target/PATH_METADATA</code>中。所以取的时候也需要<code>target</code>, <code>PATH_METADATA</code>。</p>
<h2 id="http-method前缀的保存"><a href="#http-method前缀的保存" class="headerlink" title="http-method前缀的保存"></a>http-method前缀的保存</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultMetadata = &#123;</span><br><span class="line">  [<span class="variable constant_">PATH_METADATA</span>]: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  [<span class="variable constant_">METHOD_METADATA</span>]: <span class="title class_">RequestMethod</span>.<span class="property">GET</span> <span class="comment">/* GET: 0 */</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">RequestMapping</span> = (</span><br><span class="line">  <span class="attr">metadata</span>: <span class="title class_">RequestMappingMetadata</span> = defaultMetadata,</span><br><span class="line">): <span class="function"><span class="params">MethodDecorator</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pathMetadata = metadata[<span class="variable constant_">PATH_METADATA</span>];</span><br><span class="line">  <span class="keyword">const</span> path = pathMetadata &amp;&amp; pathMetadata.<span class="property">length</span> ? pathMetadata : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> requestMethod = metadata[<span class="variable constant_">METHOD_METADATA</span>] || <span class="title class_">RequestMethod</span>.<span class="property">GET</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key, <span class="attr">descriptor</span>: <span class="title class_">PropertyDescriptor</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, descriptor.<span class="property">value</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">METHOD_METADATA</span>, requestMethod, descriptor.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createMappingDecorator</span> = (<span class="params"><span class="attr">method</span>: <span class="title class_">RequestMethod</span></span>) =&gt; (</span><br><span class="line">  <span class="attr">path</span>?: <span class="built_in">string</span> | <span class="built_in">string</span>[],</span><br><span class="line">): <span class="function"><span class="params">MethodDecorator</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">RequestMapping</span>(&#123;</span><br><span class="line">    [<span class="variable constant_">PATH_METADATA</span>]: path,</span><br><span class="line">    [<span class="variable constant_">METHOD_METADATA</span>]: method,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Get</span> = <span class="title function_">createMappingDecorator</span>(<span class="title class_">RequestMethod</span>.<span class="property">GET</span>);</span><br></pre></td></tr></table></figure>

<p>上面以<code>@Get()</code>装饰器的实现为例。和<code>@Controller</code>的实现大同小异，最终都是将工厂函数的参数使用<code>Reflect</code>保存起来，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, path, descriptor.<span class="property">value</span>);</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="variable constant_">METHOD_METADATA</span>, requestMethod, descriptor.<span class="property">value</span>);</span><br></pre></td></tr></table></figure>
<p>分别将请求方法和路径保存了起来。</p>
<p>这里就有个问题：为什么要先保存这些路由数据，而不是直接使用？</p>
<p>首先，装饰器实际发挥作用的阶段是紧接着类声明之后，立即就执行装饰器函数。而业务逻辑是在访问路由之后才会被触发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>使用Reflect存放元数据，Reflect由一个外部库<a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a>实现；</li>
<li>target(类的引用，也可以说是构造函数)&#x2F;PATH_METADATA存放<code>Controller</code>部分的路径数据；</li>
<li>descriptor.value（成员方法的引用，即方法本身）&#x2F;PATH_METADATA存放，存放剩余的http-method部分的路径数据；</li>
</ul>
<h1 id="组合路由的路径数据"><a href="#组合路由的路径数据" class="headerlink" title="组合路由的路径数据"></a>组合路由的路径数据</h1><p>下面我们来看nest怎么组合分散的路由路径<code>path</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title function_">registerRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">registerMiddleware</span>(<span class="variable language_">this</span>.<span class="property">httpAdapter</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prefix = <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>();</span><br><span class="line">  <span class="keyword">const</span> basePath = <span class="title function_">validatePath</span>(prefix);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">routesResolver</span>.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">httpAdapter</span>, basePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，获取全局前缀，得到路径的最开头部分：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>() <span class="comment">// 全局前缀</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);  </span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> resolve&lt;T <span class="keyword">extends</span> <span class="title class_">HttpServer</span>&gt;(<span class="attr">applicationRef</span>: T, <span class="attr">basePath</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> modules = <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">getModules</span>();</span><br><span class="line">  modules.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; controllers, metatype &#125;, moduleName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = metatype</span><br><span class="line">      ? <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype)</span><br><span class="line">      : <span class="literal">undefined</span>;</span><br><span class="line">    path = path ? basePath + path : basePath;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">registerRouters</span>(controllers, moduleName, path, applicationRef);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里组合模块部分的路径:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype)  <span class="comment">// 模块部分的前缀</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Controller的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">registerRouters</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">routes</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">InstanceWrapper</span>&lt;<span class="title class_">Controller</span>&gt;&gt;,</span></span><br><span class="line"><span class="params">  <span class="attr">moduleName</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">basePath</span>: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">applicationRef</span>: <span class="title class_">HttpServer</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">instanceWrapper</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; metatype &#125; = instanceWrapper;</span><br><span class="line">    <span class="keyword">const</span> path = <span class="variable language_">this</span>.<span class="property">routerBuilder</span>.<span class="title function_">extractRouterPath</span>(</span><br><span class="line">      metatype <span class="keyword">as</span> <span class="title class_">Type</span>&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">      basePath,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> controllerName = metatype.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">logger</span>.<span class="title function_">log</span>(<span class="title function_">CONTROLLER_MAPPING_MESSAGE</span>(controllerName, path));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routerBuilder</span>.<span class="title function_">explore</span>(</span><br><span class="line">      instanceWrapper,</span><br><span class="line">      moduleName,</span><br><span class="line">      applicationRef,</span><br><span class="line">      path,</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">extractRouterPath</span>(</span><br><span class="line">  <span class="attr">metatype</span>: <span class="title class_">Type</span>&lt;<span class="title class_">Controller</span>&gt;,</span><br><span class="line">  <span class="attr">prefix</span>?: <span class="built_in">string</span>,</span><br><span class="line">): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype);</span><br><span class="line">  <span class="keyword">if</span> (prefix) path = prefix + <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(path);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合<code>Controller</code>部分的路由数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype)  <span class="comment">// Controller`部分的路由数据</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> explore&lt;T <span class="keyword">extends</span> <span class="title class_">HttpServer</span> = <span class="built_in">any</span>&gt;(</span><br><span class="line">  <span class="attr">instanceWrapper</span>: <span class="title class_">InstanceWrapper</span>,</span><br><span class="line">  <span class="attr">module</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">applicationRef</span>: T,</span><br><span class="line">  <span class="attr">basePath</span>: <span class="built_in">string</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; instance &#125; = instanceWrapper;</span><br><span class="line">  <span class="keyword">const</span> routerPaths = <span class="variable language_">this</span>.<span class="title function_">scanForPaths</span>(instance);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">applyPathsToRouterProxy</span>(</span><br><span class="line">    applicationRef,</span><br><span class="line">    routerPaths,</span><br><span class="line">    instanceWrapper,</span><br><span class="line">    <span class="variable language_">module</span>,</span><br><span class="line">    basePath,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">scanForPaths</span>(</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">Controller</span>,</span><br><span class="line">  <span class="attr">prototype</span>?: <span class="built_in">any</span>,</span><br><span class="line">): <span class="title class_">RoutePathProperties</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> instancePrototype = <span class="title function_">isUndefined</span>(prototype)</span><br><span class="line">    ? <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(instance)</span><br><span class="line">    : prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">metadataScanner</span>.<span class="property">scanFromPrototype</span>&lt;</span><br><span class="line">    <span class="title class_">Controller</span>,</span><br><span class="line">    <span class="title class_">RoutePathProperties</span></span><br><span class="line">  &gt;(instance, instancePrototype, <span class="function"><span class="params">method</span> =&gt;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">exploreMethodMetadata</span>(instance, instancePrototype, method),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">exploreMethodMetadata</span>(</span><br><span class="line">  <span class="attr">instance</span>: <span class="title class_">Controller</span>,</span><br><span class="line">  <span class="attr">instancePrototype</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">methodName</span>: <span class="built_in">string</span>,</span><br><span class="line">): <span class="title class_">RoutePathProperties</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> targetCallback = instancePrototype[methodName];</span><br><span class="line">  <span class="keyword">const</span> routePath = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, targetCallback);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndefined</span>(routePath)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">requestMethod</span>: <span class="title class_">RequestMethod</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(</span><br><span class="line">    <span class="variable constant_">METHOD_METADATA</span>,</span><br><span class="line">    targetCallback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> path = <span class="title function_">isString</span>(routePath)</span><br><span class="line">    ? [<span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(routePath)]</span><br><span class="line">    : routePath.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">validateRoutePath</span>(p));</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    path,</span><br><span class="line">    requestMethod,</span><br><span class="line">    targetCallback,</span><br><span class="line">    methodName,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是剩余的http-method部分路由数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">path = [</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">config</span>.<span class="title function_">getGlobalPrefix</span>(),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">MODULE_PATH</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, metatype),</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="variable constant_">PATH_METADATA</span>, targetCallback)  <span class="comment">// http-method部分路由数据</span></span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Controller和http-method装饰工厂存储的路径数据在注册路由的时候被访问并组合成完成路径；</li>
</ul>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>Nest</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Nest</tag>
      </tags>
  </entry>
  <entry>
    <title>功能函数：大数值相加</title>
    <url>/blog/resources/%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%EF%BC%9A%E5%A4%A7%E6%95%B0%E5%80%BC%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> splitLen = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...rest</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (rest.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> rest[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> num = rest.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">return</span> +<span class="title function_">add</span>(...rest) + (+num) + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(splitLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">splitNum</span> = (<span class="params">numStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> numStrArr = numStr.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">while</span> (numStrArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = numStrArr.<span class="title function_">splice</span>(-splitLen);</span><br><span class="line">    nums.<span class="title function_">push</span>(item.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">classifyAdd</span> = (<span class="params">n1Nums, n2Nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> resNums = [];</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (n1Nums.<span class="property">length</span> &amp;&amp; n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> part;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">add</span>(n1Nums.<span class="title function_">shift</span>(), n2Nums.<span class="title function_">shift</span>(), carry);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">length</span> &gt; splitLen) &#123;</span><br><span class="line">      part = res.<span class="title function_">slice</span>(-splitLen);</span><br><span class="line">      carry = res.<span class="title function_">slice</span>(<span class="number">0</span>, -splitLen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      part = zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -res.<span class="property">length</span>) + res;</span><br><span class="line">      carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resNums.<span class="title function_">push</span>(part);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n1Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> restNums = carry ? <span class="title function_">classifyAdd</span>([carry], n1Nums) : n1Nums;</span><br><span class="line">    resNums = [...resNums, ...restNums];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> restNums = carry ? <span class="title function_">classifyAdd</span>([carry], n2Nums) : n2Nums;</span><br><span class="line">    resNums = [...resNums, ...restNums];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumAdd</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (str1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; str2.<span class="property">length</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">add</span>(str1, str2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> numArr1 = <span class="title function_">splitNum</span>(str1);</span><br><span class="line">  <span class="keyword">const</span> numArr2 = <span class="title function_">splitNum</span>(str2);</span><br><span class="line">  <span class="keyword">const</span> resNums = <span class="title function_">classifyAdd</span>(numArr1, numArr2).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> resStr = resNums.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^0*/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> resStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rest.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> rest[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> str1 = rest.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bigNumAdd</span>(str1, <span class="title function_">bigNumsAdd</span>(...rest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;1111111111&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;444&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">&#x27;00000000000000000000000000000000000000000000000000&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> resNums = <span class="title function_">bigNumsAdd</span>(str1, str2, str3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resNums&#x27;</span>, resNums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resNums &quot;1111111555&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> splitLen = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">...rest</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sum = rest.<span class="property">length</span> &lt; <span class="number">2</span> ? rest[<span class="number">0</span>] : +rest.<span class="title function_">pop</span>() + (+<span class="title function_">add</span>(...rest));</span><br><span class="line">  <span class="keyword">return</span> sum + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(splitLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">splitNum</span> = (<span class="params">numStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> numStrArr = numStr.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">while</span> (numStrArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = numStrArr.<span class="title function_">splice</span>(-splitLen);</span><br><span class="line">    nums.<span class="title function_">push</span>(item.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">classifyAdd</span> = (<span class="params">n1Nums, n2Nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> resNums = [];</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (n1Nums.<span class="property">length</span> &amp;&amp; n2Nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="title function_">add</span>(n1Nums.<span class="title function_">shift</span>(), n2Nums.<span class="title function_">shift</span>(), carry);</span><br><span class="line">    <span class="keyword">const</span> part = zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -sum.<span class="property">length</span>) + sum.<span class="title function_">slice</span>(-splitLen);</span><br><span class="line">    carry = sum.<span class="title function_">slice</span>(<span class="number">0</span>, -splitLen);</span><br><span class="line">    resNums.<span class="title function_">push</span>(part);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> restNums = n1Nums.<span class="title function_">concat</span>(n2Nums); </span><br><span class="line">  restNums = carry ? <span class="title function_">classifyAdd</span>([carry], restNums) : restNums;</span><br><span class="line">  <span class="keyword">return</span> [...resNums, ...restNums].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^0*/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bigNumAdd</span> = (<span class="params">str1, str2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> str1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; str2.<span class="property">length</span> &lt; <span class="number">16</span></span><br><span class="line">    ? <span class="title function_">add</span>(str1, str2)</span><br><span class="line">    : <span class="title function_">classifyAdd</span>(<span class="title function_">splitNum</span>(str1), <span class="title function_">splitNum</span>(str2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> rest.<span class="property">length</span> &lt; <span class="number">2</span></span><br><span class="line">    ? rest[<span class="number">0</span>]</span><br><span class="line">    : <span class="title function_">bigNumAdd</span>(rest.<span class="title function_">shift</span>(), <span class="title function_">bigNumsAdd</span>(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumAdd</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1.<span class="property">length</span> &lt; <span class="number">16</span> &amp;&amp; s2.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> +s1 + (+s2) + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sArr1 = s1.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> sArr2 = s2.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len1 = sArr1.<span class="property">length</span>, len2 = sArr2.<span class="property">length</span>; (i &lt; len1 &amp;&amp; i &lt; len2) || carry; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> num1 = +(sArr1[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> num2 = +(sArr2[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> sum = (num1 + num2 + carry + <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(sum.<span class="title function_">pop</span>());</span><br><span class="line">    carry = sum[<span class="number">0</span>] ? +sum[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bigNumAdd</span>(rest[<span class="number">0</span>], rest.<span class="property">length</span> &lt; <span class="number">3</span> ? rest[<span class="number">1</span>] : <span class="title function_">bigNumsAdd</span>(...rest.<span class="title function_">slice</span>(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bigFloatNumsAdd</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> ints = [];</span><br><span class="line">  <span class="keyword">let</span> radixs = [];</span><br><span class="line">  <span class="keyword">let</span> radixMaxLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> radixStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  rest.<span class="title function_">forEach</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [int, radix] = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    int &amp;&amp; ints.<span class="title function_">push</span>(int);</span><br><span class="line">    <span class="keyword">if</span> (radix) &#123;</span><br><span class="line">      radixMaxLen = radix.<span class="property">length</span> &gt; radixMaxLen ? radix.<span class="property">length</span> : radixMaxLen;</span><br><span class="line">      radixs.<span class="title function_">push</span>(radix);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (radixs.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> zeros = <span class="keyword">new</span> <span class="title class_">Array</span>(radixMaxLen).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    radixs = radixs.<span class="title function_">map</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> str + zeros.<span class="title function_">slice</span>(<span class="number">0</span>, -str.<span class="property">length</span>));</span><br><span class="line">    <span class="keyword">const</span> radixAllStr = <span class="title function_">bigNumsAdd</span>(...radixs);</span><br><span class="line">    <span class="keyword">const</span> exInt = radixAllStr.<span class="title function_">slice</span>(<span class="number">0</span>, -radixMaxLen);</span><br><span class="line">    radixStr = radixAllStr.<span class="title function_">slice</span>(-radixMaxLen);</span><br><span class="line">    exInt &amp;&amp; ints.<span class="title function_">push</span>(exInt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> intStr = <span class="title function_">bigNumsAdd</span>(...ints);</span><br><span class="line">  <span class="keyword">return</span> [intStr, radixStr].<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title function_">bigFloatNumsAdd</span>(<span class="string">&#x27;33333333333333331.123&#x27;</span>, <span class="string">&#x27;2.1234&#x27;</span>, <span class="string">&#x27;3.98765&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;33333333333333337.23405&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>功能函数</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas实现圆框图片</title>
    <url>/blog/resources/canvas%E5%AE%9E%E7%8E%B0%E5%9C%86%E6%A1%86%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在html中做圆框图片很容易，只需要简单的 <code>border-radius: 50%;</code> 当然，为了兼容性，还有必要做带前缀的兼容性写法。但总的来说还是很简单。</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">  -webkit-<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  -moz-<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="2838289-bd35ee9e30c8de53.png"></p>
<p><a href="https://jsfiddle.net/issaxite/3gLaoLjy/">[传送门：demo]</a></p>
<p>但是在canvas上做起来就有点麻烦了，在canvas画布上画图片，可以使用canvas的 <code>drawImage</code> 接口，但是这个接口也仅仅是将图片画在画布上，并没有如css那样提供做圆角的接口。</p>
<p>网上google过一下，常看到这样的做法(最先是在<a href="http://www.zhangxinxu.com/study/201406/image-border-radius-canvas.html">张鑫旭的blog上看到的</a>)：</p>
<h1 id="通过纹理实现"><a href="#通过纹理实现" class="headerlink" title="通过纹理实现"></a>通过纹理实现</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">CanvasRenderingContext2D</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">roundRect</span> = <span class="keyword">function</span> (<span class="params">x, y, w, h, r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> min_size = <span class="title class_">Math</span>.<span class="title function_">min</span>(w, h);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (r &gt; min_size / <span class="number">2</span>) r = min_size / <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 开始绘制</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">beginPath</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">moveTo</span>(x + r, y);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x + w, y, x + w, y + h, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x + w, y + h, x, y + h, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x, y + h, x, y, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">arcTo</span>(x, y, x + w, y, r);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">stroke</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="title function_">closePath</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pattern = context.<span class="title function_">createPattern</span>(img, <span class="string">&quot;no-repeat&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">context.<span class="title function_">roundRect</span>(<span class="number">0</span>, <span class="number">0</span>, img.<span class="property">width</span>, img.<span class="property">height</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">context.<span class="property">fillStyle</span> = pattern;</span></span><br><span class="line"><span class="language-javascript">context.<span class="title function_">fill</span>(); </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做是可以的，这个做法的关键道具是<code>createPattern</code> 这是一个专门用来作纹理的API：</p>
<p><img src="2838289-2ec590dc132f3067.png"></p>
<p><strong>但是，如果你将该形状右移50px就会发现问题所在，图片没有跟着形状（圆框）一起移动</strong>：</p>
<p><img src="2838289-9343063b631f3456.png"></p>
<p>其实，看第二个画布应该可以看出图片是对画布的左上角做定位的。如果图片没有移动，那么想办法移动图片就好啦！然而，可悲的是没有方法。因此，这是一种比较鸡肋的做法。</p>
<p><a href="https://jsfiddle.net/issaxite/3gLaoLjy/1/">[传送门：demo]</a></p>
<h1 id="通过裁剪画布部分区域实现"><a href="#通过裁剪画布部分区域实现" class="headerlink" title="通过裁剪画布部分区域实现"></a>通过裁剪画布部分区域实现</h1><p>这是我最后使用的方法，这个方法的关键道具是<code>clip()</code>API，这个API，可以用你指定的形状在画布上裁剪一部分出来，然后，接下来你在画布上的操作只有在该形状区域内可见，如果还有后续还有对画布的其他地方有操作，可以使用<code>restore()</code>接口恢复，但是必须在使用clip接口前用 <code>save()</code> 接口保存canvas的状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">  img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 首先是先画一个圆形，因为现在我们不是画圆角矩形，所以就不用“张鑫旭”画圆</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 的做法，我们直接使用 `arc` 接口</span></span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">save</span>();</span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 从画布上裁剪出这个圆形</span></span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">clip</span>();</span></span><br><span class="line"><span class="language-javascript">  context.<span class="title function_">drawImage</span>(img, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="2838289-6ae38ef8653024d8.png"></p>
<p>为此，还封装了个简单的方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 封装了一个简单的方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">circleImg</span>(<span class="params">ctx, img, x, y, r</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">save</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> d =<span class="number">2</span> * r;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> cx = x + r;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> cy = y + r;</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">arc</span>(cx, cy, r, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">clip</span>();</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">drawImage</span>(img, x, y, d, d);</span></span><br><span class="line"><span class="language-javascript">    ctx.<span class="title function_">restore</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span></span><br><span class="line"><span class="language-javascript">  img.<span class="property">src</span> = <span class="string">&#x27;https://pbs.twimg.com/profile_images/588883654157291520/4DBMn6_A.jpg&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> canvas1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#canvas1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> context1 = canvas1.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">circleImg</span>(context1, img, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><img src="2838289-b8968aabf0bdc4cb.png"></p>
<p>正如你所见，这个做法可以随意移动圆框和图片的。</p>
<p><a href="https://jsfiddle.net/issaxite/p56fkb9s/1/">[传送门：demo]</a></p>
<h1 id="两个值得注意的点，比较容易让误解的API："><a href="#两个值得注意的点，比较容易让误解的API：" class="headerlink" title="两个值得注意的点，比较容易让误解的API："></a>两个值得注意的点，比较容易让误解的API：</h1><ul>
<li>clip()<br><a href="http://www.w3school.com.cn/tiy/t.asp?f=html5_canvas_clip">这是w3c的例子</a>，或许有部分人（在说自己），会误以为，在使用clip以后，接下来的操作都是相对于这个被剪切出来的部分做定位，特别是下面这张图：</li>
</ul>
<p><img src="2838289-4cb61a8b9522b0ac.png" alt="灰色框是画布"></p>
<p>更加容易让人误以为真是如此，其实不然，其实还是相对画布的左上角做定位，用了clip后只是变成，只有clip区域可见而已。</p>
<ul>
<li>arcTo 一个用来画弧线的api</li>
</ul>
<p>关于这个API的参数说明是这样的：</p>
<p><a href="http://www.w3school.com.cn/tags/canvas_arcto.asp">[传送门：demo]</a></p>
<p><img src="2838289-619ed2977b158f5b.png"></p>
<p>上面的参数说明中的起点和终点，比较容易让人误以为是下面两个点：</p>
<p><img src="2838289-37eba062c3666da0.png"></p>
<p>然而上面的(x1,y1)和(x2,y2)其实是分别指下图上的上面一点和下面一点：</p>
<p><img src="2838289-ba345b172e3ad4b8.png"></p>
<p>继续看下图：</p>
<p><img src="2838289-f38ace5dbf8d890b.png"></p>
<p><strong>顺道说一下，canvas的坐标，x轴由原点左到右从0开始递增，y轴由原点上到下，从0开始递增。</strong></p>
<p>A点是直线的末点，这个点一般是有lineTo接口写出，或者moveTo接口，比如moveTo(50,50)，而B点则是arcTo中的x1,x2，B(100, 50)， C点则是arcTo中的x2,y2，C(100, 100)，而arcTo中的r则是AB或者CD。</p>
<p><a href="https://jsfiddle.net/issaxite/uqj700yo/">[传送门：demo]</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpha、Beta、RC、GA版本的区别</title>
    <url>/blog/resources/Alpha%E3%80%81Beta%E3%80%81RC%E3%80%81GA%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>Alpha</strong>：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</p>
<p><strong>Beta</strong>：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</p>
<p><strong>RC</strong>：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</p>
<p><strong>GA</strong>: General Availability,正式发布的版本，在国外都是用GA来说明release版本的。</p>
<p><strong>RTM</strong>：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</p>
<p><strong>OEM</strong>：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。 </p>
<p><strong>RVL</strong>：号称是正式版，其实RVL根本不是版本的名称。它是中文版&#x2F;英文版文档破解出来的。 </p>
<p><strong>EVAL</strong>：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。 </p>
<p><strong>RTL</strong>：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</p>
<p><strong>注意：</strong></p>
<p>α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Composition实现科学文字计数器</title>
    <url>/blog/resources/Composition%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E6%96%87%E5%AD%97%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="很长的前言"><a href="#很长的前言" class="headerlink" title="很长的前言"></a>很长的前言</h1><p>前端时间需要做一个input组件，组件要求之一是：动态计算input文字并展示出来，大概如下：</p>
<span id="more"></span>


<p>本来就是基于vue来做，想起来也是很简单的事情，就是获取<code>$input.value.length</code>~确实也是如此。</p>
<p>最初我是这么写的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;self-input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ref</span>=<span class="string">&quot;input&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:input</span>=<span class="string">&quot;handleInput&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:value</span>=<span class="string">&quot;currentValue&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator--current&quot;</span>&gt;</span>&#123;&#123; textCount &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;self-input__calculator--max&quot;</span>&gt;</span>&#123;&#123; maxlength &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;SelfInput&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">value</span>: &#123; <span class="attr">type</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>] &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">maxlength</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">currentValue</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">textCount</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">handleInput</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> inputVal =  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        inputVal = inputVal.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">textCount</span> = inputVal.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, inputVal);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span><br><span class="line">  .self-input&#123;</span><br><span class="line">    $--calculator-width: 56px;</span><br><span class="line">    </span><br><span class="line">    &amp; &#123; position: relative;display: inline-block; &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;__inner&#123; padding-left: 5px;line-height: 28px;width: 220px;padding-right: $--calculator-width;font-size: 14px; &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;__calculator&#123;</span><br><span class="line">      &amp; &#123;</span><br><span class="line">        position: absolute;top: 0;right: 0;bottom: 0;display: inline-flex;justify-content: flex-end;</span><br><span class="line">        align-items: center;padding-right: 5px;width: $--calculator-width;box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &amp;--current&#123;</span><br><span class="line">        &amp;::after&#123; content: &quot;/&quot;;display: inline-block; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &amp;--max&#123; color: gray; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>如你所见，在中文输入时出现了非预期的文字数目计数（附上 <a href="http://jsfiddle.net/sobq1cn9/33/">Demo1</a> ）~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>看win下的效果就知道，在使用中文输入的时候，直接使用<code>input</code>事件（v-model语法糖就是监听input事件）就出现了非预期的问题！</p>
<p>在看ElementUI源码的时候发现了一个以前没有用过的事件（见识短浅），<em>composition事件</em>。这个事件有三个事件组成，分别是：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart">compositionstart</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionupdate">compositionupdate</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionend">compositionend</a></li>
</ul>
<blockquote>
<p><code>compositionstart</code> 事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）。</p>
</blockquote>
<blockquote>
<p><code>compositionupdate</code> 事件触发于字符被输入到一段文字的时候（这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）</p>
</blockquote>
<blockquote>
<p>当文本段落的组成完成或取消时, <code>compositionend</code> 事件将被触发 (具有特殊字符的触发, 需要一系列键和其他输入, 如语音识别或移动中的字词建议)。</p>
</blockquote>
<p>换言之，在一开始中文输入的时候会触发<code>compositionstart</code>事件，当继续中文输入但未选词前会持续触发<code>compositionupdate</code>事件，然后当选词后则触发<code>compositionend</code>事件（针对当前情况如是说）！</p>
<h2 id="用input事件配合以上三事件优化文字计数器"><a href="#用input事件配合以上三事件优化文字计数器" class="headerlink" title="用input事件配合以上三事件优化文字计数器"></a>用input事件配合以上三事件优化文字计数器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;exValue&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionend</span>=<span class="string">&quot;handleComposition&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;handleInput&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">isOnComposition</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">_setTextCount</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">textCount</span> = val.<span class="property">length</span> || <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleComposition</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">isOnComposition</span> = event.<span class="property">type</span> !== <span class="string">&#x27;compositionend&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      !<span class="variable language_">this</span>.<span class="property">isOnComposition</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">handleInput</span>(event);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleInput</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> value;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">isOnComposition</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">      value = event.<span class="property">target</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">currentValue</span> = value;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">_setTextCount</span>(value);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, value);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里只是用到了Composition事件之一, <code>compositionend</code>。</p>
<p>其实要做得更加健壮应该三个事件都用到！这里的思路也很简单，如果是非中文输入的时候就不会触发<code>compositionend</code>事件，正常执行input事件的回调，</p>
<p>而中文输入的时候，<code>compositionend</code>和<code>input</code>都会同时触发，在未完成选词前，当然是不能执行input回到的真正逻辑，</p>
<p>因此加入一个<code>isOnComposition</code>状态记录当前是否进行中文输入，input回调函数则据此判断是否执行真正的业务逻辑！</p>
<p>附上jsfiddle源码Demo: <a href="http://jsfiddle.net/sobq1cn9/143/">Demo2</a></p>
<h2 id="更加简单的做法"><a href="#更加简单的做法" class="headerlink" title="更加简单的做法"></a>更加简单的做法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;self-input__inner&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;currentValue&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:maxlength</span>=<span class="string">&quot;maxlength&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">currentValue</span>: (<span class="variable language_">this</span>.<span class="property">value</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span>.<span class="property">value</span> === <span class="literal">null</span>) ? <span class="string">&#x27;&#x27;</span> : <span class="variable language_">this</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">textCount</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">currentValue</span>.<span class="property">length</span> || <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比上一种做法，将<code>v-bind</code>绑定的<code>value</code>属性，换成<code>v-model</code>，其余去掉的部分一看到<del>，基本就是做了这么一点功夫就搞定了上一种做法的长篇大论</del><br>附上jsfiddle源码Demo: <a href="http://jsfiddle.net/issaxite/wqfhnvc4/1/">另一种简单的实现</a></p>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>dom事件</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>SCSS字符分割函数获取当前选择器名</title>
    <url>/blog/resources/SCSS%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%80%89%E6%8B%A9%E5%99%A8%E5%90%8D/</url>
    <content><![CDATA[<h1 id="有点长的前言"><a href="#有点长的前言" class="headerlink" title="有点长的前言"></a>有点长的前言</h1><p>常有这样的情况：比如以下面的一段代码来说，多人开发的情况下，很可能你写了一个<code>.header-icon</code>的css样式描述，你的同事也开发了一个！</p>
<p>并且他的样式优先级比你的高，目前你负责的部分需要你的样式生效！</p>
<span id="more"></span>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这要怎么办？直接想到的有两个方法：</p>
<ul>
<li><p><code>!important</code>；</p>
</li>
<li><p>重复声明选择器，比如 <code>.bar-header-icon.bar-header-icon</code>；</p>
</li>
</ul>
<p>很多时候负责任的开发者都会使用后者，因为后者可以前者覆盖，具备一定的扩展性！</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span><span class="selector-class">.bar-header-icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错这样就ok！</p>
<p>但细想可知，虽然<code>&amp;-header</code>的当前选择器名是和<code>.bar-header-icon</code>的是相等的，但是一旦父选择器名字（<code>.header</code>）改了，就出问题，健壮性过差！</p>
<p>当然如果你不嫌麻烦，可以同时改两个地方。但实际开发时可能就不是两个地方的事了……</p>
<p>聪明如你会想到这样写：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span>&#123;</span><br><span class="line">  <span class="selector-class">.bar</span>&#123;</span><br><span class="line">    &amp;-<span class="selector-tag">header</span>&#123;</span><br><span class="line">      &amp;-<span class="attribute">icon</span>&amp;-<span class="attribute">icon</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你期望输出的是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span><span class="selector-class">.bar-header-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是，实际上输出的是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span><span class="selector-class">.side</span> <span class="selector-class">.bar-header-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，在上面的情况中<code>&amp;-icon</code>并不与<code>.bar-header-icon</code>等价，实际上，<code>&amp;</code>编译后的是<code>.side .bar-header</code>。是不是就有点尴尬了~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>scss没有提供获取当前选择器名的方法或者全局变量，那么就自己实现！</p>
<p><code>&amp;</code>输出的字符串是一个选择器名的列表，这些元素名一般以空格分割，还有的就是<code>. &gt; + ~</code>等等，</p>
<p>因此可以通过这些分割字符串，然后”数组“的最后一个元素就是目标选择器名！</p>
<h2 id="字符串分割函数"><a href="#字符串分割函数" class="headerlink" title="字符串分割函数"></a>字符串分割函数</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> str-split(<span class="variable">$str</span>, <span class="variable">$separator</span>) &#123;</span><br><span class="line">  <span class="variable">$splits</span>: ();</span><br><span class="line">  <span class="comment">// 获取下次分割点posituion</span></span><br><span class="line">  <span class="variable">$pos</span> : <span class="built_in">str-index</span>(<span class="variable">$str</span>, <span class="variable">$separator</span>);</span><br><span class="line">  <span class="keyword">@while</span> <span class="variable">$pos</span> != null &#123;</span><br><span class="line">    <span class="comment">// 根据position返回子字符串</span></span><br><span class="line">    <span class="variable">$item</span>: <span class="built_in">str-slice</span>(<span class="variable">$str</span>, <span class="number">1</span>, <span class="variable">$pos</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将切割出的字串push入list中</span></span><br><span class="line">    <span class="variable">$splits</span>: <span class="built_in">append</span>(<span class="variable">$splits</span>, <span class="variable">$item</span>);</span><br><span class="line">    <span class="comment">// 更新源字符串</span></span><br><span class="line">    <span class="variable">$str</span>: <span class="built_in">str-slice</span>(<span class="variable">$str</span>, <span class="variable">$pos</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取下次分割点posituion</span></span><br><span class="line">    <span class="variable">$pos</span> : <span class="built_in">str-index</span>(<span class="variable">$str</span>, <span class="variable">$separator</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$splits</span>: <span class="built_in">append</span>(<span class="variable">$splits</span>, <span class="variable">$str</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$splits</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop函数"><a href="#pop函数" class="headerlink" title="pop函数"></a>pop函数</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> list-pop(<span class="variable">$list</span>) &#123;</span><br><span class="line">  <span class="variable">$len</span>: <span class="built_in">length</span>(<span class="variable">$list</span>);</span><br><span class="line">  <span class="keyword">@return</span> nth(<span class="variable">$list</span>, <span class="variable">$len</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取当前selector"><a href="#获取当前selector" class="headerlink" title="获取当前selector"></a>获取当前selector</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> current-selector(<span class="variable">$str</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> list-pop(str-split(<span class="variable">$str</span>, <span class="string">&#x27; &#x27;</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="增强版的current-selector"><a href="#增强版的current-selector" class="headerlink" title="增强版的current-selector"></a>增强版的<code>current-selector</code></h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> nth-by-flag(<span class="variable">$list</span>, <span class="variable">$flag</span>) &#123;</span><br><span class="line">  <span class="variable">$els</span>: ();</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$item</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">    <span class="keyword">@if</span> str-index(<span class="variable">$item</span>, <span class="variable">$flag</span>) != null &#123;</span><br><span class="line">      <span class="variable">$els</span>: <span class="built_in">append</span>(<span class="variable">$els</span>, <span class="variable">$item</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$els</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@function</span> current-selector(<span class="variable">$str</span>, <span class="variable">$seps</span>: null, <span class="variable">$flag</span>: null) &#123;</span><br><span class="line">  <span class="variable">$current</span>: <span class="variable">$str</span>;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$seps</span> != null &#123;</span><br><span class="line">    <span class="variable">$seps</span>: <span class="built_in">append</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$seps</span>);  </span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="variable">$seps</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$sep</span> in <span class="variable">$seps</span> &#123;</span><br><span class="line">    <span class="variable">$is-exist</span>: <span class="built_in">str-index</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>);</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$is-exist</span> != null &#123;</span><br><span class="line">      <span class="keyword">@if</span> <span class="variable">$flag</span> != null &#123;</span><br><span class="line">        <span class="variable">$current</span>: <span class="built_in">nth-by-flag</span>(<span class="built_in">str-split</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>), <span class="variable">$flag</span>);</span><br><span class="line">      &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="variable">$current</span>: <span class="built_in">list-pop</span>(<span class="built_in">str-split</span>(<span class="variable">$current</span>, <span class="variable">$sep</span>));   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个debug-mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> debug(<span class="variable">$var</span>) &#123;</span><br><span class="line">  <span class="selector-class">.debug</span>&#123; <span class="attribute">content</span>: <span class="variable">$var</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> debug(current-selector(<span class="string">&quot;.a .b .c&quot;</span>)); </span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="44906193-d0f78b00-ad46-11e8-99f6-060e4ceb1453.png"></p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sep</span>: <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="variable">$current</span>: <span class="variable">$sep</span> + <span class="built_in">current-selector</span>(<span class="string">&quot;.a .b .c.c.c&quot;</span>, <span class="variable">$sep</span>);</span><br><span class="line"><span class="keyword">@include</span> debug(<span class="variable">$current</span>);; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="44906431-76126380-ad47-11e8-8779-90f5b5b2c8bb.png"></p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@include</span> debug(current-selector(<span class="string">&quot;.a .isaac .b .c&quot;</span>, null, <span class="string">&#x27;isaac&#x27;</span>)); </span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="44906552-cf7a9280-ad47-11e8-8b2a-28e25383bd90.png"></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://sass-lang.com/documentation/modules/string">Sass Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>scss</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>手势视差翻页器</title>
    <url>/blog/resources/%E6%89%8B%E5%8A%BF%E8%A7%86%E5%B7%AE%E7%BF%BB%E9%A1%B5%E5%99%A8/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>移动端实现一个轮播器，在轮播器上层有一个静止图层，不会随着轮播器翻页而偏移。<br>以下是两个已经实践的两个项目：</p>
<span id="more"></span>

<ul>
<li><a href="https://isaaxite.github.io/parallax_scrolling_flip/example/">Example-1</a></li>
<li><a href="https://isaaxite.github.io/parallax_scrolling_flip/">Example-2</a></li>
</ul>
<p><a href="https://github.com/issaxite/parallax_scrolling_flip">[Github]</a>，欢迎Fork与Star！！！</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="以上需求可以拆分成两个小的需求："><a href="#以上需求可以拆分成两个小的需求：" class="headerlink" title="以上需求可以拆分成两个小的需求："></a>以上需求可以拆分成两个小的需求：</h2><ul>
<li>实现一个轮播器；</li>
<li>做个静止图层。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>轮播器作为一个图层，静止图层是一个。</p>
<p>那么那个图层在上，那个在下？</p>
<ol>
<li>轮播器在上，则静止图层被轮播器遮盖；</li>
<li>静止图层在上，则绑定在轮播器上的手势事件由于被静止图层在上而无法触发。</li>
</ol>
<h2 id="再细分需求"><a href="#再细分需求" class="headerlink" title="再细分需求"></a>再细分需求</h2><p>为了显示静止图层，那么静止图层一定是要在上的。那么就必须解决第2个问题，怎么触发轮播器的手势。<br>我们可以通过监听静止图层或者两图层容器的手势，然后映射到轮播器。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="轮播器"><a href="#轮播器" class="headerlink" title="轮播器"></a>轮播器</h2><p>由于网上的轮播器插件的都是封装好的，触发事件比较麻烦，因此选择自己使用原生js实现一个。</p>
<p>实现轮播器的方案有很多中，比如改变<code>translate</code>属性的，也有先实现一个<code>scroll-view </code>，然后改变<code>scroll-view</code>的<code>scrollLeft</code>。我选用后者（单纯是因为我没有这样做过，而且好像很有趣）。</p>
<h3 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h3><p>一般<code>scroll-view</code>都是纵向的，根据以上需求，我们就需要实现一个横向的<code>scroll-view</code>，具体实现如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;story&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123; <span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">::-webkit-scrollbar&#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">position</span>: relative; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &gt; <span class="selector-class">.story</span>&#123; <span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">0</span>;<span class="attribute">right</span>: <span class="number">0</span>;<span class="attribute">bottom</span>: <span class="number">0</span>;<span class="attribute">left</span>: <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &gt; <span class="selector-class">.story</span>&#123; </span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1000</span>; <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;<span class="attribute">overflow-y</span>: hidden; <span class="attribute">white-space</span>: nowrap;<span class="attribute">font-size</span>: <span class="number">0</span>;<span class="attribute">letter-spacing</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* translateZ是是为了开启硬件加速 */</span></span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  -o-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">display</span>: inline-block;<span class="attribute">vertical-align</span>: top;<span class="attribute">position</span>: relative; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123; <span class="attribute">background-color</span>: red; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123; <span class="attribute">background-color</span>: orange; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123; <span class="attribute">background-color</span>: yellow; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">4</span>)&#123; <span class="attribute">background-color</span>: green; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">5</span>)&#123; <span class="attribute">background-color</span>: cyan; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">6</span>)&#123; <span class="attribute">background-color</span>: blue; &#125;</span><br><span class="line"><span class="selector-class">.story</span> &gt; <span class="selector-tag">dt</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">7</span>)&#123; <span class="attribute">background-color</span>: purple; &#125;</span><br></pre></td></tr></table></figure>

<p>核心css为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow-x</span>: auto;<span class="attribute">overflow-y</span>: hidden; <span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure>
<p>禁用块级元素的换行，依次达到横排的效果。<br><a href="http://jsbin.com/virecok/1/edit?html,css,output">[查看源码：jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/5/">[查看源码：jsfiddle]</a><br>(ps：要看效果的gay man请点击<a href="http://jsbin.com/virecok/1/edit?html,css,output">[查看源码：jsbin]</a>，并使用移动设备模式查看， 下同)<br><img src="http://ohi69gup6.bkt.clouddn.com/%E8%BD%AE%E6%92%AD-min.gif"></p>
<h2 id="静止图层并监听其上的手势"><a href="#静止图层并监听其上的手势" class="headerlink" title="静止图层并监听其上的手势"></a>静止图层并监听其上的手势</h2><p>先向#app中添加静止图层</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">&quot;mash&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://ohi69gup6.bkt.clouddn.com/005TGG6vly1fes9jc0kk0g30b40b40tv.gif&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，来分析一下轮播器的功能</p>
<ol>
<li>向左，向右滑动翻页；</li>
<li>轮播器卡片手势跟随。</li>
</ol>
<h3 id="第1点的实现思路"><a href="#第1点的实现思路" class="headerlink" title="第1点的实现思路"></a>第1点的实现思路</h3><p>获取手指 “触碰屏幕那刻” 和 “离开屏幕那刻” 的位置，根据以上两个位置判断翻页方向，要获取这两位置，就需要分别注册<code>touchstart</code>和<code>touchend</code>事件，通过事件的回调参数( <code>event</code> )获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触碰屏幕那刻横向位置</span></span><br><span class="line"><span class="keyword">var</span> touchStartX = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br><span class="line"><span class="comment">// 离开屏幕那刻横向位置</span></span><br><span class="line"><span class="keyword">var</span> touchEndX = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span>;</span><br></pre></td></tr></table></figure>

<p>判断滑动方向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>知道翻页方向就可以进行翻页</p>
<p>翻页如上文所说，通过改变卡片容器的<code>scrollLeft</code>。这里的容器是<code>#app &gt; .story</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .story&quot;</span>).<span class="property">scrollLeft</span></span><br></pre></td></tr></table></figure>
<p>想要实现翻页，还必须知道两个属性：</p>
<ol>
<li>每页宽度：可以通过<code>story.clientWidth</code>获取；</li>
<li>当前页：使用全局变量记录当前是第几页。</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> touchStartX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mash = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .mash&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> story = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app &gt; .story&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> screenWidth = story.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line"> touchStartX = touch.<span class="property">pageX</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> touchEndX = touch.<span class="property">pageX</span>;</span><br><span class="line">  <span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> oldCurrentPage = currentPage;</span><br><span class="line">  <span class="keyword">var</span> maxPage = story.<span class="property">children</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">var</span> minPage = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">  currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">  currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> targetScrollLeft = (currentPage - <span class="number">1</span>) * screenWidth;</span><br><span class="line">  </span><br><span class="line">  story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码基本实现翻页，但是仅仅是通过每次 “增加&#x2F;减少 一个<code>screenWidth</code>的距离” 达到翻页的目的，是不够的，因为你会发现翻页效果很生硬的，仅仅只有一帧。</p>
<p>下面让我们把翻页效果做得更加顺滑。</p>
<p>怎么做，使用定时器(<code>setTimeout</code>)？</p>
<p>不！不！不！当然不会！</p>
<p>我们使用<code>requestAnimationFrame</code>，至于为什么使用<code>requestAnimationFrame</code>而不使用<code>setTimeout</code>？请自行Google。接着，让我们先实现一个动画函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _animate = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> isValid = callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">    isValid &amp;&amp; <span class="title function_">requestAnimationFrame</span>(_animate);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(_animate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>ok，然后要做的就是将它运用到翻页的代码中!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置每帧改变scrollLeft距离</span></span><br><span class="line"><span class="keyword">var</span> step = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">animate</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> scrollLeft = story.<span class="property">scrollLeft</span>;</span><br><span class="line"></span><br><span class="line">    scrollLeft = isNext ? scrollLeft + step : scrollLeft - step;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isNext &amp;&amp; scrollLeft &gt; targetScrollLeft) &#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isNext &amp;&amp; scrollLeft &lt; targetScrollLeft)&#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = targetScrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      story.<span class="property">scrollLeft</span> = scrollLeft;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><a href="http://jsbin.com/qoqufo/2/edit?html,css,js,output">[查看源码：jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/26/">[查看源码：jsfiddle]</a></p>
<h3 id="第2点的实现思路"><a href="#第2点的实现思路" class="headerlink" title="第2点的实现思路"></a>第2点的实现思路</h3><p>第二点需要实现的功能是：轮播器卡片手势跟随。<br>假如你有试过以上代码实现的轮播器，你会发现一个问题：手指在未离开屏幕前，无论手指怎么滑动都不会有任何响应，这明显不是我们想要的。标准的轮播器应该是：当前卡片应该对手势做出响应，卡片跟随手指移动。</p>
<p>要实现以上效果，就需要监听手指未离开屏幕的前的动作，注册<code>touchmove</code>事件，获取手指每次移动的位置！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.<span class="property">changedTouches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moveingfPageX = touch.<span class="property">pageX</span>;</span><br><span class="line">  <span class="keyword">var</span> distance = -(moveingfPageX - touchStartX);</span><br><span class="line">  <span class="keyword">var</span> currentPageScrollLeft = (currentPage - <span class="number">1</span>) * screenWidth;</span><br><span class="line"></span><br><span class="line">  story.<span class="property">scrollLeft</span> = currentPageScrollLeft + distance;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>思路也是比较简单的，监听手指所在位置与初始位置<code>touchStartX</code>的距离，然后动态地改变<code>story.scrollLeft</code>。</p>
<p>另外，现在已经实现卡片的手势跟随，随之又可能有这么一种情况：<br>用户已经滑动卡片，但是在滑动后用户不想翻页了，转而想继续留在当前页，即 “后悔功能”。然后再看看当前我们的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> isNext = touchEndX - touchStartX &lt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br></pre></td></tr></table></figure>
<p>以上逻辑是：如果不是上一页就是下一页。并没有实现后悔功能。</p>
<p>为实现后悔功能，我做如下修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最小有效翻页距离（在手指离开屏幕时所偏移的横向距离），换言之，偏移距离小于30就触发后悔功能</span></span><br><span class="line"><span class="keyword">var</span> validFlipDistance = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"></span><br><span class="line">mash &amp;&amp; mash.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="keyword">var</span> isValid = <span class="title class_">Math</span>.<span class="title function_">abs</span>(touchEndX - touchStartX) &gt;= validFlipDistance;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="keyword">if</span>(isValid) &#123;</span><br><span class="line">    currentPage = isNext ? currentPage + <span class="number">1</span> : currentPage - <span class="number">1</span>;</span><br><span class="line">    currentPage = currentPage &gt; maxPage ? maxPage : currentPage;</span><br><span class="line">    currentPage = currentPage &lt; minPage ? minPage : currentPage;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 触发后悔功能，改变滑动方向，由animate函数将卡片反向滑回初始位置</span></span><br><span class="line">    isNext = !isNext;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a href="http://jsbin.com/qoqufo/edit?css,js,output">[查看源码: jsbin]</a><br><a href="https://jsfiddle.net/issaxite/ec6cmpkq/29/">[查看源码: jsfiddle]</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>旧文迁移</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析vue语法糖v-model</title>
    <url>/blog/resources/%E6%B5%85%E6%9E%90vue%E8%AF%AD%E6%B3%95%E7%B3%96v-model/</url>
    <content><![CDATA[<h1 id="input组件的v-model"><a href="#input组件的v-model" class="headerlink" title="input组件的v-model"></a>input组件的v-model</h1><p>关于v-model的实现原理vue文档有描述，是基于vue现有功能二次实现的语法糖。</p>
<span id="more"></span>

<p>vue中input的v-model写法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;something&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过是以下示例的语法糖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = arguments[0].target.value&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;e =&gt; something = e.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>据我们所见，v-model是个双向绑定的实现，这个实现主要是通过下面两个关键实现。</p>
<ul>
<li><p>通过<code>:value</code>&#x2F;<code>v-bind:value</code>是将data的value，即<code>data.something</code>单向绑定到input的value属性，<code>input.value</code>上。因此初始化页面的时候data.value的值会同步到对应input的value上，但如果只是这样的话，当用户通过input输入框改变input的值时并不会将改变后的值同步到data.input上。</p>
</li>
<li><p>通过<code>v-on:input</code>监听input.value的变化，可以监听到变化就可以将值更新到data.value上。通过<code>e =&gt; something = e.target.value</code></p>
<p>​</p>
</li>
</ul>
<p>对于第二点，<code>v-on</code>监听HTML5事件， <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/input">[input事件]</a>。或许有些人会对这个html5事件有点陌生，不知道的，或许还会误以为是vue中开发者自定义的事件。</p>
<p>input事件的描述</p>
<blockquote>
<p>当 <code>&lt;input&gt;</code> 或 <code>&lt;textarea&gt;</code> 元素的值更改时，DOM input 事件会同步触发。(对于 type &#x3D; checkbox 或 type &#x3D; radio 的输入元素，当用户单击控件时，输入事件不会触发，因为value属性不会更改。) 此外，当内容更改时，它会在 contenteditable 的编辑器上触发。在这种情况下，事件目标是编辑主机元素。如果有两个或多个具有 contenteditable 的元素为真，“编辑主机”是其父级不可编辑的最近的祖先元素。同样，它也会在  designMode 编辑器的根元素上触发。</p>
</blockquote>
<p>对v-model的关键句是：<strong>当 <code>&lt;input&gt;</code> 或 <code>&lt;textarea&gt;</code> 元素的值更改时，DOM input 事件会同步触发。</strong></p>
<h2 id="那为什么不使用change事件或者keyup事件实现？"><a href="#那为什么不使用change事件或者keyup事件实现？" class="headerlink" title="那为什么不使用change事件或者keyup事件实现？"></a>那为什么不使用change事件或者keyup事件实现？</h2><ul>
<li>change事件的问题</li>
</ul>
<p>mdn对change的描述</p>
<blockquote>
<p>change事件被<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;textarea&gt;</code>元素触发，访用户提交对元素值的更改时。与input事件不同，change不一定会对元素值的每次更改触发。 </p>
</blockquote>
<p>意思是什么？<br>比如说，你长按键盘输入文字到input框，input的value是一直在变的，但是长按期间的变化是不会触发到change事件的，只有在松开按键的时候并且input的value有变化才会触发。</p>
<p>而input事件则是，只要input的值发生变化都会触发，没有则不触发。</p>
<ul>
<li>key事件的问题</li>
</ul>
<p>keyup事件触发条件就如字面意思，按键松开的时候触发。这不就是和change事件相似？是很相似，但keyup是只要按键松开就会触发，无论value是否有改变，比如你按下方向键也会触发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数据双向绑定（v-model）的的核心是：v-bind同步数据到html元素节点的value;事件监听元素节点的value变化，然后将变化同步到vue.$data中。</p>
<h1 id="自定义组件实现v-model"><a href="#自定义组件实现v-model" class="headerlink" title="自定义组件实现v-model"></a>自定义组件实现v-model</h1><p>对于自定义组件实现双向数据绑定的也是和input实现思路一样，实现方法也是类似。</p>
<ul>
<li>将父组件的data.value通过向子组件传参，将其同步到子组件内部</li>
</ul>
<p>再看vue文档给出的示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// v-model实现</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;something&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">// vue给出的自定义组件中v-model的解析</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;something = arguments[0]&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-input</span> @<span class="attr">input</span>=<span class="string">&quot;something = arguments[0]&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;something&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> customInput <span class="keyword">from</span> <span class="string">&#x27;./_input&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">something</span>: <span class="string">&quot;i am isaac_宝华&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">something</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;custom-input&quot;</span>: customInput</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>子组件（我的意淫）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;updateValue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;customInput&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">value</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateValue</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="35480891-4f1300ca-0453-11e8-9b40-d49d0f45d03d.png" alt="image"></p>
<ul>
<li><p>同样，在父组件在<code>custom-input</code>中绑定<code>something</code>，向<code>custom-input</code>内部传入<code>something</code>。在<code>custom-input</code>内部将传入的value，绑定到真正的input的value上，这样就先实现单向的数据绑定。</p>
</li>
<li><p>然后要做的就是将真正的input.value的变化更新到父组件的<code>something</code>。怎么做？看父组件，在<code>custom-input</code>不是监听了input事件吗？！那么要在<code>custom-input</code>内部更新input.value到父组件，就需要触发这个input事件，就是子组件的这句: <code>$emit(&#39;input&#39;, $event.target.value)</code>。</p>
<p>那后你会发现在<code>custom-input</code>组件内部的input上也同样监听了一个input事件，因为要同步到父组件，首先就要监听到真正的input.value的变化，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> :value=<span class="string">&quot;value&quot;</span> @input=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>的input事件就会监听到input.value的变化，然后再将变化通过<code>$emit(&#39;input&#39;, $event.target.value)</code>传回父组件。</p>
</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>在这里，只是浅析v-model这个语法糖，正如vue文档中说的</p>
<blockquote>
<p><strong>预期</strong>：随表单控件类型不同而不同。</p>
</blockquote>
<p>所以这里只是简单说了input:text类型控件，而且也只是停留在vue层面浅析v-mode，并没有深入到js层面去分析v-model的实现。虽然如此，但这是有助于我们封住相关的input控件，作为一个自定义组件使用。</p>
<p>另外，不得不说，别看vue文档中将v-model好像说得很简单，但其实是vue中最复杂的组件之一。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>旧文迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn more about the nodejs package manager - npm | pnpm | yarn</title>
    <url>/blog/resources/Learn-more-about-the-nodejs-package-manager-npm-pnpm-yarn/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>todo</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>todo</p>
<h1 id="常见包管理器"><a href="#常见包管理器" class="headerlink" title="常见包管理器"></a>常见包管理器</h1>]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>Plan Of Split Isubo Code</title>
    <url>/blog/resources/Plan-Of-Split-Isubo-Code/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前 isubo（<a href="https://github.com/isaaxite/deploy-posts-to-github-issue/tree/v0.0.12-beta.0">v0.0.12-beta.0</a>） 默认以 CLI 工具存在。该版本包含了 cli 脚本 和 cli 的 prompt 提示，并且前面两者都与核心代码耦合在一起。在这种情况下不利于扩展到多平台。计划将它们与核心代码分离，将核心代码作为单独的 api 库发布。</p>
]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>practices of vscode-plugin&#39;s development</title>
    <url>/blog/resources/practices-of-vscode-plugin-s-development/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是针对 isubo 的 vscode 插件开发可行性调研记录，下面将简述第一个版本的 vscode 插件设计规划。</p>
<h1 id="isubo"><a href="#isubo" class="headerlink" title="isubo"></a>isubo</h1><ul>
<li><p>选择文章：选择需要发布的文章，最终需要得到文章名以及文章的路径；</p>
</li>
<li><p>读取配置：读取所选文章的配置文件，获取必要信息；</p>
</li>
<li><p>loading：推送文章或资源都需要时间，需要添加防抖与提示；</p>
</li>
<li><p>确认框交互：推送文章到 github-issue 成功后，需要与用户交互决定是否推送文章关联的资源；</p>
</li>
<li><p>使用 Git：文章关联的资源使用 Git 推送；</p>
</li>
</ul>
<h1 id="选择文章"><a href="#选择文章" class="headerlink" title="选择文章"></a>选择文章</h1><p>vsode 的侧边栏是项目的文件树，可以对单个或多个文件，进行右键呼出选择菜单。计划在菜单中添加推送选项：</p>
<ul>
<li><p>publish；</p>
</li>
<li><p>update;</p>
</li>
<li><p>create;</p>
</li>
</ul>
<p>因此，需要调研添加选项到菜单的可行性，以及选择后获取文章路径的可行性。</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
添加菜单项；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
获取路径；</p>
</li>
</ul>
<p>开发文档的 <a href="https://code.visualstudio.com/api/ux-guidelines/overview#context-menus">Overview - Context Menus</a> 说明添加选项的可行性。</p>
<p><img src="image.png" alt="Alt text"></p>
<p>在 <a href="https://code.visualstudio.com/api/ux-guidelines/context-menus">ux-guidelines - context-menus</a> 说明了最佳实践。</p>
<p>在 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.menus">contributes.menus</a> 说明了菜单相关的多个配置项。但是未明说每个配置所对应的菜单。</p>
<p>据推断 <code>explorer/context</code> 应该是目标。下面以此展开实践：</p>
<p>声明的配置（package.json）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第 2 维的属性</span></span><br><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isubo-ext.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;explorer/context&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isubo-ext.helloWorld&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p><code>isubo-ext.helloWorld</code> 对应在 <code>extension.js</code> 中使用 <code>vscode.commands.registerCommand</code> 注册的命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extonsion.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 注册命令：isubo-ext.helloWorld</span></span><br><span class="line">  <span class="keyword">let</span> disposable = vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;isubo-ext.helloWorld&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(disposable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，菜单中出现：“Hello World”。<code>commands</code> 配置中的 <code>title</code> 即是菜单项的文案。</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
添加菜单项；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
获取路径；</p>
</li>
</ul>
<p>在注册的命令的对调该函数中打印入参，得到 <code>vscode.commands.registerCommand</code> 的第一个回调参数是 <code>file</code> 对象，形如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;scheme: &#x27;file&#x27;, authority: &#x27;&#x27;, path: &#x27;/home/isaac/Workspace/blog/source/_posts/Get-Start-Of-Github-Action.md&#x27;, query: &#x27;&#x27;, fragment: &#x27;&#x27;, …&#125;</span><br><span class="line">extensionHostProcess.js:113</span><br><span class="line">_formatted:</span><br><span class="line">&#x27;file:///home/isaac/Workspace/blog/source/_posts/Get-Start-Of-Github-Action.md&#x27;</span><br><span class="line">_fsPath:</span><br><span class="line">&#x27;/home/isaac/Workspace/blog/source/_posts/Get-Start-Of-Github-Action.md&#x27;</span><br><span class="line">authority:</span><br><span class="line">&#x27;&#x27;</span><br><span class="line">fragment:</span><br><span class="line">&#x27;&#x27;</span><br><span class="line">fsPath:</span><br><span class="line">ƒ fsPath()&#123;return this._fsPath||(this._fsPath=w(this,!1)),this._fsPath&#125;</span><br><span class="line">path:</span><br><span class="line">&#x27;/home/isaac/Workspace/blog/source/_posts/Get-Start-Of-Github-Action.md&#x27;</span><br><span class="line">query:</span><br><span class="line">&#x27;&#x27;</span><br><span class="line">scheme:</span><br><span class="line">&#x27;file&#x27;</span><br><span class="line">[[Prototype]]:</span><br><span class="line">k</span><br></pre></td></tr></table></figure>

<p><code>vscode.commands.registerCommand</code> 注册的命令可以使用多种方式触发，其中就有 <code>control+shift+p</code> 或 对侧边栏的文件树右键选择。后者方式触发，回调函数的第一个参数会是 file 对象。</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
添加菜单项；</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
获取路径；</p>
</li>
</ul>
<h1 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h1><p>在上面已经确认可以拿到文章的路径，配置文件名是确定的，可以通过路径向上检索配置文件。因此需要确认 vscode 插件时都提供 nodejs api（fs.readFileSync）</p>
<p>vscode 本身使用 Electron 框架开发，而 Electron 是内置 nodejs 的！并且不同的 vscode 内置不同的 nodejs。通过 vsode的版本信息就可以知道对应的nodejs版本，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Version: 1.82.2</span><br><span class="line">Commit: abd2f3db4bdb28f9e95536dfa84d8479f1eb312d</span><br><span class="line">Date: 2023-09-14T05:51:20.981Z</span><br><span class="line">Electron: 25.8.1</span><br><span class="line">ElectronBuildId: 23779380</span><br><span class="line">Chromium: 114.0.5735.289</span><br><span class="line">Node.js: 18.15.0</span><br><span class="line">V8: 11.4.183.29-electron.0</span><br><span class="line">OS: Linux x64 6.1.0-12-amd64</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> 读取配置文件</li>
</ul>
<h2 id="loading-提示"><a href="#loading-提示" class="headerlink" title="loading 提示"></a>loading 提示</h2><p>防抖逻辑实现不是问题，剩下需要确认 loading 提示的</p>
<p>参考：<a href="https://code.visualstudio.com/api/references/vscode-api">https://code.visualstudio.com/api/references/vscode-api</a></p>
<h2 id="withProgress"><a href="#withProgress" class="headerlink" title="withProgress"></a>withProgress</h2><blockquote>
<p>Show progress in the editor. Progress is shown while running the given callback and while the promise it returned isn’t resolved nor rejected. The location at which progress should show (and other details) is defined via the passed ProgressOptions.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vscode.window.withProgress(&#123;</span><br><span class="line">  location: vscode.ProgressLocation.Window,</span><br><span class="line">  title: &#x27;Loading&#x27;,</span><br><span class="line">  cancellable: false</span><br><span class="line">&#125;, (progress) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    let cnt = 0;</span><br><span class="line">    const timer = setInterval(() =&gt; &#123;</span><br><span class="line">      cnt += 10;</span><br><span class="line">      // 可选</span><br><span class="line">      progress.report(&#123; increment: 10 &#125;);</span><br><span class="line"></span><br><span class="line">      if (cnt &gt;= 100) &#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在vsocde底部状态栏左边有loading动态图标的提示，点击可以在右下呼起提示框。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> loading 提示</li>
</ul>
<h1 id="确认框交互"><a href="#确认框交互" class="headerlink" title="确认框交互"></a>确认框交互</h1><p><img src="image-1.png" alt="Alt text"></p>
<p>实现方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="string">&#x27;Option 1&#x27;</span>, <span class="string">&#x27;Option 2&#x27;</span>, <span class="string">&#x27;Option 3&#x27;</span>];</span><br><span class="line"></span><br><span class="line">vscode.<span class="property">window</span>.<span class="title function_">showQuickPick</span>(options, &#123;</span><br><span class="line">  <span class="attr">placeHolder</span>: <span class="string">&#x27;Select an option&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">selectedOption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">info</span>(selectedOption);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>测试有效。会在vscode窗口顶部弹出单选项。</p>
]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>The Plan Of Isubo&#39;s Vscode Plugin Development</title>
    <url>/blog/resources/The-Plan-Of-Isubo-s-Vscode-Plugin-Development/</url>
    <content><![CDATA[<p>计划分多个非向下兼容版本开发，目前想到的暂时有两个，下面先简述第一个版本的主要功能：</p>
<ul>
<li>对 post 文件右键呼出菜单，可以对文章推送，包含更新、创建。</li>
</ul>
<p><img src="architecture-containers.png"></p>
<ul>
<li>选择推送选项后，需要一个 loading 进行防抖。</li>
</ul>
<h1 id="需要了解的功能"><a href="#需要了解的功能" class="headerlink" title="需要了解的功能"></a>需要了解的功能</h1><ul>
<li><p>插件项目初始化；</p>
</li>
<li><p>配置菜单的api；</p>
</li>
<li><p>loading 配置的 api；</p>
</li>
</ul>
<h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add install yo generator-code --save-dev</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>Get-Start-Of-VScode-Ext-Dev</title>
    <url>/blog/resources/Get-Start-Of-VScode-Ext-Dev/</url>
    <content><![CDATA[<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>安装 Yeoman 和 VS Code Extension Generator：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add install yo generator-code --save-dev</span><br></pre></td></tr></table></figure>

<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>使用 package.json 作为声明文件，详细配置字段查阅 <a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest Reference</a></p>
<h1 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h1><blockquote>
<p>The extension entry file exports two functions, activate and deactivate. activate is executed when your registered Activation Event happens. deactivate gives you a chance to clean up before your extension becomes deactivated. </p>
</blockquote>
<p>生命周期钩子函数：</p>
<ul>
<li>activate</li>
<li>deactivate</li>
</ul>
<h1 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h1><p><a href="https://code.visualstudio.com/api/references/activation-events">Activation Events</a>: events upon which your extension becomes active.<br><a href="https://code.visualstudio.com/api/references/contribution-points">Contribution Points</a>: static declarations that you make in the package.json Extension Manifest to extend VS Code.<br><a href="https://code.visualstudio.com/api/references/vscode-api">VS Code API</a>: a set of JavaScript APIs that you can invoke in your extension code.</p>
<h1 id="UX-Guidelines"><a href="#UX-Guidelines" class="headerlink" title="UX Guidelines"></a>UX Guidelines</h1><p><a href="https://code.visualstudio.com/api/ux-guidelines/overview">https://code.visualstudio.com/api/ux-guidelines/overview</a></p>
<p>说明vscode 界面布局区域</p>
<h1 id="注册命令"><a href="#注册命令" class="headerlink" title="注册命令"></a>注册命令</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;nodeDependencies.refreshEntry&#x27;</span>, <span class="function">() =&gt;</span> nodeDependenciesProvider.<span class="title function_">refresh</span>());</span><br></pre></td></tr></table></figure>

<p>注册之后即可在声明文件中调用，比如上面的 <code>nodeDependencies.refreshEntry</code></p>
]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>Practice of lerna</title>
    <url>/blog/resources/Practice-of-lerna/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近的学习内容有比较多方法论的实践，故考虑需要个仓库存放实践内容相关的内容。对于这些实践内容，我的想法是：它们唯一的共同点只是它们是“实践内容”，其他方面都应该隔离，放在一起仅仅是方便查阅与管理。同时不希望建立太多的 repository，散落在各处。故有使用 Monorepo 相关工具管理的想法。</p>
<p>粗略对比常见的几个对 Monorepo 实践的工具（<a href="https://lerna.js.org/">Lerna</a>、<a href="https://classic.yarnpkg.com/lang/en/docs/workspaces/">Yarn Workspaces</a> 和 <a href="https://pnpm.io/workspaces">Pnpm Workspaces</a>）后，考虑我建立大仓库的出发点，最终选择了 <a href="https://lerna.js.org/">Lerna</a>。</p>
<p>背景：</p>
<ul>
<li><p>系统：WSL2-Debian 12；</p>
</li>
<li><p>仓库：<a href="https://github.com/isaaxite/practices">isaaxite&#x2F;practices</a></p>
</li>
<li><p>IDE: VS Code</p>
</li>
<li><p>代码托管平台：Github</p>
</li>
<li><p>大仓库包管理工具：pnpm</p>
</li>
</ul>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/workspace</span></span><br><span class="line"></span><br><span class="line">git clone git@github.com:isaaxite/practices.git</span><br><span class="line"></span><br><span class="line">cd practices</span><br></pre></td></tr></table></figure>

<p>安装 lerna：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add lerna --save-dev</span><br></pre></td></tr></table></figure>

<p>习惯性看看 <code>--help</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna --<span class="built_in">help</span></span></span><br><span class="line">Usage: cli.js &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  cli.js add-caching          Interactive prompt to generate task runner configuration</span><br><span class="line">  cli.js changed              List local packages that have changed since the last tagged release     [aliases: updated]</span><br><span class="line">  cli.js clean                Remove the node_modules directory from all packages</span><br><span class="line">  cli.js create &lt;name&gt; [loc]  Create a new lerna-managed package</span><br><span class="line">  cli.js diff [pkgName]       Diff all packages or a single package since the last release</span><br><span class="line">  cli.js exec [cmd] [args..]  Execute an arbitrary command in each package</span><br><span class="line">  cli.js import &lt;dir&gt;         Import a package into the monorepo with commit history</span><br><span class="line">  cli.js info                 Prints debugging information about the local environment</span><br><span class="line">  cli.js init                 Create a new Lerna repo or upgrade an existing repo to the current version of Lerna</span><br><span class="line">  cli.js list                 List local packages                                                  [aliases: ls, la, ll]</span><br><span class="line">  cli.js publish [bump]       Publish packages in the current project</span><br><span class="line">  cli.js repair               Runs automated migrations to repair the state of a lerna repo</span><br><span class="line">  cli.js run &lt;script&gt;         Run an npm script in each package that contains that script</span><br><span class="line">  cli.js watch                Runs a command whenever packages or their dependents change.</span><br><span class="line">  cli.js version [bump]       Bump version of packages changed since the last release</span><br><span class="line">  cli.js add &lt;pkg&gt; [globs..]  The &quot;add&quot; command was removed by default in v7, and is no longer maintained.</span><br><span class="line">  cli.js bootstrap            The &quot;bootstrap&quot; command was removed by default in v7, and is no longer maintained.</span><br><span class="line">  cli.js link                 The &quot;link&quot; command was removed by default in v7, and is no longer maintained.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">      --loglevel       What level of logs to report.                                            [string] [default: info]</span><br><span class="line">      --concurrency    How many processes to use when lerna parallelizes tasks.                    [number] [default: 6]</span><br><span class="line">      --reject-cycles  Fail if a cycle is detected among dependencies.                                         [boolean]</span><br><span class="line">      --no-progress    Disable progress bars. (Always off in CI)                                               [boolean]</span><br><span class="line">      --no-sort        Do not sort packages topologically (dependencies before dependents).                    [boolean]</span><br><span class="line">      --max-buffer     Set max-buffer (in bytes) for subcommand execution                                       [number]</span><br><span class="line">  -h, --help           Show help                                                                               [boolean]</span><br><span class="line">  -v, --version        Show version number                                                                     [boolean]</span><br><span class="line"></span><br><span class="line">When a command fails, all logs are written to lerna-debug.log in the current working directory.</span><br><span class="line"></span><br><span class="line">For more information, check out the docs at https://lerna.js.org/docs/introduction</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 lerna 初始化项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx lerna init --dryRun</span><br></pre></td></tr></table></figure>

<p>Oops! 失败了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ ISAACGAN-PC0 <span class="keyword">in</span> ~/workspace/practices on git:main x [14:04:06]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna init --dryRun</span></span><br><span class="line">lerna notice cli v7.2.0</span><br><span class="line">lerna ERR! Cannot initialize lerna because your package manager has not been configured to use `workspaces`, and you have not explicitly specified any packages to operate on</span><br><span class="line">lerna ERR! See https://lerna.js.org/docs/getting-started#adding-lerna-to-an-existing-repo for how to resolve this</span><br></pre></td></tr></table></figure>

<p>从异常信息中得知，当前项目被识别为“已存在的仓库”。参考 lerna 对于“已存在的仓库”的指引进行初始化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">isaac @ ISAACGAN-PC0 <span class="keyword">in</span> ~/workspace/practices on git:main x [14:08:45]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npx lerna init --packages=<span class="string">&quot;packages/*&quot;</span></span></span><br><span class="line">lerna notice cli v7.2.0</span><br><span class="line">lerna info Applying the following file system updates:</span><br><span class="line">CREATE lerna.json</span><br><span class="line">lerna info Git is already initialized</span><br><span class="line">lerna info Using pnpm to install packages</span><br><span class="line">lerna success Initialized Lerna files</span><br><span class="line">lerna info New to Lerna? Check out the docs: https://lerna.js.org/docs/getting-started</span><br></pre></td></tr></table></figure>

<p>初始化后增加了 <code>lerna.json</code> 文件，见下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lerna.json</span><br><span class="line">├── LICENSE</span><br><span class="line">├── node_modules</span><br><span class="line">│   └── lerna -&gt; .pnpm/lerna@7.2.0/node_modules/lerna</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p><code>lerna.json</code> 的初始内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node_modules/lerna/schemas/lerna-schema.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;packages/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;npmClient&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>lerna.json文件主要配置如下:</p>
<ul>
<li><p>$schema: 指定配置文件结构的JSON schema</p>
</li>
<li><p>version: 项目的版本号策略,比如固定、日期等</p>
</li>
<li><p>packages: 指定包目录,这里定义在packages下所有一级子目录为独立包</p>
</li>
<li><p>npmClient: 指定所使用的包管理工具</p>
<ul>
<li>“yarn”: 默认使用Yarn</li>
<li>“npm”: 使用NPM</li>
<li>“pnpm”: 使用PNPM</li>
<li>其他工具名: 比如”my-custom-npm”</li>
</ul>
</li>
</ul>
<h1 id="新建包"><a href="#新建包" class="headerlink" title="新建包"></a>新建包</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx lerna create eslint-security</span><br></pre></td></tr></table></figure>

<p>命令执行详情见<a href="#%E5%91%BD%E4%BB%A4%E8%AF%A6%E6%83%85">附录</a>。</p>
<p>新包的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   └── eslint-security.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── __tests__</span><br><span class="line">    └── eslint-security.test.js</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>新包 <code>package.json</code> 的初始内容见 <a href="#%E6%96%B0%E5%8C%85_%60package.json%60_%E7%9A%84%E5%86%85%E5%AE%B9">附录</a>。</p>
<p><em>根目录下的 <code>lerna.json</code> 内容在新建包后未见变化。</em></p>
<p>删除已有包：</p>
<p>见上面的 <a href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><code>--help</code></a>，lerna 未提供删除已有包的命令。因此，需要手动删除。参考上面新建包后大仓库的变化，直接删除包对应目录是安全的。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="lerna-create-新建包"><a href="#lerna-create-新建包" class="headerlink" title="lerna create 新建包"></a><code>lerna create</code> 新建包</h2><h3 id="命令详情"><a href="#命令详情" class="headerlink" title="命令详情"></a>命令详情</h3><p><img src="lerna%20create%20pkg.gif"></p>
<h3 id="新的-package-json-的内容"><a href="#新的-package-json-的内容" class="headerlink" title="新的 package.json 的内容"></a>新的 <code>package.json</code> 的内容</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint-security&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;practice eslint-plugin-security&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;practice&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;eslint-plugin-security&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isaaxite &lt;isaacgun@outlook.com&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/isaaxite/practices#readme&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/eslint-security.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;__tests__&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;repository&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git+https://github.com/isaaxite/practices.git&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./__tests__/eslint-security.test.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/isaaxite/practices/issues&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://lerna.js.org/docs/getting-started">Lerna - Getting Started</a></li>
</ul>


]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>Static code analysis</title>
    <url>/blog/resources/Static-code-analysis/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h1 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h1><p>静态代码分析指的是在不实际执行代码的情况下，对源代码进行分析，并识别潜在问题、漏洞或代码质量违规。它是在持续集成和持续部署（CI&#x2F;CD）流程中进行代码分析的自动化方法。</p>
<p>静态代码分析工具会检查各种编程语言的源代码，检查常见的编码错误、安全漏洞、遵循编码规范和其他最佳实践。这些工具可以检测语法错误、未使用的变量、代码重复、潜在的安全漏洞以及遵循编码风格指南等问题。</p>
<p>通过将静态代码分析集成到 CI&#x2F;CD 流程中，开发人员可以及早发现并解决代码问题。这有助于提高代码质量、可维护性和安全性，通过在代码进入生产环境之前识别和修复问题。</p>
<h1 id="内容构成"><a href="#内容构成" class="headerlink" title="内容构成"></a>内容构成</h1><p>静态代码分析的实践主要包括以下几个部分:</p>
<ol>
<li><p>语法检查：静态代码分析工具应该能够对 JavaScript 代码进行语法检查，确保代码符合语言规范，避免常见的语法错误。</p>
</li>
<li><p>代码规范检查：静态代码分析工具可以应用各种规范（如ESLint、JSLint等）来检查代码的风格和规范是否符合约定。这包括缩进、命名约定、注释风格等。</p>
</li>
<li><p>代码质量评估：静态代码分析工具应该能够评估代码的质量，包括代码复杂性、重复代码等方面。这些评估可以帮助开发者发现潜在的问题，改进代码结构和性能。</p>
</li>
<li><p>依赖关系分析：对于 JavaScript 项目而言，依赖关系管理是重要的一部分。静态代码分析工具可以分析项目的依赖关系，检查依赖的版本、冲突和安全漏洞，并提供相关建议。</p>
</li>
<li><p>安全漏洞检测：静态代码分析工具应该能够检测 JavaScript 代码中的常见安全漏洞，如跨站脚本攻击（XSS）、SQL 注入、不安全的数据处理等，并提供修复建议。</p>
</li>
<li><p>性能优化建议：静态代码分析工具应该能够分析代码并提供性能优化的建议，帮助开发者改善代码的执行效率、减少资源消耗等。</p>
</li>
<li><p>异步代码分析：JavaScript 中的异步编程是常见的模式之一。静态代码分析工具应该能够处理和分析异步代码，以检测可能的异步错误、回调地狱和资源竞争等问题。</p>
</li>
<li><p>可读性和一致性评估：良好的代码可读性和一致性对于维护和团队协作至关重要。静态代码分析工具应该能够评估代码的可读性和一致性，并提供有关代码风格、命名规范等方面的建议。</p>
</li>
</ol>
<p>这些能力使得静态代码分析工具成为 JavaScript 开发中有力的辅助工具，可以帮助开发者提高代码质量、发现潜在问题，并改进代码风格和实践。常见的静态代码分析工具包括 ESLint、JSHint、JSLint、TSLint 等。</p>
<h1 id="实践背景"><a href="#实践背景" class="headerlink" title="实践背景"></a>实践背景</h1><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>WSL2 - Debian 12</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/os-release</span></span><br><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 12 (bookworm)&quot;</span><br><span class="line">NAME=&quot;Debian GNU/Linux&quot;</span><br><span class="line">VERSION_ID=&quot;12&quot;</span><br><span class="line">VERSION=&quot;12 (bookworm)&quot;</span><br><span class="line">VERSION_CODENAME=bookworm</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=&quot;https://www.debian.org/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://www.debian.org/support&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot;</span><br></pre></td></tr></table></figure>

<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>下面将使用 <a href="https://github.com/isaaxite/deploy-posts-to-github-issue">deploy-posts-to-github-issue</a> 作为实践的项目，期间部分实践内容会以此项目的克隆作为载体实现。</p>
<p><a href="https://github.com/isaaxite/deploy-posts-to-github-issue"><img src="Snipaste_2023-08-30_10-02-04.png"></a></p>
<ul>
<li><p>模块打包器：rollup</p>
</li>
<li><p>测试框架：jest</p>
</li>
<li><p>其他：</p>
<ul>
<li>husky：是一个用于在 Git 提交和推送前执行脚本的工具，帮助开发者在关键事件发生前自动运行定制化的操作和脚本。</li>
</ul>
</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy-posts-to-github-issue</span><br><span class="line">├── assets</span><br><span class="line">├── bin</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── commitlint.config.js</span><br><span class="line">├── dist</span><br><span class="line">├── index.js</span><br><span class="line">├── inspiration-flash.md</span><br><span class="line">├── jest.config.mjs</span><br><span class="line">├── jest.dev.config.mjs</span><br><span class="line">├── jest.js</span><br><span class="line">├── lib</span><br><span class="line">├── LICENSE</span><br><span class="line">├── MANUAL.md</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── reports</span><br><span class="line">├── rollup.config.js</span><br><span class="line">├── scripts</span><br><span class="line">└── __test__</span><br></pre></td></tr></table></figure>

<p>核心代码目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">  └── index.js</span><br><span class="line"></span><br><span class="line">lib/</span><br><span class="line">  ├── asset_finder.js</span><br><span class="line">  ├── asset_publisher.js</span><br><span class="line">  ├── conf_reader.js</span><br><span class="line">  ├── constants</span><br><span class="line">  │   ├── asset.js</span><br><span class="line">  │   ├── enum.js</span><br><span class="line">  │   └── index.js</span><br><span class="line">  ├── hinter.js</span><br><span class="line">  ├── link_formater.js</span><br><span class="line">  ├── md_frontmatter.js</span><br><span class="line">  ├── post_finder.js</span><br><span class="line">  ├── post_manager.js</span><br><span class="line">  ├── post_parse.js</span><br><span class="line">  ├── post_path.js</span><br><span class="line">  └── utils</span><br><span class="line">      ├── common.js</span><br><span class="line">      ├── error.js</span><br><span class="line">      └── index.js</span><br></pre></td></tr></table></figure>

<h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
<th>提出时间</th>
<th>GitHub Star 数量</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://eslint.org/">ESLint</a></td>
<td>可配置的 JavaScript&#x2F;JS 代码检查工具和静态分析器，替代 JSHint，提供更大的灵活性和可配置性</td>
<td>2013年</td>
<td>23.3k</td>
</tr>
<tr>
<td><a href="https://jshint.com/">JSHint</a></td>
<td>JavaScript&#x2F;JS 的静态代码分析工具，支持可定制的规则，延续 JSLint 的思想，提供更好的可定制性和适应性</td>
<td>2011年</td>
<td>8.9k</td>
</tr>
<tr>
<td><a href="https://palantir.github.io/tslint/">TSLint</a></td>
<td>针对 TypeScript 的静态代码分析工具，已被 ESLint 取代，提供静态代码检查和规范性的支持</td>
<td>2012年</td>
<td>5.9k</td>
</tr>
<tr>
<td><a href="https://www.typescriptlang.org/">TypeScript</a></td>
<td>JavaScript 的超集，带有静态类型检查和编译时静态代码分析能力，提供更严格的类型检查和更好的 IDE 支持，增强 JavaScript 开发环境的可靠性</td>
<td>2012年</td>
<td>93.5k</td>
</tr>
<tr>
<td><a href="https://flow.org/">Flow</a></td>
<td>Facebook 开发的 JavaScript&#x2F;JS 静态类型检查器，为 JavaScript 开发者提供静态类型检查，提高代码质量和可维护性</td>
<td>2014年</td>
<td>22k</td>
</tr>
</tbody></table>
<p>从功能性与和流行趋势，TSLint 和 JSHint 已经被 ESLint 替代。而 TypeScript，与其说它是静态代码分析的工具，不如说它是个类似JS的语言。当然它具备静态代码分析的能力，但如果已经开发到一定程度的项目所使用的开发语言是JS的话，使用TS的会有不小的迁移成本！</p>
<p>剩下的是 ESLint 和 Flow，它们提出时间和流行程度都差不多。不妨针对它们做一下对比分析。</p>
<p>下面是使用表格对比 ESLint 和 Flow 的功能：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>ESLint</th>
<th>Flow</th>
</tr>
</thead>
<tbody><tr>
<td>代码检查</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>类型检查</td>
<td>❌</td>
<td>✔️</td>
</tr>
<tr>
<td>静态类型推断</td>
<td>❌</td>
<td>✔️</td>
</tr>
<tr>
<td>编译时类型检查</td>
<td>❌</td>
<td>✔️</td>
</tr>
<tr>
<td>支持 JavaScript</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>支持 TypeScript</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>可配置性</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>社区支持</td>
<td>大型活跃社区，广泛的插件和扩展库可用</td>
<td>较小的社区，插件和扩展库相对较少</td>
</tr>
<tr>
<td>IDE 集成</td>
<td>广泛支持，与许多主流编辑器（如 VS Code、Sublime Text）集成良好</td>
<td>有限的 IDE 集成，可能不如 ESLint 的支持广泛和完善</td>
</tr>
<tr>
<td>项目可移植性</td>
<td>高</td>
<td>较低，Flow 的类型注释和配置文件需要进行迁移和调整才能与其他工具兼容</td>
</tr>
</tbody></table>
<p>需要注意的是，ESLint 和 Flow 在某些功能上有所重叠，但也有一些区别。ESLint 主要关注代码规范和质量检查，而 Flow 则专注于静态类型检查和类型推断。ESLint 的可配置性和社区支持相对较高，适用于 JavaScript 和 TypeScript 项目，并与各种编辑器集成良好。Flow 在类型检查和静态类型推断方面表现出色，但它的社区支持相对较小，与编辑器的集成程度可能不如 ESLint 那么广泛。此外，如果要将项目从 Flow 迁移到其他工具或框架，可能需要进行一些调整和改动。</p>
<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>ESLint 是一个用于检查和规范 JavaScript 代码的开源工具。它可以帮助开发者在编写代码时发现潜在的问题、遵循一致的代码风格，并提供自定义的代码规则。ESLint 具有高度可配置性和灵活性，可以适应不同项目和团队的需求。</p>
<p>以下是 ESLint 的一些主要特点和功能：</p>
<ol>
<li><p>代码规范检查： ESLint 可以静态地分析 JavaScript 代码，并根据预定义的规则集检查代码是否符合规范。它可以发现常见的错误、潜在的问题和不一致之处，如未声明的变量、使用未定义的函数、潜在的歧义等。</p>
</li>
<li><p>可配置性： ESLint 具有高度的可配置性，允许开发者根据项目需求和团队的代码风格指南自定义规则。你可以启用、禁用或修改规则，并设置不同的错误级别（警告或错误）。此外，ESLint 还支持配置文件的继承和共享，以便在多个项目中共享和重用配置。</p>
</li>
<li><p>插件和扩展： ESLint 具有丰富的插件生态系统，可以通过插件扩展其功能。插件可以添加额外的规则、支持其他文件类型（如 TypeScript、Vue 等），或提供特定框架或库的规则集。通过安装和配置这些插件，你可以在 ESLint 中使用更多的规则和功能。</p>
</li>
<li><p>自动修复问题： ESLint 具备自动修复问题的能力，可以通过 –fix 标志自动修复一些常见的问题，如不一致的缩进、缺少分号等。这样可以减轻开发者手动修复问题的负担，并提高代码的一致性。</p>
</li>
<li><p>与编辑器和构建工具的集成： ESLint 可以与各种编辑器和构建工具集成，以提供实时的代码检查和反馈。大多数编辑器都支持 ESLint 插件，可以在保存文件时自动运行 ESLint，并在编辑器中显示错误和警告。此外，ESLint 还可以与构建工具（如 webpack、gulp 等）集成，以便在构建过程中进行代码检查。</p>
</li>
</ol>
<p>ESLint 是一个非常强大和流行的工具，被广泛用于 JavaScript 项目中。它可以帮助开发团队保持一致的代码风格、规范代码质量，并提高代码的可读性和可维护性。通过使用 ESLint，开发者可以在早期发现和解决潜在的问题，提高代码的可靠性和稳定性。</p>
<p>eslint 对代码静态分析实践的部分：</p>
<ul>
<li><p>语法检查；</p>
</li>
<li><p>代码规范检查；</p>
</li>
<li><p>代码质量评估；</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add --save-dev eslint</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用 eslint 提供的能力进行初始化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init @eslint/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~ or ~</span></span><br><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure>
<p><img src="eslint-init.gif"></p>
<p>上面 init 命令分别做了下面几件事：</p>
<ul>
<li><p>配置 Eslint 的能力范围，prompt 提供三个选项：</p>
<ol>
<li>仅作代码检查；</li>
<li>代码检查与反馈问题；</li>
<li>代码检查、反馈问题以及格式化。</li>
</ol>
</li>
<li><p>指定模块风格：</p>
<ol>
<li>JavaScript modules；</li>
<li>CommonJS；</li>
<li>不设置。</li>
</ol>
</li>
<li><p>选择框架，目前会提供 <code>Reat</code> 和 <code>Vue</code> 或者不设置；</p>
</li>
<li><p>配置是否使用了 TypeScript；</p>
</li>
<li><p>配置项目的运行时，Node 或 浏览器（但貌似有 Bug）；</p>
</li>
<li><p>选择代码风格的配置方式，提供下面两种方式：</p>
<ol>
<li>先择现成的解决方案；</li>
<li>自定义配置；</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-08-24_02-40-55.png"></p>
<p>在初始化过程中，需要我们选择 Eslint 代码风格。在 Prompt 中可以看到有 Airbnb、Standard，Google 和 XO 四种提供。下面以表格的形式对四种规范做简短说明。</p>
<table>
<thead>
<tr>
<th>代码规范</th>
<th>特点</th>
<th>缩进</th>
<th>引号</th>
<th>分号</th>
<th>严格相等和不严格相等</th>
<th>对象字面量属性排序</th>
<th>Github Star</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/airbnb/javascript">Airbnb</a></td>
<td>- 强调代码的可读性和一致性<br>- 鼓励使用现代的JavaScript语言特性和最佳实践<br>- 包括对代码风格、命名约定、缩进、注释等的建议<br>- 要求使用ES6及以上版本的JavaScript并强制一些严格的规则</td>
<td>2 个空格</td>
<td>单引号</td>
<td>可选</td>
<td>推荐使用</td>
<td>推荐排序</td>
<td>136k</td>
</tr>
<tr>
<td><a href="https://github.com/standard/standard">Standard</a></td>
<td>- 简洁明了的JavaScript代码规范<br>- 减少代码样式的争议<br>- 鼓励一种统一的代码风格<br>- 使用两个空格的缩进、禁止使用分号等的具体规则<br>- 遵循ES5的语法</td>
<td>2 个空格</td>
<td>单引号</td>
<td>禁止</td>
<td>推荐使用</td>
<td>推荐排序</td>
<td>28.4k</td>
</tr>
<tr>
<td><a href="https://github.com/google/eslint-config-google">Google</a></td>
<td>- Google公司内部广泛使用的规范<br>- 强调可读性、可维护性和性能<br>- 提供了详细的代码编写指南<br>- 支持ES5和ES6语法<br>- 提供一些特定于Google编码风格的规则</td>
<td>2 个空格</td>
<td>双引号</td>
<td>强制</td>
<td>推荐使用</td>
<td>推荐排序</td>
<td>1.7k</td>
</tr>
<tr>
<td><a href="https://github.com/xojs/eslint-config-xo">XO</a></td>
<td>- 具有严格规则集的JavaScript代码规范和代码检查工具<br>- 基于ESLint构建<br>- 提供零配置的规范<br>- 强制执行高级规则，如使用ES6模块、禁止使用<code>console</code>等<br>- 提供可选的规则来适应不同的开发需求</td>
<td>2 个空格</td>
<td>单引号</td>
<td>禁止</td>
<td>推荐使用</td>
<td>推荐排序</td>
<td>248</td>
</tr>
</tbody></table>
<p>请注意，以上表格只列出了一些主要的规范特点，并不能穷尽所有规范的细节。对于更详细的规范内容和具体规则，建议查阅各自的官方文档或 GitHub 仓库。选择适合自己或团队的代码规范时，可以深入研究每个规范的详细规则，并根据实际需求进行定制。</p>
<p>在 init 的过程中选择了 airbnb。airbnb发布的ESLint配置规则广为人知,我们可以从以下几个方面对其规则进行分类:</p>
<ul>
<li><p><strong>代码质量</strong>：包含无用代码检测、最佳实践、复杂度限制等,如no-unused-vars、no-implicit-globals、complexity等。</p>
</li>
<li><p><strong>错误防范</strong>：包含可能导致错误的代码模式检测,如no-console、no-debugger、no-alert等。</p>
</li>
<li><p><strong>风格统一</strong>：包含代码风格方面的规则,强制一致的代码风格,如quotes、indent、space-before-function-paren等。</p>
</li>
<li><p><strong>ES6优先</strong>：包含优先使用ES6新特性的规则,如prefer-const、prefer-rest-params、prefer-spread等。</p>
</li>
<li><p><strong>浏览器环境</strong>：包含针对浏览器环境的规则,如no-restricted-globals、no-alert等。</p>
</li>
<li><p><strong>Node.js环境</strong>：包含针对Node.js环境的规则,如handle-callback-err、no-mixed-requires等。</p>
</li>
<li><p><strong>规范与习惯</strong>：根据通用代码编写规范制定的规则,如camelcase、new-cap、curly等。</p>
</li>
<li><p><strong>可读性</strong>：关注代码可读性的规则,如max-len、max-lines、max-params等。</p>
</li>
<li><p><strong>变量声明</strong>：规范变量声明方式的规则,如no-var、prefer-const等。</p>
</li>
</ul>
<p>以上分类让我们更直观地看到airbnb规则的覆盖面和侧重点。</p>
<p>初始化完成后，会得到如下的配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.cjs</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">  <span class="attr">overrides</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">files</span>: [</span><br><span class="line">        <span class="string">&#x27;.eslintrc.&#123;js,cjs&#125;&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;script&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 env 的配置与上面 init 过程中选择运行时明显不同，下面手动修改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">env</span>: &#123;</span><br><span class="line">  <span class="attr">browser</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>下面对生成的配置文件中几个配置项做简单说明：</p>
<ul>
<li><p><code>env</code>：指定代码运行的环境，如浏览器环境 (browser)、Node.js 环境 (node) 等；</p>
</li>
<li><p><code>extends</code>：引用其他配置文件或扩展，可以是已经定义好的配置（如 airbnb-base）、共享配置（如 eslint:recommended）或自定义的配置；</p>
</li>
<li><p><code>globals</code>：定义全局变量，避免因为全局变量未定义而产生警告；</p>
</li>
<li><p><code>parser</code>：指定代码解析器，例如 Babel 解析器 (babel-eslint) 或 TypeScript 解析器 (@typescript-eslint&#x2F;parser)；</p>
</li>
<li><p><code>parserOptions</code>：指定解析器选项，如 ECMAScript 版本 (ecmaVersion)、源代码类型 (sourceType)、额外的语言特性支持等；</p>
</li>
<li><p><code>plugins</code>：加载并使用 ESLint 插件，扩展额外的规则和功能；</p>
</li>
<li><p><code>rules</code>：定义规则，用于检查和强制执行代码的编码规范，可以启用、禁用、配置规则的错误级别等；</p>
</li>
<li><p><code>overrides</code>：允许对特定文件或文件类型进行额外的配置，可以覆盖全局配置；</p>
</li>
</ul>
<p>ESLint 常用的插件包括:</p>
<ul>
<li><p><a href="https://github.com/jsx-eslint/eslint-plugin-react">eslint-plugin-react</a> - 检查 React 代码,支持 JSX 语法等。</p>
</li>
<li><p><a href="https://github.com/vuejs/eslint-plugin-vue">eslint-plugin-vue</a> - 检查 Vue 代码,支持 *.vue 文件。</p>
</li>
<li><p><a href="https://github.com/Gillespie59/eslint-plugin-angular">eslint-plugin-angular</a> - 检查 Angular 代码,支持指令、模块等特性。</p>
</li>
<li><p><a href="https://github.com/jquery/eslint-plugin-jquery">eslint-plugin-jquery</a> - 检查 jQuery 代码。</p>
</li>
<li><p><a href="https://github.com/mysticatea/eslint-plugin-node">eslint-plugin-node</a> - 添加Node.js环境下的JavaScript代码检查。</p>
</li>
<li><p><a href="https://github.com/benmosher/eslint-plugin-import">eslint-plugin-import</a> - 检查ES6+ 的 import&#x2F;export 语法。</p>
</li>
<li><p><a href="https://github.com/jsx-eslint/eslint-plugin-jsx-a11y">eslint-plugin-jsx-a11y</a> - 辅助检查JSX元素的可访问性。</p>
</li>
<li><p><a href="https://github.com/xjamundx/eslint-plugin-promise">eslint-plugin-promise</a> - 添加Promise相关的规则。</p>
</li>
<li><p><a href="https://github.com/standard/eslint-plugin-standard">eslint-plugin-standard</a> - 实现standard代码风格的规则。</p>
</li>
<li><p><a href="https://github.com/BenoitZugmeyer/eslint-plugin-html">eslint-plugin-html</a> - 检查HTML文件中的JavaScript代码。</p>
</li>
<li><p><a href="https://github.com/eslint/eslint-plugin-markdown">eslint-plugin-markdown</a> - 检查Markdown文件中的代码。</p>
</li>
<li><p><a href="https://github.com/amilajack/eslint-plugin-compat">eslint-plugin-compat</a> - 检查浏览器兼容性问题。</p>
</li>
<li><p><a href="https://github.com/jest-community/eslint-plugin-jest">eslint-plugin-jest</a> - 检查Jest测试框架的代码。</p>
</li>
<li><p><a href="https://github.com/typescript-eslint/typescript-eslint">eslint-plugin-typescript</a> - 添加TypeScript语法支持。</p>
</li>
<li><p><a href="https://github.com/eslint-community/eslint-plugin-security">eslint-plugin-security</a> - 用于检测 JavaScript 代码中的潜在安全漏洞。它提供了一系列规则，用于查找并警告可能导致安全问题的代码模式。</p>
</li>
</ul>
<p>通过使用不同的插件可以大大扩展ESLint的功能范围,适应不同的项目需求。</p>
<h2 id="扫描代码"><a href="#扫描代码" class="headerlink" title="扫描代码"></a>扫描代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx eslint ./lib/ ./bin/</span><br></pre></td></tr></table></figure>

<p><img src="Snipaste_2023-08-24_10-05-38.png"></p>
<h2 id="质量报告"><a href="#质量报告" class="headerlink" title="质量报告"></a>质量报告</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx eslint ./lib ./bin --format=html --output-file=reports/eslint-report.html</span><br></pre></td></tr></table></figure>

<p>使用 anywhere 启动 http 服务:</p>
<p><img src="Snipaste_2023-08-24_05-44-28.png"></p>
<p>其他支持的输出的格式：</p>
<ul>
<li><p>checkstyle：以 Checkstyle XML 格式输出，适合与其他工具集成；</p>
</li>
<li><p>compact：以紧凑的格式输出，适合在终端上显示；</p>
</li>
<li><p>html：以 HTML 格式输出，适合在浏览器中查看；</p>
</li>
<li><p>jslint-xml：以 JSLint XML 格式输出，适合与其他工具集成；</p>
</li>
<li><p>json-with-metadata：以 JSON 格式输出，包含元数据信息；</p>
</li>
<li><p>json：以纯 JSON 格式输出；</p>
</li>
<li><p>junit：以 JUnit XML 格式输出，适合与持续集成工具集成；</p>
</li>
<li><p>stylish：以类似于代码样式的格式输出，适合在终端上显示；</p>
</li>
<li><p>tap：以 TAP（Test Anything Protocol）格式输出，适合与测试框架集成；</p>
</li>
<li><p>unix：以类 Unix 风格的格式输出，适合在终端上显示；</p>
</li>
<li><p>visualstudio：以 Visual Studio Code 的问题报告格式输出，适合在编辑器中显示。</p>
</li>
</ul>
<h2 id="自动修复"><a href="#自动修复" class="headerlink" title="自动修复"></a>自动修复</h2><p>使用 <code>--fix</code> 可选项修复部分问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx eslint --fix ./lib/ ./bin/</span><br></pre></td></tr></table></figure>

<p>修复后的报告见下。对比前面的报告，eslint 修复了大部分问题，但实际上 eslint 尽可以修复部分类型的问题。</p>
<p>以下是一些常见的 ESLint 可以自动修复的问题类型：</p>
<ul>
<li><p>格式问题：例如缩进、空格、换行等方面的问题可以通过自动修复功能进行修复；</p>
</li>
<li><p>引号问题：例如单引号和双引号之间的一致性问题可以自动修复；</p>
</li>
<li><p>无用代码：例如未使用的变量、未使用的导入等可以通过自动修复进行删除；</p>
</li>
<li><p>标准化问题：例如统一函数命名、统一变量命名等可以通过自动修复进行标准化；</p>
</li>
<li><p>基本语法问题：例如缺少分号、多余的逗号等可以通过自动修复进行修复。</p>
</li>
</ul>
<p><img src="Snipaste_2023-08-24_10-06-16.png"></p>
<p>在了解自动修复的相关内容时，另一款据说相较 Eslint 更强的工具，prettier 出现在我的视线。</p>
<p>根据 prettier 的文档（<a href="https://prettier.io/docs/en/integrating-with-linters">Integrating with Linters</a>）指引安装了扩展（eslint-config-prettier）和插件（eslint-plugin-prettier）。最终修过没有达到预期，剩下大部分问题依然无法自动格式化，下面是使用 prettier 前（左）后（右）的对比：</p>
<p><img src="Snipaste_2023-08-26_18-37-50.png"></p>
<ul>
<li><p>使用后，问题从162个减少到153个，共11个；</p>
</li>
<li><p>对比后得知，被自动修复的问题是 <code>max-len</code> 类问题（如下）；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:1	Error	This line has a length of 105. Maximum allowed is 100.	max-len</span><br></pre></td></tr></table></figure></li>
</ul>
<p>根据 ESLint 报告里面的错误信息,可以将检测到的问题分类如下:</p>
<ol>
<li>导入语句问题</li>
</ol>
<ul>
<li><p>Unexpected use of file extension “js” for imports: 应该直接导入模块名,不需要添加.js后缀</p>
</li>
<li><p>Prefer default export on a file with single export: 当模块只有一个导出时应设置为default导出</p>
</li>
</ul>
<ol start="2">
<li>代码质量问题</li>
</ol>
<ul>
<li>no-use-before-define: 在定义前使用变量</li>
<li>no-nested-ternary: 不要嵌套三元表达式 </li>
<li>no-plusplus: 不要使用++&#x2F;–运算符</li>
<li>no-restricted-syntax: 不允许使用语法结构generate&#x2F;yield</li>
</ul>
<ol start="3">
<li>最佳实践问题</li>
</ol>
<ul>
<li>no-param-reassign: 不要修改函数参数</li>
<li>no-console: 不要使用console语句</li>
<li>no-alert: 不要使用alert</li>
</ul>
<ol start="4">
<li>风格问题</li>
</ol>
<ul>
<li>camelcase: 变量名应使用驼峰命名</li>
<li>max-classes-per-file: 每个文件类的数量不应超过1个</li>
</ul>
<ol start="5">
<li>可读性问题</li>
</ol>
<ul>
<li>no-magic-numbers: 不要使用难懂的数字常量</li>
<li>no-nested-ternary: 不要嵌套三元表达式</li>
</ul>
<ol start="6">
<li>未使用变量问题</li>
</ol>
<ul>
<li>no-unused-vars: 定义后未使用的变量</li>
</ul>
<ol start="7">
<li>循环问题</li>
</ol>
<ul>
<li>no-loop-func: 循环中不要定义函数</li>
</ul>
<p>以上这些问题都是确实 Eslint 和 prettier 无法自动格式化的问题。实际上，EsLint 的官网也有对那些规则无法格式化有做简短说明，可查阅：<a href="https://eslint.org/docs/latest/rules/">Rules Reference</a>。</p>
<blockquote>
<p><img src="Snipaste_2023-08-26_18-51-04.png"></p>
</blockquote>
<h2 id="安全检测"><a href="#安全检测" class="headerlink" title="安全检测"></a>安全检测</h2><p>eslint-plugin-security：<a href="https://github.com/eslint-community/eslint-plugin-security">https://github.com/eslint-community/eslint-plugin-security</a></p>
<p>ESLint内置对XSS漏洞的检测规则,但是需要安装额外的插件才能启用。</p>
<p>具体操作如下:</p>
<ol>
<li>安装eslint-plugin-security插件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install eslint-plugin-security</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在.eslintrc.js配置文件中添加plugins和rules:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;security&#x27;</span>],</span><br><span class="line">  </span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;security/detect-object-injection&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;security/detect-non-literal-fs-filename&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;security/detect-non-literal-regexp&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;security/detect-possible-timing-attacks&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&#x27;security/detect-non-literal-require&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行ESLint,它会检查可能导致XSS的内容注入风险。</li>
</ol>
<p>如变量直接插入到HTML中而未经过滤、模板字符串注入等情况。</p>
<ol start="4">
<li>需要进一步配置白名单或黑名单来去除误报。</li>
</ol>
<p>使用这个插件可以在开发阶段及早发现XSS问题,但不可完全替代动态测试。</p>
<h2 id="IDE-集成"><a href="#IDE-集成" class="headerlink" title="IDE 集成"></a>IDE 集成</h2><p>TODO</p>
<h2 id="强制执行"><a href="#强制执行" class="headerlink" title="强制执行"></a>强制执行</h2><h3 id="git-hook"><a href="#git-hook" class="headerlink" title="git-hook"></a>git-hook</h3><p>TODO</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 语法检查</li>
<li><input checked="" disabled="" type="checkbox"> 代码规范检查</li>
<li><input checked="" disabled="" type="checkbox"> 代码质量评估</li>
<li><input disabled="" type="checkbox"> 依赖关系分析</li>
<li><input disabled="" type="checkbox"> 安全漏洞检测</li>
<li><input disabled="" type="checkbox"> 性能优化建议</li>
<li><input disabled="" type="checkbox"> 异步代码分析</li>
<li><input disabled="" type="checkbox"> 可读性和一致性评估</li>
</ul>
<h1 id="统计报告"><a href="#统计报告" class="headerlink" title="统计报告"></a>统计报告</h1><h2 id="Plato"><a href="#Plato" class="headerlink" title="Plato"></a>Plato</h2><p>Plato 是一个基于 JavaScript 的代码分析和可视化工具，用于生成代码复杂度报告和可视化图表。它提供了对圈复杂度、函数长度、类复杂度等指标的详细分析和可视化展示。</p>
<h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">pnpm add plato --save-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用</span></span><br><span class="line">npx plato -r -d ./reports/plato -e .eslintrc.cjs ./lib ./bin</span><br></pre></td></tr></table></figure>

<p>这句命令是使用 <code>plato</code> 工具生成代码复杂度报告的命令。它的作用是在指定的目录下分析 JavaScript 文件，并生成递归的代码复杂度报告，报告输出到 <code>./reports/plato</code> 目录。同时，还会使用指定的 ESLint 配置文件进行代码分析。</p>
<p>下面对命令中的各个部分进行解释：</p>
<ul>
<li><p><code>-r</code>: 表示生成递归报告。递归报告会分析指定目录下的所有 JavaScript 文件及其子目录中的文件。</p>
</li>
<li><p><code>-d ./reports/plato</code>: <code>-d</code> 是 <code>plato</code> 的一个命令行选项，用于指定报告输出目录。在这个命令中，将报告输出到 <code>./reports/plato</code> 目录。</p>
</li>
<li><p><code>-e .eslintrc.cjs</code>: <code>-e</code> 是 <code>plato</code> 的一个命令行选项，用于指定 ESLint 配置文件。在这个命令中，使用 <code>.eslintrc.cjs</code> 文件作为 ESLint 的配置文件。</p>
</li>
<li><p><code>./lib ./bin</code>: <code>./lib ./bin</code> 是指定要分析的 JavaScript 文件或目录。在这个命令中，分析 <code>./lib</code> 和 <code>./bin</code> 目录下的 JavaScript 文件。</p>
</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="配置文件扩展名"><a href="#配置文件扩展名" class="headerlink" title="配置文件扩展名"></a>配置文件扩展名</h3><p><em>遇到第一个问题：不支持 <code>cjs</code> 扩展名的配置文件，根据提示推断是要求 json 格式的。</em></p>
<p><img src="Snipaste_2023-08-27_02-21-07.png"></p>
<p>这个先按下，跳过指定 eslint 的配置文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx plato -r -d ./reports/plato ./lib ./bin</span><br></pre></td></tr></table></figure>

<p>出现了第二个问题：plato 不支持 ES6+ 的 Class 死有属性语法。时至今日，不支持这个语法，或许可以认为这个工具已经被抛弃。从目前的状况确实是这样，最后一次更新已经是 7 年前！但是它确实目前我可以找到功能比较完备的带质量报告生成工具。</p>
<p><img src="Snipaste_2023-08-27_02-28-03.png"></p>
<p>既然是语法的兼容性问题，那就用 babel 做转译兼容。最终目的是在保留目录解构的前提下，做最小程度的兼容：</p>
<p>安装 babel 相关 pkg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add --save-dev @babel/core @babel/cli</span><br></pre></td></tr></table></figure>

<p>添加插件编译私有方法与属性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add --save-dev \</span><br><span class="line">  @babel/plugin-transform-class-properties \</span><br><span class="line">  @babel/plugin-transform-private-methods \</span><br><span class="line">  @babel/plugin-transform-private-property-in-object</span><br></pre></td></tr></table></figure>

<p>配置文件（<code>.babelrc</code>）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-class-properties&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-private-property-in-object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-private-methods&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>编译与生成质量报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf temp/dist ./reports/plato &amp;&amp; \</span><br><span class="line">  npx babel lib --out-dir temp/dist &amp;&amp; \</span><br><span class="line">  npx plato -r -d ./reports/plato ./temp/dist</span><br></pre></td></tr></table></figure>

<h3 id="点操作符的可选语法"><a href="#点操作符的可选语法" class="headerlink" title="点操作符的可选语法"></a>点操作符的可选语法</h3><p>出现另外的问题：plato 不支持点操作符的可选语法。安装 <code>@babel/plugin-transform-optional-chaining</code> 插件转译此语法，再此生成报告：</p>
<p><img src="Snipaste_2023-08-27_10-56-23.png"></p>
<p>生成 html 格式的质量报告，使用 <code>anywhere</code> 渲染后，在浏览器打开：</p>
<p><img src="Snipaste_2023-08-27_10-59-57.png"></p>
<h2 id="Plato报告概述"><a href="#Plato报告概述" class="headerlink" title="Plato报告概述"></a>Plato报告概述</h2><p>Plato 提供了一系列质量指标来评估代码的质量和复杂性。以下是一些常见的 Plato 提供的质量指标：</p>
<ul>
<li><p>Lines of Code(LOC) - 源代码总行数。</p>
</li>
<li><p>Total Complexity - 整体复杂度评分。增加表示代码整体复杂度上升。</p>
</li>
<li><p>Average Complexity - 每个函数的平均复杂度。增加表示每个函数复杂度提高。</p>
</li>
<li><p>Function Declarations - 函数声明数量。增加表示函数数增多。</p>
</li>
<li><p>Global Variables - 全局变量使用数量。增加表示使用更多全局变量。</p>
</li>
<li><p>Cyclomatic Complexity - 圈复杂度。增加表示代码路径增加,逻辑更复杂。</p>
</li>
<li><p>Halstead metrics - 几项代码复杂度度量。提高表示代码更复杂。</p>
</li>
<li><p>Maintainability Index - 可维护性指数。下降代表可维护性降低。</p>
</li>
<li><p>Lint Errors - Lint检查出的错误数。增加表示代码质量问题更多。 </p>
</li>
<li><p>Estimated Errors - 预测出的错误数。增加表示可能出错机会上升。</p>
</li>
</ul>
<p>综上, Plato的指标上升通常代表代码质量和可维护性下降,复杂度提高,这可以帮助我们分析和改进代码。</p>
<h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><h3 id="Palto-报告"><a href="#Palto-报告" class="headerlink" title="Palto 报告"></a>Palto 报告</h3><p>使用 babel 解决 palto 的兼容问题。babel 将核心源码配合下面示例中的四个插件做最小程序的编译，输出到 <code>./temp/dist</code> 目录。</p>
<p>palto 基于 <code>./temp/dist</code> 目录的代码生成报告，输出到 <code>./reports/plato</code>。</p>
<p><strong><code>./scripts/plato.report.js</code>：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; execSync &#125; <span class="keyword">from</span> <span class="string">&#x27;child_process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">  <span class="string">&#x27;@babel/plugin-transform-optional-chaining&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;@babel/plugin-transform-class-properties&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;@babel/plugin-transform-private-property-in-object&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;@babel/plugin-transform-private-methods&#x27;</span>,</span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cmd = [</span><br><span class="line">  <span class="string">&#x27;rm -rf temp/dist ./reports/plato&#x27;</span>,</span><br><span class="line">  <span class="string">`npx babel ./bin ./lib --plugins <span class="subst">$&#123;plugins&#125;</span> --out-dir temp/dist`</span>,</span><br><span class="line">  <span class="string">&#x27;npx plato -r -d ./reports/plato ./temp/dist&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;rm -rf temp/dist&#x27;</span>,</span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27; &amp;&amp; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="property">stderr</span>.<span class="title function_">write</span>(<span class="string">`<span class="subst">$&#123;cmd&#125;</span>\n`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">execSync</span>(cmd, &#123;</span><br><span class="line">  <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span>,</span><br><span class="line">  <span class="attr">shell</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>package.json</code>：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;plato-report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node scripts/plato.report.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="组合-Eslint"><a href="#组合-Eslint" class="headerlink" title="组合 Eslint"></a>组合 Eslint</h3><p>简单组合 Eslint。同时生成 Eslint 与 Palto 报告。</p>
<p><strong><code>package.json</code>：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;plato-report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node scripts/plato.report.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;eslint-report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rm -rf reports/eslint-report.html &amp;&amp; npx eslint ./lib ./bin --format=html --output-file=reports/eslint-report.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;static-report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run plato-report &amp;&amp; npm run eslint-report&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>npm run static-report</code> 生成两份报告。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>进一步加强“代码质量评估”部分的实践。增加更多的代码质量指标，比如“整体复杂度”、“圈复杂度”、“预测出的错误数”等等。</p>
<p>但是由于 Palto 对于 ES6+ 的语法兼容性不足，以致需要使用 Babel 做向下兼容的编译。导致报告中出现非预期的兼容性代码和报告内容，让报告的可读性下降。虽然如此，Palto 生成的报告依然比Eslint的更加详尽。</p>
<h1 id="依赖分析"><a href="#依赖分析" class="headerlink" title="依赖分析"></a>依赖分析</h1><p>下面将使用其他工具针对 “依赖关系分析” 部分进行实践。将列出常用几款工具做对比，然后会选择其中一款进行安装与使用。</p>
<h2 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>指标</th>
<th>说明</th>
<th>GitHub Star</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/adamtornhill/code-maat">Code Maat ↗</a></td>
<td>- 模块间的循环依赖关系<br>- 无效引用<br>- 模块的入度和出度<br>- 模块的内部复杂性<br>- 模块的外部复杂性<br>- 模块的深度<br>- 模块的大小</td>
<td>Code Maat 是一个通用的代码度量工具，支持多种指标，包括循环依赖关系、无效引用、模块的入度和出度、模块的内部复杂性、模块的外部复杂性、模块的深度和模块的大小等。它提供了灵活的配置选项和可视化功能，适用于多种编程语言。</td>
<td>2.2k</td>
</tr>
<tr>
<td><a href="https://github.com/sverweij/dependency-cruiser">Dependency-Cruiser ↗</a></td>
<td>- 可持续性指标<br>- 简单性指标<br>- 复杂性指标<br>- 规模指标</td>
<td>Dependency-Cruiser 提供了可持续性指标、简单性指标、复杂性指标和规模指标。可持续性指标包括模块间的循环依赖关系和无效引用。简单性指标包括模块的入度和出度、模块的内部复杂性。复杂性指标包括模块的外部复杂性和模块的深度。规模指标包括模块的大小。它提供了自定义规则和配置的功能，可用于 JavaScript 项目的依赖分析和优化。</td>
<td>4.4k</td>
</tr>
<tr>
<td><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle Analyzer ↗</a></td>
<td>- 模块大小<br>- 模块依赖关系<br>- 模块的引用路径<br>- 模块的体积占比</td>
<td>Webpack Bundle Analyzer 提供了模块大小、模块依赖关系、模块的引用路径和模块的体积占比等指标。它通过可视化图表和图形的方式展示这些指标，帮助你分析和优化 Webpack 打包后的代码。</td>
<td>12.4k</td>
</tr>
<tr>
<td><a href="https://github.com/btd/rollup-plugin-visualizer">Rollup Plugin Visualizer ↗</a></td>
<td>- 模块大小<br>- 模块依赖关系<br>- 模块的引用路径<br>- 模块的体积占比</td>
<td>Rollup Plugin Visualizer 提供了模块大小、模块依赖关系、模块的引用路径和模块的体积占比等指标。它通过可视化图表和图形的方式展示这些指标，帮助你分析和优化使用 Rollup 打包后的代码。</td>
<td>1.5k</td>
</tr>
</tbody></table>
<p>Code Maat 是一个通用的代码度量工具，由于它是基于 Java 开发的，所以要在 Node.js 环境中安装和使用 Code Maat，你需要确保你的系统已经安装了 Java 运行时环境 (JRE) 或者 Java 开发工具包 (JDK)。</p>
<p><em>考虑到环境配置的复杂度问题，Code Maat 的优先级会下降，暂不考虑它！</em></p>
<p>Webpack Bundle Analyzer 是以往有使用过的一款工具，确实不错。它提供的参考指标也符合预期，流行程度也是上面 4 款中最高的，但是考虑到当前实践项目的背景（rollup），因此优先级也是往下降的。</p>
<p><strong>因此，就目前情况优先考虑 Rollup Plugin Visualizer 和 Dependency-Cruiser。</strong></p>
<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Dependency%20cruiser.png" alt="Dependency cruiser">
    <img src="Rollup%20Plugin%20Visualizer.png" alt="Rollup Plugin Visualizer">
  </blockquote>
</details>
<br>

<p>下面将先后安装 Rollup Plugin Visualizer 和 Dependency-Cruiser，在看它们最后的实际效果。如果两者相差不大，考虑到实践项目背景，当优先选择前者。</p>
<h2 id="Rollup-Plugin-Visualizer"><a href="#Rollup-Plugin-Visualizer" class="headerlink" title="Rollup Plugin Visualizer"></a>Rollup Plugin Visualizer</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add --save-dev rollup-plugin-visualizer</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改 rollup 配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> copy <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-copy&#x27;</span>;</span><br><span class="line">+ <span class="keyword">import</span> &#123; visualizer &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-visualizer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;bin/index&#x27;</span>: <span class="string">&#x27;bin/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title function_">terser</span>()]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">copy</span>(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [</span><br><span class="line">        <span class="comment">// &#123; src: &#x27;assets/conf.template.yml&#x27;, dest: &#x27;dist/assets&#x27; &#125;,</span></span><br><span class="line">        &#123; <span class="attr">src</span>: [<span class="string">&#x27;package.json&#x27;</span>, <span class="string">&#x27;README.md&#x27;</span>], <span class="attr">dest</span>: <span class="string">&#x27;dist/&#x27;</span> &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;),</span><br><span class="line">+   ...[</span><br><span class="line">+     <span class="string">&#x27;sunburst&#x27;</span>,</span><br><span class="line">+     <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">+     <span class="string">&#x27;treemap&#x27;</span>,</span><br><span class="line">+     <span class="string">&#x27;network&#x27;</span>,</span><br><span class="line">+     <span class="string">&#x27;raw-data&#x27;</span></span><br><span class="line">+   ].<span class="title function_">map</span>(<span class="function">(<span class="params">template</span>) =&gt;</span> <span class="title function_">visualizer</span>(&#123;</span><br><span class="line">+     template,</span><br><span class="line">+     <span class="attr">filename</span>: <span class="string">`reports/visualizer/<span class="subst">$&#123;template&#125;</span>.html`</span>,</span><br><span class="line">+     <span class="attr">gzipSize</span>: <span class="literal">true</span>,</span><br><span class="line">+     <span class="attr">brotliSize</span>: <span class="literal">true</span></span><br><span class="line">+   &#125;)),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>见配置文件，rollup-plugin-visualizer 提供 5 中输出样式，其中 <code>list</code> 和 <code>raw-data</code> 输出的是数据，而其他则是输出可视化图表。</p>
<h3 id="生成图表"><a href="#生成图表" class="headerlink" title="生成图表"></a>生成图表</h3><p>执行 <code>build</code> 脚本触发 rollup 构建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>下面是生成的三种可视化的依赖图表：</p>
<p><code>rollup-plugin-visualizer</code> 提供了以下几种可视化图表来帮助分析 Rollup 打包的结果：</p>
<p><strong><code>Sunburst Chart</code>（旭日图）</strong></p>
<p>旭日图以圆形层级结构的方式展示模块之间的依赖关系。每个模块在图表中表示为一个扇形区域，其大小表示模块的体积或大小。模块之间的依赖关系通过扇形的嵌套关系来表示。你可以通过旭日图快速了解模块之间的依赖关系和体积占比。</p>
<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-30_17-35-51.png" alt="Sunburst Chart">
  </blockquote>
</details>
<br>

<p><strong><code>Treemap Chart</code>（矩形树图）</strong></p>
<p>矩形树图以矩形的层级结构展示模块之间的依赖关系和体积占比。每个模块在图表中表示为一个矩形，其大小表示模块的体积或大小。模块之间的依赖关系通过矩形的嵌套关系来表示。你可以通过矩形树图直观地了解模块之间的依赖关系和体积占比。</p>
<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-30_17-36-22.png" alt="Treemap Chart">
  </blockquote>
</details>
<br>

<p><strong><code>Network Graph</code>（网络图）</strong></p>
<p>网络图以节点和边的形式展示模块之间的依赖关系。每个模块在图表中表示为一个节点，模块之间的依赖关系通过边连接。你可以通过网络图观察模块之间的依赖关系和体积占比，并通过交互式操作来探索图表。</p>
<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-30_17-37-14.png" alt="Network Graph">
  </blockquote>
</details>
<br>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>上面是对 Rollup Plugin Visualizer 的实践。它包含 5 种依赖分析输出格式，其中两种原始数据（list 和 raw-data），三种 HTML 可视化报告（Sunburst Chart、Treemap Chart 和 Network Graph）</p>
<p>HTML 可视化报告中，除了提供模块间的依赖关系信息外，每个模块还提供 Rendered （原始大小）、Gzip 算法压缩后大小 和 Brotli 算法压缩后的大小。</p>
<p>安装简单，无单独的配置文件。需要在 rollup 配置文件中引入，声明依赖报告的输入输出。不能单独生成报告，需要配置 rollup 打包流程使用。另外，三个可视化报告不支持一同输出到同一个 HTML 文件，相互独立。</p>
<h2 id="Dependency-cruiser"><a href="#Dependency-cruiser" class="headerlink" title="Dependency cruiser"></a>Dependency cruiser</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm add --save-dev dependency-cruiser</span><br></pre></td></tr></table></figure>

<p>初始化，将在当前目录下生成 <code>.dependency-cruiser.cjs</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx depcruise --init</span><br></pre></td></tr></table></figure>

<p><img src="dependency-cruiser_init.gif" alt="dependency-cruiser init"></p>
<h3 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h3><p>根据README的指引，可以使用以下命令生成依赖报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx depcruise src --include-only &quot;^src&quot; --output-type dot \</span><br><span class="line">  | dot -T svg \</span><br><span class="line"><span class="meta prompt_">  &gt; </span><span class="language-bash">dependency-graph.svg</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>--include-only &quot;^src&quot;</code>: <code>--include-only</code> 参数用于指定只包括满足特定正则表达式的文件或目录。在这个命令中，它指定只包括以 <code>src</code> 开头的文件或目录。</p>
</li>
<li><p><code>--output-type dot</code>: <code>--output-type</code> 参数用于指定生成的输出类型。在这个命令中，它指定生成 DOT 格式的输出。</p>
</li>
<li><p><code>dot -T svg</code>: <code>dot</code> 是 GraphViz 工具包中的一部分，用于将 DOT 格式的输入转换为不同的图形输出格式。<code>-T svg</code> 参数指定将输出转换为 SVG 格式。</p>
</li>
<li><p><code>&gt; dependency-graph.svg</code>: <code>&gt;</code> 是重定向操作符，用于将命令的输出重定向到一个文件。在这个命令中，它将生成的 SVG 图形输出重定向到名为 <code>dependency-graph.svg</code> 的文件。</p>
</li>
</ul>
<p><code>dot</code> 是 GraphViz 工具包中的一部分，因此需要安装相关的工具，<code>graphviz</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install graphviz -y</span><br></pre></td></tr></table></figure>

<p>准备工作完成，下面根据上面的指引略作修改，然后生成报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx depcruise bin --output-type dot \</span><br><span class="line">  | dot -T svg \</span><br><span class="line"><span class="meta prompt_">  &gt; </span><span class="language-bash">dependency-graph.svg</span></span><br></pre></td></tr></table></figure>

<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-30_20-27-01.png" alt>
  </blockquote>
</details>
<br>

<p>生成交互性更强的报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx depcruise -v -T dot bin \</span><br><span class="line">  | dot -T svg \</span><br><span class="line">  | npx depcruise-wrap-stream-in-html \</span><br><span class="line"><span class="meta prompt_">  &gt; </span><span class="language-bash">dependency-graph.html</span></span><br></pre></td></tr></table></figure>

<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-30_20-37-11.png" alt>
  </blockquote>
</details>
<br>

<p><em>上面两种方式生成的报告都依赖系统软件 <code>graphviz</code>，在特定情况下，或许无法安装。下面介绍无需系统软件便可生成的方式。</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dependency-cruise -T html -f dependencies.html bin</span><br></pre></td></tr></table></figure>

<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-31_15-30-56.png" alt>
  </blockquote>
</details>
<br>


<p>除了上面实践的 3 种报告外，Dependency cruiser 还支持更多的报告输出方式，想要了解更多可查阅：<a href="https://github.com/sverweij/dependency-cruiser/blob/main/doc/cli.md">dependency-cruiser command line interface</a>。</p>
<h3 id="集成到-IDE"><a href="#集成到-IDE" class="headerlink" title="集成到 IDE"></a>集成到 IDE</h3><p>Dependency cruiser 除了可以通过 CLI 生成报告外，还可以集成到 VS Code。见下：</p>
<p><img src="Snipaste_2023-08-31_15-55-07.png" alt="Dependency Cruiser Extension"></p>
<p>Extension ID：<code>juanallo.vscode-dependency-cruiser</code></p>
<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-31_15-58-54.png" alt>
  </blockquote>
</details>
<br>

<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>上面做了 Dependency cruiser 的实践。生成报告前需要初始化配置文件。实践了 3 种报告，其中 2 种需要依赖系统软件 graphviz，1 种不需要。前 2 种类似，区别在于可交互性（可高亮模块的引入路线），相较后面 1 种可读性强。</p>
<p>Dependency cruiser 支持配置文件，可配置多种规则和报告输出格式，除了上面实践的三种外，还支持很多，大部分依赖系统软件，或需要特定应用层级软件查看，更多信息可查阅 <a href="https://github.com/sverweij/dependency-cruiser/blob/main/doc/cli.md">dependency-cruiser command line interface</a>。</p>
<p>Dependency cruiser 除了支持 CLI 单独生成依赖报告外，还支持集成到 IDE（VS Code），可以查阅单个模块的依赖上下文，生成的报告支持在 VS CODE 跳转到相应模块文件。</p>
<p>Dependency cruiser 提供多种样式与格式的依赖图，可读性强。它专注于依赖关系的描述，无其他更多信息提供，比如模块大小，压缩后大小等等。</p>
<h2 id="最终实现-1"><a href="#最终实现-1" class="headerlink" title="最终实现"></a>最终实现</h2><p>从上面 rollup-plugin-visualizer 与 Dependency cruiser 的实践中发现，相比前者，后者的可读性更强，如果单纯追求可视化依赖关系，Dependency cruiser 是不二之选。可惜 Dependency cruiser 仅仅如此，若果可以展示模块大小等等数据会更优，而这是 rollup-plugin-visualizer 相对它的优势。</p>
<p><em>因此何不将两者结合，毕竟它们是开发的辅助工具，它们臃肿与否不影响最终源码体积。</em></p>
<p>上面对 rollup-plugin-visualizer 的最终实现已经说明，不做赘述，下面说明 Dependency cruiser 的最终实现并将两者结合。</p>
<p>首先，生成交互性更强的报告，输出到与 rollup-plugin-visualizer 相同的报告目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx depcruise -v -T dot bin \</span><br><span class="line">  | dot -T svg \</span><br><span class="line">  | npx depcruise-wrap-stream-in-html \</span><br><span class="line"><span class="meta prompt_">  &gt; </span><span class="language-bash">reports/visualizer/dependency.html</span></span><br></pre></td></tr></table></figure>

<p>将此命令与 rollup 的 build 关联到一起：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;dependency-report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx depcruise -v -T dot bin | dot -T svg | npx depcruise-wrap-stream-in-html &gt; reports/visualizer/dependency.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node ./scripts/build.js &amp;&amp; npm run dependency-report&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>如此这边，只有运行 <code>npm run build</code>，即可生成以上 rollup-plugin-visualizer 与 Dependency cruiser 的 4 个依赖报告。</p>
<p>为方便查看，当增加入口查看这 4 个报告。添加一个简单的 <code>index.html</code> 文件到 <code>reports/visualizer/</code> 目录下，通过 <code>iframe</code> 引入 4 个报告的 html 文件。</p>
<details>
  <summary><strong>reports/visualizer/index.html</strong></summary>
  <pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>visualizer<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;
      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-selector-tag">body</span> &#123;
      <span class="hljs-attribute">margin</span>: auto;
    &#125;
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> getViewportSize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> width = <span class="hljs-built_in">window</span>.innerWidth || <span class="hljs-built_in">document</span>.documentElement.clientWidth || <span class="hljs-built_in">document</span>.body.clientWidth;
    <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">window</span>.innerHeight || <span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">document</span>.body.clientHeight;
    <span class="hljs-keyword">return</span> &#123;
      width,
      height
    &#125;;
  &#125;;
  <span class="hljs-keyword">const</span> insertIframeAfterPageLoad = <span class="hljs-function">(<span class="hljs-params">&#123; title, src, width, height &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>);
    iframe.title = title;
    iframe.src = src;
    iframe.width = <span class="hljs-built_in">Math</span>.ceil(width);
    iframe.height = <span class="hljs-built_in">Math</span>.ceil(height);
    iframe.style = <span class="hljs-string">"border:none;"</span>;
    <span class="hljs-built_in">document</span>.body.appendChild(iframe);
  &#125;;<br/>
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; &#123;
    <span class="hljs-keyword">const</span> viewportSize = getViewportSize();
    <span class="hljs-keyword">let</span> size = viewportSize.width / <span class="hljs-number">2</span> - <span class="hljs-number">10</span>;
    insertIframeAfterPageLoad(&#123;
      <span class="hljs-attr">src</span>: <span class="hljs-string">'./network.html'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'network'</span>,
      <span class="hljs-attr">width</span>: size,
      <span class="hljs-attr">height</span>: size,
    &#125;);<br/>
    insertIframeAfterPageLoad(&#123;
      <span class="hljs-attr">src</span>: <span class="hljs-string">'./sunburst.html'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'sunburst'</span>,
      <span class="hljs-attr">width</span>: size,
      <span class="hljs-attr">height</span>: size,
    &#125;);<br/>
    insertIframeAfterPageLoad(&#123;
      <span class="hljs-attr">src</span>: <span class="hljs-string">'./dependency.html'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'dependency'</span>,
      <span class="hljs-attr">width</span>: size,
      <span class="hljs-attr">height</span>: size,
    &#125;);<br/>
    insertIframeAfterPageLoad(&#123;
      <span class="hljs-attr">src</span>: <span class="hljs-string">'./treemap.html'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'treemap'</span>,
      <span class="hljs-attr">width</span>: size,
      <span class="hljs-attr">height</span>: size,
    &#125;);
  &#125;);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
</details>
<br>

<details>
  <summary><strong>预览效果</strong></summary>
  <blockquote>
    <img src="Snipaste_2023-08-31_19-11-09.png" alt>
  </blockquote>
</details>
<br>

<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>以上是对依赖分析的实践。挑选了常见的分析工具（Code Maat、Dependency-Cruiser、Webpack Bundle Analyzer 和 Rollup Plugin Visualizer）对比，结合实际请款，选择 Dependency-Cruiser 和 Rollup Plugin Visualizer 作为实践内容。分别先后安装 Rollup Plugin Visualizer 和 Dependency-Cruiser。</p>
<p>Rollup Plugin Visualizer 是 rollup 常见，需要配置 rollup 的打包流程使用。它支持 Sunburst Chart、Treemap Chart 和 Network Graph 3 种可视化报告，除了依赖关系信息外，还提供压缩与原始的模块大小信息。</p>
<p>Dependency-Cruiser 单纯提供依赖关系信息，支持多种样式报告，但多依赖系统软件。它生成的报告，在模块依赖关系的信息方面比起 Rollup Plugin Visualizer 更强。</p>
<p>鉴于 Rollup Plugin Visualizer 与 Dependency-Cruiser 有一定的互补关系，在实践中，选择同时生成它们的报告，总共 4 个可视化的报告，为方便对比查看，通过 iframe 将它们缝合到一个 HTML 文件中。</p>
<p>下面回顾 <a href="#%E5%86%85%E5%AE%B9%E6%9E%84%E6%88%90">内容构成</a> 中提到的一系列实践内容：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 语法检查</li>
<li><input checked="" disabled="" type="checkbox"> 代码规范检查</li>
<li><input checked="" disabled="" type="checkbox"> 代码质量评估</li>
<li><input checked="" disabled="" type="checkbox"> 依赖关系分析</li>
<li><input disabled="" type="checkbox"> 安全漏洞检测</li>
<li><input disabled="" type="checkbox"> 性能优化建议</li>
<li><input disabled="" type="checkbox"> 异步代码分析</li>
<li><input disabled="" type="checkbox"> 可读性和一致性评估</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7096650413209813029">治理项目模块依赖关系，试试这艘「依赖巡洋舰」</a></li>
</ul>


]]></content>
      <tags>
        <tag>writting</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo插件</title>
    <url>/blog/resources/Hexo%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>按文档描述，操作之后没有加载自己写的插件！</p>
<p>再npm i 了之后才出现加载到！</p>
<p><a href="https://hexo.io/docs/plugins.html">Hexo Docs | Plugins</a></p>
]]></content>
      <tags>
        <tag>bottoming</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/blog/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>程序员生存手册</title>
    <url>/blog/coder_manual/index.html</url>
    <content><![CDATA[<ul>
<li><a href="Autocomplete%20cmd%20invoked%20by%20npx">自动补全被npx的局部命令</a></li>
<li><a href="Kitty%20Terminal">Kitty 终端模拟器配置指南</a></li>
<li><a href="Rollup%20-%20ESM%20to%20CJS">Rollup - ESM 转 CJS</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>日常</title>
    <url>/blog/daily/index.html</url>
    <content><![CDATA[<ul>
<li><a href="101%E5%9C%9F%E5%9C%B0%E7%BA%A0%E7%BA%B7">101土地纠纷</a></li>
<li><a href="C1-Test2">C1科目二</a></li>
<li><a href="%E9%A9%BE%E9%A9%B6%E8%AF%81%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BC%82%E5%B8%B8%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95">驾驶证科目一异常题目解析记录</a></li>
<li><a href="%E9%A9%BE%E9%A9%B6%E8%AF%81%EF%BC%9A%E7%A7%91%E7%9B%AE%E4%B8%80%E7%BB%83%E4%B9%A0%E9%A2%98%E8%AE%B0%E5%BD%95">source&#x2F;daily&#x2F;驾驶证：科目一练习题记录</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>游戏相关文章</title>
    <url>/blog/games/index.html</url>
    <content><![CDATA[<ul>
<li><a href="Dark%20Soul3-Quick%20Kill%20Outfit">【黑魂3】速杀配装记录</a></li>
<li><a href="Parry-Pontiff-Sulyvahn">Parry Pontiff Sulyvahn</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计划</title>
    <url>/blog/plan/index.html</url>
    <content><![CDATA[<ul>
<li><a href="202401">2024-01 计划</a></li>
<li><a href="glvz-to-eemw">2024-01 计划</a></li>
<li><a href="isubo%20-%20add%20feat%20of%20inserting%20back2top">Inserting back-to-top</a></li>
<li><a href="isubo%20-%20add%20feat%20of%20only-print">isubo - add feat of only-print</a></li>
<li><a href="knowledge-types">vpn learning</a></li>
<li><a href="my-tech-review">my-tech-review</a></li>
<li><a href="vpn-learning">vpn learning</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>schedule</title>
    <url>/blog/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/blog/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>自动补全被npx的局部命令</title>
    <url>/blog/coder_manual/Autocomplete%20cmd%20invoked%20by%20npx/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>npx 可以访问局部安装的pkg，但是无法补这些包的cli命令，在输入时较容易出错。</p>
<p>查阅 npm docs 无果，参考网上的解决方案，使用脚本补全npx的命令。</p>
<p>📣 <strong>思路是：</strong></p>
<ol>
<li><p>遍历 <code>node_modules/.bin</code> 目录下查找可执行文件。</p>
</li>
<li><p>使用 <code>compgen</code> 命令生成补全候选项。</p>
</li>
<li><p>基于得到的补全候选项，使用 <code>complete</code> 命令为 <code>npx</code> 命令设置自动补全功能。</p>
</li>
</ol>
<h1 id="自动补全逻辑"><a href="#自动补全逻辑" class="headerlink" title="自动补全逻辑"></a>自动补全逻辑</h1><p>接下来将给出完整的脚本内容，然后再逐行分析脚本的实现逻辑。</p>
<p><strong>以下是完整的脚本内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_autocomplete() &#123;</span><br><span class="line">  local dir=$(pwd -P)</span><br><span class="line">  while [[ -n &quot;$dir&quot; ]]; do</span><br><span class="line">    if [[ ! -d $dir/node_modules/.bin ]]; then</span><br><span class="line">      dir=$&#123;dir%/*&#125;</span><br><span class="line">      continue</span><br><span class="line">    fi</span><br><span class="line">    local execs=( `cd $dir/node_modules/.bin; find -L . -type f -executable` )</span><br><span class="line">    execs=( $&#123;execs[@]/#.\//&#125; )</span><br><span class="line">    local cur=$&#123;COMP_WORDS[COMP_CWORD]&#125;</span><br><span class="line">    COMPREPLY=( $(compgen -W &quot;$&#123;execs[*]&#125;&quot; -- &quot;$cur&quot; ) )</span><br><span class="line">    break</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complete -F _autocomplete npx</span><br></pre></td></tr></table></figure>

<p><strong>下面是对该脚本的逐行解释：</strong></p>
<p><code>local dir=$(pwd -P)</code> 将当前工作目录的绝对路径赋值给局部变量 <code>dir</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_autocomplete() &#123;</span><br><span class="line">  local dir=$(pwd -P)</span><br></pre></td></tr></table></figure>


<p>开始一个 while 循环，只要 <code>dir</code> 变量非空，就会执行循环体。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [[ -n &quot;$dir&quot; ]]; do</span><br></pre></td></tr></table></figure>

<p>检查当前目录的 <code>node_modules/.bin</code> 文件夹是否存在。如果不存在，将 <code>dir</code> 变量设置为上一级目录，并继续下一次循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ ! -d $dir/node_modules/.bin ]]; then</span><br><span class="line">  dir=$&#123;dir%/*&#125;</span><br><span class="line">  continue</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>进入 <code>node_modules/.bin</code> 目录，使用 <code>find</code> 命令查找可执行文件，并将结果存储在 <code>execs</code> 数组变量中。<code>$&#123;execs[@]/#.\//&#125;</code> 将数组中的每个元素（文件路径）的开头的 <code>./</code> 替换为空字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local execs=( `cd $dir/node_modules/.bin; find -L . -type f -executable` )</span><br><span class="line">execs=( $&#123;execs[@]/#.\//&#125; )</span><br></pre></td></tr></table></figure>

<p>将当前命令行参数数组中光标所在位置的参数赋值给局部变量 <code>cur</code>。<code>compgen -W</code> 命令生成基于给定单词列表的补全候选项，并将结果存储在 <code>COMPREPLY</code> 数组变量中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local cur=$&#123;COMP_WORDS[COMP_CWORD]&#125;</span><br><span class="line">COMPREPLY=( $(compgen -W &quot;$&#123;execs[*]&#125;&quot; -- &quot;$cur&quot; ) )</span><br></pre></td></tr></table></figure>

<p><a href="#compgen">📑 compgen 是什么？</a></p>
<p>使用 <code>complete</code> 命令为 <code>npx</code> 命令设置自动补全功能，其中 <code>-F _autocomplete</code> 指定了使用 <code>_autocomplete</code> 函数进行补全。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">complete -F _autocomplete npx</span><br></pre></td></tr></table></figure>

<p><a href="#complete">📑 complete 是什么？</a></p>
<h1 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h1><p>在 Shell 配置文件（如 ~&#x2F;.zshrc 或 ~&#x2F;.bashrc）中使用 <a href="#source">source命令</a> 加载了补全脚本，那么每次打开一个新的 Shell 会话时，该补全脚本会被加载并生效。</p>
<p><strong>1. 新建脚本文件，并将上面逻辑添加到脚本中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/npx_autocomplete.sh</span><br></pre></td></tr></table></figure>

<p><strong>2. 给脚本添加可执行权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ~/npx_autocomplete.sh</span><br></pre></td></tr></table></figure>

<p><strong>3. 编辑shell配置文件，在底部使用 <a href="#source">source命令</a> 引入脚本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim ~/.zshrc</span></span><br><span class="line"></span><br><span class="line">source ~/npx_autocomplete.sh</span><br></pre></td></tr></table></figure>

<p><strong>4. 保存，退出。使用 <code>source ~/.zshrc</code> 重载配置文件，让脚本立即生效</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p><img src="autocomplete_npx.gif"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h2><p><code>source</code> 命令（或其等效命令 <code>.</code>）用于在当前 Shell 环境中读取并执行指定文件中的命令。它的作用是在当前 Shell 会话中将指定文件中的命令加载到环境中，使其立即生效。</p>
<p>具体来说，当您在 Shell 中执行 <code>source filename</code> 或 <code>. filename</code> 时，Shell 会打开指定的文件并按顺序读取其中的命令。这些命令将在当前 Shell 环境中执行，就好像您直接在命令行中输入这些命令一样。这意味着任何定义的变量、函数、别名或其他 Shell 设置都会在执行后立即生效。</p>
<p>对于您提到的补全脚本的情况，如果您在 Shell 配置文件（如 <code>~/.zshrc</code> 或 <code>~/.bashrc</code>）中使用 <code>source</code> 命令加载了补全脚本，那么每次打开一个新的 Shell 会话时，该补全脚本会被加载并生效。此外，当您切换到不同的目录时，如果补全脚本中的逻辑包括查找当前目录或其父目录中的特定文件或配置文件，那么脚本可能会根据目录结构的不同而提供不同的补全选项。</p>
<p>总结起来，<code>source</code> 命令的作用是在当前 Shell 环境中加载并执行指定文件中的命令，使其立即生效。在配置文件中使用 <code>source</code> 命令可以确保补全脚本在每次打开新的 Shell 会话时都会被加载，而在切换目录时，补全脚本可以根据目录的不同提供不同的补全选项。</p>
<h2 id="complete"><a href="#complete" class="headerlink" title="complete"></a><code>complete</code></h2><p><code>complete</code> 命令是用于在 Shell 中配置命令的自动补全行为。它可以告诉 Shell 在输入命令时如何生成补全选项，并指定要使用的补全函数或补全方式。</p>
<p><code>complete</code> 命令的一般语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">complete [options] command</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code> 是一些选项参数，可以用于指定补全的行为，例如补全的方式、补全函数等。<code>command</code> 是要配置补全的命令名称。</p>
<p><code>complete</code> 命令的作用包括：</p>
<ul>
<li><p>指定使用的补全函数：通过使用 <code>-F</code> 选项，可以指定要使用的自定义补全函数。该函数将根据需要生成补全选项。</p>
</li>
<li><p>指定使用的补全方式：通过使用不同的选项，如 <code>-c</code>、<code>-d</code>、<code>-a</code> 等，可以指定不同的补全方式。例如，<code>-c</code> 表示使用命令名补全，<code>-d</code> 表示使用目录名补全，<code>-a</code> 表示使用别名补全。</p>
</li>
<li><p>指定补全的条件：可以使用 <code>-X</code> 选项来指定补全应该在何时触发。例如，<code>-X &quot;!*.txt&quot;</code> 表示只在输入命令时后缀不是 <code>.txt</code> 的情况下触发补全。</p>
</li>
<li><p>禁用命令补全：使用 <code>-r</code> 选项可以禁用命令的自动补全功能。</p>
</li>
<li><p>显示或修改补全配置：使用 <code>-p</code> 选项可以显示当前命令的补全配置，而 <code>-r</code> 选项可以删除或重置补全的配置。</p>
</li>
</ul>
<p>通过使用 <code>complete</code> 命令，您可以根据需要对命令的自动补全进行灵活的配置，以满足您的特定需求。</p>
<p><em>如何触发 <code>complete</code> 命令？</em></p>
<p><code>complete</code> 命令的效果通常在配置之后立即生效。一旦配置了自动补全行为，可以在输入命令时尝试按下 <code>Tab 键</code>，看看是否触发了补全，并生成了相应的补全选项。</p>
<h2 id="compgen"><a href="#compgen" class="headerlink" title="compgen"></a><code>compgen</code></h2><p><code>compgen</code> 是一个用于生成补全列表的 Bash 内置命令。它可以帮助您列出与特定上下文相关的补全选项，包括命令、变量、函数、别名等。</p>
<p><code>compgen</code> 命令的一般语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compgen [options] [word]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code> 是一些选项参数，用于指定补全的类型或行为。<code>word</code> 是要补全的单词或前缀。</p>
<p><code>compgen</code> 命令的作用包括：</p>
<ol>
<li>生成命令补全列表：通过省略选项或使用 <code>-c</code> 选项，可以生成可用的命令补全列表。</li>
<li>生成别名补全列表：使用 <code>-a</code> 选项可以生成可用的别名补全列表。</li>
<li>生成变量补全列表：使用 <code>-v</code> 选项可以生成可用的变量补全列表。</li>
<li>生成函数补全列表：使用 <code>-f</code> 选项可以生成可用的函数补全列表。</li>
<li>生成用户自定义补全列表：使用 <code>-A</code> 选项可以指定自定义的补全类型，例如 <code>-A function</code> 生成函数补全列表。</li>
<li>生成以指定前缀开头的补全列表：通过在命令中提供 <code>word</code> 参数，可以生成以指定前缀开头的补全列表。</li>
</ol>
<p>通过使用 <code>compgen</code> 命令，您可以在编写脚本或配置自动补全时，动态生成适当的补全选项，并将其用于自定义补全函数或其他用途。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.gnu.org/software/bash/manual/bash.html#index-source">Bash Reference Manual | Source</a></p>
</li>
<li><p><a href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html">Bash Reference Manual | Programmable Completion Builtins</a></p>
</li>
<li><p><a href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html">Bash Reference Manual | Programmable Completion</a></p>
</li>
</ul>


]]></content>
  </entry>
  <entry>
    <title>Kitty 终端模拟器配置指南</title>
    <url>/blog/coder_manual/Kitty%20Terminal/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>背景：</p>
<p>System:<br>  Kernel: 5.15.0-86-generic x86_64 bits: 64 compiler: gcc v: 11.4.0 Desktop: Cinnamon 5.8.4<br>    tk: GTK 3.24.33 wm: Tabby dm: LightDM Distro: Linux Mint 21.2 Victoria base: Ubuntu 22.04 jammy</p>
<h1 id="Kitty"><a href="#Kitty" class="headerlink" title="Kitty"></a>Kitty</h1><p>kitty是一个跨平台的终端模拟器，它被设计为一个快速、灵活和可定制的终端应用程序。以下是一些关于kitty终端的特点和功能的介绍：</p>
<ol>
<li><p>GPU 渲染：kitty利用现代显卡的能力，使用GPU进行终端内容的渲染，以提供更快的显示速度和更平滑的滚动体验。</p>
</li>
<li><p>支持多窗口布局：kitty允许你在一个终端窗口中创建多个分割窗格，以同时运行和管理多个终端会话。</p>
</li>
<li><p>内置图像和图标支持：kitty可以直接在终端中显示图像和图标，包括常见的图像格式和TrueType字体中的图标。</p>
</li>
<li><p>支持不透明度和背景模糊：kitty允许你调整终端窗口的不透明度，并提供背景模糊效果，以增强视觉效果。</p>
</li>
<li><p>内置跨平台脚本支持：kitty支持通过脚本来自动化和扩展其功能。你可以使用脚本来创建自定义键绑定、自动化任务、自定义外观等。</p>
</li>
<li><p>Unicode 和字体支持：kitty完全支持Unicode字符集，并允许你在终端中使用各种字体，包括等宽字体和图标字体。</p>
</li>
<li><p>高级配置选项：kitty提供了广泛的配置选项，允许你自定义终端的外观、行为和键绑定，以满足个人偏好和需求。</p>
</li>
<li><p>跨平台支持：kitty可以在多个操作系统上运行，包括Linux、macOS和Windows。</p>
</li>
</ol>
<p>总而言之，kitty终端模拟器通过其快速性能、多窗口布局、图像支持、定制能力和跨平台支持等特点，为用户提供了一个功能强大且灵活的终端环境。无论是日常使用还是开发工作，kitty都是一个值得考虑的终端选择。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install kitty -y</span><br></pre></td></tr></table></figure>

<p><img src="image.png" alt="Alt text"></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>配置文件的位置在：<code>～/.config/kitty/kitty.conf</code>，如果没有则新建配置文件。</p>
<p>修改配置后，需要重新启动 Kitty 才会生效！</p>
<h1 id="窗口分割（Split-Pane）"><a href="#窗口分割（Split-Pane）" class="headerlink" title="窗口分割（Split Pane）"></a>窗口分割（Split Pane）</h1><p>默认情况下，Kitty 没有提供快捷键对窗口进行分割。需要手动编辑配置文件，配置分割、关闭窗口的快捷键。</p>
<p>下面是手动配置的 3 个快捷键，分别是：</p>
<p><code>ctrl+r</code>：在水平方向上左右分割窗口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map ctrl+d launch --location=hsplit</span><br></pre></td></tr></table></figure>

<p><code>ctrl+r</code>：在竖直方向上上下分割窗口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map ctrl+r launch --location=vsplit</span><br></pre></td></tr></table></figure>

<p><code>ctrl+w</code>：关闭当前分割的窗口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">map Ctrl+W close_window</span><br></pre></td></tr></table></figure>

<h1 id="配置字体"><a href="#配置字体" class="headerlink" title="配置字体"></a>配置字体</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fonts</span></span><br><span class="line">font_family      Fira Code</span><br><span class="line">bold_font        auto</span><br><span class="line">italic_font      auto</span><br><span class="line">bold_italic_font auto</span><br><span class="line"></span><br><span class="line">font_size 14.0</span><br></pre></td></tr></table></figure>

<h1 id="配置背景色"><a href="#配置背景色" class="headerlink" title="配置背景色"></a>配置背景色</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Background</span></span><br><span class="line">background #282c34</span><br></pre></td></tr></table></figure>

<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Kitty-无法切换输入法"><a href="#Kitty-无法切换输入法" class="headerlink" title="Kitty 无法切换输入法"></a>Kitty 无法切换输入法</h2><p>TODO</p>
]]></content>
  </entry>
  <entry>
    <title>Rollup - ESM 转 CJS</title>
    <url>/blog/coder_manual/Rollup%20-%20ESM%20to%20CJS/index.html</url>
    <content><![CDATA[<p>主题：将一个 ESM 语法实现的 NodeJS 包转化为 CJS 模块语法的包。</p>
<p>最终目的：不单只是将内容转化为 CJS 模块语法，需要连带所依赖的第三方包一并转化。保证在 CJS 语境下有效运行！</p>
<ul>
<li><p><code>package.json</code> 中使用 <code>type</code> 字段强制指定为 <code>module</code>，以方便在 <code>.js</code> 文件中使用 ESM 模块语法。</p>
</li>
<li><p>包的内容使用 ESM 模块语法，推测部分依赖包也是仅仅支持 ESM 语法。</p>
</li>
<li><p>Rollup 有几个插件组成之后，他们支持将 ESM 转化为 CJS。但是就目前观察的情况来看，仅仅支持将包内容转化，对依赖暂无解法。有待深入研究。</p>
</li>
</ul>
<p>esm转cjs的探索</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(),</span><br><span class="line">    <span class="title function_">commonjs</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>出现的问题：</p>
<p><img src="image.png" alt="Alt text"></p>
<p><em>先尝试解决 warning：<code>preferBuiltins</code>。从 chatgpt 查阅 node-resolve 的这个属性。</em></p>
<p>在使用<code>@rollup/plugin-node-resolve</code>插件时，你可以使用<code>preferBuiltins</code>选项来指定哪些模块应该优先使用 Node.js 内置的模块。</p>
<p><code>preferBuiltins</code>选项接受一个布尔值或一个对象，用于配置内置模块的优先级。以下是一些常见的用法：</p>
<ol>
<li><p>使用布尔值：</p>
<ul>
<li><code>preferBuiltins: true</code>：表示所有内置模块都优先使用。</li>
<li><code>preferBuiltins: false</code>：表示所有内置模块都不优先使用。</li>
</ul>
</li>
<li><p>使用对象：</p>
<ul>
<li><code>preferBuiltins: &#123; moduleA: true, moduleB: false &#125;</code>：表示只有指定的模块（moduleA）会优先使用内置模块，而其他模块（moduleB）不会优先使用。</li>
</ul>
</li>
</ol>
<p>这样，当引入第三方包时，<code>@rollup/plugin-node-resolve</code>插件会根据配置的<code>preferBuiltins</code>选项来决定是否优先使用内置模块。如果指定的模块在 Node.js 中存在内置实现，插件将尝试使用内置模块，而不是将其打包到最终的输出中。</p>
<p>例如，以下是使用<code>@rollup/plugin-node-resolve</code>插件的示例配置，其中指定了某个模块（例如<code>fs</code>）优先使用内置模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">preferBuiltins</span>: &#123; <span class="attr">fs</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，如果第三方包中导入了<code>fs</code>模块，<code>@rollup/plugin-node-resolve</code>插件将尝试使用 Node.js 中的内置<code>fs</code>模块，而不是将其打包到输出中。</p>
<p>请注意，<code>preferBuiltins</code>选项只会在使用<code>@rollup/plugin-node-resolve</code>插件时起作用，对其他插件或工具没有影响。</p>
<p>添加以下修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">+     <span class="attr">preferBuiltins</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">commonjs</span>(),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>warning 消失！</p>
<p><em>尝试解决错误（<code>@rollup/plugin-json</code>）引发的问题</em></p>
<p>下面是 chatgpt 给出的解决方案：</p>
<p>根据错误提示，你需要使用<code>@rollup/plugin-json</code>插件来处理导入的JSON文件。该插件允许你在Rollup中导入和处理JSON模块。</p>
<p>请按照以下步骤进行配置：</p>
<ol>
<li><p>安装<code>@rollup/plugin-json</code>插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @rollup/plugin-json</span><br></pre></td></tr></table></figure>
</li>
<li><p>在你的Rollup配置文件中引入和使用<code>@rollup/plugin-json</code>插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import resolve from &#x27;@rollup/plugin-node-resolve&#x27;;</span><br><span class="line">import commonjs from &#x27;@rollup/plugin-commonjs&#x27;;</span><br><span class="line">import json from &#x27;@rollup/plugin-json&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  input: &#123;</span><br><span class="line">    index: &#x27;index.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    dir: &#x27;dist&#x27;,</span><br><span class="line">    format: &#x27;cjs&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    resolve(),</span><br><span class="line">    commonjs(),</span><br><span class="line">    json() // Add the json() plugin here</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过添加<code>json()</code>插件，Rollup将能够正确处理导入的JSON模块，并解决你遇到的错误。重新运行打包命令后，应该能够成功地打包你的项目。</p>
<p>在添加 json 插件后，json 问题已经解决。但是出现了新的编译错误！</p>
<p><img src="image-1.png" alt="Alt text"></p>
<p>暂时无法解决 markdown-toc 导致的问题，而且它本身也是使用cjs实现，因此暂时将它排除在外。</p>
<p><strong>添加 resolve、commonjs 插件成功编译后，第三方包被编译进包内容中。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>101土地纠纷</title>
    <url>/blog/daily/101%E5%9C%9F%E5%9C%B0%E7%BA%A0%E7%BA%B7/index.html</url>
    <content><![CDATA[<p>要点1：</p>
<p>仍然有争议的时候，要求政府部门，有争议的地方先不要开工，协商好后再动工。</p>
<p>要点2：</p>
<p>屋与屋之间巷道，汉生在施工他自己地基过程涉及到我屋地基，在施工完后，我屋地基还有大部分裸漏。汉生没有做好修复工作。</p>
<p>本身挖那么深地基并且离得那么近就会影响到傍边的建筑</p>
<p>本身双方屋地是差不多平的，你挖低差不多1米，为什么还要争议这个地方？难道你再挖低2米，我还要迁就你，难道再挖低点，全村都来迁就你啊？！。</p>
<p>追究裸漏地基问题，要求补好。</p>
<p>要点3：</p>
<p>正常来讲，确权是需要4个方向的邻近住户没有意见分歧后才可以通过。</p>
<p>如果汉生有确权证，质疑他怎么没有问我方意见，有没有公开和公示</p>
<p>如果当日事情没有解决的，这个公共区域有争议，我要求不可以开工，协商好再开工，有争议的地方就不可以动，里面屋内装修我不管。</p>
<p>如果开工就报警。</p>
<p>大佬当日会避嫌，另外叫 费主任 处理。到时大佬会通知国土，规划，驻村参与会议。</p>
<p>要点4：</p>
<p>如果没有证就不和他谈，向与会领导质疑，为什么他没有证还可以建筑，现在是违章建筑。</p>
<p>要点5：</p>
<p>看他的证规划，他二楼是否有飘出规划边界，是则违建。</p>
<p>要点6：</p>
<p>建这栋楼，看他有没有报建。任何地方建筑都要报建，搭棚都要报建。</p>
<p>报建需要：1 村民小组盖章给意见；2 村委会给意见；3 到镇再到市；</p>
<p>如果他报建跨过了我村，则质疑大田塱为什么没有经过我村处理。</p>
<p>要点7：</p>
<p>确权后，证有没有发到他手上。质疑他地方有没有确权，有没有报建，等部门解答先。</p>
<p>你建房子我不想捣乱，现在你说这个平台妨碍到你的建筑，你后期的建筑规划为什么考虑到这一点？！你现在说我的平台影响到你风水叫我拆，我也认为你现在的房子影响到我的风水，我想让你拆</p>
<p>要点8：</p>
<p>总之，谈到最后还是吵架，就不要谈了，要和部分说，这里公共地方、有争议的地方未先上好，就叫他先不要开工。出来协调，协调不成功，我不想吵架，这个有争议的公共地方，谈不妥就不要开工</p>
<p>要点9：</p>
<p>在拿到确权证的情况下，保持争议，他就拿不到土地证。</p>
<p>在他的证书的土地规划中，包含了巷道，向部门提出质疑。这样的规划不合理，如果他封住了出路不让我出去怎么解决？！</p>
<h1 id="与规划办交底"><a href="#与规划办交底" class="headerlink" title="与规划办交底"></a>与规划办交底</h1><p>start：00：09：55<br>end：</p>
<p>他现在帮我补了地脚，我都比较满意。今时今日，他说要保持现状我都没有话说，他里面怎么装修我都不会干涉太多。不过他这个人呢是这样的，如果万一他建好这栋楼。再撂起这条巷，要铲我平台呢，我不担保我不会撂起他的屋地问题。</p>
<p>呢，x主任，我大l也在zf做，我和我阿嫂都是这样的人，我亦都不想难为你、难为你部门。总之这条路我希望保持原装，保持方便我们出行。因为他甘hs呢开始到现在都是没有口齿的！我不担保他不会在搞好这栋楼之后再去挖这条路。如果一旦这条路发生问题，牵涉到我，我出入方便问题，我可能会重新撂起这件事。</p>
<p>x主任，今时今日我给你面子。他现在帮我补了水泥，我就不会干涉他装修了。因为他这种人，同我老都承诺之后，到现在都是反悔了很多东西。这条路，x主任你叫他不用动它，一旦动了，牵涉到我出入呢，我保留追责的权利，不单只是追责违法建筑。我大l都教我，不要搞太多事情，不牵涉到我呢野，我不会参与。</p>
<p>我屋企呢人不是惹事生非的人，实在是欺负到我头上，我才会有动作。总之，今日今日补好了我的地脚，我都算数了。他装不装修，与我无关。一言蔽之，这条路，不能挖断，不要动门口的地台，不要影响我出入呢，我都不会干预。但是，他反悔，建好他房屋后，又乱来私自动工我刚才说的几点呢，我觉得也会做很多野的。</p>
<p>当时呢我没想话找到你们介入，是我这边去和他们沟通，他们都不理，又话我有意见去找政府来解决，正话怎么样就怎么样，就算拆他都立马拆。他也不愿意私底下找我商量。</p>
<p>x主任，换个角度，你站到我角度，你怎么处理先。</p>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>x主任，下午好。今次电话你无其他事，主要是想就村里土地纠纷问题，和你交个低。</p>
<p>现在他帮我补了地脚，我都算数，算是比较满意。之后他屋装修我也不会干涉太多，他现在也都没有动我门口的平台，没有继续破坏门前的斜坡，他继续房内施工，我就不干涉。</p>
<p>但是，对方屋主是个反复无口齿的人。如果之后，他私自动工这条公共巷道，涉及到个平台、斜坡，影响到我出入。我保留追究他房屋和公共巷道的问题的权利。</p>
<p>x主任，这件事我也不想你和你部门难做。我也问过我blong大l意见，不涉及自己的方面自己不要参与，不要为难政府做事。</p>
<p>（不太重要，可以不说）<br>当时呢我没想话找到你们介入，是我这边去和他们沟通，他们都不理，又话我有意见去找政府来解决，政府话怎么样就怎么样，就算拆他都立马拆。他也不愿意私底下找我商量。</p>
<p>x主任，换个角度，你站到我角度，你怎么处理先。</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul>
<li><p>补了地脚后，不干涉他房屋施工；</p>
</li>
<li><p>对方私自动工公共巷道以及我财产利益，保留追究对方房屋和巷道的责任；</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C1科目二</title>
    <url>/blog/daily/C1-Test2/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>科目二包括4个考试项目，不分先后分别有 1）倒车入库，2）侧方停车，3）S弯和直角弯，4）坡道定点停车。</p>
<p><strong>倒车入口</strong>包含4个小项目，按顺序分别是 1）右倒车入口，2）左出库，3）左倒车入库，4）右出库；</p>
<p><strong>侧方停车</strong>包含2个小项目，按顺序分别是 1）右方向倒车进入停车位，2）右方向离开停车位；</p>
<p><strong>S弯和直角弯</strong>包含2段，先是过左、右弯连续而成的S弯，然后是左转直角弯</p>
<p><strong>半坡定点停车</strong>主要考点是上坡，分半坡定点停车，以及半坡停车后的启动。</p>
<span id="more"></span>



<h1 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h1><h2 id="右入库"><a href="#右入库" class="headerlink" title="右入库"></a>右入库</h2><p>人身背向车库的右手边入库。</p>
<h3 id="方向调整"><a href="#方向调整" class="headerlink" title="方向调整"></a>方向调整</h3><p>进入考试区域。调整车身，直到人、方向盘与前方左起第三段虚线中点连成一线。调整完成后，观察左边，直到人坐的位置与左边横虚线大概重合，立刻停车，挂倒挡。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230410152338.jpg"></p>
<h3 id="向右打死"><a href="#向右打死" class="headerlink" title="向右打死"></a>向右打死</h3><p>倒车，观察左镜柄下边缘，直到视觉上柄与横黄线接触，<strong>立刻向右打死方向盘</strong>，观察右镜。</p>
<h3 id="向左回半圈"><a href="#向左回半圈" class="headerlink" title="向左回半圈"></a>向左回半圈</h3><p>观察右镜，确认车身与虚线，直到车身遮完第二段虚线，立刻向左回半圈方向盘，观察左镜。</p>
<h3 id="向左回正"><a href="#向左回正" class="headerlink" title="向左回正"></a>向左回正</h3><p>观察左镜，观察车身与左边线差不到平行，立刻回正方向。此时观察左边，确认左肩膀与左边黄点成一线，立刻停车。</p>
<h2 id="左出库"><a href="#左出库" class="headerlink" title="左出库"></a>左出库</h2><p>向人左手方向出库。</p>
<h3 id="左打5-4圈"><a href="#左打5-4圈" class="headerlink" title="左打5&#x2F;4圈"></a>左打5&#x2F;4圈</h3><p>停车挂1挡。确认左边A柱与库口横线，直到连成一线，立刻向左打 5&#x2F;4 圈，直到左门把手与虚线重合立刻停车。</p>
<h2 id="左入库"><a href="#左入库" class="headerlink" title="左入库"></a>左入库</h2><p>人身背向车库，从左手边开始倒车入库。</p>
<h3 id="调整方向盘"><a href="#调整方向盘" class="headerlink" title="调整方向盘"></a>调整方向盘</h3><p>挂倒挡，向左打多一节手指方向盘，开始倒车。</p>
<h3 id="向右回方向"><a href="#向右回方向" class="headerlink" title="向右回方向"></a>向右回方向</h3><p>观察左镜，直到车身遮完库口虚线第二段虚线，立刻向右回方向盘至剩余一圈。立刻观察右镜。</p>
<h3 id="向右回正"><a href="#向右回正" class="headerlink" title="向右回正"></a>向右回正</h3><p>观察右镜中，车身与右边线直到差不多两线平行，立刻向右回正方向盘。观察左边，直到左肩膀与左边 <em>黄点</em> 水平重合立即停车。</p>
<p>注意，停车点在练习场地是黄点，在考场测试第一条白线末尾！见下图。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230409122211.jpg" alt="入库停车点"></p>
<h2 id="右出库"><a href="#右出库" class="headerlink" title="右出库"></a>右出库</h2><p>从人右手边出库。</p>
<h3 id="起步调整"><a href="#起步调整" class="headerlink" title="起步调整"></a>起步调整</h3><p>观察左右后视镜。确认车身与两边线距离，视情况在出库起步时调整：</p>
<ul>
<li>车身与右边线距离太窄：适当向左调整再回正出库，避免右后轮压右库角。</li>
<li>车身停止后向右歪：起步适当向右打方向，再回正。避免左后轮压左库角。</li>
</ul>
<h3 id="向右5-4圈"><a href="#向右5-4圈" class="headerlink" title="向右5&#x2F;4圈"></a>向右5&#x2F;4圈</h3><p>起步观察左A柱与左库口横线，他们重合时，立即向右打5&#x2F;4圈方向盘。</p>
<h3 id="回正"><a href="#回正" class="headerlink" title="回正"></a>回正</h3><p>出库，转弯至回正车身，立刻回正方向盘离开考试区域。</p>
<h1 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h1><h2 id="入库"><a href="#入库" class="headerlink" title="入库"></a>入库</h2><p>step1：进入考试区域，调整车辆方向直至方向盘、人和路中间成一线。调整完成后看左镜，观察左边线，直到<a href="#%E5%B7%A6%E9%95%9C%E5%B7%AE%E4%B8%8D%E5%88%B0%E5%88%B0%E5%B7%A6%E7%BA%BF%E5%B0%BD%E5%A4%B4">左镜差不到到左线尽头</a>停车。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230409122619.jpg" alt="方向调整"></p>
<p>step2：停车挂倒挡。倒车同时观察右镜，直到看到右镜中库角（距离车辆最近的入库直角，即上图右边直角）消失，立刻向右打死方向盘。</p>
<p>step3：开始右转后，观察左镜。在左镜中找<a href="#%E7%A0%96%E5%A4%B4">砖头</a>（下图中第三只脚。转的过程，会看到图中从右到左依次看到1、2、3脚），等到车身与砖头连城一线时，立即回正方向盘（即，第三脚出现在后视镜）。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230410152749.jpg" alt="考场参考点，对应练习场的砖头"></p>
<p>继续看左镜，观察后轮与库虚线，倒车直到后轮压住虚线，立即向左打死方向盘。观察引擎盖左突起与左边线距离，倒车直到左突起完全越过左线（同时看左镜，确认车身与左边线是否水平），立刻停车。</p>
<h2 id="出库"><a href="#出库" class="headerlink" title="出库"></a>出库</h2><p>step1：打左转向灯，后续不用手动取消，回正方向盘回自动取消。</p>
<p>step2：挂1挡，保持入库时的方向盘位置出库。继续直到左突起与最外面的左边线交汇，<strong>立刻回正方向盘</strong>，继续观察车头，直到引擎盖视觉消失线与左边线交汇点到达前玻璃中点，<strong>立刻向右打一圈方向盘</strong>，此时直视前方等到车身回正，<strong>立刻向左回正方向盘</strong>，直到进入休息区。</p>
<h1 id="S弯和直角弯"><a href="#S弯和直角弯" class="headerlink" title="S弯和直角弯"></a>S弯和直角弯</h1><p>该项目不限时间，尽量保持慢速通行。</p>
<p>S弯是由两个弯到连续组成，先是左弯，然后是右弯。</p>
<h2 id="S弯-入弯调整"><a href="#S弯-入弯调整" class="headerlink" title="S弯-入弯调整"></a>S弯-入弯调整</h2><p>调整车身，保持人、方向盘和道路中间连成一竖线。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230410153733.jpg" alt="S弯-入弯调整"></p>
<p><strong>扩展技巧</strong></p>
<p>左玻璃夹角对准左边线头</p>
<p><img src="Snipaste_2023-04-07_00-20-44.png"></p>
<p>来源：<a href="https://www.bilibili.com/video/BV1LV4y1S7XH/?spm_id_from=333.851.b_7265636f6d6d656e64.2&vd_source=33ac0456d389f10fb21747392b35389b">曲线行驶满分通过技巧来了，绝对通俗易懂</a></p>
<h2 id="S弯-左打一圈"><a href="#S弯-左打一圈" class="headerlink" title="S弯-左打一圈"></a>S弯-左打一圈</h2><p>调整好方向后，准备进入左弯。</p>
<p>坐直身体保持视觉中出现引擎盖左侧突起。观测突起与右边线的接触情况，在两者汇合时，立刻向左打一圈方向盘，保持不动，以此为基础，视情况动态微调方向盘。</p>
<p>如何判断需要动态调整？</p>
<ul>
<li><p>方法一：看左镜中，车身与边线距离。在镜中，保持黄线与车身距离2指宽，有正负1指余量；<br><img src="Snipaste_2023-04-11_17-06-57.png" alt="2-3指宽"><br>保持1指宽，经过弯度最大后的情况<br><img src="Snipaste_2023-04-11_17-10-19.png" alt="未过弯度最大，1指宽"><br><img src="Snipaste_2023-04-11_17-12-21.png" alt="保持1指已过弯度最大，下车观察"></p>
</li>
<li><p>方法二：看左车头突起，保持突起与右边线交汇而不越过。<br><img src="Snipaste_2023-04-06_21-47-42.png"></p>
<p>参考：<a href="https://www.bilibili.com/video/BV1fU4y1u77U/?spm_id_from=333.851.header_right.fav_list.click&vd_source=33ac0456d389f10fb21747392b35389b">科目二S弯最简单又准的方法，新手掌握后，考试轻松应对拿100分！</a></p>
</li>
</ul>
<h2 id="S弯-向右回正"><a href="#S弯-向右回正" class="headerlink" title="S弯-向右回正"></a>S弯-向右回正</h2><p>在转完左弯后，继续观察车头左突起继续保持左弯方向盘位置，直到左突起与左边线交汇，此时立刻向右回正方向盘。</p>
<h2 id="S弯-右打一圈"><a href="#S弯-右打一圈" class="headerlink" title="S弯-右打一圈"></a>S弯-右打一圈</h2><p>回正方向盘后，观察左边线与引擎盖视觉水平线，注意两线的交汇点，等到交汇点处于后者中点时，向右打一圈方向盘，开始过右弯，然后视情况动态微调整方向盘。</p>
<p>如何判断需要动态调整？</p>
<ul>
<li>方法一：靠左窗，观察（不是从后视镜观察）地面左线与车身距离；</li>
<li>方法二：向前看，保持视觉中引擎盖视觉水平线的中点与左边线重合；</li>
<li>方法三：观察右镜，保持黄线与镜子玻璃左边缘2指宽；<br><img src="Snipaste_2023-04-11_17-29-31.png" alt="大概2指宽，正负1指"></li>
</ul>
<h2 id="s弯-结束方向回正"><a href="#s弯-结束方向回正" class="headerlink" title="s弯-结束方向回正"></a>s弯-结束方向回正</h2><p>保持右转。</p>
<ul>
<li>方法三的结束点：<br><img src="Snipaste_2023-04-11_17-33-25.png" alt="右镜出现黄线末尾即结束"><br><img src="Snipaste_2023-04-11_17-36-34.png" alt="车外视角"></li>
</ul>
<h2 id="直角弯-入弯调整"><a href="#直角弯-入弯调整" class="headerlink" title="直角弯-入弯调整"></a>直角弯-入弯调整</h2><p>人、方向盘中心与前方点位（练习场是砖头，考场是右起第二条白线中点）连成一线。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230411174209.jpg" alt="直角弯-入弯调整的点位"></p>
<h2 id="直角弯-向左打死"><a href="#直角弯-向左打死" class="headerlink" title="直角弯-向左打死"></a>直角弯-向左打死</h2><p>左门把手竖直对齐弯角，立刻向左打死方向盘。</p>
<p>Q1：何时打左转向灯？</p>
<p>A1：xxx</p>
<p>Q2：何时关闭左转灯？</p>
<p>A2：打完方向盘后。</p>
<h2 id="直角弯-向右回正"><a href="#直角弯-向右回正" class="headerlink" title="直角弯-向右回正"></a>直角弯-向右回正</h2><p>保持左转，直到车身回正即可向右回正方向盘。</p>
<h1 id="半坡定点起步"><a href="#半坡定点起步" class="headerlink" title="半坡定点起步"></a>半坡定点起步</h1><h2 id="方向调整-1"><a href="#方向调整-1" class="headerlink" title="方向调整"></a>方向调整</h2><p>人对准前方箭头，见下图。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230411175239.jpg"></p>
<p>车已经过箭头后的对点调整：</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230411175425.jpg"></p>
<h2 id="停车"><a href="#停车" class="headerlink" title="停车"></a>停车</h2><p>观察左边，左肩膀对齐第一条横虚线前左侧红色方块的开始竖线即停车。</p>
<p>停车：1）踩尽离合+踩刹车；2）拉手刹。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230411175908.jpg" alt="左肩膀对齐红白交接线"></p>
<p><strong>扩展参考：</strong></p>
<p>左镜下边缘压第二条横线，立即停车。</p>
<p><img src="Snipaste_2023-04-07_00-54-42.png"></p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><ol>
<li><p>放下手刹，保持踩住刹车和踩尽离合；</p>
</li>
<li><p>慢松离合直到车身抖动，再多放一点，松开刹车。</p>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.bilibili.com/video/BV1fU4y1u77U/?spm_id_from=333.851.header_right.fav_list.click&vd_source=33ac0456d389f10fb21747392b35389b">科目二S弯最简单又准的方法，新手掌握后，考试轻松应对拿100分！</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1TT4y1f7sU/?spm_id_from=333.851.header_right.fav_list.click&vd_source=33ac0456d389f10fb21747392b35389b">科目二考试全过程，不会的，多看看</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1LV4y1S7XH/?spm_id_from=333.851.b_7265636f6d6d656e64.2&vd_source=33ac0456d389f10fb21747392b35389b">曲线行驶满分通过技巧来了，绝对通俗易懂</a></p>
</li>
</ul>
<h2 id="需要确认的点位"><a href="#需要确认的点位" class="headerlink" title="需要确认的点位"></a>需要确认的点位</h2><h3 id="左镜差不到到左线尽头"><a href="#左镜差不到到左线尽头" class="headerlink" title="左镜差不到到左线尽头"></a>左镜差不到到左线尽头</h3><p>考试标准：？</p>
<h3 id="砖头"><a href="#砖头" class="headerlink" title="砖头"></a>砖头</h3><p>练习场地特有的点位，以一块砖头标识。实际考场与此略有不同！等待教练通知确认。</p>
<h1 id="俊达驾校"><a href="#俊达驾校" class="headerlink" title="俊达驾校"></a>俊达驾校</h1><ul>
<li><p>左镜柄与横黄线：下车确认实际车的真实位置（最好拍照）；</p>
</li>
<li><p>车位碰到库前第三段虚线：、</p>
</li>
<li><p>下车确认车的真是位置（拍照、找参照物）；</p>
</li>
<li><p>找人确认后续入库是否压线；</p>
</li>
<li><p>出库（肩膀横向对齐第一段与第二段虚线的缺口）：</p>
<ul>
<li>下车确认位置；</li>
<li>确认后续出库是否压线</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>驾驶证科目一异常题目解析记录</title>
    <url>/blog/daily/%E9%A9%BE%E9%A9%B6%E8%AF%81%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BC%82%E5%B8%B8%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无特殊说明的规则引用，均引用自《道路交通安全法实施条例》。</p>
<span id="more"></span>

<h1 id="醉驾"><a href="#醉驾" class="headerlink" title="醉驾"></a>醉驾</h1><p>机动车驾驶人血液中究竟含量大于或等于80mg&#x2F;100ml会被判定为醉驾</p>
<h1 id="高速路低能见度条件行车"><a href="#高速路低能见度条件行车" class="headerlink" title="高速路低能见度条件行车"></a>高速路低能见度条件行车</h1><table>
<thead>
<tr>
<th>能见度（米）</th>
<th>车速（时速）</th>
<th>车距</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>60以下</td>
<td>100米以上</td>
</tr>
<tr>
<td>100</td>
<td>40以下</td>
<td>50米以上</td>
</tr>
<tr>
<td>50</td>
<td>20以下</td>
<td>尽快驶离高速</td>
</tr>
</tbody></table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>能见度按200、100、50米分布，相互之间是2倍关系；</li>
<li>时速最高60，以20差值分布；</li>
<li>车距刚好是能见度的一半以上，除了50m的能见度</li>
</ul>
<blockquote>
<p><strong>第八十一条</strong>　机动车在高速公路上行驶，遇有雾、雨、雪、沙尘、冰雹等低能见度气象条件时，应当遵守下列规定：</p>
<p>（一）能见度小于200米时，开启雾灯、近光灯、示廓灯和前后位灯，车速不得超过每小时60公里，与同车道前车保持100米以上的距离；</p>
<p>（二）能见度小于100米时，开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速不得超过每小时40公里，与同车道前车保持50米以上的距离；</p>
<p>（三）能见度小于50米时，开启雾灯、近光灯、示廓灯、前后位灯和危险报警闪光灯，车速不得超过每小时20公里，并从最近的出口尽快驶离高速公路。</p>
<p>遇有前款规定情形时，高速公路管理部门应当通过显示屏等方式发布速度限制、保持车距等提示信息。</p>
</blockquote>
<h1 id="特殊路段不能停车"><a href="#特殊路段不能停车" class="headerlink" title="特殊路段不能停车"></a>特殊路段不能停车</h1><blockquote>
<p><strong>第六十三条</strong>　机动车在道路上临时停车，应当遵守下列规定：</p>
<p>（一）在设有禁停标志、标线的路段，在机动车道与非机动车道、人行道之间设有隔离设施的路段以及人行横道、施工地段，不得停车；</p>
<p>（二）交叉路口、铁路道口、急弯路、宽度不足4米的窄路、桥梁、陡坡、隧道以及距离上述地点50米以内的路段，不得停车；</p>
<p>（三）公共汽车站、急救站、加油站、消防栓或者消防队（站）门前以及距离上述地点30米以内的路段，除使用上述设施的以外，不得停车；</p>
<p>（四）车辆停稳前不得开车门和上下人员，开关车门不得妨碍其他车辆和行人通行；</p>
<p>（五）路边停车应当紧靠道路右侧，机动车驾驶人不得离车，上下人员或者装卸物品后，立即驶离；</p>
<p>（六）城市公共汽车不得在站点以外的路段停车上下乘客。</p>
</blockquote>
<h1 id="无限速标志的限速规定"><a href="#无限速标志的限速规定" class="headerlink" title="无限速标志的限速规定"></a>无限速标志的限速规定</h1><p>没有中心线：</p>
<ul>
<li>城市：30时速</li>
<li>公路：40时速</li>
</ul>
<p>单行道：</p>
<ul>
<li>城市：50时速；</li>
<li>公路：70时速；</li>
</ul>
<blockquote>
<p><strong>第四十五条</strong>　机动车在道路上行驶不得超过限速标志、标线标明的速度。在没有限速标志、标线的道路上，机动车不得超过下列最高行驶速度：</p>
<p>（一）没有道路中心线的道路，城市道路为每小时30公里，公路为每小时40公里；</p>
<p>（二）同方向只有1条机动车道的道路，城市道路为每小时50公里，公路为每小时70公里。</p>
</blockquote>
<h1 id="故障停车"><a href="#故障停车" class="headerlink" title="故障停车"></a>故障停车</h1><ul>
<li>警告标志位置</li>
</ul>
<h2 id="警告标志位置"><a href="#警告标志位置" class="headerlink" title="警告标志位置"></a>警告标志位置</h2><ul>
<li>普通道路：车后50~100米以内放置</li>
<li>高速公路：来车方向150以外放置</li>
</ul>
<h1 id="高速路跟车距离"><a href="#高速路跟车距离" class="headerlink" title="高速路跟车距离"></a>高速路跟车距离</h1><ul>
<li>时速100以上，100m以上</li>
<li>时速100以下，50~100m</li>
</ul>
<blockquote>
<p><strong>第八十条</strong>　机动车在高速公路上行驶，车速超过每小时100公里时，应当与同车道前车保持100米以上的距离，车速低于每小时100公里时，与同车道前车距离可以适当缩短，但最小距离不得少于50米。</p>
</blockquote>
<h1 id="停车位"><a href="#停车位" class="headerlink" title="停车位"></a>停车位</h1><h2 id="标线颜色"><a href="#标线颜色" class="headerlink" title="标线颜色"></a>标线颜色</h2><ul>
<li>蓝色：免费（谐音记忆：蓝染【免】）</li>
<li>白色：收费（谐音记忆：白手【收】不分离）</li>
<li>黄色：专属车位</li>
</ul>
<h1 id="牵引故障车"><a href="#牵引故障车" class="headerlink" title="牵引故障车"></a>牵引故障车</h1><ul>
<li>牵引距离4~10米</li>
</ul>
<blockquote>
<p><strong>第六十一条</strong>　牵引故障机动车应当遵守下列规定：</p>
<p>（一）被牵引的机动车除驾驶人外不得载人，不得拖带挂车；</p>
<p>（二）被牵引的机动车宽度不得大于牵引机动车的宽度；</p>
<p>（三）使用软连接牵引装置时，牵引车与被牵引车之间的距离应当大于4米小于10米；</p>
<p>（四）对制动失效的被牵引车，应当使用硬连接牵引装置牵引；</p>
<p>（五）牵引车和被牵引车均应当开启危险报警闪光灯。</p>
<p>汽车吊车和轮式专用机械车不得牵引车辆。摩托车不得牵引车辆或者被其他车辆牵引。</p>
<p>转向或者照明、信号装置失效的故障机动车，应当使用专用清障车拖曳。</p>
</blockquote>
<h1 id="对校车应对"><a href="#对校车应对" class="headerlink" title="对校车应对"></a>对校车应对</h1><ul>
<li><p>超越停靠校车：三车道情况下，使用左车道超越；</p>
</li>
<li><p>对临时停靠（上下客）：需要停车等待；</p>
</li>
</ul>
<blockquote>
<p><strong>第三十三条</strong>　校车在道路上停车上下学生，应当靠道路右侧停靠，开启危险报警闪光灯，打开停车指示标志。校车在同方向只有一条机动车道的道路上停靠时，后方车辆应当停车等待，不得超越。校车在同方向有两条以上机动车道的道路上停靠时，校车停靠车道后方和相邻机动车道上的机动车应当停车等待，其他机动车道上的机动车应当减速通过。校车后方停车等待的机动车不得鸣喇叭或者使用灯光催促校车。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.gov.cn/zwgk/2012-04/10/content_2109706.htm">校车安全管理条例</a></li>
</ul>
<h1 id="对积水路面应对"><a href="#对积水路面应对" class="headerlink" title="对积水路面应对"></a>对积水路面应对</h1><h2 id="车距"><a href="#车距" class="headerlink" title="车距"></a>车距</h2><p>保持与前车较大距离的原因是：前车溅起的水会影响后车视线</p>
<h1 id="特殊路段使用交替远近光灯"><a href="#特殊路段使用交替远近光灯" class="headerlink" title="特殊路段使用交替远近光灯"></a>特殊路段使用交替远近光灯</h1><blockquote>
<p><strong>第五十九条</strong>　机动车在夜间通过急弯、坡路、拱桥、人行横道或者没有交通信号灯控制的路口时，应当交替使用远近光灯示意。</p>
<p>机动车驶近急弯、坡道顶端等影响安全视距的路段以及超车或者遇有紧急情况时，应当减速慢行，并鸣喇叭示意。</p>
</blockquote>
<h1 id="特殊情形限时速30"><a href="#特殊情形限时速30" class="headerlink" title="特殊情形限时速30"></a>特殊情形限时速30</h1><ul>
<li>能见度50米以内，遇雾、雨、雪、沙尘、冰雹，限速30</li>
</ul>
<p>这里要区别<a href="#%E9%AB%98%E9%80%9F%E8%B7%AF%E4%BD%8E%E8%83%BD%E8%A7%81%E5%BA%A6%E6%9D%A1%E4%BB%B6%E8%A1%8C%E8%BD%A6">#高速路低能见度条件行车</a>，高速路是限速20！</p>
<blockquote>
<p><strong>第四十六条</strong>　机动车行驶中遇有下列情形之一的，最高行驶速度不得超过每小时30公里，其中拖拉机、电瓶车、轮式专用机械车不得超过每小时15公里：</p>
<p>（一）进出非机动车道，通过铁路道口、急弯路、窄路、窄桥时；</p>
<p>（二）掉头、转弯、下陡坡时；</p>
<p>（三）遇雾、雨、雪、沙尘、冰雹，能见度在<strong>50米以内</strong>时；</p>
<p>（四）在冰雪、泥泞的道路上行驶时；</p>
<p>（五）牵引发生故障的机动车时。</p>
</blockquote>
<h1 id="小型载客汽车外的高速最高时速"><a href="#小型载客汽车外的高速最高时速" class="headerlink" title="小型载客汽车外的高速最高时速"></a>小型载客汽车外的高速最高时速</h1><ul>
<li>大型货车高速最高时速100</li>
</ul>
<blockquote>
<p><strong>第七十八条</strong>　高速公路应当标明车道的行驶速度，最高车速不得超过每小时120公里，最低车速不得低于每小时60公里。</p>
<p>在高速公路上行驶的小型载客汽车最高车速不得超过每小时120公里，其他机动车不得超过每小时100公里，摩托车不得超过每小时80公里。</p>
<p>同方向有2条车道的，左侧车道的最低车速为每小时100公里；同方向有3条以上车道的，最左侧车道的最低车速为每小时110公里，中间车道的最低车速为每小时90公里。道路限速标志标明的车速与上述车道行驶车速的规定不一致的，按照道路限速标志标明的车速行驶。</p>
</blockquote>
<h1 id="重大交通事故和事后逃逸"><a href="#重大交通事故和事后逃逸" class="headerlink" title="重大交通事故和事后逃逸"></a>重大交通事故和事后逃逸</h1><ul>
<li><p>重大事故，构成犯罪，依法追究刑事责任；</p>
</li>
<li><p>交通事故后逃逸的，吊销车牌，终生不得考证。</p>
</li>
</ul>
<blockquote>
<p>《道路交通安全法》<br>第一百零一条　违反道路交通安全法律、法规的规定，发生重大交通事故，构成犯罪的，依法追究刑事责任，并由公安机关交通管理部门吊销机动车驾驶证。</p>
<p>　　造成交通事故后逃逸的，由公安机关交通管理部门吊销机动车驾驶证，且终生不得重新取得机动车驾驶证</p>
</blockquote>
<h1 id="不正当获取驾照"><a href="#不正当获取驾照" class="headerlink" title="不正当获取驾照"></a>不正当获取驾照</h1><ul>
<li>3年内不得重新申请</li>
</ul>
<blockquote>
<p>第一百零三条　以欺骗、贿赂等不正当手段取得机动车登记或者驾驶许可的，收缴机动车登记证书、号牌、行驶证或者机动车驾驶证，撤销机动车登记或者机动车驾驶许可；申请人在3年内不得申请机动车登记或者机动车驾驶许可。</p>
</blockquote>
<h1 id="证件携带"><a href="#证件携带" class="headerlink" title="证件携带"></a>证件携带</h1><ul>
<li>注意是没有携带行驶证、驾驶证等，不是身份证！</li>
</ul>
<blockquote>
<p>《道路交通安全法》<br>第九十五条　上道路行驶的机动车未悬挂机动车号牌，未放置检验合格标志、保险标志，或者未随车携带行驶证、驾驶证的，公安机关交通管理部门应当扣留机动车，通知当事人提供相应的牌证、标志或者补办相应手续，并可以依照本法第九十条的规定予以处罚。当事人提供相应的牌证、标志或者补办相应手续的，应当及时退还机动车。</p>
<p>　　故意遮挡、污损或者不按规定安装机动车号牌的，依照本法第九十条的规定予以处罚。</p>
</blockquote>
<h1 id="驾驶拼装、报废车"><a href="#驾驶拼装、报废车" class="headerlink" title="驾驶拼装、报废车"></a>驾驶拼装、报废车</h1><p>处罚：</p>
<ul>
<li>接受罚款，200~2000元；</li>
<li>收缴车辆；</li>
<li>吊梢驾照</li>
</ul>
<blockquote>
<p>《道路交通安全法》第一百条　驾驶拼装的机动车或者已达到报废标准的机动车上道路行驶的，公安机关交通管理部门应当予以收缴，强制报废。</p>
<p>　　对驾驶前款（第九十九条）所列机动车上道路行驶的驾驶人，处二百元以上二千元以下罚款，并吊销机动车驾驶证。</p>
<p>　　出售已达到报废标准的机动车的，没收违法所得，处销售金额等额的罚款，对该机动车依照本条第一款的规定处理。</p>
</blockquote>
<h1 id="罚款200-2000"><a href="#罚款200-2000" class="headerlink" title="罚款200~2000"></a>罚款200~2000</h1><ul>
<li>超速50%；</li>
<li>驾驶拼装、报废车</li>
<li>将机动车交由驾驶证被吊销的人驾驶。不但罚款，还会被<strong>吊销驾照</strong></li>
</ul>
<blockquote>
<p>《道路交通安全法》<br>第九十九条　有下列行为之一的，由公安机关交通管理部门处二百元以上二千元以下罚款：</p>
<p>　　（一）未取得机动车驾驶证、机动车驾驶证被吊销或者机动车驾驶证被暂扣期间驾驶机动车的；</p>
<p>　　（二）将机动车交由未取得机动车驾驶证或者机动车驾驶证被吊销、暂扣的人驾驶的；</p>
<p>　　（三）造成交通事故后逃逸，尚不构成犯罪的；</p>
<p>　　（四）机动车行驶超过规定时速百分之五十的；</p>
<p>　　（五）强迫机动车驾驶人违反道路交通安全法律、法规和机动车安全驾驶要求驾驶机动车，造成交通事故，尚不构成犯罪的；</p>
<p>　　（六）违反交通管制的规定强行通行，不听劝阻的；</p>
<p>　　（七）故意损毁、移动、涂改交通设施，造成危害后果，尚不构成犯罪的；</p>
<p>　　（八）非法拦截、扣留机动车辆，不听劝阻，造成交通严重阻塞或者较大财产损失的。</p>
<p>　　行为人有前款第二项、第四项情形之一的，可以并处吊销机动车驾驶证；有第一项、第三项、第五项至第八项情形之一的，可以并处十五日以下拘留。</p>
</blockquote>
<h1 id="违反交通运输管理法"><a href="#违反交通运输管理法" class="headerlink" title="违反交通运输管理法"></a>违反交通运输管理法</h1><p>违反交通运输管理法规，因而发生重大事故，致人重伤、死亡或者使公私财产遭受重大损失的：</p>
<ul>
<li><p>未逃逸：3年以下或者拘役；</p>
</li>
<li><p>逃逸或者有其他特别恶劣情节的：3~7年；</p>
</li>
<li><p>因逃逸致人死亡的：7年以上；</p>
</li>
</ul>
<p>危险驾驶，<strong>处拘役，并处罚金</strong>：</p>
<ul>
<li><p>追逐竞驶，情节恶劣的；</p>
</li>
<li><p>醉驾</p>
</li>
</ul>
<blockquote>
<p>《中华人民共和国刑法》<strong>第一百三十三条</strong>　【交通肇事罪】违反交通运输管理法规，因而发生重大事故，致人重伤、死亡或者使公私财产遭受重大损失的，处三年以下有期徒刑或者拘役；交通运输肇事后逃逸或者有其他特别恶劣情节的，处三年以上七年以下有期徒刑；因逃逸致人死亡的，处七年以上有期徒刑。</p>
<p>　　<strong>第一百三十三条之一</strong>　【危险驾驶罪】在道路上驾驶机动车，有下列情形之一的，处拘役，并处罚金：</p>
<p>　　（一）追逐竞驶，情节恶劣的；</p>
<p>　　（二）醉酒驾驶机动车的；</p>
<p>　　（三）从事校车业务或者旅客运输，严重超过额定乘员载客，或者严重超过规定时速行驶的；</p>
<p>　　（四）违反危险化学品安全管理规定运输危险化学品，危及公共安全的。</p>
<p>　　机动车所有人、管理人对前款第三项、第四项行为负有直接责任的，依照前款的规定处罚。</p>
<p>　　有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。</p>
<p>　　<strong>第一百三十三条之二</strong>　【妨害安全驾驶罪】对行驶中的公共交通工具的驾驶人员使用暴力或者抢控驾驶操纵装置，干扰公共交通工具正常行驶，危及公共安全的，处一年以下有期徒刑、拘役或者管制，并处或者单处罚金。</p>
<p>　　前款规定的驾驶人员在行驶的公共交通工具上擅离职守，与他人互殴或者殴打他人，危及公共安全的，依照前款的规定处罚。</p>
<p>　　有前两款行为，同时构成其他犯罪的，依照处罚较重的规定定罪处罚。</p>
</blockquote>
<h1 id="伪造或变造号牌、行驶证或使用"><a href="#伪造或变造号牌、行驶证或使用" class="headerlink" title="伪造或变造号牌、行驶证或使用"></a>伪造或变造号牌、行驶证或使用</h1><ul>
<li>扣留车辆，以及其他处罚（详见引用）</li>
</ul>
<blockquote>
<p>《道路交通安全法》<br>第九十六条　伪造、变造或者使用伪造、变造的机动车登记证书、号牌、行驶证、检验合格标志、保险标志、驾驶证或者使用其他车辆的机动车登记证书、号牌、行驶证、检验合格标志、保险标志的，由公安机关交通管理部门予以收缴，扣留该机动车，并处二百元以上二千元以下罚款；构成犯罪的，依法追究刑事责任。</p>
<p>　　当事人提供相应的合法证明或者补办相应手续的，应当及时退还机动车。</p>
</blockquote>
<h1 id="投保交强险"><a href="#投保交强险" class="headerlink" title="投保交强险"></a>投保交强险</h1><ul>
<li>扣留车辆直至投保后</li>
</ul>
<blockquote>
<p>《道路交通安全法》<br>第九十八条　机动车所有人、管理人未按照国家规定投保机动车第三者责任强制保险的，由公安机关交通管理部门扣留车辆至依照规定投保后，并处依照规定投保最低责任限额应缴纳的保险费的二倍罚款。</p>
<p>　　依照前款缴纳的罚款全部纳入道路交通事故社会救助基金。具体办法由国务院规定</p>
</blockquote>
<h1 id="记分处理"><a href="#记分处理" class="headerlink" title="记分处理"></a>记分处理</h1><p>一个周期内满12分，扣留驾照</p>
<blockquote>
<p><strong>第二十三条</strong>　公安机关交通管理部门对机动车驾驶人的道路交通安全违法行为除给予行政处罚外，实行道路交通安全违法行为累积记分(以下简称记分)制度，记分周期为12个月。对在一个记分周期内记分达到12分的，由公安机关交通管理部门扣留其机动车驾驶证，该机动车驾驶人应当按照规定参加道路交通安全法律、法规的学习并接受考试。考试合格的，记分予以清除，发还机动车驾驶证；考试不合格的，继续参加学习和考试。</p>
<p>　　应当给予记分的道路交通安全违法行为及其分值，由国务院公安部门根据道路交通安全违法行为的危害程度规定。</p>
<p>　　公安机关交通管理部门应当提供记分查询方式供机动车驾驶人查询。</p>
</blockquote>
<h1 id="组织作弊"><a href="#组织作弊" class="headerlink" title="组织作弊"></a>组织作弊</h1><ul>
<li><p>组织作弊：处3年以下有期徒刑或拘役，并处或单处罚金；</p>
</li>
<li><p>情节严重：处3~7年有期徒刑，并处罚金；</p>
</li>
</ul>
<blockquote>
<p>《刑法》<br><strong>第二百八十四条</strong> 非法使用窃听、窃照专用器材，造成严重<br>后果的，处二年以下有期徒刑、拘役或者管制。</p>
<p><strong>第二百八十四条之一</strong> 在法律规定的国家考试中，组织作弊<br>的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节严<br>重的，处三年以上七年以下有期徒刑，并处罚金。<br>为他人实施前款犯罪提供作弊器材或者其他帮助的，依照前<br>款的规定处罚。<br>为实施考试作弊行为，向他人非法出售或者提供第一款规定<br>的考试的试题、答案的，依照第一款的规定处罚。<br>代替他人或者让他人代替自己参加第一款规定的考试的，处<br>拘役或者管制，并处或者单处罚金。</p>
</blockquote>
<h1 id="不得申请驾照"><a href="#不得申请驾照" class="headerlink" title="不得申请驾照"></a>不得申请驾照</h1><ul>
<li>未取得驾照驾驶，发生负同等以上责任交通事故造成人员伤亡或死亡未满<strong>十年</strong>的，不得申请机动车驾驶证。<blockquote>
<p>《<a href="http://www.gov.cn/gongbao/content/2022/content_5679696.htm">机动车驾驶证申领和使用规定</a>》<br>第十五条　有下列情形之一的，不得申请机动车驾驶证：</p>
<p>（一）有器质性心脏病、癫痫病、美尼尔氏症、眩晕症、癔病、震颤麻痹、精神病、痴呆以及影响肢体活动的神经系统疾病等妨碍安全驾驶疾病的；</p>
<p>（二）三年内有吸食、注射毒品行为或者解除强制隔离戒毒措施未满三年，以及长期服用依赖性精神药品成瘾尚未戒除的；</p>
<p>（三）造成交通事故后逃逸构成犯罪的；</p>
<p>（四）饮酒后或者醉酒驾驶机动车发生重大交通事故构成犯罪的；</p>
<p>（五）醉酒驾驶机动车或者饮酒后驾驶营运机动车依法被吊销机动车驾驶证未满五年的；</p>
<p>（六）醉酒驾驶营运机动车依法被吊销机动车驾驶证未满十年的；</p>
<p>（七）驾驶机动车追逐竞驶、超员、超速、违反危险化学品安全管理规定运输危险化学品构成犯罪依法被吊销机动车驾驶证未满五年的；</p>
<p>（八）因本款第四项以外的其他违反交通管理法律法规的行为发生重大交通事故构成犯罪依法被吊销机动车驾驶证未满十年的；</p>
<p>（九）因其他情形依法被吊销机动车驾驶证未满二年的；</p>
<p>（十）驾驶许可依法被撤销未满三年的；</p>
<p>（十一）未取得机动车驾驶证驾驶机动车，发生负同等以上责任交通事故造成人员重伤或者死亡未满十年的；</p>
<p>（十二）三年内有代替他人参加机动车驾驶人考试行为的；</p>
<p>（十三）法律、行政法规规定的其他情形。</p>
</blockquote>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><p><a href="%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E9%81%93%E8%B7%AF%E4%BA%A4%E9%80%9A%E5%AE%89%E5%85%A8%E6%B3%95%E5%AE%9E%E6%96%BD%E6%9D%A1%E4%BE%8B.pdf">中华人民共和国道路交通安全法实施条例</a></p>
</li>
<li><p><a href="http://www.gov.cn/zwgk/2012-04/10/content_2109706.htm">校车安全管理条例</a></p>
</li>
<li><p><a href="http://www.gov.cn/banshi/2005-08/23/content_25575.htm">道路交通安全法</a></p>
</li>
<li><p><a href="https://www.faxin.cn/lib/Zyfl/ZyflContent.aspx?gid=A296510">中华人民共和国刑法</a></p>
</li>
<li><p><a href="%E5%88%91%E6%B3%95.pdf">刑法</a></p>
</li>
<li><p><a href="http://www.gov.cn/gongbao/content/2022/content_5679696.htm">机动车驾驶证申领和使用规定</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>驾驶证：科目一练习题记录</title>
    <url>/blog/daily/%E9%A9%BE%E9%A9%B6%E8%AF%81%EF%BC%9A%E7%A7%91%E7%9B%AE%E4%B8%80%E7%BB%83%E4%B9%A0%E9%A2%98%E8%AE%B0%E5%BD%95/index.html</url>
    <content><![CDATA[<h1 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h1><p>科目一：道路交通安全法律、法规和相关知识考试科目<br>科目二：场地驾驶技能考试科目<br>科目三：道路驾驶技能和安全文明驾驶常识考试科目。科目三可以特指 道路驾驶技能，而安全文明驾驶常识考试则称为科目四</p>
<span id="more"></span>


<h1 id="载货、载客汽车分类"><a href="#载货、载客汽车分类" class="headerlink" title="载货、载客汽车分类"></a>载货、载客汽车分类</h1><p>质量（GA）划分为：<br>微型货车（GA≤1．8吨）<br>轻型货车（1．8吨&lt;GA≤6吨）<br>中型货车（6．0吨&lt;GA≤14吨）<br>重型货车（GA&gt;14吨）</p>
<p>客车： 依车长（L）划分为：<br>微型（L≤3．5米）<br>轻型（3．5米&lt;L≤7米）<br>中型（7米&lt;L≤10米）<br>大型客车（L&gt;10米）和特大型客车<br>中大型客车又可分为城市、长途、旅游及团体客车<br>特大型客车指铰接和双层客车</p>
<h1 id="考试题目知识"><a href="#考试题目知识" class="headerlink" title="考试题目知识"></a>考试题目知识</h1><ul>
<li><p>违反（禁令标志、禁止标线指示）的，一次扣 1 分；</p>
</li>
<li><p>不按规定会车：记1分</p>
</li>
<li><p>不按规定倒车和掉头<br>情况1：在高速公路和城市快速路<strong>以外</strong>的道路，扣1分</p>
<p>类似情况：</p>
<ul>
<li>在高速公路，城市快速路上 穿越中央分隔带，掉头的，扣12分！</li>
</ul>
</li>
<li><p>正常情况下满足以下4种情况可返还机动车驾驶证；</p>
<ul>
<li>满分学习；</li>
<li>考试合格；</li>
<li>罚款已缴纳；</li>
<li>积分予以清除；</li>
</ul>
<p>但是，如果被处以暂扣的，需要期限届满后才可以返还！</p>
</li>
<li><p>载货长宽高超过规定，扣1分</p>
</li>
<li><p>可以在驾驶证核发地，违法发生地，处理地进行学习参加考试</p>
<p>主要不要要回到核发地。可以理解为发生事故，解除惩罚无地方限制！</p>
</li>
<li><p>借用超车、占用对面车道、穿插扣3分</p>
</li>
<li><p>实习期不可以单独上高速</p>
</li>
<li><p>满分教育<br>情况1：</p>
<ul>
<li>现场学习、网络学习的天数累计不得少于 5 天；</li>
<li>现场学习不得少于 2 天。</li>
</ul>
</li>
<li><p>可以一次性处理完毕同一辆车的多起违法记录和积分。</p>
</li>
<li><p>记分未满12，可以处理其驾驶的其他车的记录；满12则不可以！</p>
</li>
<li><p>代替参加审验教育，罚2000以下！</p>
</li>
<li><p>一个周期内记满12分的次数惩罚：</p>
<ul>
<li>1次：科目一 + 科目二</li>
<li>2次：科目一 + 科目三</li>
<li>3次：</li>
</ul>
</li>
<li><p>审验教育违规处罚：</p>
<ul>
<li>弄虚作假：1000以下；</li>
<li>无违法所得：二万以下；</li>
<li>有违法所得：所得的3倍，二万以下；</li>
</ul>
</li>
<li><p>实习期间违规无渠道减分</p>
</li>
<li><p>超载情况处罚：</p>
<ul>
<li>校车、公路客运车、旅游客运车、<ul>
<li>不到20%：6分；</li>
</ul>
</li>
<li>7座以上载客车：<br>20%~50%：6分</li>
<li>其他：<ul>
<li>50%：扣6分；</li>
</ul>
</li>
</ul>
</li>
<li><p>超速50%以上的处罚：<br>情况1：驾驶校车、中型以上载货载客汽车、危险品运输车辆；<br>情况2：高速公路、城市快速路</p>
<ul>
<li>1 + 2：9分；</li>
<li>1|2：6分</li>
</ul>
</li>
<li><p>驾驶未安检车辆处罚：</p>
<ul>
<li>公路客运汽车、旅游客运汽车和危险品运输车辆：3分</li>
<li>其他：1分</li>
</ul>
</li>
<li><p>车是被盗抢的不可以办理登记注册</p>
</li>
<li><p>申请减分限制</p>
<ul>
<li>在当前或上个周期内有2次以上满分教育记录，不予申请</li>
</ul>
</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="记分档次"><a href="#记分档次" class="headerlink" title="记分档次"></a>记分档次</h2><p>12分、9分、6分、3分和1分。</p>
<h2 id="记分周期"><a href="#记分周期" class="headerlink" title="记分周期"></a>记分周期</h2><p>12个月一周期。满分为12分。记分周期自初次领取证之⽇起连续计算，或者⾃初次取得临时许可之⽇起累积计算。</p>
<h2 id="规定车辆群体类型"><a href="#规定车辆群体类型" class="headerlink" title="规定车辆群体类型"></a>规定车辆群体类型</h2><ul>
<li>校⻋、公路客运汽⻋、旅游客运汽⻋；</li>
<li>校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆在⾼速公路；</li>
<li>校⻋、公路客运汽⻋、旅游客运汽⻋、7座以上载客汽⻋；</li>
<li>驾驶7座以上载客汽⻋；</li>
<li>中型以上载客汽⻋、危险物品运输⻋辆；</li>
<li>载货汽⻋；</li>
</ul>
<h2 id="规定道路类型"><a href="#规定道路类型" class="headerlink" title="规定道路类型"></a>规定道路类型</h2><ul>
<li>⾼速公路、城市快速路</li>
</ul>
<h1 id="记分分值"><a href="#记分分值" class="headerlink" title="记分分值"></a>记分分值</h1><p>按分值档次分类，可以参考 <img src="%E9%81%93%E8%B7%AF%E4%BA%A4%E9%80%9A%E5%AE%89%E5%85%A8%E8%BF%9D%E6%B3%95%E8%A1%8C%E4%B8%BA%E8%AE%B0%E5%88%86%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95.pdf"></p>
<h2 id="分布情况"><a href="#分布情况" class="headerlink" title="分布情况"></a>分布情况</h2><ul>
<li>12分有 7 条规定；</li>
<li>9分有 7 条规定；</li>
<li>6分有 11 条规定；</li>
<li>3分有 15 条规定；</li>
<li>1分有 10 条规定；</li>
</ul>
<p>总计：50条规定；</p>
<h2 id="超载（8条）"><a href="#超载（8条）" class="headerlink" title="超载（8条）"></a>超载（8条）</h2><p>超载分为 载客超载 和 载货超载。</p>
<p>载货分为质量和尺寸超载！</p>
<h3 id="载客超载"><a href="#载客超载" class="headerlink" title="载客超载"></a>载客超载</h3><h4 id="分布情况-1"><a href="#分布情况-1" class="headerlink" title="分布情况"></a>分布情况</h4><ul>
<li><p>12分：驾驶校⻋、公路客运汽⻋、旅游客运汽⻋载人超过核定人数百分之二十以上，或者驾驶其他<br>载客汽⻋载人超过核定人数百分之百以上的；</p>
</li>
<li><p>9分：驾驶7座以上载客汽⻋载⼈超过核定⼈数百分之五⼗以上未达到百分之百的；</p>
</li>
<li><p>6分：驾驶校⻋、公路客运汽⻋、旅游客运汽⻋载人超过核定人数未达到百分之二十，或者驾驶7<br>座以上载客汽⻋载人超过核定人数百分之二十以上未达到百分之五十，或者驾驶其他载客汽⻋载人超过<br>核定人数百分之五十以上未达到百分之百的；</p>
</li>
<li><p>3分：驾驶校⻋、公路客运汽⻋、旅游客运汽⻋、7座以上载客汽⻋以外的其他载客汽⻋载人超过<br>核定人数百分之二十以上未达到百分之五十的；</p>
</li>
<li><p>1分：无</p>
</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>车辆类型：</p>
<ul>
<li>车辆包：校⻋、公路客运汽⻋、旅游客运汽⻋。</li>
<li>7座以上载客汽车；</li>
<li>其他</li>
</ul>
<p>车辆包超载（2个分段，分段分支是倍数）：</p>
<ul>
<li>高于20%： 12分；</li>
<li>低于20%：6分。<br>注意没有9分；</li>
</ul>
<p>7座以上（3个分段，分值是等差数列）：</p>
<ul>
<li>高于100%，12分；</li>
<li>50%~100%：9分；</li>
<li>20%~50%：6分；</li>
</ul>
<p>其他车（2个分段。既是倍数，也是等差）：</p>
<ul>
<li>20%~50%：3分</li>
<li>高于50%：6分</li>
</ul>
<p>车辆包以外的车（包含7座以上），要超载100%才是最高惩罚；</p>
<table>
<thead>
<tr>
<th>-</th>
<th>车辆包</th>
<th>7座以上载客车</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>0~20%</td>
<td>6</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>20%~50%</td>
<td>12</td>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>50%~100%</td>
<td>12</td>
<td><strong>9</strong></td>
<td>6</td>
</tr>
<tr>
<td>&gt;100%</td>
<td>12</td>
<td>12</td>
<td>6</td>
</tr>
</tbody></table>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>载客超载没有1分处罚；</li>
<li>除了车辆包，载客超载最低20%起产生处罚；</li>
<li>车辆被划分为三类：车辆包、7座以上载客车和其他车，按车辆处罚严重程度：车辆包 &gt; 7座以上载客车 &gt; 其他；</li>
<li>车辆包包含2个处罚分段，他们是倍数，分别是6和12分，阈值是20%；</li>
<li>7座以上有3个分段，分值是等差数列：12、9、6。最低阈值是20%，最高是超过100%，中间是50%；</li>
<li>其他车和车辆包一样有2个分段，同样是倍数也是等差数列，但是较低的：6和3。超50%的就会罚6分，低于就罚3分！</li>
</ul>
<hr>
<h3 id="载货超载"><a href="#载货超载" class="headerlink" title="载货超载"></a>载货超载</h3><p>载货可以分为 质量 和 尺寸超载</p>
<h4 id="分布情况-2"><a href="#分布情况-2" class="headerlink" title="分布情况"></a>分布情况</h4><ul>
<li><p>6分：驾驶载货汽⻋载物超过最⼤允许总质量百分之五⼗以上的；</p>
</li>
<li><p>3分：驾驶载货汽⻋载物超过最⼤允许总质量百分之三⼗以上未达到百分之五⼗的，或者违反规定载客的；</p>
</li>
<li><p>1分（2条）：</p>
<ul>
<li><p>质量超载：驾驶载货汽⻋载物超过最⼤允许总质量未达到百分之三⼗的；</p>
</li>
<li><p>尺寸超载：驾驶机动⻋载货⻓度、宽度、⾼度超过规定的；</p>
</li>
</ul>
</li>
</ul>
<p>梗概：</p>
<ul>
<li>高于50%：6分；</li>
<li>30%~50% 或者 载客：3分；</li>
<li>低于30%：1分；</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>不能使用载货汽车载客；</li>
<li>处罚情况分成3类；</li>
<li>最高处罚是6分，是满分的一半。最低是1分，分数档的最低档。中间是3分；</li>
<li>超载上限是50%，下限是0，只要超载都要处罚，高于30%就要扣3分（刚好都是3开头）；</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>超载分成载客超载和载物超载两类；</li>
<li>载客的车辆分为三类，载物车辆无分类；</li>
<li>载物超载覆盖低段三个分段，载客覆盖高分三个分段；</li>
</ul>
<h2 id="超速（7条）"><a href="#超速（7条）" class="headerlink" title="超速（7条）"></a>超速（7条）</h2><p>包含超高速和超低速。</p>
<h3 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h3><ul>
<li><p>12分：驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆在⾼速公路、城市快速路上⾏驶超过规定时速百分之⼆⼗以上，或者驾驶其他机动⻋在⾼速公路、城市快速路上⾏驶超过规定时速百分之五<br>⼗以上的；</p>
</li>
<li><p>9分：驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆在⾼速公路、城市快速路以外的道路上⾏驶超过规定时速百分之五⼗以上的；</p>
</li>
<li><p>6分（2条）：</p>
<ul>
<li><p>驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆在⾼速公路、城市快速路上⾏驶超过规定时速未达到百分之⼆⼗，或者在⾼速公路、城市快速路以外的道路上⾏驶超过规定时速百分之⼆⼗以上未达到百分之五⼗的；</p>
</li>
<li><p>驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆以外的机动⻋在⾼速公路、城市快速路上⾏驶超过规定时速百分之⼆⼗以上未达到百分之五⼗，或者在⾼速公路、城市快速路以外的道路上⾏驶超过规定时速百分之五⼗以上的；</p>
</li>
</ul>
</li>
<li><p>3分（2条）：</p>
<ul>
<li><p>驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆以外的机动⻋在⾼速公路、城市快速路以外的道路上⾏驶超过规定时速百分之⼆⼗以上未达到百分之五⼗的；</p>
</li>
<li><p>驾驶机动⻋在⾼速公路上⾏驶低于规定最低时速的。</p>
</li>
</ul>
</li>
<li><p>1分：驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆在⾼速公路、城市快速路以外的道路<br>上⾏驶超过规定时速百分之⼗以上未达到百分之⼆⼗的；</p>
</li>
</ul>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>特征车型：</p>
<ul>
<li>车辆包（3种），驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆；</li>
<li>其他；</li>
</ul>
<p>特征道路：</p>
<ul>
<li>道路包（2种），⾼速公路、城市快速路；</li>
<li>其他；</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>车辆包</th>
<th>其他车辆</th>
</tr>
</thead>
<tbody><tr>
<td>道路包</td>
<td>&lt;20%：6分；&gt;&#x3D;20%：12分</td>
<td>20%~50%：6分；&gt;&#x3D;50%：12分</td>
</tr>
<tr>
<td>其他道路</td>
<td><code>10%~20%</code>：1分；<code>20%~50%</code>：6分；<code>&gt;=50%</code>：9分</td>
<td>20%~50%：3分；&gt;&#x3D;50%：6分</td>
</tr>
</tbody></table>
<p>超速区间：</p>
<ul>
<li>10%<del>20%，20%</del>50%，&gt;&#x3D;50%</li>
<li>&lt;20%，&gt;&#x3D;20%；</li>
<li>20%~50%，&gt;&#x3D;50%</li>
</ul>
<p>视超速的车型、道路，百分比情况，越严重处罚越重</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>道路包上超速只有6分和12分两个处罚分值段；</li>
<li>超速处罚覆盖全档次分段；</li>
<li>车辆包包揽最低和最高处罚；</li>
<li>在道路包上超速且达到处罚门槛后，较为严重，要么6分要么12分！</li>
<li>道路包上也存在超速不扣分得情况：其他车辆超速低于50%；</li>
<li>在道路包上分布2个扣分段：6和12。剩下的3个扣分段，1、3和9则分布在其他道路（每个段分支正好是前一个的3倍）；</li>
<li>其他车辆在不同道路上的超速区间一样，扣分段刚好时2倍关系；</li>
<li>车辆包在其他道路上的扣分制刚好是1、6、9（哈哈哈）</li>
<li>对其他车辆的宽容度最高，无论在哪里的道路，只要超速低于20%，都不扣分！</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>全分段覆盖；</li>
<li>车辆类型分为两类：a）驾驶校⻋、中型以上载客载货汽⻋、危险物品运输⻋辆；b）其他；</li>
<li>道路情况分为两类：a）⾼速公路、城市快速路；b）其他</li>
</ul>
<h2 id="肇事逃逸（2条）"><a href="#肇事逃逸（2条）" class="headerlink" title="肇事逃逸（2条）"></a>肇事逃逸（2条）</h2><h3 id="分布情况-3"><a href="#分布情况-3" class="headerlink" title="分布情况"></a>分布情况</h3><ul>
<li><p>12分：造成致⼈轻伤以上或者死亡的交通事故后逃逸，尚不构成犯罪的；</p>
</li>
<li><p>6分：造成致⼈轻微伤或者财产损失的交通事故后逃逸，尚不构成犯罪的；</p>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>肇事逃逸只做了2条限定，较严重12分否则6分；</li>
<li>对于肇事逃逸处罚比较严重，只要是轻伤以上就是12分；</li>
</ul>
<h2 id="车牌证件（5条）"><a href="#车牌证件（5条）" class="headerlink" title="车牌证件（5条）"></a>车牌证件（5条）</h2><h3 id="分布情况-4"><a href="#分布情况-4" class="headerlink" title="分布情况"></a>分布情况</h3><ul>
<li><p>12分：使⽤伪造、变造的机动⻋号牌、⾏驶证、驾驶证、校⻋标牌或者使⽤其他机动⻋号牌、⾏驶证的；</p>
</li>
<li><p>9分：</p>
<ul>
<li>驾驶未悬挂机动⻋号牌或者故意遮挡、污损机动⻋号牌的机动⻋上道路⾏驶的；</li>
<li>未取得校⻋驾驶资格驾驶校⻋的；</li>
</ul>
</li>
<li><p>6分：机动⻋驾驶证被暂扣或者扣留期间驾驶机动⻋的；</p>
</li>
<li><p>3分：驾驶不按规定安装机动⻋号牌的机动⻋上道路⾏驶的；</p>
</li>
</ul>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>TODO</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>TODO</p>
<h2 id="安检类（3条）"><a href="#安检类（3条）" class="headerlink" title="安检类（3条）"></a>安检类（3条）</h2><ul>
<li><p>3分：</p>
<ul>
<li><p>驾驶未按规定定期进⾏安全技术检验的公路客运汽⻋、旅游客运汽⻋、危险物品运输⻋辆上道路⾏驶的；</p>
</li>
<li><p>驾驶校⻋上道路⾏驶前，未对校⻋⻋况是否符合安全技术要求进⾏检查，或者驾驶存在安全隐患的校⻋上道路⾏驶的；</p>
</li>
</ul>
</li>
<li><p>1分：驾驶未按规定定期进⾏安全技术检验的公路客运汽⻋、旅游客运汽⻋、危险物品运输⻋辆以外的机动⻋上道路⾏驶的；</p>
</li>
</ul>
<h2 id="警示（3条）"><a href="#警示（3条）" class="headerlink" title="警示（3条）"></a>警示（3条）</h2><ul>
<li><p>6分：</p>
<ul>
<li><p>驾驶机动⻋运载超限的不可解体的物品，未按指定的时间、路线、速度⾏驶或者未悬挂警示标志的；</p>
</li>
<li><p>驾驶机动⻋运载超限的不可解体的物品，未按指定的时间、路线、速度⾏驶或者未悬挂警示标志的；</p>
</li>
</ul>
</li>
<li><p>3分：在道路上⻋辆发⽣故障、事故停⻋后，不按规定使⽤灯光或者设置警告标志的；</p>
</li>
</ul>
<h2 id="驾驶者保护措施（3条）"><a href="#驾驶者保护措施（3条）" class="headerlink" title="驾驶者保护措施（3条）"></a>驾驶者保护措施（3条）</h2><ul>
<li><p>1分：</p>
<ul>
<li>驾驶机动⻋在道路上⾏驶时，机动⻋驾驶⼈未按规定系安全带的；</li>
<li>驾驶摩托⻋，不戴安全头盔的。</li>
</ul>
</li>
<li><p>3分：驾驶机动⻋有拨打、接听⼿持电话等妨碍安全驾驶的⾏为的；</p>
</li>
</ul>
<h2 id="行驶动作（12条）"><a href="#行驶动作（12条）" class="headerlink" title="行驶动作（12条）"></a>行驶动作（12条）</h2><ul>
<li><p>12分：驾驶机动⻋在⾼速公路、城市快速路上倒⻋、逆⾏、穿越中央分隔带掉头的；</p>
</li>
<li><p>9分：驾驶机动⻋在⾼速公路或者城市快速路上违法停⻋的；</p>
</li>
<li><p>6分：</p>
<ul>
<li><p>驾驶机动⻋在⾼速公路或者城市快速路上违法占⽤应急⻋道⾏驶的。</p>
</li>
<li><p>驾驶机动⻋运输危险化学品，未经批准进⼊危险化学品运输⻋辆限制通⾏的区域的；</p>
</li>
<li><p>驾驶机动⻋不按交通信号灯指示通⾏的；</p>
</li>
</ul>
</li>
<li><p>3分（5条）：</p>
<ul>
<li><p>驾驶机动⻋在⾼速公路或者城市快速路上不按规定⻋道⾏驶的；</p>
</li>
<li><p>驾驶机动⻋不按规定超⻋、让⾏，或者在⾼速公路、城市快速路以外的道路上逆⾏的；</p>
</li>
<li><p>驾驶机动⻋遇前⽅机动⻋停⻋排队或者缓慢⾏驶时，借道超⻋或者占⽤对⾯⻋道、穿插等候⻋辆的；</p>
</li>
<li><p>驾驶机动⻋⾏经⼈⾏横道不按规定减速、停⻋、避让⾏⼈的；</p>
</li>
<li><p>驾驶机动⻋不按规定避让校⻋的；</p>
</li>
</ul>
</li>
<li><p>1分：</p>
<ul>
<li><p>驾驶机动⻋不按规定会⻋，或者在⾼速公路、城市快速路以外的道路上不按规定倒⻋、掉头的；</p>
</li>
<li><p>驾驶机动⻋违反禁令标志、禁⽌标线指示的；</p>
</li>
</ul>
</li>
</ul>
<h2 id="异常状态行车（3条）"><a href="#异常状态行车（3条）" class="headerlink" title="异常状态行车（3条）"></a>异常状态行车（3条）</h2><ul>
<li><p>12分：饮酒后驾驶机动⻋的；</p>
</li>
<li><p>9分：连续驾驶中型以上载客汽⻋、危险物品运输⻋辆超过4⼩时未停⻋休息或者停⻋休息时间少于20分钟的。</p>
</li>
<li><p>3分：连续驾驶载货汽⻋超过4⼩时未停⻋休息或者停⻋休息时间少于20分钟的；</p>
</li>
</ul>
<h2 id="其他（4条）"><a href="#其他（4条）" class="headerlink" title="其他（4条）"></a>其他（4条）</h2><ul>
<li><p>12分：</p>
<ul>
<li>代替实际机动⻋驾驶⼈接受交通违法⾏为处罚和记分牟取经济利益的。</li>
</ul>
</li>
</ul>
<p>9分：驾驶与准驾⻋型不符的机动⻋的；</p>
<ul>
<li>1分：<ul>
<li><p>驾驶机动⻋不按规定使⽤灯光的；</p>
</li>
<li><p>驾驶擅⾃改变已登记的结构、构造或者特征的载货汽⻋上道路⾏驶的；</p>
</li>
</ul>
</li>
</ul>
<h1 id="记分执行"><a href="#记分执行" class="headerlink" title="记分执行"></a>记分执行</h1><h1 id="满分处理"><a href="#满分处理" class="headerlink" title="满分处理"></a>满分处理</h1><h1 id="记分减免"><a href="#记分减免" class="headerlink" title="记分减免"></a>记分减免</h1><h1 id="法律责任"><a href="#法律责任" class="headerlink" title="法律责任"></a>法律责任</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="%E9%81%93%E8%B7%AF%E4%BA%A4%E9%80%9A%E5%AE%89%E5%85%A8%E8%BF%9D%E6%B3%95%E8%A1%8C%E4%B8%BA%E8%AE%B0%E5%88%86%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95.pdf">道路交通安全违法行为记分管理办法</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【黑魂3】速杀配装记录</title>
    <url>/blog/games/Dark%20Soul3-Quick%20Kill%20Outfit/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文旨在记录法师击杀不同boss的出装，出装的内容包含左右手武器、上身套装和戒指配装。</p>
<p>以表格的形式介绍不同boss的属性弱点，并以数值的形式展示弱点的大小，数值越大表示弱点越大。</p>
<p>以弱点判断对应boss应该使用的击杀技能。</p>
<p>另外，此处说的法师不单单指魔法类，还包含咒术、奇迹等等非物理系的攻击手段。</p>
<span id="more"></span>

<h1 id="希拉套装"><a href="#希拉套装" class="headerlink" title="希拉套装"></a>希拉套装</h1><p>希拉套装，是环印城（DLC）装备</p>
<h1 id="大块灵魂沉淀物"><a href="#大块灵魂沉淀物" class="headerlink" title="大块灵魂沉淀物"></a>大块灵魂沉淀物</h1><p>环印城道具</p>
<p>buff叠加释放顺序</p>
<ol>
<li>自打鞭子+，减血。可以使用宝箱头辅助减血至触发红泪；</li>
<li>金石之誓；</li>
<li>阳光滋润；</li>
<li>内在潜力；</li>
</ol>
<p>配装：</p>
<ul>
<li>艾雷德尔蔷薇+5</li>
</ul>
<p><img src="Snipaste_2023-03-14_22-21-39.png"></p>
<h1 id="灰古达"><a href="#灰古达" class="headerlink" title="灰古达"></a>灰古达</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>95</td>
</tr>
<tr>
<td>雷</td>
<td>114</td>
</tr>
<tr>
<td>火</td>
<td>98</td>
</tr>
<tr>
<td>暗</td>
<td>62</td>
</tr>
</tbody></table>
<p>适用技能：阳光枪（贴脸施放）</p>
<h2 id="阳光枪获取"><a href="#阳光枪获取" class="headerlink" title="阳光枪获取"></a>阳光枪获取</h2><p>todo</p>
<h1 id="冰狗"><a href="#冰狗" class="headerlink" title="冰狗"></a>冰狗</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>76</td>
</tr>
<tr>
<td>雷</td>
<td>85</td>
</tr>
<tr>
<td>火</td>
<td>82</td>
</tr>
<tr>
<td>暗</td>
<td>127（很弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：大块灵魂沉积物</p>
<h2 id="配装"><a href="#配装" class="headerlink" title="配装"></a>配装</h2><ul>
<li><p>右手</p>
<ol>
<li>伊扎里斯杖+5；</li>
<li>摩利安刀剑；</li>
<li>血癫狂+5；</li>
</ol>
</li>
<li><p>左手</p>
<ol>
<li>费莲诺尔圣铃+5；</li>
<li>白发护符；</li>
<li>摩利安刀剑；</li>
</ol>
</li>
<li><p>头盔：覆眼面罩</p>
</li>
<li><p>戒指</p>
<ol>
<li>稚嫩龙徽戒指；</li>
<li>狂吼龙徽戒指；</li>
<li>暗怪手戒指；</li>
<li>红泪石戒指；</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-03-14_22-23-00.png"></p>
<h2 id="大块灵魂沉积物获取"><a href="#大块灵魂沉积物获取" class="headerlink" title="大块灵魂沉积物获取"></a>大块灵魂沉积物获取</h2><p>todo</p>
<h1 id="舞娘"><a href="#舞娘" class="headerlink" title="舞娘"></a>舞娘</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>81</td>
</tr>
<tr>
<td>雷</td>
<td>83</td>
</tr>
<tr>
<td>火</td>
<td>82</td>
</tr>
<tr>
<td>暗</td>
<td>126（很弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：追踪者+大块灵魂沉积物</p>
<h2 id="配装-1"><a href="#配装-1" class="headerlink" title="配装"></a>配装</h2><p>同冰狗一致。</p>
<h1 id="妖王"><a href="#妖王" class="headerlink" title="妖王"></a>妖王</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>60</td>
</tr>
<tr>
<td>雷</td>
<td>140（极弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>80</td>
</tr>
<tr>
<td>暗</td>
<td>78</td>
</tr>
</tbody></table>
<p>适用技能：阳光枪（远程）</p>
<p>PS：魅惑可以骗地方咒术师的buf</p>
<h1 id="英雄古达"><a href="#英雄古达" class="headerlink" title="英雄古达"></a>英雄古达</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>88</td>
</tr>
<tr>
<td>雷</td>
<td>112（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>90</td>
</tr>
<tr>
<td>暗</td>
<td>95</td>
</tr>
</tbody></table>
<p>适用技能：弹反+阳光枪（贴脸）</p>
<h1 id="猎龙铠甲"><a href="#猎龙铠甲" class="headerlink" title="猎龙铠甲"></a>猎龙铠甲</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>76</td>
</tr>
<tr>
<td>雷</td>
<td>28</td>
</tr>
<tr>
<td>火</td>
<td>80（略弱火，理论最佳）</td>
</tr>
<tr>
<td>暗</td>
<td>32</td>
</tr>
</tbody></table>
<p>适用技能：结晶枪</p>
<h2 id="配装-2"><a href="#配装-2" class="headerlink" title="配装"></a>配装</h2><ul>
<li><p>右手</p>
<ol>
<li>宫廷魔法师+10；</li>
</ol>
</li>
<li><p>左手</p>
<ol>
<li>白发护符；</li>
<li>老者结晶杖+5；</li>
</ol>
</li>
<li><p>头盔：xx</p>
</li>
<li><p>戒指</p>
<ol>
<li>稚嫩龙徽戒指；</li>
<li>狂吼龙徽戒指；</li>
<li>魔力怪戒指；</li>
<li>老者戒指+2；</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-03-14_23-27-32.png"></p>
<h1 id="大树"><a href="#大树" class="headerlink" title="大树"></a>大树</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>57</td>
</tr>
<tr>
<td>雷</td>
<td>60</td>
</tr>
<tr>
<td>火</td>
<td>105（弱火，理论最佳）</td>
</tr>
<tr>
<td>暗</td>
<td>60</td>
</tr>
</tbody></table>
<p>适用技能：温床残渣</p>
<h1 id="配装-3"><a href="#配装-3" class="headerlink" title="配装"></a>配装</h1><ul>
<li><p>右手</p>
<ol>
<li>咒术之火+10；</li>
</ol>
</li>
<li><p>左手</p>
<ol>
<li>费莲诺尔圣铃+5</li>
<li>白发护符；</li>
<li>摩利安刀剑；</li>
</ol>
</li>
<li><p>头盔：希拉头冠</p>
</li>
<li><p>臂甲：希拉手套</p>
</li>
<li><p>戒指</p>
<ol>
<li>大沼泽戒指；</li>
<li>魔女们的戒指；</li>
<li>火焰怪手戒指；</li>
<li>红泪石戒指；</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-03-14_23-37-07.png"></p>
<h1 id="结晶长老"><a href="#结晶长老" class="headerlink" title="结晶长老"></a>结晶长老</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>60</td>
</tr>
<tr>
<td>雷</td>
<td>98</td>
</tr>
<tr>
<td>火</td>
<td>100（弱火，理论最佳）</td>
</tr>
<tr>
<td>暗</td>
<td>100（弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：黑焰+净化火焰</p>
<h1 id="配装-4"><a href="#配装-4" class="headerlink" title="配装"></a>配装</h1><ul>
<li><p>右手</p>
<ol>
<li>咒术送灵火+10；</li>
</ol>
</li>
<li><p>左手</p>
<ol>
<li>费莲诺尔圣铃+5</li>
<li>白发护符；</li>
<li>xx；</li>
</ol>
</li>
<li><p>头盔：覆眼面罩</p>
</li>
<li><p>臂甲：希拉手套</p>
</li>
<li><p>戒指</p>
<ol>
<li>大沼泽戒指；</li>
<li>魔女们的戒指；</li>
<li>魔力怪手戒指；</li>
<li>红泪石戒指；</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-03-14_23-48-30.png"></p>
<h1 id="主教群"><a href="#主教群" class="headerlink" title="主教群"></a>主教群</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>64</td>
</tr>
<tr>
<td>雷</td>
<td>102（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>100</td>
</tr>
<tr>
<td>暗</td>
<td>56</td>
</tr>
</tbody></table>
<p>适用技能：风暴落雷（一阶段）+阳光枪（贴脸，二阶段），诱敌头盖骨（道具）</p>
<h1 id="不死队"><a href="#不死队" class="headerlink" title="不死队"></a>不死队</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>90</td>
</tr>
<tr>
<td>雷</td>
<td>112（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>92</td>
</tr>
<tr>
<td>暗</td>
<td>65</td>
</tr>
</tbody></table>
<p>适用技能：结晶枪</p>
<h1 id="霸王"><a href="#霸王" class="headerlink" title="霸王"></a>霸王</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>76（弱魔，理论最佳）</td>
</tr>
<tr>
<td>雷</td>
<td>60（贴脸阳光枪1.68伤害，等于101）</td>
</tr>
<tr>
<td>火</td>
<td>72</td>
</tr>
<tr>
<td>暗</td>
<td>30</td>
</tr>
</tbody></table>
<p>适用技能：阳光枪（贴脸）</p>
<h1 id="老恶魔王"><a href="#老恶魔王" class="headerlink" title="老恶魔王"></a>老恶魔王</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>95</td>
</tr>
<tr>
<td>雷</td>
<td>96</td>
</tr>
<tr>
<td>火</td>
<td>22</td>
</tr>
<tr>
<td>暗</td>
<td>100（弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：大块灵魂沉积物</p>
<p>攻击要点：远距离边攻击边往前走</p>
<h1 id="尤姆"><a href="#尤姆" class="headerlink" title="尤姆"></a>尤姆</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>95</td>
</tr>
<tr>
<td>雷</td>
<td>112（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>0</td>
</tr>
<tr>
<td>暗</td>
<td>100</td>
</tr>
</tbody></table>
<p>适用技能：阳光枪（远程）</p>
<p>攻击要点：远距站桩输出</p>
<h1 id="沙力万"><a href="#沙力万" class="headerlink" title="沙力万"></a>沙力万</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>88</td>
</tr>
<tr>
<td>雷</td>
<td>95（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>92</td>
</tr>
<tr>
<td>暗</td>
<td>95（弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：结晶枪</p>
<h1 id="埃尔德里奇"><a href="#埃尔德里奇" class="headerlink" title="埃尔德里奇"></a>埃尔德里奇</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>35</td>
</tr>
<tr>
<td>雷</td>
<td>100</td>
</tr>
<tr>
<td>火</td>
<td>112（弱火，理论最佳）</td>
</tr>
<tr>
<td>暗</td>
<td>25</td>
</tr>
</tbody></table>
<p>boss部位弱点：爆头1.5倍伤害</p>
<p>适用技能：温床残渣</p>
<h1 id="风暴龙-无名"><a href="#风暴龙-无名" class="headerlink" title="风暴龙&#x2F;无名"></a>风暴龙&#x2F;无名</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>90&#x2F;76</td>
</tr>
<tr>
<td>雷</td>
<td>131&#x2F;17</td>
</tr>
<tr>
<td>火</td>
<td>65&#x2F;77</td>
</tr>
<tr>
<td>暗</td>
<td>100&#x2F;108（弱暗，理论最佳）</td>
</tr>
</tbody></table>
<p>适用技能：大块灵魂沉积物</p>
<p>攻击压迫点：</p>
<ol>
<li>先开魔力武器；</li>
<li>风龙首次降落后，出一发等风暴龙撞击大块灵魂沉积物；</li>
<li>风暴龙停稳后，再出一发；</li>
<li>打出硬直，最后补一发；</li>
<li>二阶段，补内潜+魔力武器；</li>
<li>看时机出大块灵魂沉积物。</li>
</ol>
<h1 id="双王子"><a href="#双王子" class="headerlink" title="双王子"></a>双王子</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>95&#x2F;53</td>
</tr>
<tr>
<td>雷</td>
<td>120&#x2F;96（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>98&#x2F;98</td>
</tr>
<tr>
<td>暗</td>
<td>30&#x2F;27</td>
</tr>
</tbody></table>
<p>适用技能：</p>
<ul>
<li>扭曲光壁：挡二阶段激光雨；</li>
<li>阳光枪：远近结合</li>
</ul>
<p>攻击要点：墙壁打法</p>
<h1 id="薪王化身"><a href="#薪王化身" class="headerlink" title="薪王化身"></a>薪王化身</h1><table>
<thead>
<tr>
<th>属性&#x2F;弱</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>魔</td>
<td>81</td>
</tr>
<tr>
<td>雷</td>
<td>95（弱雷，理论最佳）</td>
</tr>
<tr>
<td>火</td>
<td>65</td>
</tr>
<tr>
<td>暗</td>
<td>85</td>
</tr>
</tbody></table>
<p>适用技能：</p>
<ul>
<li>阳光枪（远程）；</li>
<li>结晶枪；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Parry Pontiff Sulyvahn</title>
    <url>/blog/games/Parry-Pontiff-Sulyvahn/index.html</url>
    <content><![CDATA[<p>我真是发神经，怎么突然就刷到了魂2的mod视频（旧神之薪），它做得相当的不错，很符合我的审美。在看到被mod优化后的魂2主角套装（法汉），加上长戟时，我被深深地吸引。我迫不及待想玩这个mod，但是很可惜，还没有上线，目前进有实机演示视频。我转而想到了魂3，我有这个游戏，最近我还给它购买了新的DLC，魂3也有战戟，也有法汉一套。最后，我果然是再次开始了黑暗之魂3的传火之旅，yes，indeed！</p>
<p>战戟法汉的传火之旅在今天傍晚为止都算是比较顺利，直到再次遇到老对手——教宗沙立万。真是一生之敌，这个可以弹反的boss，我想学会弹反这个臭boss。沙立万的弹反对于我来说还是比较难，一方面，是错学习成本很高，它对我连击2下，我的角色就会死亡。而且它连击频率异常高！导致大部分时候我都是在跑过去找他的路上，每次进门就会被快速砍死。</p>
<p>我觉得这样的学习方式太愚蠢了，必然会浪费大量的无用时间。我想，有没有mod可以做到角色无敌，让我可以和boss一直对练。我尝试去找了，找的过程中发现这种mod不多！真是让人震惊！而且mod的安装有安全问题和学习成本，最后我放弃这个道路。接着，我去看别人的针对沙立万的弹反教程，<a href="https://www.bilibili.com/video/BV1W34y1B7cM/?vd_source=33ac0456d389f10fb21747392b35389b">【黑暗之魂3】沙力万全招式弹反分解</a>。对于这个视频我的感受是：它的有效信息确实多，但感觉不像个教程！</p>
<p>我想起以前攻略一些招式比较多、比较复杂的boss，我也回去找视频学习如何攻略。一些将boss招式逐个分析的教程会出现在我们的搜索结果中。这些方法不是说不对，但是感觉缺少最关键的东西。它们都只看到boss当前这一招，不能看到未来几招。只能看到一招的话，如果你想战胜敌人，那么就要求你有超强的反应能力，在无防备的情况下即时应对当前boss出招。</p>
<p>所谓可以看到未来几招的意思是，看到boss当前的出招，可以预判这招之后，下一招是什么。让你在应对当前时就已经做好下一招的准备，这样才能做到游刃有余！这样才是正常人的攻略手段！</p>
<p>如果仅学会了每一招的应对方式，而不懂预判下一招。这样子留给自己的余裕太少，过于被动，很容易陷入手忙脚乱的境地！</p>
<p>准确预判下一招很难，应该主动引导，让它的出招符合预期，让下一招的可选范围缩到最小。换句话说就是，让boss陷入我们的节奏！</p>
<h1 id="出招特点"><a href="#出招特点" class="headerlink" title="出招特点"></a>出招特点</h1><ul>
<li><p>所有左手魔剑（蓝色）出招中，仅有一招是可以被弹反的；</p>
</li>
<li><p>所有右手火焰剑出招中，仅有一招是无法被弹反的。</p>
</li>
</ul>
<h1 id="出招详情"><a href="#出招详情" class="headerlink" title="出招详情"></a>出招详情</h1>

<table>
<thead>
<tr>
<th>序号</th>
<th>招式</th>
<th align="center">起手式</th>
<th align="center">可弹反</th>
<th align="center">起手式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>右移斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>01</td>
<td>左移刺</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>02</td>
<td>突进斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>03</td>
<td>右踏斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>04</td>
<td>右踏反斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>05</td>
<td>右踏斩·连</td>
<td align="center">左剑突刺，举盾应对</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="left"></td>
</tr>
<tr>
<td>06</td>
<td>左剑蓄力突刺</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>07</td>
<td>左剑突刺-连</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="left"></td>
</tr>
<tr>
<td>08</td>
<td>左剑突刺连·无蕾力动作</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="left"></td>
</tr>
<tr>
<td>09</td>
<td>左剑回旋斩</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>10</td>
<td>右退斩</td>
<td align="center">左剑突刺，举盾应对</td>
<td align="center">✔️，在第三招弹反</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>11</td>
<td>左剑伪突刺</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>12</td>
<td>右剑蓄力下劈</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>13</td>
<td>回旋二连击</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>14</td>
<td>回身斩</td>
<td align="center">左剑突刺</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>15</td>
<td>左剑回身斩</td>
<td align="center">左剑突刺</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>16</td>
<td>蓄力后跳下斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left">出现频率很低</td>
</tr>
<tr>
<td>17</td>
<td>跳斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>18</td>
<td>空跳下戳</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>19</td>
<td>空跳右剑下戳</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>20</td>
<td>腾空跳劈</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>21</td>
<td>混合四连击</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>22</td>
<td>上挑回旋斩</td>
<td align="center">-</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>23</td>
<td>变身</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="left"></td>
</tr>
<tr>
<td>24</td>
<td>左剑蓄力突刺·起</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>25</td>
<td>蓄力气剑</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="left"></td>
</tr>
<tr>
<td>26</td>
<td>分身</td>
<td align="center">-</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>以“左剑突刺”为起手式的招数</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>招式</th>
<th align="center">应对突刺</th>
<th align="center">总招数</th>
<th align="center">弹反招数</th>
</tr>
</thead>
<tbody><tr>
<td>05</td>
<td>右踏斩·连</td>
<td align="center">举盾</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td>10</td>
<td>右退斩</td>
<td align="center">举盾</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td>14</td>
<td>回身斩</td>
<td align="center">向前翻滚</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td>15</td>
<td>左剑回身斩</td>
<td align="center">向前翻滚</td>
<td align="center">2 或 3</td>
<td align="center">最后一招（2 或  3）</td>
</tr>
</tbody></table>
<h1 id="派生出招"><a href="#派生出招" class="headerlink" title="派生出招"></a>派生出招</h1><h2 id="右移斩"><a href="#右移斩" class="headerlink" title="右移斩"></a>右移斩</h2><ol>
<li><p>快速右移（向boss右手方向）一段距离；</p>
</li>
<li><p>右手右剑，从右上至左下正手斜劈。</p>
</li>
</ol>
<p><strong>招数共</strong>：1招</p>
<p><img src="Snipaste_2023-07-28_12-33-57.png"></p>
<p><img src="Snipaste_2023-07-28_12-33-57.gif"></p>
<h2 id="突进斩"><a href="#突进斩" class="headerlink" title="突进斩"></a>突进斩</h2><p><strong>招数共</strong>：1招</p>
<ol>
<li><p>向前（玩家方向）突进一大段距离近身；</p>
</li>
<li><p>右手右剑，从右上至左下正手斜劈。</p>
</li>
</ol>
<p><img src="Snipaste_2023-07-28_13-14-02.png"></p>
<p><strong>注意</strong>：<em>弹反时机是最初剑高过9点方向时，而不是抬至最高点</em></p>
<h2 id="右踏斩"><a href="#右踏斩" class="headerlink" title="右踏斩"></a>右踏斩</h2><p><strong>招数共</strong>：1招</p>
<p>与 突进斩 类似，但是没有大段突进。弹反时机不同！</p>
<ol>
<li>右手右剑，从右上至左下正手斜劈。注意，boss的右剑是夸张的右举，已达到后背，见下图。</li>
</ol>
<p><img src="Snipaste_2023-07-28_13-20-52.png"></p>
<p><strong>提醒</strong>：<em>弹反时机与右移斩差不多！算是不横移的“右移斩”</em></p>
<h2 id="右踏反斩"><a href="#右踏反斩" class="headerlink" title="右踏反斩"></a>右踏反斩</h2><p><strong>招数共</strong>：2招，<em>包含第1招起手，可能是右移斩或右踏斩；第2招结尾，右踏反斩</em></p>
<h3 id="派生1"><a href="#派生1" class="headerlink" title="派生1"></a>派生1</h3><ol>
<li>起手：右踏斩【#03】（右上至左下）；</li>
<li>右手右剑，从左上至右下，反手斩下</li>
</ol>
<h3 id="派生2"><a href="#派生2" class="headerlink" title="派生2"></a>派生2</h3><ol>
<li>起手：右移斩【#00】；</li>
<li>右手右剑反手，从左上王右下，反手斩下【#04】</li>
</ol>
<p><img src="Snipaste_2023-07-28_06-27-26.png"></p>
<p><strong>注意</strong>：<em>从视频中弹反的时机观察到的特点：右手从胸前往左后方抬，抬起至最高点出手</em></p>
<p><em>剑身差不多到达八点钟方向</em></p>
<h2 id="右踏斩-连"><a href="#右踏斩-连" class="headerlink" title="右踏斩-连"></a>右踏斩-连</h2><p>右踏斩不作为起手式，而是作为后续招式。</p>
<ol>
<li>起手，左剑突刺。*<em>应对：举盾格挡，观察下一个出招</em></li>
<li>接 右踏斩。</li>
</ol>
<p><img src="Snipaste_2023-07-28_11-41-51.png"></p>
<p><strong>注意</strong>：<em>“右踏斩-连”的弹反时机与右踏斩的时机区别较大，前者只要右手反手到2点钟，后者要到4.5点钟</em></p>
<h2 id="右退斩"><a href="#右退斩" class="headerlink" title="右退斩"></a>右退斩</h2><p>起手：左剑突刺（举盾挡）-&gt; 右旋双手下劈（举盾挡） -&gt; 右手单剑下劈【#10-右退斩】（弹反）</p>
<p><img src="Snipaste_2023-07-28_05-21-19.png"></p>
<h2 id="右剑蓄力下劈"><a href="#右剑蓄力下劈" class="headerlink" title="右剑蓄力下劈"></a>右剑蓄力下劈</h2><p>起手：右剑右正手蓄力下劈【#12】</p>
<p><img src="Snipaste_2023-07-28_05-24-55.png"></p>
<h2 id="回身斩"><a href="#回身斩" class="headerlink" title="回身斩"></a>回身斩</h2><p>起手：左剑突刺（前翻滚，boss冲到后面，自己跟上）- 右手单剑下劈（玩家还在boss身后）- 右手回身斩【#14】（弹反）</p>
<p><img src="Snipaste_2023-07-28_05-29-46.png"></p>
<h2 id="左剑回身斩"><a href="#左剑回身斩" class="headerlink" title="左剑回身斩"></a>左剑回身斩</h2><h3 id="派生1-1"><a href="#派生1-1" class="headerlink" title="派生1"></a>派生1</h3><ol>
<li>起手，左剑突刺。<em>应对：前翻滚，转身追boss；</em></li>
<li>左剑回身斩【#15】。<em>应对：弹反</em></li>
</ol>
<h3 id="派生2-1"><a href="#派生2-1" class="headerlink" title="派生2"></a>派生2</h3><ol>
<li>起手，左剑突刺。<em>应对：前翻滚，转身追boss；</em></li>
<li>右手单剑下劈。<em>无应对，在攻击范围外，继续靠近boss</em></li>
<li>左剑回身斩【#15】。<em>应对：弹反</em></li>
</ol>
<p><img src="Snipaste_2023-07-28_05-37-08.png"></p>
<h2 id="跳劈"><a href="#跳劈" class="headerlink" title="跳劈"></a>跳劈</h2><h3 id="派生1-2"><a href="#派生1-2" class="headerlink" title="派生1"></a>派生1</h3><ol>
<li>远距离发射光线；</li>
<li>起跳突进右手下劈</li>
</ol>
<p><img src="Snipaste_2023-07-28_05-47-19.png"></p>
<p>注意：这里弹反的目标是幻影。</p>
<h2 id="腾空跳劈"><a href="#腾空跳劈" class="headerlink" title="腾空跳劈"></a>腾空跳劈</h2><ol>
<li>起手：几乎竖直升起，然后下劈【#20】</li>
</ol>
<p><img src="Snipaste_2023-07-28_05-56-33.png"></p>
<p><strong>注意</strong>：<em>弹反的目标是幻影</em></p>
<h2 id="混合四连击"><a href="#混合四连击" class="headerlink" title="混合四连击"></a>混合四连击</h2><h3 id="派生1-3"><a href="#派生1-3" class="headerlink" title="派生1"></a>派生1</h3><p>起手第一击就可以弹反，不需要等后续出招到某一次斩击！</p>
<p><img src="Snipaste_2023-07-28_05-58-21.png"></p>
<p><strong>注意</strong>：<em>boss双手此时不是最高点，而是最高点之后稍微下降</em></p>
<h3 id="派生2-2"><a href="#派生2-2" class="headerlink" title="派生2"></a>派生2</h3><p>举盾扛过第一二次斩击，瞄准第三次攻击进行弹反！</p>
<ol>
<li>起手，右剑右下横砍；</li>
<li>左剑左下横砍；</li>
<li>右手回身右剑反手下劈。瞄准，等待弹反！</li>
</ol>
<p><img src="Snipaste_2023-07-28_06-07-20.png"></p>
<h2 id="上挑回旋"><a href="#上挑回旋" class="headerlink" title="上挑回旋"></a>上挑回旋</h2><p>这一招包含2次斩击，分别是上挑和下劈，两个都是可以弹反。这一招是接在混合四连击后面。</p>
<h3 id="派生1-4"><a href="#派生1-4" class="headerlink" title="派生1"></a>派生1</h3><ol>
<li>起手，混合四连击。最后一击是左手蓝剑直刺；</li>
<li>右手火焰剑，从右下往左上，上挑。</li>
</ol>
<p><img src="Snipaste_2023-07-28_06-15-52.png"></p>
<h3 id="派生2-3"><a href="#派生2-3" class="headerlink" title="派生2"></a>派生2</h3><ol>
<li>基于派生1；</li>
<li>双手下劈；</li>
</ol>
<p><img src="Snipaste_2023-07-28_06-17-14.png"></p>
<h1 id="起手式"><a href="#起手式" class="headerlink" title="起手式"></a>起手式</h1><h2 id="左剑突刺"><a href="#左剑突刺" class="headerlink" title="左剑突刺"></a>左剑突刺</h2><ul>
<li>右踏斩-连：</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2024-01 计划</title>
    <url>/blog/plan/202401/index.html</url>
    <content><![CDATA[<p>[ ] 学会 2 首口琴曲子；</p>
<p>[ ] 学习节拍知识；</p>
<p>[ ] 学会双拼输入法；</p>
<p>[ ] 找新的出租屋</p>
]]></content>
  </entry>
  <entry>
    <title>2024-01 计划</title>
    <url>/blog/plan/glvz-to-eemw/index.html</url>
    <content><![CDATA[<p><img src="image-20241119221924662.png"></p>
<p>地图估计用时：24+15&#x3D;39h<br>里程：1861km</p>
<p>预估单日行程：200km、300km</p>
<p>第一个 200km<br><img src="image-20241119222622861.png"></p>
<p>到达郁南县<br><img src="image-20241119222747281.png"></p>
<h2 id="以-300km-划分"><a href="#以-300km-划分" class="headerlink" title="以 300km 划分"></a>以 300km 划分</h2><p>300 * 1</p>
<p><img src="image-20241119223050276.png"></p>
<h2 id="200km"><a href="#200km" class="headerlink" title="200km"></a>200km</h2><p>目的地：德庆广丽酒店</p>
]]></content>
  </entry>
  <entry>
    <title>Inserting back-to-top</title>
    <url>/blog/plan/isubo%20-%20add%20feat%20of%20inserting%20back2top/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>isubo - add feat of only-print</title>
    <url>/blog/plan/isubo%20-%20add%20feat%20of%20only-print/index.html</url>
    <content><![CDATA[<p>yargs 添加 <code>options</code>，<code>only-print</code></p>
<p>参考：<a href="https://github.com/yargs/yargs/blob/main/docs/api.md#optionkey-opt">https://github.com/yargs/yargs/blob/main/docs/api.md#optionkey-opt</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">&#x27;yargs/yargs&#x27;</span>)(process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>))</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;f&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">alias</span>: <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">      <span class="attr">demandOption</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;/etc/passwd&#x27;</span>,</span><br><span class="line">      <span class="attr">describe</span>: <span class="string">&#x27;x marks the spot&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="property">argv</span>;</span><br></pre></td></tr></table></figure>

<p>修改为使用cmd，<code>isubo format</code>。</p>
<p>增加 option</p>
<ul>
<li><p><code>--print</code>: 打印到 console；</p>
</li>
<li><p><code>--clipboard</code>: 输出到剪切板</p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kgajera.com/blog/how-to-test-yargs-cli-with-jest/">How to Test Yargs CLI with Jest</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vpn learning</title>
    <url>/blog/plan/knowledge-types/index.html</url>
    <content><![CDATA[<p>以一个节点完全整理我的知识、技能结构目前看不容易。一多个根分类去区分比较好。</p>
<ul>
<li><p>以开发内容做区分</p>
<ul>
<li>基建</li>
<li>业务逻辑</li>
<li>监控</li>
</ul>
</li>
<li><p>以语言做分类（主要是基础知识的整理）</p>
<ul>
<li>js</li>
<li>css</li>
<li>html</li>
<li>nodejs</li>
<li>rust</li>
</ul>
</li>
</ul>
<p>在上面5个分类按各自语言特点去向下划分分类</p>
<p>在开发技术知识上：</p>
<ul>
<li><p>基础实现；</p>
</li>
<li><p>优秀实现（性能提升）</p>
</li>
<li><p>设计思想；</p>
</li>
</ul>
<p>源码阅读</p>
<ul>
<li><p>vue</p>
</li>
<li><p>react</p>
</li>
<li><p>等等</p>
</li>
</ul>
<p>安全</p>
<ul>
<li><p>前端</p>
</li>
<li><p>后端</p>
</li>
</ul>
<p>性能优化</p>
<p>思维到图：<a href="https://www.processon.com/mindmap/5f068d155653bb2925d5b9ea">https://www.processon.com/mindmap/5f068d155653bb2925d5b9ea</a></p>
]]></content>
  </entry>
  <entry>
    <title>my-tech-review</title>
    <url>/blog/plan/my-tech-review/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vpn learning</title>
    <url>/blog/plan/vpn-learning/index.html</url>
    <content><![CDATA[<ul>
<li><p>v2ray&#x2F;xray</p>
</li>
<li><p>warp</p>
</li>
</ul>
<p>dns解析过程查询：<a href="https://www.diggui.com/">https://www.diggui.com/</a></p>
<p>mac地址</p>
<p>MAC地址（Media Access Control address）是一个唯一的物理地址，用于标识网络设备（如计算机、网络适配器、路由器等）在局域网中的身份。</p>
<ul>
<li><p>设备识别：每个网络设备都有一个唯一的MAC地址。通过MAC地址，网络中的设备可以互相识别和区分。这样，数据包就可以准确地被发送到目标设备，而不是广播给整个网络。</p>
</li>
<li><p>数据链路层寻址：MAC地址在数据链路层起到寻址的作用。在以太网（Ethernet）等数据链路层协议中，数据包的目标地址和源地址字段都包含了MAC地址信息。这样，网络设备可以根据目标MAC地址决定是否接收数据包。</p>
</li>
</ul>
<p>参考：</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=iidqJ7p7ln4">video|互联网是如何工作的？VPN、SSR、V2ray翻墙是什么原理？</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=ZT-q6mJ-e3g">video|VPN翻墙到底是什么原理？</a></p>
</li>
</ul>
]]></content>
  </entry>
</search>
