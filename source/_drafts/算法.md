---
title: 算法
excerpt: 算法
date: 2024-07-06 14:46:42
tags:
categories:
---
# 二分查找（Binary Search）

![](image-20240715214758376.jpeg)

二分查找是一种高效的搜索算法，用于在有序数组中查找特定元素。它的基本原理是：将目标值与数组中间元素比较；如果相等，则找到目标；如果目标小于中间元素，在左半部分继续查找；如果目标大于中间元素，在右半部分继续查找。
时间复杂度为 `O(log n)`，其中n是数组长度；空间复杂度：`O(1)`，只需要常数额外空间。使用二分查找的前提为数组必须是有序的，实现的方式可使用迭代法或递归法。

优点：
   - 查找速度快，尤其适用于大型数据集；
   - 实现简单。

缺点：
   - 仅适用于有序数组；
   - 不适合频繁插入删除的动态数组。

## 不同类型的二分查找

有比较常见的：在有序序列中找一个数。

```js
const target = 3；
const nums = [1, 2, 3, 4, 5];
```

稍微变种的：寻找目标值的边界位置，有左侧（最小）、右侧（最大）边界查找。所谓边界即：在序列中，存在与目标值相等复数个元素，序列中某段连续位置上的值都是与目标值相等，连续位置中最小和最大的位置即为左侧和右侧边界。

```js
const target = 3；
// targetLeftIdx = 2;
// targetRightIdx = 4;
const nums = [1, 2, 3, 3, 3, 4, 5];
```


## 找一个数

在一个有序数组中找一个数的场景是二分查找最常见的应用场景，也是迭代发中它最简单的算法实现。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
	
  while (left <= right) {
    // 使用位运算来计算中间索引,避免可能的整数溢出
    const mid = left + ((right - left) >> 1);

    if (arr[mid] === target) {
      return mid; // 找到目标,返回索引
    } else if (arr[mid] < target) {
      left = mid + 1; // 目标在右半部分
    } else {
      right = mid - 1; // 目标在左半部分
    }
  }
  
  return -1; // 目标不在数组中
}

// 测试
const arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log(binarySearch(arr, 13)); // 输出: 6
console.log(binarySearch(arr, 4));  // 输出: -1
```

以下几个逻辑是实现二分查找算法值得多留心的点：

1. **边界索引的取值**：`left = 0;right = arr.length - 1`，`left` 和 `right` 存储搜索范围的边界（数组的索引）；
2. **中间索引的取值**：`mid = left + ((right - left) >> 1)`，`mid` 存储范围的中间索引。计算中间值索引时，是该向上取整还是向下取整；
3. **迭代循环的条件**：`while(left <= right)`，针对迭代循环的条件，需要考虑的是何时该跳出循环； 
4. **缩小搜索范围时的新边界索引的取值**：`left = mid + 1;right = mid - 1`，在缩小搜索范围时，是该以中间值索引还是中间值索引向内偏移一个单位的索引为边界；

两个边界值的赋值决定了程序进行搜索的区间。根据边界索引值的赋值，可以将搜索区间向数学中的开闭区间定义靠。比如上文中的 `left = 0;right = arr.length - 1`，第一个元素（索引为 `0`）和最后一个元素（索引为 `arr.length - 1`）都是理应要搜索的元素，因此可以认为此情况为左闭右闭的区间，写作 `[left, right]`。以此类推还会有以下三种情况：

- `left = 0;right = arr.length`：`right` 赋值为 `arr.length`，右边界已经越界，因此可认为此情况是左闭右闭区间，写作 `[left, right)`；

- `left = -1;right = arr.length - 1`：`left` 的赋值已经越界，因此可认为此情况是左开右闭区间，写作 `(left, right]`；

- `left = -1;right = arr.length`：`left` 和 `right` 的赋值已经越界，因此可认为此情况是左闭右闭区间，写作 `(left, right)`；

*注意：区间并非只有仅在最初赋值设定，而是需要在搜索区间不断缩小的时候保持开闭区间逻辑*

在决定使用何种开闭区间组织二分查找逻辑后，就应该一直保持，直到迭代循环的结束，否则将是预期外的结果，这些预期外的结果将在下文探讨（todo）。

搜索区间的开闭是二分查找的重要组成部分！它影响着如何设定未命中时退出循环的条件和缩小搜索范围时新边界索引的取值。下面分类讨论选用每种开闭区间搜索范围时，循环条件和新边界索引应如何组织逻辑。

### 左右闭区间

**搜索范围选用左右闭区间即左右边界索引无越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

由于索引为 `mid` 的元素在当前搜索范围中已经确认它并非与目标值相等的元素，因此在新的搜索范围中无需包含它。

循环条件的设定，应在数组中无目标值为前提考虑！由于左右闭区间的搜索范围中，两个边界索引的元素也是需要检查的元素，因此可以预见，尽管在搜索区间缩小为两个边界索引相等时（`left === right` 为真）依然需要继续检查（此时区间内仅剩一个元素），那么进入循环的条件应为：

```js
while (left <= right) {
  // ...
}
```


### 左闭右开区间

**搜索范围选用左右闭区间即左边界索引无越界，右边界索引越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

由于目前使用的搜索区间为左闭右开，因此，更新左边界时需要保持不越界（即使用 `mid + 1` 的索引值作为新的边界）；而更新右边界时则需要保持越界（即直接使用 `mid` 的索引值作为新的边界，而不是 `mid - 1`）。

考虑进入循环条件时，同考虑到极限下的情况即 `[left, right), left = right - 1`，可以代入索引值进行讨论：

假设 `left = 0`，即当前搜索区间 `[0, 1)`，由于搜索区间为左闭右开，可知当前仍剩 `arr[0]` 这一个元素未检查（`arr[1]` 是越界元素，不在搜索区间内）！那么可以推断出：当左边界索引与右边界索引相等时即搜索区间内已经无可检查的元素，那么退出循环的就是 `left === right` 为真。进入循环的条件就是：

```js
while (left < right) {
  // ...
}
```

### 左开右闭区间

**搜索范围选用左开右闭区间即左边界索引越界，右边界索引无越界**。这种搜索区间的选择与上文的“左闭右开区间”相类似，正好是一个反面，因此下面不做过多赘述。那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

进入循环的条件是（与“左闭右开区间”一样）：

```js
while (left < right) {
  // ...
}
```

### 左右开区间

**搜索范围选用左右闭区间即左右边界索引都越界**。即边界索引指向的元素皆不在搜索区间中！那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

左右边界都在搜索区间外，则左右边界索引在更新时只需将索引指向 `mid` 即可，毕竟在上一轮 `mid` 已经被检查并确认非目标值！

讨论当前情况的进入循环的条件，同样可以使用“左闭右开区间”中使用的“极限法”。考虑极限情况下，搜索区间仅剩一个元素未检查即：`(left, right), left = right - 2`。同样代入常数：

假设 `left = 0`，即 `(0, 2)`。此时仅剩 `arr[1]` 未检查！当搜索区间缩小为 `(0, 1)` 或 `(1, 2)` 搜索区间中无元素需要继续检查，可以退出循环！即 `left + 1 === right` 为真。那么进入循环的条件就是：

```js
while (left + 1 < right) {
  // ...
}
```


### 搜索区间选择对中间索引值的影响

上文中一直未提及中间值索引的计算，并非它不受搜索区间开闭的影响，正相反它同样是基于区间开闭进行逻辑组织。上文也提到了 `mid` 的计算逻辑：`mid` 搜索区间的中间元素的索引，即 `mid = (left + right) / 2`。但可以预见这般计算的中间值不一定会是整数（比如：`left = 0, right = 7` 则 `mid = 3.5`），当不是整数时就需要考虑是向上还是向下取整了！向下或向上取整不是问题的本质。关键在于取整之后得到的中间元素索引值是否越界（超出了当前的搜索区间），因此，当前选择的搜索区间的开闭就很关键，下面将针对上文几种区间开闭对中间索引值的影响展开讨论：


取整的方式已知有以下 2 种：

1. 向上：`Math.ceil((left + right) / 2)`；
2. 向下：`Math.floor((left + right) / 2)`；

极限情况下，即搜索区间缩小至新计算的中间索引与边界索引重合且需要进行取整处理。

**左右闭区间`[left, right]`**

极限情况下有：`[left, right], left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1]`，未取整前的中间索引是：`0.5`。此时数组中剩下两个未检查的元素（`arr[0], arr[1]`）即两个边界索引指向的元素。在此情况下，无论中间索引如何取整得到的索引值依然落在搜索区间内！*因此，选用“左右闭区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*


**左闭右开区间`[left, right)`**

极限情况下有：`[left, right), left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1)`，未取整前的中间索引是：`0.5`。此时数组中剩下一个未检查的元素（`arr[0]`，`arr[1]` 是当前搜索区间外的越界元素）即左边界索引指向的元素。显然在此情况下，若向上取整（让 `mid = 1`）将出现越界现象！更糟糕的是：`arr[1]` 已经在上一次迭代时已经被检查且确认并非目标值，再看上文已阐明的右边界索引的更新逻辑（`right = mid`），这意味下一次的搜索区间依然是 `[0, 1)`，没有缩小！这就会导致迭代一直继续，无限循环，无法退出循环，直到内存溢出！*因此，选用“左闭右开区间”作为搜索区间可以使用向下取整计算中间值索引，但绝不可以使用向上取整计算！*


**左开右闭区间`(left, right]`**

选用“左开右闭区间”与选用“左右开区间”正好是相互的镜像，正好相反！因此不做赘述，金给出结论：*选用“左开右闭区间”作为搜索区间可以使用向上取整计算中间值索引，但绝不可以使用向下取整计算！*


**左右开区间`(left, right)`**

使用“左右开区间”作为搜索区间不存在中间索引与边界索引重合的情况。可以代入常数，分别分析搜索区间仅剩 0 个、1 个、2个的情况：

- 剩余 2 个：`(left, right), left = right - 3`。设 `left = 0`，则 `(0, 3)`，搜索区间剩余元素是 `arr[1], arr[2]`。计算中间索引，向上取整是 2, 向下取整是 1，依然在搜索区间内，不存在与边界索引重合的情况；

- 剩余 1 个：`(left, right), left = right - 2`。设 `left = 0`，则 `(0, 2)`，搜索区间剩余元素是 `arr[1]`。计算中间索引得到的是 1，无需做取整处理且不存在与边界索引重合的情况；

- 剩余 0 个：搜索区间内已无元素需要检查，直接退出循环，不存在与边界索引重合的情况。

*因此，选用“左右开区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*


| 关键逻辑 \ 搜索区间 | `[left, right]`                       | `[left, right)`                   | `(left, right]`                      | `(left, right)`                   |
| ----------- | ------------------------------------- | --------------------------------- | ------------------------------------ | --------------------------------- |
| 初始边界        | `left = 0;`、`right = arr.length;`     | `left = 0;`、`right = arr.length;` | `left = 0;`、`right = arr.length - 1` | `left = -1;`、`right = arr.length` |
| 边界更新        | `left = mid + 1;` 、`right = mid - 1;` | `left = mid + 1;` 、`right = mid;` | `left = mid;` 、`right = mid - 1;`    | `left = mid;` 、`right = mid;`     |
| 进入循环条件      | `while(left <= right)`                | `while(left < right)`             | `while(left < right)`                | `while(left + 1 < right)`         |
| 中间索引取整      | 向下、向上取整皆可                             | 可向下取整；不可向上取整，否则无法退出循环导致内存溢出       | 可向上取整；不可向下取整，否则无法退出循环导致内存溢出          | 向下、向上取整皆可                         |



```js
// [left, right]

function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// [left, right)
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}

// (left, right]
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// (left, right)
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```













## 寻找边界

使用二分查找的基本场景是在一个有序序列中寻找目标数值。在此之上还存在这样一种场景：序列中的元素值不是唯一的，可能存在复数个，比如在：`[1,2,3,3,3,4,5]` 中 `3` 即为复数的存在！有可能需要寻找目标数值在序列中出现的最小或最大索引或两者兼有。使用基础的二分查找算法找出目标值后，使用线性遍历的方式向两个方向进行嗅探也不失为一种方式，但伴随序列的量级膨胀，可以预见复杂度在增加！而二分查找是存在用于快速寻找边界的变种算法！即为寻找最小边界的“寻找左侧边界的二分查找”和“寻找右侧边界的二分查找”。

### 寻找左侧边界

todo

### 寻找右侧边界

todo

## QA

- `rightIdx = nums.length - 1` 还是 `rightIdx = nums.length`？
- 在计算中间索引时，向上还是向下取整？
- `while` 循环终止的条件是 `leftIdx < rightIdx` 还是 `leftIdx <= rightIdx` ？
- 在缩小搜索区间时，赋值等式是 `leftIdx = midIdx` 还是 `leftIdx = midIdx - 1` （类推 `rightIdx`）？
# 应用场景

- 在有序序列中快速寻找一个数；
