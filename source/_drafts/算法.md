---
title: 算法
excerpt: 算法
date: 2024-07-06 14:46:42
tags:
categories:
---
# 二分查找（Binary Search）

![](image-20240715214758376.jpeg)

二分查找是一种高效的搜索算法，用于在有序数组中查找特定元素。它的基本原理是：将目标值与数组中间元素比较；如果相等，则找到目标；如果目标小于中间元素，在左半部分继续查找；如果目标大于中间元素，在右半部分继续查找。
时间复杂度为 `O(log n)`，其中n是数组长度；空间复杂度：`O(1)`，只需要常数额外空间。使用二分查找的前提为数组必须是有序的，实现的方式可使用迭代法或递归法。

优点：
   - 查找速度快，尤其适用于大型数据集；
   - 实现简单。

缺点：
   - 仅适用于有序数组；
   - 不适合频繁插入删除的动态数组。

## 不同类型的二分查找

有比较常见的：在有序序列中找一个数。

```js
const target = 3；
const nums = [1, 2, 3, 4, 5];
```

稍微变种的：寻找目标值的边界位置，有左侧（最小）、右侧（最大）边界查找。所谓边界即：在序列中，存在与目标值相等复数个元素，序列中某段连续位置上的值都是与目标值相等，连续位置中最小和最大的位置即为左侧和右侧边界。

```js
const target = 3；
// targetLeftIdx = 2;
// targetRightIdx = 4;
const nums = [1, 2, 3, 3, 3, 4, 5];
```


## 找一个数

在一个有序数组中找一个数的场景是二分查找最常见的应用场景，也是迭代发中它最简单的算法实现。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
	
  while (left <= right) {
    // 使用位运算来计算中间索引,避免可能的整数溢出
    const mid = left + ((right - left) >> 1);

    if (arr[mid] === target) {
      return mid; // 找到目标,返回索引
    } else if (arr[mid] < target) {
      left = mid + 1; // 目标在右半部分
    } else {
      right = mid - 1; // 目标在左半部分
    }
  }
  
  return -1; // 目标不在数组中
}

// 测试
const arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log(binarySearch(arr, 13)); // 输出: 6
console.log(binarySearch(arr, 4));  // 输出: -1
```

以下几个逻辑是实现二分查找算法值得多留心的点：

1. **边界索引的取值**：`left = 0;right = arr.length - 1`，`left` 和 `right` 存储搜索范围的边界（数组的索引）；
2. **中间索引的取值**：`mid = left + ((right - left) >> 1)`，`mid` 存储范围的中间索引。计算中间值索引时，是该向上取整还是向下取整；
3. **迭代循环的条件**：`while(left <= right)`，针对迭代循环的条件，需要考虑的是何时该跳出循环； 
4. **缩小搜索范围时的新边界索引的取值**：`left = mid + 1;right = mid - 1`，在缩小搜索范围时，是该以中间值索引还是中间值索引向内偏移一个单位的索引为边界；

两个边界值的赋值决定了程序进行搜索的区间。根据边界索引值的赋值，可以将搜索区间向数学中的开闭区间定义靠。比如上文中的 `left = 0;right = arr.length - 1`，第一个元素（索引为 `0`）和最后一个元素（索引为 `arr.length - 1`）都是理应要搜索的元素，因此可以认为此情况为左闭右闭的区间，写作 `[left, right]`。以此类推还会有以下三种情况：

- `left = 0;right = arr.length`：`right` 赋值为 `arr.length`，右边界已经越界，因此可认为此情况是左闭右闭区间，写作 `[left, right)`；

- `left = -1;right = arr.length - 1`：`left` 的赋值已经越界，因此可认为此情况是左开右闭区间，写作 `(left, right]`；

- `left = -1;right = arr.length`：`left` 和 `right` 的赋值已经越界，因此可认为此情况是左闭右闭区间，写作 `(left, right)`；

*注意：区间并非只有仅在最初赋值设定，而是需要在搜索区间不断缩小的时候保持开闭区间逻辑*

在决定使用何种开闭区间组织二分查找逻辑后，就应该一直保持，直到迭代循环的结束，否则将是预期外的结果，这些预期外的结果将在下文探讨（todo）。

搜索区间的开闭是二分查找的重要组成部分！它影响着如何设定未命中时退出循环的条件和缩小搜索范围时新边界索引的取值。下面分类讨论选用每种开闭区间搜索范围时，循环条件和新边界索引应如何组织逻辑。

### 左右闭区间

**搜索范围选用左右闭区间即左右边界索引无越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

由于索引为 `mid` 的元素在当前搜索范围中已经确认它并非与目标值相等的元素，因此在新的搜索范围中无需包含它。

循环条件的设定，应在数组中无目标值为前提考虑！由于左右闭区间的搜索范围中，两个边界索引的元素也是需要检查的元素，因此可以预见，尽管在搜索区间缩小为两个边界索引相等时（`left === right` 为真）依然需要继续检查（此时区间内仅剩一个元素），那么进入循环的条件应为：

```js
while (left <= right) {
  // ...
}
```


### 左闭右开区间

**搜索范围选用左右闭区间即左边界索引无越界，右边界索引越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

由于目前使用的搜索区间为左闭右开，因此，更新左边界时需要保持不越界（即使用 `mid + 1` 的索引值作为新的边界）；而更新右边界时则需要保持越界（即直接使用 `mid` 的索引值作为新的边界，而不是 `mid - 1`）。

考虑进入循环条件时，同考虑到极限下的情况即 `[left, right), left = right - 1`，可以代入索引值进行讨论：

假设 `left = 0`，即当前搜索区间 `[0, 1)`，由于搜索区间为左闭右开，可知当前仍剩 `arr[0]` 这一个元素未检查（`arr[1]` 是越界元素，不在搜索区间内）！那么可以推断出：当左边界索引与右边界索引相等时即搜索区间内已经无可检查的元素，那么退出循环的就是 `left === right` 为真。进入循环的条件就是：

```js
while (left < right) {
  // ...
}
```

### 左开右闭区间

**搜索范围选用左开右闭区间即左边界索引越界，右边界索引无越界**。这种搜索区间的选择与上文的“左闭右开区间”相类似，正好是一个反面，因此下面不做过多赘述。那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

进入循环的条件是（与“左闭右开区间”一样）：

```js
while (left < right) {
  // ...
}
```

### 左右开区间

**搜索范围选用左右闭区间即左右边界索引都越界**。即边界索引指向的元素皆不在搜索区间中！那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

左右边界都在搜索区间外，则左右边界索引在更新时只需将索引指向 `mid` 即可，毕竟在上一轮 `mid` 已经被检查并确认非目标值！

讨论当前情况的进入循环的条件，同样可以使用“左闭右开区间”中使用的“极限法”。考虑极限情况下，搜索区间仅剩一个元素未检查即：`(left, right), left = right - 2`。同样代入常数：

假设 `left = 0`，即 `(0, 2)`。此时仅剩 `arr[1]` 未检查！当搜索区间缩小为 `(0, 1)` 或 `(1, 2)` 搜索区间中无元素需要继续检查，可以退出循环！即 `left + 1 === right` 为真。那么进入循环的条件就是：

```js
while (left + 1 < right) {
  // ...
}
```


### 搜索区间选择对中间索引值的影响

上文中一直未提及中间值索引的计算，并非它不受搜索区间开闭的影响，正相反它同样是基于区间开闭进行逻辑组织。上文也提到了 `mid` 的计算逻辑：`mid` 搜索区间的中间元素的索引，即 `mid = (left + right) / 2`。但可以预见这般计算的中间值不一定会是整数（比如：`left = 0, right = 7` 则 `mid = 3.5`），当不是整数时就需要考虑是向上还是向下取整了！向下或向上取整不是问题的本质。关键在于取整之后得到的中间元素索引值是否越界（超出了当前的搜索区间），因此，当前选择的搜索区间的开闭就很关键，下面将针对上文几种区间开闭对中间索引值的影响展开讨论：


取整的方式已知有以下 2 种：

1. 向上：`Math.ceil((left + right) / 2)`；
2. 向下：`Math.floor((left + right) / 2)`；

极限情况下，即搜索区间缩小至新计算的中间索引与边界索引重合且需要进行取整处理。

**左右闭区间`[left, right]`**

极限情况下有：`[left, right], left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1]`，未取整前的中间索引是：`0.5`。此时数组中剩下两个未检查的元素（`arr[0], arr[1]`）即两个边界索引指向的元素。在此情况下，无论中间索引如何取整得到的索引值依然落在搜索区间内！*因此，选用“左右闭区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*


**左闭右开区间`[left, right)`**

极限情况下有：`[left, right), left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1)`，未取整前的中间索引是：`0.5`。此时数组中剩下一个未检查的元素（`arr[0]`，`arr[1]` 是当前搜索区间外的越界元素）即左边界索引指向的元素。显然在此情况下，若向上取整（让 `mid = 1`）将出现越界现象！更糟糕的是：`arr[1]` 已经在上一次迭代时已经被检查且确认并非目标值，再看上文已阐明的右边界索引的更新逻辑（`right = mid`），这意味下一次的搜索区间依然是 `[0, 1)`，没有缩小！这就会导致迭代一直继续，无限循环，无法退出循环，直到内存溢出！*因此，选用“左闭右开区间”作为搜索区间可以使用向下取整计算中间值索引，但绝不可以使用向上取整计算！*


**左开右闭区间`(left, right]`**

选用“左开右闭区间”与选用“左右开区间”正好是相互的镜像，正好相反！因此不做赘述，金给出结论：*选用“左开右闭区间”作为搜索区间可以使用向上取整计算中间值索引，但绝不可以使用向下取整计算！*


**左右开区间`(left, right)`**

使用“左右开区间”作为搜索区间不存在中间索引与边界索引重合的情况。可以代入常数，分别分析搜索区间仅剩 0 个、1 个、2个的情况：

- 剩余 2 个：`(left, right), left = right - 3`。设 `left = 0`，则 `(0, 3)`，搜索区间剩余元素是 `arr[1], arr[2]`。计算中间索引，向上取整是 2, 向下取整是 1，依然在搜索区间内，不存在与边界索引重合的情况；

- 剩余 1 个：`(left, right), left = right - 2`。设 `left = 0`，则 `(0, 2)`，搜索区间剩余元素是 `arr[1]`。计算中间索引得到的是 1，无需做取整处理且不存在与边界索引重合的情况；

- 剩余 0 个：搜索区间内已无元素需要检查，直接退出循环，不存在与边界索引重合的情况。

*因此，选用“左右开区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*

### 小结

下面用表格将搜索区间与其他几个关键逻辑进行归类：

| 搜索区间   | `[left, right]`                       | `[left, right)`                   | `(left, right]`                      | `(left, right)`                   |
| ------ | ------------------------------------- | --------------------------------- | ------------------------------------ | --------------------------------- |
| 初始边界   | `left = 0;`、`right = arr.length - 1;` | `left = 0;`、`right = arr.length;` | `left = 0;`、`right = arr.length - 1` | `left = -1;`、`right = arr.length` |
| 边界更新   | `left = mid + 1;` 、`right = mid - 1;` | `left = mid + 1;` 、`right = mid;` | `left = mid;` 、`right = mid - 1;`    | `left = mid;` 、`right = mid;`     |
| 进入循环条件 | `while(left <= right)`                | `while(left < right)`             | `while(left < right)`                | `while(left + 1 < right)`         |
| 中间索引取整 | 向下、向上取整皆可                             | 可向下取整；不可向上取整，否则无法退出循环导致内存溢出       | 可向上取整；不可向下取整，否则无法退出循环导致内存溢出          | 向下、向上取整皆可                         |


从表中可看出，随着搜索区间的开闭变化，初始边界、边界更新、进入循环条件和中间索引取整的有着相应的变化。结合上文可知，初始边界和边界更新是对搜索区间开闭思想的实现；“进入循环条件”不是开闭区间思想的实现，是基于它的延伸。“进入循环条件”的设定是为保证检查数组所有元素（若无目标值），不漏检任何元素的前提下退出迭代循环。在设定迭代循环条件时，可使用“极限法”思考极限情况下，搜索区间收缩到何种程度后数组所有元素皆被检查；“中间索引取整”设定的关键是保证它在任何情况下不会与越界的边界索引重合！另外，在上文可见到中间值的计算有两种方式，分别是 `(left + right) / 2` 和 `left + (right - left) / 2`。视情况，两种方式都无问题，但已知需要处理的数组长度大到接近安全整数范围（JavaScript 使用 IEEE 754 双精度浮点数表示法，提供大约 15-17 位十进制数字的精度。需要注意的是，当处理超出安全整数范围的大数时，可能会出现精度问题。），使用后者才是最优解！
### 代码组织思路

1. 选用区间
2. 保证初始边界和边界更新逻辑与选用区间一致；
3. 确定中间值索引取整方向：保证在任何情况下中间值索引不会越界，即那个边界是 “闭” 的就往哪个方向取整；
4. 结合所选用区间思考极限情况下，当前区间是否还有为检查的元素。可以先考虑 `left = right` 的情况，若区间无未检查元素，继续扩大一个单位差距（`left = right - 1`）继续思考是否区间有无未检查的元素，若有则说明前者是应当退出循环的情况，若无未检查元素则继续扩大一个单位差距，重复以上步骤直到确定何情况下该退出循环。

### 错误示例

| -        | A                                       | B                                      | C                                    | D                                 |
| -------- | --------------------------------------- | -------------------------------------- | ------------------------------------ | --------------------------------- |
| 1.初始边界   | `left = 0;`、`right = arr.length - 1;`   | `left = 0;`、`right = arr.length;`      | `left = -1;`、`right = arr.length - 1` | `left = -1;`、`right = arr.length` |
| 2.进入循环条件 | `while(left <= right)`                  | `while(left < right)`                  | `while(left + 1 < right)`            | -                                 |
| 3.中间索引取整 | `Math.floor(left + (right - left) / 2)` | `Math.ceil(left + (right - left) / 2)` | -                                    | -                                 |
| 4.边界更新   | `left = mid + 1;` 、`right = mid - 1;`   | `left = mid + 1;` 、`right = mid;`      | `left = mid;` 、`right = mid - 1;`    | `left = mid;` 、`right = mid;`     |


#### 01异常#A1A2B3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 9
```

边界初始是使用左右闭区间的搜索范围，但边界更新时则转变为左闭右开区间。而循环条件和中间值索引计算是配合左右闭区间的搜索范围组织的。使用“左闭右开区间”时，中间值索引向上取整会导致在极限情况下它与右边界（越界）不断重合，进入死循环。即引起上面用例所暴露的问题的两处关键逻辑语句是：

```js
const mid = Math.ceil(left + (right - left) / 2);
right = mid;
```

以上程序，在搜索区间剩余的元素个数小于或等于 2 个元素时，存在无法处理的情况（其中 2 种无需处理），需要增加额外代码修补漏洞。

当搜索区间剩余或仅有 2 个元素时：

- 左边界元素是目标值；
- 右边界元素是目标值（无需处理）；
- 左右边界元素非目标值。

当搜索区间剩余或仅有 1 个元素时：

- 是目标值（无需处理）；
- 不是目标值，但比目标值大；
- 不是目标值，但比目标值小（无需处理）；

```js
function(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间剩余的元素个数小于或等于 2 个元素
    if (left + 1 >= right) {
      // 左边界元素是目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意：未被前一个 if 拦截则表示左边界元素不是目标值
      // 情况1：剩余 2 元素时，左右边界元素均非目标值；
      // 情况2：剩余 1 元素时，不是目标值，但比目标值大
      // 情况3：剩余 1 元素时，不是目标值，但比目标值小（虽不需要处理，但这部分代码自带了此功能）
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```


#### 02异常#A1A2A3B4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```

这份代码与上一份的（[异常#A1A2B3A4](#异常-A1A2B3A4)）区别是，中间值索引的计算为向下取整。虽然解决了取整导致的问题，但依然无法避免中间值索引与越界边界索引重合的情况。问题在“进入循环的条件”，在 `left = right` 的情况下，中间索引依然与越界边界索引重合（`right`），由于 `target < arr[right]` 和 `right = mid` 的边界更新逻辑，导致无法退出循环！即引起上面用例所暴露的问题的关键逻辑是：

```js
while (left <= right) {}
right = mid;
```

根据以上分析，上面程序在搜索区间剩余或仅有 1 个元素，此元素非目标值且元素值大于目标值（仅在此时无法继续收缩区间）时，需要增加额外代码修补漏洞：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间剩余或仅有 1 个元素，此元素非目标值且元素值大于目标值
    if (left === right && arr[mid] > target) {
      return -1;
    }
  }

  return -1;
}
```


#### 03异常#A1B2A3B4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 输出 -1， 预期结果 0
nums = [5]
target = 5

# 输出 -1， 预期结果 1
nums = [2,5]
target = 5
```

这份代码与上一份的区别是，“进入循环的条件”改为 `left < right`，解决了中间值索引与越界边界索引重合导致无法退出循环的问题。已经是左闭右开区间标准写法的“边界初始化”替换为左右闭区间的。虽然解决了无法退出循环的问题，但存在无法进入循环的问题，见异常用例！

从组合上分析，这份代码的核心逻辑是由“左右闭区间”的“初始化边界”和“左闭右开区间”的“进入循环条件”、“中间值索引取整”以及“边界更新”组成而成。换个角度思考，一个使用“左右闭区间”初始化边界的 `arr.length` 长度的数组，相当于一个使用了“左闭右开区间”初始化边界的 `arr.length - 1` 长度的数组！因此，只需在进入循环前先处理 `arr[arr.length - 1]` 这个元素，即可将上边代码转变为使用“左开右闭区间”的，长度为 `arr.length - 1` 的二分查找代码。见下：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 进入循环前先处理 `arr[arr.length - 1]` 这个元素
  if (arr[right] === target) {
    return right;
  }

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```


#### 04异常#A1A2A3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 0
```

从关键逻辑的构成上分析，这份代码是“左右闭区间”的“初始边界”、“进入循环条件”和“中间索引取整”逻辑组合“左开右闭区间”的“边界更新”逻辑。中间值索引是向下取整，适合“左右闭区间”，但不适用于”左开右闭区间“。

当搜索区间（`[left, right], left = right - 1`）收缩至或仅有的元素个数小于等于 2 个时，存在上面程序无法处理的情况。这是由于中间值索引与左边界索引更新逻辑引起的，搜索区间无法随着循环迭代次数的增加而收缩。也因为无法收缩搜索区间，所以修补的逻辑只能在循环内添加！

左右边界索引相差1个单位（包含仅有 2 个元素的数组）：

- 左边界元素是目标值（无需处理）；
- 右边界元素是目标值；
- 左右边界元素不是目标值。

左右边界索引相等（包含仅有 1 个元素的数组）：

- 元素是目标值（无需处理）；
- 元素不是目标值；

因此，仅有 3 种情况需要增加额外代码对上面代码进行修补，见下：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }

    // 搜索区间剩余或仅有的元素个数小于等于 2 个
    if (left + 1 >= right) {
      // 情况1：搜索区间剩余或仅有 2 个元素时，右边界元素是目标值
      // 情况2：搜索区间剩余或仅有 1 个元素时，元素是目标值（无需处理，但当前逻辑具备此能力）
      if (arr[right] === target) {
        return right;
      }

      // 注意：没有被上一个 if 拦截及表示右边界元素不是目标值
      // 情况1：搜索区间剩余或仅有 1 个元素时，元素不是目标值
      // 情况2：搜索区间剩余或仅有 2 个元素时，左右边界不是目标值
      if (arr[left] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```

#### 05异常#A1A2B3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```

从关键逻辑的构成上分析，上面代码由“左右闭区间”的“初始边界”、“进入循环条件”与“左开右闭区间”的“中间索引取整”、“边界更新”等几个关键逻辑组成。中间值索引向上取整与“左开右闭区间”的“边界更新逻辑的组合可以预见的是，当搜索区间收缩至剩余 1 个元素时（`left = right`），若 `left = right` 时未触发退出循环（当前进入循环的条件是：`left <= right`），中间值索引将随着迭代次数的增加，不断与左边界索引重合，不再收缩搜索区间，导致进入死循环。

由于“中间索引取整”和“边界更新”都是“左开右闭区间”的，因此可以通过增加额外代码将“初始边界”和“进入循环条件”转化为“左开右闭区间”：

- “进入循环条件”：可在循环内增加逻辑让循环在边界索引值重合时提前退出循环；

- “初始边界”：可提前处理左边界索引的元素，让处理长度为`arr.length`的数组转化为处理长度为`arr.length - 1`的数组。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 处理长度为`arr.length`的数组转化为处理长度为`arr.length - 1`的数组
  if (arr[left] === target) {
    return left;
  }

  while (left <= right) {
    // 让循环在边界索引值重合时提前退出循环
    if (left === right) {
      return -1;
    }

    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```


#### 06异常#A1B2B3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

异常用例：

```
# 输出 -1， 预期结果 0
nums = [5]
target = 5
```

上面程序与[05异常#A1A2B3C4](#05异常-A1A2B3C4)极为相似，“进入循环条件”已经是“左开右闭区间”的逻辑，因此仅有“初始边界”不同引起的漏检边界索引元素漏洞，只需提前处理左边界索引元素即可修补此异常。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 处理长度为`arr.length`的数组转化为处理长度为`arr.length - 1`的数组
  if (arr[left] === target) {
    return left;
  }

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

#### 07异常#A1A2B3D4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```

边界更新使用的是左右开区间的逻辑，其他则是使用左右闭区间的逻辑。从上表可知道两种区间的选择对中间值索引计算的取整方式没有要求，因此关注点可放在边界更新和循环条件上。在搜索区间越发缩小就会发现问题，当 `left = right` 时，程序还在循环内。此时向上取整计算中间值索引，得到的是 `right`，即 `mid = right`，而边界索引的更新还是 `right`。搜索范围不会变化，循环也退出不了，从而导致死循环。

当搜索区间（左右闭区间）内元素个数少于等于 2 个时，当前程序基本无法处理，除了其中两种特殊情况即：
- 当元素个数剩余 2 个且右边界元素是目标值时（这是因为向上取整使中间值索引偏向了右边界）
- 当元素个数剩余 1 个且为目标值（原因同为中间值取整）。

因此需要增加额外代码修补这部分漏洞，下面列出的是需要增加额外代码的情况：

剩余或数组仅为 2 个元素（`[left, right], left = right - 1`）：

- 左边界为目标值；
- 左右边界均非目标值；
- 右边界为目标值（无需处理）；

剩余或数组仅为 1 个元素（`[left, right], left = right`）：

- 是目标值（无需处理）；
- 非目标值；

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }

    // 当搜索区间剩余元素小于等于 2 个时
    if (left + 1 >= right) {
      // 剩余 2 个元素且左边界元素为目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意：未被上一个if拦截即左边界非目标值
      // 情况1：剩余 1 个元素且不是目标值
      // 情况2：剩余 2 个元素且均非目标值
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```

#### 08异常#A1B2B3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”、“中间值索引取整”和左开右闭区间的“进入循环条件”、“边界更新”组成。首先看“边界更新”和“中间值索引取整”，中间值索引的取整方向是下，偏向了越界边界一方。这样的情况结会导致最终有可能无法退出循环而内存溢出！以下 2 种情况，中间值索引的向下取整而使 `mid = left` 持续发生，循环就无法结束：

- 在 `left = right - 1` 且 `arr[left] < target`；

- 在 `left = right`  且 `arr[left] < target`。

<!-- ps：区间对比判断是否漏检的前提是：A区间的“初始边界”和B区间的“进入循环条件”、“边界更新” -->

因此，在区间收缩至小于等于 `(left, right], left = right - 1` 时就需要增加代码修补漏洞。

当区间边界索引相差 1 个单位：

- 左边界元素是目标值（无需处理）；

- 右边界元素是目标值；

- 左右边界元素均非目标值。

当区间边界索引相差 0 个单位：

- 当前元素是目标值（无需处理）；

- 当前元素非目标值；

另外，由于使用的是左开右闭区间的“进入循环条件”（`while(left < right)`）组合左右开区间的“初始边界”逻辑，导致仅有 1 个元素（即左右边界索引相差 1 个单位）的数组无法进入循环，因此需要提前处理。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 提前处理仅有 1 个元素（即左右边界索引相差 1 个单位）的数组
  if (arr[left] === target) {
    return left;
  }

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }

    // 区间收缩至小于等于 `(left, right], left = right - 1`
    if (left >= right - 1) {
      // 情况1： 边界索引相差 1 个单位，右边界元素是目标值
      // 情况2： 边界索引相差 0 个单位，当前元素是目标值（无需处理，但当前逻辑具备此能力）
      if (arr[right] === target) {
        return right;
      }

      // 注意：未被上一个 if 拦截则说明右边界元素非目标值
      // 情况1： 边界索引相差 1 个单位，左右边界元素均非目标值
      // 情况2： 边界索引相差 0 个单位，当前元素非目标值
      if (arr[left] !== target) {
        return -1;
      }
    } 
  }

  return -1;
}
```

#### 09异常#A1A2A3D4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# Time Limit Exceeded
nums = [-1,0,3,5,9,12]
target = 2
```

从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”、“进入循环条件”与左右开区间的“中间值索引取整”（也可说是左右闭区间的，因为左右闭区间与左右开区间对中间值索引的取整逻辑都没有要求）、“边界更新”逻辑组成。但是左右开区间的“边界更新”逻辑仅能处理边界索引相差大于 1 个单位的搜索区间（`left + 1 > right`）。因此，当前程序的“进入循环条件”会导致死循环直到内存溢出。那么就需要在循环内增加额外代码处理边界索引等于 1 个单位的搜索区间（没有相差 0 个单位的搜索区间，因为左右开区间的“边界更新”逻辑无法收缩至此尺度的区间）。

以下是边界索引相差大于 1 个单位的搜索区间的各种情况：

- 左边界元素是目标值（无需处理，因为中间值索引向下取整，会与左边界索引重合）；
- 右边界元素是目标值；
- 左右边界元素均非目标值；

增加的额外修补代码见下：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }

    // 边界索引等于 1 个单位的搜索区间
    if (left + 1 >= right) {
      if (arr[right] === target) { // 右边界元素是目标值
        return right;
      } else if (arr[left] != target) { // 左右边界元素均非目标值
        return -1;
      }
    }
  }

  return -1;
}
```

#### 10异常#A1B2B3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

异常用例

```
# Testcase
[-1,0,3,5,9,12]
9

# Answer
-1

# Expected Answer
4
```

从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”、“边界更新”、“中间值索引取整”（也是左闭右开区间或左右开区间的）与左开右闭区间（或左闭右开区间）的“进入循环条件”逻辑。左右闭区间的“边界更新”组合左开右闭区间的“进入循环条件”逻辑会导致未检查完元素（剩余 1 个，即其中 1 个边界索引的元素）就提前退出循环。因此，只需在循环结束后增加代码处理剩余的边界元素即可。见下：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  // 处理剩余的边界元素（循环退出时，left = right，取其中一个边界索引即可）
  if (arr[left] === target) {
    return left;
  }

  return -1;
}
```

#### 11异常#A1B2B2B4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# Time Limit Exceeded
0/47 cases passed (N/A)

# Testcase
[-1,0,3,5,9,12]
9

#Expected Answer
4
```


从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”、“中间值索引取整”与左闭右开区间的“边界更新”、“进入循环条件”（或左闭右开区间）逻辑组成。

当前使用向上取整的中间值索引计算，在搜索区间收缩至边界索引相差 1 个单位（`left = right - 1`）时，中间值索引的计算结果会持续与右边界索引重合，以致于进入死循环直到内存溢出。因此需要增加额外代码处理 `left = right - 1` 的情况（无需处理 `left = right` 的情况，因为搜索区间无法收缩到此尺度）：

- 左边界元素是目标值；
- 右边界元素是目标值（无需处理）；
- 左右边界元素均非目标值。

在区间尺度大于 `left = right - 1` 时，中间值索引的取整对程序的工作影响（可以正常工作，至于效率还有待探究）不大，可以认为程序的核心就是偏向围绕左开右闭区间组织的。在区间的选择上，长度为 `arr.length` 的数组使用了左右闭区间的“初始边界”，相当于长度为 `arr.length - 1` 的数组使用了左闭右开区间的“初始边界”。如果不增加额外代码处理 `arr[arr.length - 1]` 元素，它就会漏检。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 提前处理右边界元素，将处理长度为 arr.length 的数组问题，转化为处理长度为 arr.length - 1 的
  if (arr[right] === target) {
    return right;
  }

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间收缩至边界索引相差 1 个单位
    if (left + 1 === right) {
      //  情况1： 左边界元素是目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意： 若未被前一个 if 拦截即左边界元素非目标值
      // 情况1： 左右边界元素均非目标值
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```


#### 12异常#A1B2B3D4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```


从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”与左右开区间的“边界更新”以及左开右闭区间“进入循环条件”（或左闭右开区间），还有向上取整的中间值取整逻辑组成。

左右开区间的“边界更新”只能处理 `left < right - 1` 的搜索区间，因此无法退出条件为 `left < right` 的循环。要顺利退出循环只能在循环内增加额外代码（`if`）以提前退出循环，让整个循环逻辑转变为左右开区间。使用左右闭区间的“初始边界”与前面的左右开区间，将导致漏检两个边界元素，因此需要提前处理两个边界元素后再进入循环。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 提前处理左边界元素
  if (arr[left] === target) {
    return left;
  }

  // 提前处理右边界元素
  if (arr[right] === target) {
    return right;
  }

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }

    // 搜索区间收缩至 left = right - 1 即可退出循环
    if (left >= right - 1) {
      return -1;
    }
  }

  return -1;
}
```

#### 13异常#A1B2A3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

```
# Testcase
nums = [5]
target = 5

输出 -1
预期结果 0
```

从关键逻辑的构成上，当前程序由左右闭区间的“初始边界”、“中间值索引取整”、“边界更新”与左开右闭区间（或左闭右开区间）的“进入循环条件”逻辑组成。

这样的构成岁不会导致无法退出循环的情况，反而是会出现提前退出或无法进入循环的情况：

- 无法进入循环：搜索区间仅有 1 个元素；

- 提前退出循环：搜索区间收缩至剩余 1 个元素。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  // 搜索区间仅有或收缩至剩余 1 个元素
  if (arr[left] === target) {
    return left;
  }

  return -1;
}
```

#### 14异常#A1B2A3D4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

当前程序与[12异常#A1B2B3D4](#12异常-A1B2B3D4)的情况基本一致，仅在中间值索引取整上有所不同，但对于左右开区间而言，无论向上或向下都影响程序正常工作。因此，出现的漏洞与[异常#A1B2B3D4](#异常-A1B2B3D4)一样，修补的方式也是一样：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 提前处理左边界元素
  if (arr[left] === target) {
    return left;
  }

  // 提前处理右边界元素
  if (arr[right] === target) {
    return right;
  }

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }

    // 搜索区间收缩至 left = right - 1 即可退出循环
    if (left >= right - 1) {
      return -1;
    }
  }

  return -1;
}
```

#### 15异常#A1C2B3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

从关键逻辑的结构上分析，此程序由左右闭区间的“初始边界”、“中间值索引取整”、“边界更新”与左右开区间的“进入循环条件”逻辑组成。

这样的构成会漏检搜索区间尺度为 `0 <= right - left <= 1`，即会提前退出循环和无法进入循环。因此需要增加代码检查此漏检区间：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  if (arr[left] === target) {
    return left;
  }

  if (arr[right] === target) {
    return left;
  }

  return -1;
}
```

#### 16异常#A1C2B3B4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# Testcase
nums = [-1,0,3,5,9,12]
target = 9

输出 -1
预期结果 4
```

从关键逻辑的构成上看：

- 初始边界：左右闭区间；

- 进入循环条件：左右开区间；

- 中间值索引取整：左右闭区间、左右开区间和左开右闭区间；

- 边界更新：左闭右开区间。

当前中间值索引取整逻辑与边界更新逻辑是不匹配的，但由于当前的“进入循环条件”的原因，使得还未触发前两者引发的漏洞就先退出循环了。而当前使用左右开区间的“进入循环条件”，在使用左右闭区间的“初始边界”逻辑的前提下会无法进入循环，即搜索区间是 `0 <= right - left <= 1` 的数组。收缩至同样尺度的搜索区间同样无法处理。因此，需要在循环结束后，增加额外代码处理此搜索区间：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}
```

#### 17异常#A1C2B3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

异常用例：

```
# Testcase
nums = [5]
target = 5

输出 -1
预期结果 0
```

从关键逻辑的构成上看：

- 初始边界：左右闭区间；

- 进入循环条件：左右开区间；

- 中间值索引取整：左右闭区间、左右开区间和左开右闭区间；

- 边界更新：左开右闭区间。

当前程序与[16异常#A1C2B3B4](#16异常-A1C2B3B4)的情况基本一致。程序中唯一不同的是边界更新逻辑，但由于左右开区间的“进入循环条件”逻辑，同样是提前退出了循环！因此修补思路与[16异常#A1C2B3B4](#16异常-A1C2B3B4)一样：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}
```

#### 18异常#A1C2B3D4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

从关键逻辑的构成上看，当前程序由左右闭区间的“初始边界”逻辑与左右开区间的“进入循环条件”、“中间值索引取整”、“边界更新”逻辑组成。

这样的组成会导致两个边界元素漏检，因此需要在进入循环前，处理两个边界元素。这样相当于将处理长度为 `arr.length` 的数组转变为长度为 `arr.length - 2` 的数组的“初始边界”：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

与其相似的还有：

```js
// 异常#A1C2A3D4
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}

// 修改后
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}
```

#### 19异常#A1C2A3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

从关键逻辑的构成上看，当前程序由左右开区间“进入循环条件”逻辑与左右闭区间的“初始边界”、“中间值索引取整”、“边界更新”逻辑组成。

引发的漏洞及其原因与[16异常#A1C2B3B4](#16异常-A1C2B3B4)、[17异常#A1C2B3C4](#17异常-A1C2B3C4)一样。因此修改思路也是一样：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}
```

与其相似的还有下面 2 个异常程序（异常#），修补漏洞的思路以及插入代码的位置也是一样：

```js
// 异常#A1C2A3B4
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}

// 异常#A1C2A3C4
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  // 情况1：搜索区间剩余或仅有 1 个元素，且目标值
  // 情况2：搜索区间剩余或仅有 2 个元素，且左边界为目标值
  if (arr[left] === target) {
    return left;
  }

  // 搜索区间剩余或仅有 2 个元素，且右边界为目标值
  if (arr[right] === target) {
    return right;
  }

  return -1;
}
```

#### 20异常#B1A2B3A4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

#### 21异常#B1A2B3B4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
Time Limit Exceeded
0/47 cases passed (N/A)
Testcase
[-1,0,3,5,9,12]
9
Expected Answer
4
```

从关键逻辑的构成上看：

- 初始边界：左闭右开区间；

- 进入循环条件：左右闭区间；

- 中间值索引取整：左右闭区间、左右开区间和左开右闭区间；

- 边界更新：左闭右开区间。

当前程序的中间值索引计算使用向上取整加上左闭右开的“边界更新”逻辑，导致循环处理的极限搜索区间是 `left < right - 1`。当搜索区间收缩至 `left = right - 1` 时，中间值索引的计算就会随着迭代次数的增加不断与左边界元素重合，从而导致死循环知道内存溢出。因此，需要增加额外代码处理 `0 <= right - left <= 1` 范围的搜索区间，并退出循环：


```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间收缩至剩余或仅有或少于 1 个元素
    if (left + 1 >= right) {
      // 情况1：搜索区间收缩至 left = right - 1 时，左边界元素是目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意：前面 if 没有拦截则表示左边界元素非目标值
      // 情况1：搜索区间收缩至 left = right - 1 时，左右边界元素均非目标值
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```

#### 22异常#B1A2B3C4

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

异常用例：

```
# Time Limit Exceeded
1/47 cases passed (N/A)

# Testcase
[-1,0,3,5,9,12]
2

# Expected Answer
-1
```

从关键逻辑的构成上看：

- 初始边界：左闭右开区间；

- 进入循环条件：左右闭区间；

- 中间值索引取整：左右闭区间、左右开区间和左开右闭区间；

- 边界更新：左开右闭区间。



### 应用场景

todo


## 寻找边界

使用二分查找的基本场景是在一个有序序列中寻找目标数值。在此之上还存在这样一种场景：序列中的元素值不是唯一的，可能存在复数个，比如在：`[1,2,3,3,3,4,5]` 中 `3` 即为复数的存在！有可能需要寻找目标数值在序列中出现的最小或最大索引或两者兼有。使用基础的二分查找算法找出目标值后，使用线性遍历的方式向两个方向进行嗅探也不失为一种方式，但伴随序列的量级膨胀，可以预见复杂度在增加！而二分查找是存在用于快速寻找边界的变种算法！即为寻找最小边界的“寻找左侧边界的二分查找”和“寻找右侧边界的二分查找”。

### 寻找左侧边界

todo

### 寻找右侧边界

todo


## 附录

### 各搜索区间开闭的二分查找的逻辑实现

PS：以下各搜索区间开闭的二分查找的逻辑实现均已通过 [leetcode 的 704. 二分查找](https://leetcode.cn/problems/binary-search/description/)！

**左右闭区间**

```js
// [left, right]
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

```

**左闭右开区间**

```js
// [left, right)
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}

```

**左开右闭区间**

```js
// (left, right]
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

```


**左右开区间**

```js
// (left, right)
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

