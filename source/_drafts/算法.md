---
title: 算法
excerpt: 算法
date: 2024-07-06 14:46:42
tags:
categories:
---
# 二分查找（Binary Search）

![](image-20240715214758376.jpeg)

二分查找是一种高效的搜索算法，用于在有序数组中查找特定元素。它的基本原理是：将目标值与数组中间元素比较；如果相等，则找到目标；如果目标小于中间元素，在左半部分继续查找；如果目标大于中间元素，在右半部分继续查找。
时间复杂度为 `O(log n)`，其中n是数组长度；空间复杂度：`O(1)`，只需要常数额外空间。使用二分查找的前提为数组必须是有序的，实现的方式可使用迭代法或递归法。

优点：
   - 查找速度快，尤其适用于大型数据集；
   - 实现简单。

缺点：
   - 仅适用于有序数组；
   - 不适合频繁插入删除的动态数组。

## 不同类型的二分查找

有比较常见的：在有序序列中找一个数。

```js
const target = 3；
const nums = [1, 2, 3, 4, 5];
```

稍微变种的：寻找目标值的边界位置，有左侧（最小）、右侧（最大）边界查找。所谓边界即：在序列中，存在与目标值相等复数个元素，序列中某段连续位置上的值都是与目标值相等，连续位置中最小和最大的位置即为左侧和右侧边界。

```js
const target = 3；
// targetLeftIdx = 2;
// targetRightIdx = 4;
const nums = [1, 2, 3, 3, 3, 4, 5];
```


## 找一个数

在一个有序数组中找一个数的场景是二分查找最常见的应用场景，也是迭代发中它最简单的算法实现。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
	
  while (left <= right) {
    // 使用位运算来计算中间索引,避免可能的整数溢出
    const mid = left + ((right - left) >> 1);

    if (arr[mid] === target) {
      return mid; // 找到目标,返回索引
    } else if (arr[mid] < target) {
      left = mid + 1; // 目标在右半部分
    } else {
      right = mid - 1; // 目标在左半部分
    }
  }
  
  return -1; // 目标不在数组中
}

// 测试
const arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log(binarySearch(arr, 13)); // 输出: 6
console.log(binarySearch(arr, 4));  // 输出: -1
```

以下几个逻辑是实现二分查找算法值得多留心的点：

1. **边界索引的取值**：`left = 0;right = arr.length - 1`，`left` 和 `right` 存储搜索范围的边界（数组的索引）；
2. **中间索引的取值**：`mid = left + ((right - left) >> 1)`，`mid` 存储范围的中间索引。计算中间值索引时，是该向上取整还是向下取整；
3. **迭代循环的条件**：`while(left <= right)`，针对迭代循环的条件，需要考虑的是何时该跳出循环； 
4. **缩小搜索范围时的新边界索引的取值**：`left = mid + 1;right = mid - 1`，在缩小搜索范围时，是该以中间值索引还是中间值索引向内偏移一个单位的索引为边界；

两个边界值的赋值决定了程序进行搜索的区间。根据边界索引值的赋值，可以将搜索区间向数学中的开闭区间定义靠。比如上文中的 `left = 0;right = arr.length - 1`，第一个元素（索引为 `0`）和最后一个元素（索引为 `arr.length - 1`）都是理应要搜索的元素，因此可以认为此情况为左闭右闭的区间，写作 `[left, right]`。以此类推还会有以下三种情况：

- `left = 0;right = arr.length`：`right` 赋值为 `arr.length`，右边界已经越界，因此可认为此情况是左闭右闭区间，写作 `[left, right)`；

- `left = -1;right = arr.length - 1`：`left` 的赋值已经越界，因此可认为此情况是左开右闭区间，写作 `(left, right]`；

- `left = -1;right = arr.length`：`left` 和 `right` 的赋值已经越界，因此可认为此情况是左闭右闭区间，写作 `(left, right)`；

*注意：区间并非只有仅在最初赋值设定，而是需要在搜索区间不断缩小的时候保持开闭区间逻辑*

在决定使用何种开闭区间组织二分查找逻辑后，就应该一直保持，直到迭代循环的结束，否则将是预期外的结果，这些预期外的结果将在下文探讨（todo）。

搜索区间的开闭是二分查找的重要组成部分！它影响着如何设定未命中时退出循环的条件和缩小搜索范围时新边界索引的取值。下面分类讨论选用每种开闭区间搜索范围时，循环条件和新边界索引应如何组织逻辑。

### 左右闭区间

**搜索范围选用左右闭区间即左右边界索引无越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

由于索引为 `mid` 的元素在当前搜索范围中已经确认它并非与目标值相等的元素，因此在新的搜索范围中无需包含它。

循环条件的设定，应在数组中无目标值为前提考虑！由于左右闭区间的搜索范围中，两个边界索引的元素也是需要检查的元素，因此可以预见，尽管在搜索区间缩小为两个边界索引相等时（`left === right` 为真）依然需要继续检查（此时区间内仅剩一个元素），那么进入循环的条件应为：

```js
while (left <= right) {
  // ...
}
```


### 左闭右开区间

**搜索范围选用左右闭区间即左边界索引无越界，右边界索引越界**。那么初始的边界索引的赋值逻辑是：

```js
let left = 0;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid + 1; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

由于目前使用的搜索区间为左闭右开，因此，更新左边界时需要保持不越界（即使用 `mid + 1` 的索引值作为新的边界）；而更新右边界时则需要保持越界（即直接使用 `mid` 的索引值作为新的边界，而不是 `mid - 1`）。

考虑进入循环条件时，同考虑到极限下的情况即 `[left, right), left = right - 1`，可以代入索引值进行讨论：

假设 `left = 0`，即当前搜索区间 `[0, 1)`，由于搜索区间为左闭右开，可知当前仍剩 `arr[0]` 这一个元素未检查（`arr[1]` 是越界元素，不在搜索区间内）！那么可以推断出：当左边界索引与右边界索引相等时即搜索区间内已经无可检查的元素，那么退出循环的就是 `left === right` 为真。进入循环的条件就是：

```js
while (left < right) {
  // ...
}
```

### 左开右闭区间

**搜索范围选用左开右闭区间即左边界索引越界，右边界索引无越界**。这种搜索区间的选择与上文的“左闭右开区间”相类似，正好是一个反面，因此下面不做过多赘述。那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length - 1;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid - 1; // 目标在左半部分
}
```

进入循环的条件是（与“左闭右开区间”一样）：

```js
while (left < right) {
  // ...
}
```

### 左右开区间

**搜索范围选用左右闭区间即左右边界索引都越界**。即边界索引指向的元素皆不在搜索区间中！那么初始的边界索引的赋值逻辑是：

```js
let left = -1;
let right = arr.length;
```

新边界索引的更新逻辑是：

```js
if (arr[mid] === target) {
  return mid;
} else if (arr[mid] < target) {
  left = mid; // 目标在右半部分
} else {
  right = mid; // 目标在左半部分
}
```

左右边界都在搜索区间外，则左右边界索引在更新时只需将索引指向 `mid` 即可，毕竟在上一轮 `mid` 已经被检查并确认非目标值！

讨论当前情况的进入循环的条件，同样可以使用“左闭右开区间”中使用的“极限法”。考虑极限情况下，搜索区间仅剩一个元素未检查即：`(left, right), left = right - 2`。同样代入常数：

假设 `left = 0`，即 `(0, 2)`。此时仅剩 `arr[1]` 未检查！当搜索区间缩小为 `(0, 1)` 或 `(1, 2)` 搜索区间中无元素需要继续检查，可以退出循环！即 `left + 1 === right` 为真。那么进入循环的条件就是：

```js
while (left + 1 < right) {
  // ...
}
```


### 搜索区间选择对中间索引值的影响

上文中一直未提及中间值索引的计算，并非它不受搜索区间开闭的影响，正相反它同样是基于区间开闭进行逻辑组织。上文也提到了 `mid` 的计算逻辑：`mid` 搜索区间的中间元素的索引，即 `mid = (left + right) / 2`。但可以预见这般计算的中间值不一定会是整数（比如：`left = 0, right = 7` 则 `mid = 3.5`），当不是整数时就需要考虑是向上还是向下取整了！向下或向上取整不是问题的本质。关键在于取整之后得到的中间元素索引值是否越界（超出了当前的搜索区间），因此，当前选择的搜索区间的开闭就很关键，下面将针对上文几种区间开闭对中间索引值的影响展开讨论：


取整的方式已知有以下 2 种：

1. 向上：`Math.ceil((left + right) / 2)`；
2. 向下：`Math.floor((left + right) / 2)`；

极限情况下，即搜索区间缩小至新计算的中间索引与边界索引重合且需要进行取整处理。

**左右闭区间`[left, right]`**

极限情况下有：`[left, right], left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1]`，未取整前的中间索引是：`0.5`。此时数组中剩下两个未检查的元素（`arr[0], arr[1]`）即两个边界索引指向的元素。在此情况下，无论中间索引如何取整得到的索引值依然落在搜索区间内！*因此，选用“左右闭区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*


**左闭右开区间`[left, right)`**

极限情况下有：`[left, right), left = right - 1`。代入常数，设 `left = 0`，则搜索区间为：`[0, 1)`，未取整前的中间索引是：`0.5`。此时数组中剩下一个未检查的元素（`arr[0]`，`arr[1]` 是当前搜索区间外的越界元素）即左边界索引指向的元素。显然在此情况下，若向上取整（让 `mid = 1`）将出现越界现象！更糟糕的是：`arr[1]` 已经在上一次迭代时已经被检查且确认并非目标值，再看上文已阐明的右边界索引的更新逻辑（`right = mid`），这意味下一次的搜索区间依然是 `[0, 1)`，没有缩小！这就会导致迭代一直继续，无限循环，无法退出循环，直到内存溢出！*因此，选用“左闭右开区间”作为搜索区间可以使用向下取整计算中间值索引，但绝不可以使用向上取整计算！*


**左开右闭区间`(left, right]`**

选用“左开右闭区间”与选用“左右开区间”正好是相互的镜像，正好相反！因此不做赘述，金给出结论：*选用“左开右闭区间”作为搜索区间可以使用向上取整计算中间值索引，但绝不可以使用向下取整计算！*


**左右开区间`(left, right)`**

使用“左右开区间”作为搜索区间不存在中间索引与边界索引重合的情况。可以代入常数，分别分析搜索区间仅剩 0 个、1 个、2个的情况：

- 剩余 2 个：`(left, right), left = right - 3`。设 `left = 0`，则 `(0, 3)`，搜索区间剩余元素是 `arr[1], arr[2]`。计算中间索引，向上取整是 2, 向下取整是 1，依然在搜索区间内，不存在与边界索引重合的情况；

- 剩余 1 个：`(left, right), left = right - 2`。设 `left = 0`，则 `(0, 2)`，搜索区间剩余元素是 `arr[1]`。计算中间索引得到的是 1，无需做取整处理且不存在与边界索引重合的情况；

- 剩余 0 个：搜索区间内已无元素需要检查，直接退出循环，不存在与边界索引重合的情况。

*因此，选用“左右开区间”作为搜索区间可以使用向上或向下取整计算中间值索引！*

下面用表格将搜索区间与其他几个关键逻辑进行归类：

| 关键逻辑\搜索区间 | `[left, right]`                       | `[left, right)`                   | `(left, right]`                      | `(left, right)`                   |
| ----------- | ------------------------------------- | --------------------------------- | ------------------------------------ | --------------------------------- |
| 初始边界        | `left = 0;`、`right = arr.length - 1;`     | `left = 0;`、`right = arr.length;` | `left = 0;`、`right = arr.length - 1` | `left = -1;`、`right = arr.length` |
| 边界更新        | `left = mid + 1;` 、`right = mid - 1;` | `left = mid + 1;` 、`right = mid;` | `left = mid;` 、`right = mid - 1;`    | `left = mid;` 、`right = mid;`     |
| 进入循环条件      | `while(left <= right)`                | `while(left < right)`             | `while(left < right)`                | `while(left + 1 < right)`         |
| 中间索引取整      | 向下、向上取整皆可                             | 可向下取整；不可向上取整，否则无法退出循环导致内存溢出       | 可向上取整；不可向下取整，否则无法退出循环导致内存溢出          | 向下、向上取整皆可                         |


从表中可看出，随着搜索区间的开闭变化，初始边界、边界更新、进入循环条件和中间索引取整的有着相应的变化。结合上文可知，初始边界和边界更新是对搜索区间开闭思想的实现；“进入循环条件”不是开闭区间思想的实现，是基于它的延伸。“进入循环条件”的设定是为保证检查数组所有元素（若无目标值），不漏检任何元素的前提下退出迭代循环。在设定迭代循环条件时，可使用“极限法”思考极限情况下，搜索区间收缩到何种程度后数组所有元素皆被检查；“中间索引取整”设定的关键是保证它在任何情况下不会与越界的边界索引重合！另外，在上文可见到中间值的计算有两种方式，分别是 `(left + right) / 2` 和 `left + (right - left) / 2`。视情况，两种方式都无问题，但已知需要处理的数组长度大到接近安全整数范围（JavaScript 使用 IEEE 754 双精度浮点数表示法，提供大约 15-17 位十进制数字的精度。需要注意的是，当处理超出安全整数范围的大数时，可能会出现精度问题。），使用后者才是最优解！


### 异常

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 9
```

边界初始是使用左右闭区间的搜索范围，但边界更新时则转变为左闭右开区间。而循环条件和中间值索引计算是配合左右闭区间的搜索范围组织的。使用“左闭右开区间”时，中间值索引向上取整会导致在极限情况下它与右边界（越界）不断重合，进入死循环。即引起上面用例所暴露的问题的两处关键逻辑语句是：

```js
const mid = Math.ceil(left + (right - left) / 2);
right = mid;
```

以上程序，在搜索区间剩余的元素个数小于或等于 2 个元素时，存在无法处理的情况（其中 2 种无需处理），需要增加额外代码修补漏洞。

当搜索区间剩余或仅有 2 个元素时：

- 左边界元素是目标值；
- 右边界元素是目标值（无需处理）；
- 左右边界元素非目标值。

当搜索区间剩余或仅有 1 个元素时：

- 是目标值（无需处理）；
- 不是目标值，但比目标值大；
- 不是目标值，但比目标值小（无需处理）；

```js
function(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间剩余的元素个数小于或等于 2 个元素
    if (left + 1 >= right) {
      // 左边界元素是目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意：未被前一个 if 拦截则表示左边界元素不是目标值
      // 情况1：剩余 2 元素时，左右边界元素均非目标值；
      // 情况2：剩余 1 元素时，不是目标值，但比目标值大
      // 情况3：剩余 1 元素时，不是目标值，但比目标值小（虽不需要处理，但这部分代码自带了此功能）
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```


---

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```

这份代码与上一份的区别是，中间值索引的计算为向下取整。虽然解决了取整导致的问题，但依然无法避免中间值索引与越界边界索引重合的情况。问题在“进入循环的条件”，在 `left = right` 的情况下，中间索引依然与越界边界索引重合（`right`），由于 `target < arr[right]` 和 `right = mid` 的边界更新逻辑，导致无法退出循环！即引起上面用例所暴露的问题的关键逻辑是：

```js
while (left <= right) {}
right = mid;
```

修补后：

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }

    // 搜索区间剩余或仅有 1 个元素，且非目标值
    if (left === right && arr[right] !== target) {
      return -1;
    }
  }

  return -1;
}
```

---


```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 输出 -1， 预期结果 0
nums = [5]
target = 5
```

这份代码与上一份的区别是，“进入循环的条件”改为 `left < right`，解决了中间值索引与越界边界索引重合导致无法退出循环的问题。已经是左闭右开区间标准写法的“边界初始化”替换为左右闭区间的。虽然解决了无法退出循环的问题，但存在无法进入循环的问题，见异常用例！

与左闭右开区间相对应的左开右闭区间同样会出现以上问题：

```js
// # 超出时间限制
// nums = [-1,0,3,5,9,12]
// target = 0
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// # 超出时间限制
// nums = [-1,0,3,5,9,12]
// target = 2
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// # 输出 -1， 预期结果 0
// nums = [5]
// target = 5
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

---


```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

异常用例：

```
# 超出时间限制
nums = [-1,0,3,5,9,12]
target = 2
```

边界更新使用的是左右开区间的逻辑，其他则是使用左右闭区间的逻辑。从上表可知道两种区间的选择对中间值索引计算的取整方式没有要求，因此关注点可放在边界更新和循环条件上。在搜索区间越发缩小就会发现问题，当 `left = right` 时，程序还在循环内。此时向上取整计算中间值索引，得到的是 `right`，即 `mid = right`，而边界索引的更新还是 `right`。搜索范围不会变化，循环也退出不了，从而导致死循环。

当搜索区间（左右闭区间）内元素个数少于等于 2 个时，当前程序基本无法处理，除了其中两种特殊情况即：
- 当元素个数剩余 2 个且右边界元素是目标值时（这是因为向上取整使中间值索引偏向了右边界）
- 当元素个数剩余 1 个且为目标值（原因同为中间值取整）。

因此需要增加额外代码修补这部分漏洞，下面列出的是需要增加额外代码的情况：

剩余或数组仅为 2 个元素（`[left, right], left = right - 1`）：

- 左边界为目标值；
- 左右边界均非目标值；
- 右边界为目标值（无需处理）；

剩余或数组仅为 1 个元素（`[left, right], left = right`）：

- 是目标值（无需处理）；
- 非目标值；

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }

    // 当搜索区间剩余元素小于等于 2 个时
    if (left + 1 >= right) {
      // 剩余 2 个元素且左边界元素为目标值
      if (arr[left] === target) {
        return left;
      }

      // 注意：未被上一个if拦截即左边界非目标值
      // 情况1：剩余 1 个元素且不是目标值
      // 情况2：剩余 2 个元素且均非目标值
      if (arr[right] !== target) {
        return -1;
      }
    }
  }

  return -1;
}
```


### 应用场景

todo


## 寻找边界

使用二分查找的基本场景是在一个有序序列中寻找目标数值。在此之上还存在这样一种场景：序列中的元素值不是唯一的，可能存在复数个，比如在：`[1,2,3,3,3,4,5]` 中 `3` 即为复数的存在！有可能需要寻找目标数值在序列中出现的最小或最大索引或两者兼有。使用基础的二分查找算法找出目标值后，使用线性遍历的方式向两个方向进行嗅探也不失为一种方式，但伴随序列的量级膨胀，可以预见复杂度在增加！而二分查找是存在用于快速寻找边界的变种算法！即为寻找最小边界的“寻找左侧边界的二分查找”和“寻找右侧边界的二分查找”。

### 寻找左侧边界

todo

### 寻找右侧边界

todo


## 附录

### 各搜索区间开闭的二分查找的逻辑实现

PS：以下各搜索区间开闭的二分查找的逻辑实现均已通过 [leetcode 的 704. 二分查找](https://leetcode.cn/problems/binary-search/description/)！

**左右闭区间**

```js
// [left, right]
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

```

**左闭右开区间**

```js
// [left, right)
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}

```

**左开右闭区间**

```js
// (left, right]
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

```


**左右开区间**

```js
// (left, right)
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

```js

function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}


function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}


function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.ceil(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
function binarySearch(arr, target) {
  let left = -1;
  let right = arr.length;

  while (left + 1 < right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return -1;
}
```

